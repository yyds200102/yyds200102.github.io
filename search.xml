<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM(三):JVM类加载和对象加载</title>
      <link href="/2021/06/22/JVM/JVM%20(%20%E4%B8%89%20)%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2021/06/22/JVM/JVM%20(%20%E4%B8%89%20)%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1、JVM简介"><a href="#1、JVM简介" class="headerlink" title="1、JVM简介"></a>1、JVM简介</h2><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现<br>（Windows，Linux，macOS），⽬的是使用相同的字节码，它们都会给出相同的结果。</p><blockquote><p>字节码</p></blockquote><p><strong>概念：</strong>JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），只面向虚拟机。</p><p>Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时又保留了解释型语⾔可移植的特点。所以 Java 程序运行时比较高效，同时，由于字节码并不针对⼀种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><h2 id="2、Java程序从源码到执行"><a href="#2、Java程序从源码到执行" class="headerlink" title="2、Java程序从源码到执行"></a>2、Java程序从源码到执行</h2><p><img src="/img/JVM/19.jpg"></p><h2 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h2><p> <strong>语法糖：</strong></p><ul><li>其实就是指 java 编译器把 .java 源码编译为 .class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</li></ul><p><strong>注意：</strong></p><p>以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h3 id="3-1、默认构造器"><a href="#3-1、默认构造器" class="headerlink" title="3.1、默认构造器"></a>3.1、默认构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这个无参构造器是java编译器帮我们加上的</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Candy1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、自动拆装箱"><a href="#3-2、自动拆装箱" class="headerlink" title="3.2、自动拆装箱"></a>3.2、自动拆装箱</h3><p>基本类型和其包装类型的相互转换过程，称为拆装箱，在 JDK 5 以后，它们的转换可以在编译期自动完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Integer x = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> y = x;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转换之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 基本类型赋值给包装类型，称为装箱</span></span><br><span class="line">      Integer x = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 包装类型赋值给基本类型，称谓拆箱</span></span><br><span class="line">      <span class="keyword">int</span> y = x.intValue();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、泛型集合取值"><a href="#3-3、泛型集合取值" class="headerlink" title="3.3、泛型集合取值"></a>3.3、泛型集合取值</h3><p>泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行泛型擦除的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy3</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      list.add(<span class="number">10</span>);</span><br><span class="line">      Integer x = list.get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以调用 get 函数取值时，会有一个类型转换的操作（JDK帮我们自动做的）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer x = (Integer) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>如果要将返回结果赋值给一个 int 类型的变量，则还有自动拆箱的操作</strong></p><p>如果要将返回结果赋值给一个 int 类型的变量，则还有自动拆箱的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = (Integer) list.get(<span class="number">0</span>).intValue();</span><br></pre></td></tr></table></figure><p><strong>但是不是全部都被擦除，可以看到类型被记录了</strong></p><p><img src="/img/JVM/17.jpg"></p><p><strong>通过反射可以获取（只有为参数和返回类型时可以获取）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 拿到方法</span></span><br><span class="line">    Method method = Code_20_ReflectTest.class.getMethod(<span class="string">&quot;test&quot;</span>, List.class, Map.class);</span><br><span class="line">    <span class="comment">// 2. 得到泛型参数的类型信息</span></span><br><span class="line">    Type[] types = method.getGenericParameterTypes();</span><br><span class="line">    <span class="keyword">for</span>(Type type : types) &#123;</span><br><span class="line">        <span class="comment">// 3. 判断参数类型是否，带泛型的类型。</span></span><br><span class="line">        <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 得到原始类型</span></span><br><span class="line">            System.out.println(<span class="string">&quot;原始类型 - &quot;</span> + parameterizedType.getRawType());</span><br><span class="line">            <span class="comment">// 5. 拿到泛型类型</span></span><br><span class="line">            Type[] arguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Integer&gt; <span class="title">test</span><span class="params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-4、可变参数"><a href="#3-4、可变参数" class="headerlink" title="3.4、可变参数"></a>3.4、可变参数</h3><p>可变参数也是 JDK 5 开始加入的新特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy4</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 将 args 赋值给 arr ，可以看出 String... 实际就是 String[]  </span></span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      foo(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy4</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Candy4 &#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      foo(<span class="keyword">new</span> String[]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果调用的是 foo() ，即未传递参数时，等价代码为 foo(new String[]{}) ，创建了一个空数组，而不是直接传递的 null </p><h3 id="3-5、foreach循环"><a href="#3-5、foreach循环" class="headerlink" title="3.5、foreach循环"></a>3.5、foreach循环</h3><ul><li>数组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Candy5 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // 数组赋初值的简化写法也是一种语法糖。</span><br><span class="line">int[] arr = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for(int x : arr) &#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 转换</span><br><span class="line">public class Candy5 &#123;</span><br><span class="line">    public Candy5() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = new int[]&#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for(int i = 0; i &lt; arr.length; ++i) &#123;</span><br><span class="line">int x = arr[i];</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy5</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span> (Integer x : list) &#123;</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合要使用 foreach ，需要该集合类实现了 Iterable 接口，因为集合的遍历需要用到迭代器 Iterator.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy5</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="comment">// 获得该集合的迭代器</span></span><br><span class="line">      Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">         Integer x = iterator.next();</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-6、switch字符串"><a href="#3-6、switch字符串" class="headerlink" title="3.6、switch字符串"></a>3.6、switch字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cnady6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;world&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器的操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Candy6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 通过字符串的 hashCode + value 来判断是否匹配</span></span><br><span class="line">      <span class="keyword">switch</span> (str.hashCode()) &#123;</span><br><span class="line">         <span class="comment">// hello 的 hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">99162322</span> :</span><br><span class="line">            <span class="comment">// 再次比较，因为字符串的 hashCode 有可能相等</span></span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">// world 的 hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">11331880</span> :</span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 用第二个 switch 在进行输出判断</span></span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在编译期间，单个的 switch 被分为了<strong>两个</strong></p><ul><li><p>第一个用来匹配字符串，并给 x 赋值</p><p>字符串的匹配用到了字符串的 hashCode ，还用到了 equals 方法使用 hashCode 是为了提高比较效率，使用 equals 是防止有 hashCode 冲突（如 BM 和 C .）</p></li><li><p>第二个用来根据x的值来决定输出语句</p></li></ul><h3 id="3-7、swtich枚举"><a href="#3-7、swtich枚举" class="headerlink" title="3.7、swtich枚举"></a>3.7、swtich枚举</h3><h3 id="3-8、枚举类"><a href="#3-8、枚举类" class="headerlink" title="3.8、枚举类"></a>3.8、枚举类</h3><p>JDK 7 新增了枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Sex</span>&gt; </span>&#123;   </span><br><span class="line">   <span class="comment">// 对应枚举类中的元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> &#123;       </span><br><span class="line">    <span class="comment">// 调用构造函数，传入枚举元素的值及 ordinal</span></span><br><span class="line">    MALE = <span class="keyword">new</span> Sex(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);    </span><br><span class="line">        FEMALE = <span class="keyword">new</span> Sex(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);   </span><br><span class="line">        $VALUES = <span class="keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用父类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">super</span>(name, ordinal);    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;  </span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Sex.class, name);  </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-9、try-with-resources"><a href="#3-9、try-with-resources" class="headerlink" title="3.9、try-with-resources"></a>3.9、try-with-resources</h3><h3 id="3-10、方法重写时的桥接方法"><a href="#3-10、方法重写时的桥接方法" class="headerlink" title="3.10、方法重写时的桥接方法"></a>3.10、方法重写时的桥接方法</h3><h3 id="3-11、匿名内部类"><a href="#3-11、匿名内部类" class="headerlink" title="3.11、匿名内部类"></a>3.11、匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用匿名内部类创建线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 用额外创建的类来创建匿名内部类对象</span></span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Candy10$<span class="number">1</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个额外的类，实现了 Runnable 接口</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Demo8$<span class="number">1</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用引用局部变量的匿名内部类，源代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123; </span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;ok:&quot;</span> + x); </span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 额外生成的类 </span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> val$x; </span><br><span class="line">Candy11$<span class="number">1</span>(<span class="keyword">int</span> x) &#123; </span><br><span class="line"><span class="keyword">this</span>.val$x = x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;ok:&quot;</span> + <span class="keyword">this</span>.val$x); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Candy11$<span class="number">1</span>(x); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>所以匿名内部类引用局部变量时，局部变量必须是 final 的：</li><li>因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 值后，如果不是 final 声明的，若 x 值发生了改变，匿名内部类则值不一致。</li></ol><h2 id="4、类加载过程"><a href="#4、类加载过程" class="headerlink" title="4、类加载过程"></a>4、类加载过程</h2><h3 id="4-1、加载"><a href="#4-1、加载" class="headerlink" title="4.1、加载"></a>4.1、加载</h3><p>将类的<strong>字节码</strong>载入<strong>方法区</strong>（1.8后为元空间，在本地内存）中，内部采用 <strong><code>C++ 的 instanceKlass</code></strong> 描述 java 类</p><p>它的重要 ﬁeld 有：</p><ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul><p>如果这个类还有父类没有加载，先加载父类</p><p><strong>加载和链接可能是交替运行的</strong><br><img src="/img/JVM/18.jpg"></p><ul><li>instanceKlass保存在方法区。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<code>堆内存</code>中</li><li>instanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h3 id="4-2、链接"><a href="#4-2、链接" class="headerlink" title="4.2、链接"></a>4.2、链接</h3><p><strong>验证</strong></p><ul><li>验证类是否符合 JVM规范，安全性检查</li><li>用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行</li></ul><p><strong>准备</strong></p><ul><li>为 static 变量分配空间，设置默认值</li></ul><p><strong>注意：</strong></p><ul><li>static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾</li><li>static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，**<code>赋值在初始化阶段完成</code>**</li><li>如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li><li>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成将常量池中的符号引用解析为直接引用</li></ul><h3 id="4-3、初始化"><a href="#4-3、初始化" class="headerlink" title="4.3、初始化"></a>4.3、初始化</h3><p><strong>&lt; clinit &gt;()v 方法</strong></p><ul><li>初始化即调用 &lt; clinit &gt;()V ，虚拟机会保证这个类的『构造方法』的线程安全</li></ul><p><strong>作用：</strong></p><ul><li>为静态变量赋予初始值</li><li>执行静态代码块</li></ul><p><strong>发生的时机</strong></p><ul><li>概括得说，类初始化是【懒惰的】</li></ul><p><strong>会导致类初始化的情况（类的主动引用）</strong></p><ul><li>虚拟机启动时，先初始化main方法所在类</li><li>new类对象</li><li>对类进行反射</li><li>首次调用类的<code>静态成员和方法</code>(final 常量除外)</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>初始化一个类时，若其父类没有被初始化，会先初始化其父类</li></ul><p><strong>不会导致类初始化的情况（类的被动使用）</strong></p><ul><li><p>访问静态域时，只有真正声明的这个域的类才会被初始化</p><p>如子类引用父类的静态变量，子类不会初始化</p></li><li><p>通过数组定义类引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Son[] array = <span class="keyword">new</span> Son[<span class="number">5</span>];  <span class="comment">//Son为一个类</span></span><br></pre></td></tr></table></figure></li><li><p>引用常量(常量在链接阶段就存入调用类的常量池中了)</p></li><li><p>类对象.class 不会触发初始化</p></li></ul><h2 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h2><h3 id="5-1、简介"><a href="#5-1、简介" class="headerlink" title="5.1、简介"></a>5.1、简介</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，<strong>只要加载它们的类加载器不同，那这两个类就必定不相等</strong>！</p><p><strong>作用：</strong></p><p>​        将class文件字节码内容加载到内存中，并把静态数据转化成方法区的运行时数据结构，然后再<code>堆</code>中生成一个代表这个类的java.lang.Class对象作为方法区中类数据的访问入口。</p><p>​        <strong>总而言之，就是把JVM编译的class文件加载到内存并且生成一个class对象便于访问</strong></p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>AVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，显示为null</td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>classpath    上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>自定义    上级为Application</td></tr></tbody></table><p><strong>启动类的加载器</strong></p><ul><li>可通过在控制台输入指令，使得类被启动类加器加载</li></ul><p><strong>扩展类的加载器</strong></p><ul><li>如果 classpath 和 JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。</li></ul><h3 id="5-2、双亲委派机制"><a href="#5-2、双亲委派机制" class="headerlink" title="5.2、双亲委派机制"></a>5.2、双亲委派机制</h3><p><strong>概述：</strong></p><ol><li>类加载器**<code>需要加载类时</code>**，会调用应用程序/拓展类加载器，向上委托父类加载器，直到根加载器。</li><li>根加载器寻找有没有需要加载的类，能加载结束，没有则抛出异常通知子类加载，</li><li>重复步骤②，</li></ol><p>优点1：自定义String类会报错，可以保护系统核心类</p><p>优点2：避免全限定命名的类重复加载</p><h3 id="5-3、线程上下文加载器"><a href="#5-3、线程上下文加载器" class="headerlink" title="5.3、线程上下文加载器"></a>5.3、线程上下文加载器</h3><p>线程上下文加载器会打破双亲委派机制</p><ol><li>Java存在第三方接口（SPI），属于核心库，在rt.jar包中，需要根类加载去加载</li><li>而这些接口的实现，常见的比如JDBC一般存放在ClassPath路径下，</li><li>SPI需要调用第三方包，但是SPI是通过根加载器去加载的，显然按照双亲委派机制，已经是根加载器就无法向上托管了，<strong>这种情况就只能通过线程上下文加载器去加载了</strong>。</li></ol><h3 id="5-4、自定义类加载器"><a href="#5-4、自定义类加载器" class="headerlink" title="5.4、自定义类加载器"></a>5.4、自定义类加载器</h3><p><strong>使用场景</strong></p><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><p><strong>步骤</strong></p><ul><li><p>继承 ClassLoader 父类</p></li><li><p>要遵从双亲委派机制，重写 ﬁndClass 方法</p><p>如果重写 loadClass 方法，就不会走双亲委派机制</p></li><li><p>读取类文件的字节码</p></li><li><p>调用父类的 deﬁneClass 方法来加载类</p></li><li><p>使用者调用该类加载器的 loadClass 方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Demo2 demo2 = <span class="keyword">new</span> Demo2();</span><br><span class="line">        demo2.loadClass(<span class="string">&quot;要加载的类名&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String s) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 定义路径</span></span><br><span class="line">            String path = <span class="string">&quot;路径&quot;</span>+s+<span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            Files.copy(Paths.get(path),os);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = os.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> defineClass(s,bytes,<span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;未找到类加载器&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>破坏双亲委派模式</strong></p><ol><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<br>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<br>如果有**<code>基础类型又要调用回用户的代码</code>**，此时也会破坏双亲委派模式</li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<br>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ol><h2 id="6、对象创建的过程"><a href="#6、对象创建的过程" class="headerlink" title="6、对象创建的过程"></a>6、对象创建的过程</h2><h3 id="6-1、类加载检查"><a href="#6-1、类加载检查" class="headerlink" title="6.1、类加载检查"></a>6.1、类加载检查</h3><p>虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在常量池中定位到<code>这个类的符号引⽤</code>，并且检查这个符号引⽤代表的类<code>是否已被加载过、解析和初始化过</code>。如果没有，那必须先执⾏相应的类加载过程。</p><h3 id="6-2、分配内存"><a href="#6-2、分配内存" class="headerlink" title="6.2、分配内存"></a>6.2、分配内存</h3><p>虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定大小的内存从 Java 堆中划分出来。有两种分配方式，根据Java内存是否整齐来决定，取决于GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p><ul><li>指针碰撞：整理内存，把没有的内存整理到一起，再分配内存</li><li>空闲列表：虚拟机维护一个列表，记录哪些位置可用，分配内存</li></ul><blockquote><p>内存分配并发问题</p></blockquote><p>作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用<code>两种方式</code>一起来保证线程安全</p><ul><li>TLAB：为每⼀个线程预先在 Eden 区分配⼀块⼉内存，JVM 在给线程中的对象分配内存时，首先先在 TLAB 分配，当对象⼤于 TLAB 中的剩余内存或 TLAB 的内存已⽤尽时，使用上述的 CAS 进行内存分配</li><li>CAS + 失败重试</li></ul><h3 id="6-3、初始化零值"><a href="#6-3、初始化零值" class="headerlink" title="6.3、初始化零值"></a>6.3、初始化零值</h3><h3 id="6-4、设计对象头"><a href="#6-4、设计对象头" class="headerlink" title="6.4、设计对象头"></a>6.4、设计对象头</h3><p>这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄、偏向锁信息等，这些信息存放在对象头中。</p><h3 id="6-5、执行init方法"><a href="#6-5、执行init方法" class="headerlink" title="6.5、执行init方法"></a>6.5、执行init方法</h3><p>把对象按照程序员的意愿进行初始化</p><h2 id="7、对象访问的定位方式"><a href="#7、对象访问的定位方式" class="headerlink" title="7、对象访问的定位方式"></a>7、对象访问的定位方式</h2><p>对象的访问方式有虚拟机实现而定，⽬前主流的访问方式有使⽤<strong>句柄、直接指针</strong>两种：</p><ul><li>句柄：Java堆中将会划分出⼀块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li><li>直接指针： Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(二):垃圾回收</title>
      <link href="/2021/06/22/JVM/JVM%20(%20%E4%BA%8C%20)%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2021/06/22/JVM/JVM%20(%20%E4%BA%8C%20)%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1、判断对象可以回收"><a href="#1、判断对象可以回收" class="headerlink" title="1、判断对象可以回收"></a>1、判断对象可以回收</h2><h3 id="1-1、引用计数法"><a href="#1-1、引用计数法" class="headerlink" title="1.1、引用计数法"></a>1.1、引用计数法</h3><p>当一个对象<strong>被引用时</strong>，就当引用对象的值加一，当值为 0 时，就表示该对象不被引用，可以被垃圾收集器回收。</p><p><strong>缺陷：</strong>循环引用时，两个对象的计数都为1，导致两个对象都无法被释放。</p><p><img src="/img/JVM/9.jpg"></p><h3 id="1-2、可达性分析算法"><a href="#1-2、可达性分析算法" class="headerlink" title="1.2、可达性分析算法"></a>1.2、可达性分析算法</h3><p>扫描堆中的对象，看能否沿着 GC Root 对象为起点的引用链找到该对象，如果找不到，则表示可以回收</p><p><strong>GC Root 对象</strong>：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的Native方法）引用的对象</li></ul><h3 id="1-3、如何判断⼀个常量是废弃常量"><a href="#1-3、如何判断⼀个常量是废弃常量" class="headerlink" title="1.3、如何判断⼀个常量是废弃常量"></a>1.3、如何判断⼀个常量是废弃常量</h3><p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p><h3 id="1-4、-如何判断⼀个类是无用的类"><a href="#1-4、-如何判断⼀个类是无用的类" class="headerlink" title="1.4、 如何判断⼀个类是无用的类"></a>1.4、 如何判断⼀个类是无用的类</h3><p>满足下面3个条件，可能被回收，不是一定</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地⽅被引⽤，⽆法在任何地⽅通过反射访问该类的方法。</li></ul><h3 id="1-5、四种引用"><a href="#1-5、四种引用" class="headerlink" title="1.5、四种引用"></a>1.5、四种引用</h3><p><img src="/img/JVM/10.jpg"></p><ol><li><strong>强引用</strong>：宁愿抛出OOM异常也不会被回收，除非不再被强引用</li><li><strong>软引用</strong>（SoftReference）：在垃圾回收后，**<code>内存仍不足时</code>**会被回收。实现对内存敏感的高速缓存。</li><li><strong>弱引用</strong>（WeakReference）：在垃圾回收时，无论内存是否充足，都会回收弱引用对象。</li><li><strong>虚引用</strong>（PhantomReference）：如果⼀个对象仅持有虚引用，那么它就和没有任何引用⼀样，在任何时候都可能被回收；虚引用必须配合引用队列使用，主要配合 ByteBuffer 使用，<strong>被引用对象回收时</strong>，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法<strong>释放</strong>直接内存</li></ol><p><strong>注意点：</strong></p><ul><li>软引用、弱引用、虚引用都可以和⼀个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加⼊到与之关联的引⽤队列中。</li><li>在程序设计中⼀般很少使用弱引用与虚引用，使用软引用的情况多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出OOM等问题的产⽣。</li></ul><p><strong>终结器引用</strong>（FinalReference）：无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</p><h2 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h2><h3 id="2-1、标记清除算法"><a href="#2-1、标记清除算法" class="headerlink" title="2.1、标记清除算法"></a>2.1、标记清除算法</h3><ol><li>标记：把需要清除的垃圾标记起来</li><li>清除：定义一张表，记录垃圾占用空间的<strong>首地址</strong>和<strong>尾地址</strong>，这些空间下次就可以继续分配</li></ol><p>优点：速度快</p><p>缺点：会产生内存碎片</p><p><img src="/img/JVM/11.jpg"></p><h3 id="2-2、标记整理"><a href="#2-2、标记整理" class="headerlink" title="2.2、标记整理"></a>2.2、标记整理</h3><ol><li>标记：把需要清除的垃圾标记起来</li><li>整理：把垃圾清除后，再把剩余的空间整理，确保没有内存碎片</li></ol><p>缺点：速度慢</p><p>优点：没有内存碎片</p><p><img src="/img/JVM/12.jpg"></p><h3 id="2-3、复制"><a href="#2-3、复制" class="headerlink" title="2.3、复制"></a>2.3、复制</h3><ol><li>标记：把需要清除的垃圾标记起来</li><li>复制：把from的区域的存活的对象全部复制到to区域</li><li>交换：复制完后，to区变成原来的from区，from区变为to区</li></ol><p>优点：没有内存的碎片</p><p>缺点：浪费内存空间，一半空间永远为空</p><p><img src="/img/JVM/13.jpg"></p><h2 id="3、分代垃圾回收算法"><a href="#3、分代垃圾回收算法" class="headerlink" title="3、分代垃圾回收算法"></a>3、分代垃圾回收算法</h2><h3 id="3-1、堆内存介绍及算法"><a href="#3-1、堆内存介绍及算法" class="headerlink" title="3.1、堆内存介绍及算法"></a>3.1、堆内存介绍及算法</h3><p><img src="/img/JVM/14.jpg"></p><p><strong>特点：</strong>新生代采用复制算法，老年代采用标记整理算法，提高效率</p><p><strong>新生代：</strong>有伊甸园区、幸存区</p><ol><li>新创建的对象首先分配在 eden 区</li><li>新生代空间不足时，触发 minor gc（轻GC） ，eden 区 和 from 区存活的对象使用 <strong><code>复制算法</code></strong> 复制到 to 中，存活的对象年龄加一，然后交换 from to区</li><li>minor gc（轻GC）会引发 stop the world，暂停其他线程，等垃圾回收结束后，恢复用户线程运行</li><li>当幸存区对象的寿命超过阈值时，会晋升到老年代，最大的寿命是 15（4bit）</li><li>当老年代空间不足时，会先触发 minor gc（轻GC），如果空间仍然不足，那么就触发 full fc （重GC），停止的时间更长！</li></ol><p><strong>老年代：</strong>当幸存区对象的寿命超过阈值时，会晋升到老年代</p><p><strong>永久代：</strong>常驻内存，存java运行时的环境，<strong>不存在垃圾回收</strong>，虚拟机关闭时释放</p><ul><li>JDK6之前，叫永久代，常量池在方法区</li><li>JDK7时，  叫永久代，但是慢慢退化，去永久代，常量池在堆中</li><li>JDK8之后，无永久代，常量池还在堆里，方法区在元空间里</li></ul><blockquote><p>分配担保机制</p></blockquote><p>当新生代几乎全部被分配完的时候，会发生轻GC，如果此时需要分配内存空间给对象，但是空间有不足，就会提前把新生代的转移到老年代中</p><blockquote><p>大对象直接进入老年代</p></blockquote><p>字符串、数组等，为了避免为⼤对象分配内存时由于分配担保机制带来的复制⽽降低效率。</p><blockquote><p>Hotsopt 更新阈值</p></blockquote><p>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的⼀半时，取这个年龄和MaxTenuringThreshold 中更小的⼀个值，作为新的晋升年龄阈值</p><p>Hotsopt 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的⼀半时，取这个年龄和MaxTenuringThreshold 中更小的⼀个值，作为新的晋升年龄阈值</p><h3 id="3-2、JVM参数"><a href="#3-2、JVM参数" class="headerlink" title="3.2、JVM参数"></a>3.2、JVM参数</h3><p>堆初始大小：-Xms<br>堆最大大小：-Xmx 或 -XX:MaxHeapSize=size<br>新生代大小：-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )<br>幸存区比例：   -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy<br>幸存区比例：    -XX:SurvivorRatio=ratio<br>晋升阈值：    -XX:MaxTenuringThreshold=threshold<br>晋升详情：    -XX:+PrintTenuringDistribution<br>GC详情：                      -XX:+PrintGCDetails -verbose:gc<br>FullGC 前 MinorGC：    -XX:+ScavengeBeforeFullGC</p><h3 id="3-3、测试"><a href="#3-3、测试" class="headerlink" title="3.3、测试"></a>3.3、测试</h3><p>public class Code_10_GCTest {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _512KB = <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _6MB = <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _7MB = <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _8MB = <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_6MB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_512KB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_6MB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_512KB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_6MB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h2><h3 id="4-1、串行"><a href="#4-1、串行" class="headerlink" title="4.1、串行"></a>4.1、串行</h3><ul><li>单线程</li><li>堆内存较少，适合个人电脑</li></ul><h3 id="4-2、吞吐量优先"><a href="#4-2、吞吐量优先" class="headerlink" title="4.2、吞吐量优先"></a>4.2、吞吐量优先</h3><ul><li>多线程</li><li>堆内存较大，多核 cpu</li><li>让单位时间内，STW 的时间最短 0.2 0.2 = 0.4</li></ul><h3 id="4-3、响应时间优先"><a href="#4-3、响应时间优先" class="headerlink" title="4.3、响应时间优先"></a>4.3、响应时间优先</h3><ul><li>多线程</li><li>堆内存较大，多核 cpu</li><li>尽可能让 STW 的单次时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5</li></ul><h3 id="4-4、G1回收器"><a href="#4-4、G1回收器" class="headerlink" title="4.4、G1回收器"></a>4.4、G1回收器</h3><p><strong>定义：</strong> Garbage First</p><p><strong>适用场景：</strong></p><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域</li><li>整体上是标记-整理算法，两个区域之间是复制算法</li></ul><p><strong>相关参数：</strong></p><ul><li>JDK8 并不是默认开启的，所需要参数开启</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br><span class="line">-XX:G1HeapRegionSize=size</span><br><span class="line">-XX:MaxGCPauseMillis=time</span><br></pre></td></tr></table></figure><h4 id="G1-垃圾回收阶段"><a href="#G1-垃圾回收阶段" class="headerlink" title="G1 垃圾回收阶段"></a>G1 垃圾回收阶段</h4><p><img src="/img/JVM/15.jpg"></p><ul><li>Young Collection：对新生代垃圾收集</li><li>Young Collection + Concurrent Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。</li><li>Mixed Collection：会对新生代 + 老年代 + 幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(一):内存结构</title>
      <link href="/2021/06/22/JVM/JVM%20(%20%E4%B8%80%20)%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2021/06/22/JVM/JVM%20(%20%E4%B8%80%20)%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><ul><li>栈、本地方法栈、程序计数器100%不会有垃圾</li><li>JVM调优99%在调整堆(方法区属于特殊的堆)</li><li>一般插件都是在执行引擎上动手脚</li></ul><p><img src="/img/JVM/1.jpg"></p><p><strong>Program Counter Register 程序计数器（寄存器）</strong></p><p><strong>作用：</strong></p><ul><li>每条JVM指令都会交给JVM解释器，解释器把字节码变成机器码，让CPU执行，然后此时<code>下一条 jvm 指令的执行地址行号</code>会被放入程序计数器中，然后解释器根据地址去取指令并执行。</li><li>多线程的环境下，如果两个线程发生了上下文切换，那么程序计数器会记录线程下一条指令的地址行号，以便线程切换回来继续执行命令。</li><li>总而言之，程序计数器就是存放<strong>JVM下一条指令的地址</strong>，特殊的：执行本地方法时，无法定位地址</li></ul><p><strong>特点：</strong></p><ul><li>是线程<strong>私有</strong>的，每个程序有自己的程序计数器</li><li>JVM中<code>唯一一个</code>不会存在内存溢出</li></ul><p><strong>实现方式：</strong></p><ul><li>通过<code>寄存器</code>来实现的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左边是JVM指令(二进制字节码)      右边是Java源代码</span></span><br><span class="line"><span class="number">0</span>: getstatic #<span class="number">20</span>        <span class="comment">// PrintStream out = System.out; </span></span><br><span class="line"><span class="number">3</span>: astore_1             <span class="comment">// -- </span></span><br><span class="line"><span class="number">4</span>: aload_1              <span class="comment">// out.println(1); </span></span><br><span class="line"><span class="number">5</span>: iconst_1             <span class="comment">// -- </span></span><br><span class="line"><span class="number">6</span>: invokevirtual #<span class="number">26</span>    <span class="comment">// -- </span></span><br><span class="line"><span class="number">9</span>: aload_1              <span class="comment">// out.println(2); </span></span><br><span class="line"><span class="number">10</span>: iconst_2            <span class="comment">// -- </span></span><br><span class="line"><span class="number">11</span>: invokevirtual #<span class="number">26</span>   <span class="comment">// -- </span></span><br><span class="line"><span class="number">14</span>: aload_1             <span class="comment">// out.println(3); </span></span><br><span class="line"><span class="number">15</span>: iconst_3            <span class="comment">// -- </span></span><br><span class="line"><span class="number">16</span>: invokevirtual #<span class="number">26</span>   <span class="comment">// -- </span></span><br><span class="line"><span class="number">19</span>: aload_1             <span class="comment">// out.println(4); </span></span><br><span class="line"><span class="number">20</span>: iconst_4            <span class="comment">// -- </span></span><br><span class="line"><span class="number">21</span>: invokevirtual #<span class="number">26</span>   <span class="comment">// -- </span></span><br><span class="line"><span class="number">24</span>: aload_1             <span class="comment">// out.println(5); </span></span><br><span class="line"><span class="number">25</span>: iconst_5            <span class="comment">// -- </span></span><br><span class="line"><span class="number">26</span>: invokevirtual #<span class="number">26</span>   <span class="comment">// -- </span></span><br><span class="line"><span class="number">29</span>: <span class="keyword">return</span></span><br><span class="line"><span class="comment">//     </span></span><br></pre></td></tr></table></figure><h2 id="2、虚拟机栈（线程运行时需要的内存空间）"><a href="#2、虚拟机栈（线程运行时需要的内存空间）" class="headerlink" title="2、虚拟机栈（线程运行时需要的内存空间）"></a>2、虚拟机栈（线程运行时需要的内存空间）</h2><h3 id="2-1、定义"><a href="#2-1、定义" class="headerlink" title="2.1、定义"></a>2.1、定义</h3><p><strong>概念：</strong></p><ul><li>每个线程运行需要的内存空间，称为虚拟机栈，栈是**<code>私有</code>**的</li><li>每个栈由多个栈帧（Frame）组成，对应着每次<code>调用方法</code>时所占用的内存（参数、变量等）</li><li>每个线程只能有一个<code>活动栈帧</code>，对应着当前正在执行的<code>方法</code>，每⼀次函数调用都会有⼀个对应的栈帧被压⼊ Java 栈，每⼀个函数调⽤结束后（或抛出异常导致结束），都会有⼀个栈帧被弹出</li><li>先进后出，main方法最先执行，最晚结束</li></ul><p><strong>栈帧的信息：</strong>局部变量表(编译期可知的各种基本数据类型、对象引用)、操作数栈、动态链接、⽅法出⼝信息。</p><p><img src="/img/JVM/2.jpg"></p><h3 id="2-2、几个问题"><a href="#2-2、几个问题" class="headerlink" title="2.2、几个问题"></a>2.2、几个问题</h3><ol><li><p>垃圾回收是否涉及栈内存？</p><ul><li>不会。栈内存是<strong>方法调用</strong>产生的，方法调用结束后会弹出栈。</li></ul></li><li><p>栈内存分配越大越好吗？</p><ul><li>不是，栈内存越大，每个线程的栈就越大，但是可执行的线程数就会越少。</li></ul></li><li><p>方法内的局部变量是否线程安全？</p><ul><li><p>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的</p></li><li><p>如果是局部变量引用了对象，<strong>并逃离了方法的访问</strong>（其他线程也能访问到），就要考虑线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">// 这样不会导致线程安全，因为只在线程内部有效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不安全的几种情况</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">// 静态变量被多个线程共享，导致线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(StringBuilder sb)</span></span>&#123; </span><br><span class="line">    <span class="comment">// 引用外部的对象，不安全</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 返回值可能被其他线程获取到修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="2-3、线程溢出"><a href="#2-3、线程溢出" class="headerlink" title="2.3、线程溢出"></a>2.3、线程溢出</h3><ul><li>栈帧太多（如无限递归，java.lang.StackOverflowError）</li><li>栈帧太大（一般不太可能发生）</li></ul><h3 id="2-4、线程运行诊断"><a href="#2-4、线程运行诊断" class="headerlink" title="2.4、线程运行诊断"></a>2.4、线程运行诊断</h3><p><strong>案例一：cpu 占用过多</strong></p><p><strong>描述：</strong>Linux 环境下运行某些程序的时候，可能导致 CPU 的占用过高，这时需要定位占用 CPU 过高的线程</p><ol><li>输入 top 命令，查看是哪个进程占用 CPU 过高</li><li>输入 ps H -eo pid, tid, %cpu | grep 加进程号（刚刚的进程号）可以过滤进程</li><li>输入 jstack 进程 id  ，即可显示java的线程信息</li><li>刚才通过 ps 命令看到的 tid 来对比定位，注意 jstack 查找出的线程 id 是 16 进制的，需要转换。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、 top   // 会显示进程这里假设是 32655 进制占用CPU过高</span><br><span class="line">2、 ps H -eo pid, tid, %cpu | grep 32655   // 查看进行信息,假设 32665进程占用过高</span><br><span class="line">3、 jstack 32665 // 获取java的线程信息</span><br><span class="line">4、 根据线程号32665比对线程找出，先换成16进制，找出错误所在</span><br></pre></td></tr></table></figure><p><img src="/img/JVM/3.jpg"></p><p><strong>案例二：线程很长时间未响应</strong></p><p>同上，排查异常情况</p><h3 id="2-5、本地方法栈"><a href="#2-5、本地方法栈" class="headerlink" title="2.5、本地方法栈"></a>2.5、本地方法栈</h3><p><img src="/img/JVM/4.jpg"></p><p>调用<strong>本地方法</strong>时需要使用本地方法栈</p><p>本地方法：native修饰的方法，底层调用的是C/C++方法等</p><h2 id="3、堆"><a href="#3、堆" class="headerlink" title="3、堆"></a>3、堆</h2><h3 id="3-1、定义："><a href="#3-1、定义：" class="headerlink" title="3.1、定义："></a>3.1、定义：</h3><p><strong>Heap 堆</strong></p><ul><li>通过new关键字创建的对象都会被放在堆中，在堆里面分配内存。</li></ul><p><strong>特点</strong></p><ul><li>它是所有<code>线程共享</code>，堆内存中的对象都需要考虑<code>线程安全</code>问题</li><li>有垃圾回收机制</li></ul><p><strong>注意：</strong>从jdk 1.7开始已经默认开启逃逸分析，如果某些⽅法中的对象引⽤没有被返回或者未被外⾯使⽤（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p><h3 id="3-2、堆内存溢出"><a href="#3-2、堆内存溢出" class="headerlink" title="3.2、堆内存溢出"></a>3.2、堆内存溢出</h3><p><strong>OOM错误：</strong></p><ul><li>java.lang.OutOfMemoryError: Java heap space  堆内存满了，堆内存不够</li><li>即 新生区 + 老年区 大小等于总堆内存</li></ul><p><strong>默认情况：</strong>JVM分配总内存为电脑四分之一，初始化的内存为六十四分之一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> max = Runtime.getRuntime().maxMemory();</span><br><span class="line"><span class="keyword">long</span> total = Runtime.getRuntime().totalMemory();</span><br><span class="line">System.out.println((<span class="keyword">double</span>)max/<span class="number">1024</span>/<span class="number">1024</span>);</span><br><span class="line">System.out.println((<span class="keyword">double</span>)total/<span class="number">1024</span>/<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p><strong>修改堆空间大小：</strong>-Xmx1024m 指定大小</p><p>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</p><p><img src="/img/JVM/5.jpg"></p><h3 id="3-3、堆内存诊断"><a href="#3-3、堆内存诊断" class="headerlink" title="3.3、堆内存诊断"></a>3.3、堆内存诊断</h3><ol><li>jps 工具：查看当前系统中有哪些 java 进程</li><li>jmap 工具：查看堆内存占用情况 jmap - heap 进程id</li><li>jconsole 工具：图形界面的，多功能的监测工具，可以连续监测</li><li>jvisualvm 工具：</li></ol><h3 id="3-4、垃圾回收"><a href="#3-4、垃圾回收" class="headerlink" title="3.4、垃圾回收"></a>3.4、垃圾回收</h3><p>垃圾回收主要发生在堆里，因为几乎所有的对象都在堆中分配。</p><h2 id="4、方法区："><a href="#4、方法区：" class="headerlink" title="4、方法区："></a>4、方法区：</h2><h3 id="4-1、定义"><a href="#4-1、定义" class="headerlink" title="4.1、定义"></a>4.1、定义</h3><ol><li><p>方法区被所有 Java 虚拟机线程之间**<code>共享</code>**的方法区域。</p></li><li><p>它存储每个<strong>类的结构</strong>，常量、静态变量、即时编译器编译后的代码等数据</p></li><li><p>方法区域是在**<code>虚拟机启动时</code>**创建的。</p></li><li><p>尽管方法区域<strong>在逻辑上是堆的一部分</strong>，但是并不强制要求，而且名字也叫做<strong>非堆</strong>。</p></li><li><p><strong>HotSpot</strong>（其他不一定）使用永久代实现方法区，在JDK1.8时移除，采用**<code>元空间</code>**实现（不再占用堆的空间，在本地内存占用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整个永久代有⼀个 JVM 本身设置固定⼤⼩上限，⽆法进⾏调整，⽽元空间使⽤的是直接内存，受本机可⽤内存的限制，虽然元空间仍旧可能溢出，但是⽐原来出现的⼏率会更⼩。</span><br><span class="line"><span class="comment">// 元空间溢出仍然是OOM，因为逻辑上是堆的一部分</span></span><br></pre></td></tr></table></figure></li><li><p>也存在垃圾回收，但是较少可以忽略</p></li></ol><p><img src="/img/JVM/6.jpg"></p><h3 id="4-2、方法区内存溢出"><a href="#4-2、方法区内存溢出" class="headerlink" title="4.2、方法区内存溢出"></a>4.2、方法区内存溢出</h3><ul><li>1.8 之前会导致**<code>永久代</code>**内存溢出<ul><li>使用 -XX:MaxPermSize=8m 指定永久代内存大小</li></ul></li><li>1.8 之后会导致**<code>元空间</code>**内存溢出<ul><li>使用 -XX:MaxMetaspaceSize=8m 指定元空间大小</li></ul></li></ul><h3 id="4-3、各种常量池剖析"><a href="#4-3、各种常量池剖析" class="headerlink" title="4.3、各种常量池剖析"></a>4.3、各种常量池剖析</h3><p><strong>常量池：</strong>每个class文件都有类的基本信息，<code>常量池</code>、类方法定义、虚拟机指令等信息，常量池用于存放编译期间生成的各种字面量和符号引用。</p><p><strong>运行时常量池：</strong>程序运行到某个类时，即类加载到方法区时，<code>Class文件的信息</code>就会被解析到内存的<code>方法区</code>中的运行时常量池，因此每个类都有一个运行时常量池。加载之后，运行时常量池自然获得了常量池的各种信息。</p><p><strong>字符串常量池：</strong>JDK7之前在方法区的运行时常量池中，JDK7开始<strong>被单独拿到堆</strong>；当类加载的时候，常量池的字符串文本就会加载进入字符串常量池中</p><p><strong>原因：</strong>方法区的永久代回收要等到FullGC，频率太低，所以容易导致内存不够用。</p><p>注意：</p><ul><li>运行时常量池自始至终在方法区，JDK7在方法区（堆），JDK8在元空间</li><li>字符串常量池JDK7之前在方法区的运行时常量池，JDK7开始单独放到堆中</li></ul><h3 id="4-4、StringTable字符串常量池"><a href="#4-4、StringTable字符串常量池" class="headerlink" title="4.4、StringTable字符串常量池"></a>4.4、StringTable字符串常量池</h3><p><strong>存储</strong></p><ul><li>字符串用**<code>哈希表</code>**存储</li><li>常量池的信息加载到字符串常量池，不过开始仅是符号，**<code>只有用到时才会转化为对象</code>**</li></ul><p><strong>创建字符串：</strong></p><ul><li><p>字面量创建字符串时，对象指向的是字符串常量池里的对象</p></li><li><p>new方法创建或者拼接字符串变量时，对象指向的是堆里的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;a&quot;</span>;  <span class="comment">//此时创建1个对象，放在常量池中</span></span><br><span class="line">String s2 = <span class="string">&quot;a&quot;</span>;  <span class="comment">//此时创建0个对象，指向s1</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>); <span class="comment">// 此时创建2个对象，先在常量池中创建，再在堆创建</span></span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>); <span class="comment">// 此时创建1个对象，在堆创建,常量池已经存在</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>字符串拼接：</strong></p><ul><li>字符串变量拼接的原理是**<code>StringBuilder</code>**，所以结果在堆里</li><li>字符串常量拼接的原理是**<code>编译器优化</code>**，所以结果在常量池里</li></ul><p><strong>intern方法（1.8）：</strong>假设 字符串str调用</p><ul><li>若字符串常量池中没有a，就会**<code>添加到常量池</code>**中，返回常量池的对象</li><li>若字符串常量池中有a，就会**<code>添加失败</code>**，不过仍然返回常量池的对象</li></ul><p><strong>intern方法（1.6）：</strong>假设 字符串str调用</p><ul><li><p>添加成功，会创建新对象放入常量池</p><p><strong>注意：</strong>intern不会改变原对象，只是会返回常量池的对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// StringTable&#123;&quot;a&quot; ,&quot;b&quot;,&quot;ab&quot; &#125; 哈希表结构，不能扩容</span></span><br><span class="line"><span class="comment">// 常量池中的信息，都会被加载到运行时常量池，不过字符串默认都是符号，还不是String对象</span></span><br><span class="line"></span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;  <span class="comment">// 当调用该行代码时，若不存在字面量“a”，才会创建String对象</span></span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2;   <span class="comment">// 字符串变量拼接的原理是StringBuilder</span></span><br><span class="line">        <span class="comment">// String s4 = new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString();</span></span><br><span class="line">        <span class="comment">// toString方法  等于 new String(&quot;ab&quot;)</span></span><br><span class="line">        String s5 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;      <span class="comment">// 字符串常量拼接的原理是编译器优化</span></span><br><span class="line">                                    <span class="comment">// 因为&quot;a&quot; &quot;b&quot;是确定的，而s1 s2 不确定</span></span><br><span class="line">        System.out.println(s3==s4); <span class="comment">// false s3是常量池 ，s4在堆中</span></span><br><span class="line">        System.out.println(s3==s5); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s3==s4.intern());<span class="comment">// 1.8是true intern()方法会放到常量池中</span></span><br><span class="line">System.out.println(s3==s4);  <span class="comment">// false 注意intern不会改变原对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 还需注意一点</span></span><br><span class="line">        String x1 = <span class="keyword">new</span> String(<span class="string">&quot;A&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        x1.intern();</span><br><span class="line">        String x2 = <span class="string">&quot;AB&quot;</span>;</span><br><span class="line">        System.out.println(x1 == x2);   </span><br><span class="line">        <span class="comment">// 此时返回true，因为x1对象成功放到了常量池，所以此时常量池和堆中的对象是同一个</span></span><br><span class="line">        <span class="comment">// 注意1.6也为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5、StringTable垃圾回收"><a href="#4-5、StringTable垃圾回收" class="headerlink" title="4.5、StringTable垃圾回收"></a>4.5、StringTable垃圾回收</h3><p>-Xmx10m 指定堆内存大小<br>-XX:+PrintStringTableStatistics 打印字符串常量池信息<br>-XX:+PrintGCDetails<br>-verbose:gc 打印 gc 的次数，耗费时间等信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 StringTable 垃圾回收</span></span><br><span class="line"><span class="comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_05_StringTableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123; <span class="comment">// j = 100, j = 10000</span></span><br><span class="line">                String.valueOf(j).intern();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6、StringTable性能调优"><a href="#4-6、StringTable性能调优" class="headerlink" title="4.6、StringTable性能调优"></a>4.6、StringTable性能调优</h3><p><strong>一：</strong>上面说过StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=桶个数（最少设置为 <span class="number">1009</span> 以上）</span><br></pre></td></tr></table></figure><p><strong>二：</strong>可以通过 intern 方法减少重复入池</p><h2 id="5、直接内存"><a href="#5、直接内存" class="headerlink" title="5、直接内存"></a>5、直接内存</h2><h3 id="5-1、定义"><a href="#5-1、定义" class="headerlink" title="5.1、定义"></a>5.1、定义</h3><ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>由系统直接管理，不受 JVM 内存回收管理，但是仍然可能导致OOM</li></ul><h3 id="5-2、直接内存的优点"><a href="#5-2、直接内存的优点" class="headerlink" title="5.2、直接内存的优点"></a>5.2、直接内存的优点</h3><p><strong>文件读写流程</strong></p><p><img src="/img/JVM/7.jpg"></p><p>因为 java 不能直接操作文件管理，需要切换到内核态，使用本地方法进行操作，然后读取磁盘文件，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区， 然后在将系统缓冲区数据，复制到 java 堆内存中。缺点是数据存储了两份，在系统内存中有一份，java 堆中有一份，造成了不必要的复制</p><p><strong>使用了 DirectBuffer 文件读取流程</strong></p><p>直接内存是操作系统和 Java 代码**<code>都可以访问</code>**的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率</p><p><img src="/img/JVM/8.jpg"></p><h3 id="5-3、直接内存的内存回收"><a href="#5-3、直接内存的内存回收" class="headerlink" title="5.3、直接内存的内存回收"></a>5.3、直接内存的内存回收</h3><ul><li>使用了 Unsafe 类来完成直接内存的分配回收，回收需要主动调用freeMemory 方法</li><li>ByteBuffer 的实现内部使用了 Cleaner（虚引用）来检测 ByteBuffer 。一旦ByteBuffer 被垃圾回收，那么会由 ReferenceHandler（守护线程） 来调用 Cleaner 的 clean 方法调用 freeMemory 来释放内存</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE知识精简</title>
      <link href="/2021/06/21/JavaSE/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/06/21/JavaSE/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1、char和string"><a href="#1、char和string" class="headerlink" title="1、char和string"></a>1、char和string</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">码点与代码单元</span><br><span class="line">String a = “<span class="number">43</span>”; </span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(a);</span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">ValueOf</span><span class="params">(String s)</span></span>;   </span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">ValueOf</span><span class="params">(String s,<span class="keyword">int</span> rad/2ix)</span></span>;方法的重载和重写</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>JDK9之后 String采用 byte[] 数组存储字符串</p><ul><li>操作少量的数据: 适⽤ String</li><li>单线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder</li><li>多线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer</li></ul><h3 id="2、方法问题"><a href="#2、方法问题" class="headerlink" title="2、方法问题"></a>2、方法问题</h3><p><strong>重载与重写</strong></p><ol><li>静态方法可以重载但是不可以重写</li><li><strong>方法重写约束:</strong><ul><li>方法必须具有相同的<strong>名称和参数</strong></li><li>返回值类型、异常类型要和父类一致，或为父类返回类型的子类</li><li><strong>访问权限要比父类的高或者相等</strong></li><li>无法重写static、final、private方法，因为static方法是类方法，不是成员方法</li></ul></li><li>子类对象实例化时不会实例化父类对象</li><li><strong>方法的签名：</strong>方法的名字和参数构成方法的签名，与返回值无关，重载需要签名不同</li></ol><p><strong>值传递：</strong>Java里方法的参数传递方式只有一种：值传递。 将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。 </p><h3 id="3、构造器"><a href="#3、构造器" class="headerlink" title="3、构造器"></a>3、构造器</h3><p><strong>特点：</strong>不能重写可以重载、没有修饰符、子类构造器必须调用父类构造器（默认自动调用无参）</p><p><strong>构造器调用构造器：</strong>最多调用一个；必须放在最上面</p><p><strong>初始化顺序：</strong></p><ol><li>声明成员变量的默认初始化</li><li>显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）</li><li>构造器再对成员进行初始化操作</li><li>通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值</li></ol><p><strong>注意：</strong>构造器被调用后，会先判断是否调用了其他构造器</p><ul><li>若调用了，则转到另一个构造器执行</li><li>若没调用，<strong>先调用初始化块，在调用构造器剩下的部分</strong></li></ul><p><strong>静态代码块：</strong>优先于类的构造，<strong>只能对静态成员变量初始化</strong>，从上而下执行</p><h3 id="4、static和final"><a href="#4、static和final" class="headerlink" title="4、static和final"></a>4、static和final</h3><p><strong>final：</strong></p><ul><li>变量：不能修改，直接定义或者构造函数处赋值</li><li>方法：不能被重写，可以重载</li><li>类：不能被继承</li></ul><p><strong>static</strong></p><ul><li>变量：不再属于某个对象，而是属于类被共享</li><li>方法：独立于类，静态方法不能调用非静态字段，类和对象都可以调用静态方法。</li></ul><h3 id="5、多态问题"><a href="#5、多态问题" class="headerlink" title="5、多态问题"></a>5、多态问题</h3><p><strong>多态：</strong>多态是运行时实现的，一个引用变量在运行时才能确定指向哪个对象。</p><p><strong>数组向上转型的问题：</strong>数组对象转型问题，数组向上转型之后，只能添加子类对象而不能添加父类对象，因为子类和父类引用都是指向该地址，添加父类对象，就相当于子类指向父类对象属于向下转型不安全。</p><h3 id="6、枚举类"><a href="#6、枚举类" class="headerlink" title="6、枚举类"></a>6、枚举类</h3><ul><li>枚举是一个特殊的类，一般表示一组常量，参数默认用public static final 修饰，</li><li>枚举类构造器只能是private，</li><li>枚举类初始化对象，里面成员变量全部初始化</li></ul><h3 id="7、接口和抽象"><a href="#7、接口和抽象" class="headerlink" title="7、接口和抽象"></a>7、接口和抽象</h3><p><strong>接口：</strong></p><ul><li>接口只含 静态常量值，抽象方法，jdk8新增默认方法，静态方法，jdk9允许私有</li><li>接口继承规则<ul><li>超子类冲突超类优先：如果超类提供了一个具体方法，子类方法签名一致的默认方法将被忽略</li><li>超类之间冲突： 子类需要重写</li></ul></li></ul><p><strong>抽象：</strong>抽象只是可能含有抽象方法，其他和普通类完全一致。</p><p><strong>注意点：</strong></p><ul><li><p>抽象类可以实现多个接口，只能继承实现一个抽象类</p></li><li><p>一个接口可以继承多个接口。</p></li><li><p>从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接口是对行为的抽象，是⼀种行</p><p>为的规范。</p></li></ul><h3 id="8、内部类"><a href="#8、内部类" class="headerlink" title="8、内部类"></a>8、内部类</h3><ul><li>局部内部类的this指向外部，只能获得外部不改变的值</li><li>普通成员内部类不能含静态方法属性，可以重写外部方法。</li><li>静态成员内部类，静态方法只能调静态属性和静态方法，和外部资源。</li></ul><h3 id="9、成员变量和局部变量"><a href="#9、成员变量和局部变量" class="headerlink" title="9、成员变量和局部变量"></a>9、成员变量和局部变量</h3><table><thead><tr><th></th><th><strong>成员变量</strong></th><th><strong>局部变量</strong></th></tr></thead><tbody><tr><td>声明的位置</td><td>直接声明在类中</td><td>方法形参或内部、代码块内、构造器内等</td></tr><tr><td>修饰符</td><td>用权限修饰符修饰</td><td>只能使用final</td></tr><tr><td>初始化值</td><td>有默认值</td><td>没有默认值</td></tr><tr><td>内存加载位置</td><td><strong>堆空间或静态域内</strong></td><td><strong>栈空间</strong></td></tr></tbody></table><h3 id="10、集合"><a href="#10、集合" class="headerlink" title="10、集合"></a>10、集合</h3><ul><li>hashset 可以为null，<strong>保证equals相等的对象，hashcode也必须相等</strong>，HashTable不支持</li><li>treeset不能为Null</li><li>weakhashmap 弱引用</li><li>IdentityHashMap hashcode比较就是比较地址，比较两个对象使用＝＝，也就是说永远不会用相等的对象</li></ul><h3 id="11、队列"><a href="#11、队列" class="headerlink" title="11、队列"></a>11、队列</h3><p>queue是一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>; <span class="comment">// 队列满回跑出异常</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>; <span class="comment">// 若队列没空，则从队首取出，不然抛出异常，返回false</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">peak</span><span class="params">()</span></span>; <span class="comment">// 获取队首的元素,失败抛出异常</span></span><br></pre></td></tr></table></figure><p>Deque是一个双端队列接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Object obj)</span>       <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(Object obj)</span>  <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 移除数据</span></span></span><br><span class="line"><span class="function">Object <span class="title">removeFirst</span><span class="params">()</span>           Object <span class="title">removeLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">pollFirst</span><span class="params">(Object obj)</span>   Object <span class="title">pollLast</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 获得数据</span></span></span><br><span class="line"><span class="function">Object <span class="title">getFirst</span><span class="params">()</span>               Object <span class="title">getLast</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">Object <span class="title">peekFirst</span><span class="params">()</span>              Object <span class="title">peekLast</span><span class="params">()</span>   </span></span><br></pre></td></tr></table></figure><ul><li>ArrayDeque<E></li><li>PriorityQueue()：优先级队列，需要传入构造器或元素实现排序接口</li></ul><p>8、Collections工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步集合</span></span><br><span class="line">synchronizedCollection()   <span class="comment">// 把Collection替换成下面的即可</span></span><br><span class="line">List/Map/Set/SortedSet/SortedMap/NavigableSet/NavigableMap</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 分割集合</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; List &lt;E&gt; asList(E...array);                      <span class="comment">// Arrays类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> firstIncluded,<span class="keyword">int</span> firstExcluded)</span></span>;<span class="comment">// List类</span></span><br><span class="line"></span><br><span class="line">subset(E firstIncluded,E firstExcluded);</span><br><span class="line">headSet(E firstExcluded);    <span class="comment">// SortedSet、SortedMap(Map方法把set换成Map即可)</span></span><br><span class="line">tailSet(E firstExcluded);     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List)</span>          <span class="comment">// 反转 List 中元素的顺序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List)</span>          <span class="comment">// 对 List 集合元素进行随机排序</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List)</span>             <span class="comment">// 根据元素的自然顺序对按升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List，Comparator)</span> <span class="comment">// </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List，<span class="keyword">int</span>， <span class="keyword">int</span>)</span>  <span class="comment">// 将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 查找和替换</span></span></span><br><span class="line"><span class="function"><span class="comment">// 最值</span></span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection)</span>             <span class="comment">// 自然排序，或者自己实现接口</span></span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection,Comparator)</span>  <span class="comment">// 传入一个实现排序接口的对象</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection)</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection，Comparator)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置值    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span>      <span class="comment">// 将src中的内容复制到dest中 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List dest,Object value)</span>  <span class="comment">// 所有值变为value </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c,T...values)</span> <span class="comment">// 把所有值添加到集合里面    </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list,Object old,Object new)</span>  <span class="comment">// 替换</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">// 查询    </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection，Object o)</span>        <span class="comment">// 返回指定集合中指定元素的出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">disjoint</span><span class="params">(Collection c1,Collection c2)</span>   <span class="comment">// 没有公共元素，返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List father,List son)</span>  <span class="comment">// 返回子集合在父集合的索引索引 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfSubList</span><span class="params">(List father,List son)</span></span></span><br></pre></td></tr></table></figure><h3 id="12、栈：stack"><a href="#12、栈：stack" class="headerlink" title="12、栈：stack"></a>12、栈：stack</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">push</span><span class="params">(E item)</span></span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="13、泛型简单使用"><a href="#13、泛型简单使用" class="headerlink" title="13、泛型简单使用"></a>13、泛型简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span>&lt;<span class="title">T</span>&gt;</span>&#123;                        <span class="comment">// 泛型类</span></span><br><span class="line">    T t;                                      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T...a)</span></span>&#123;     <span class="comment">// 泛型方法</span></span><br><span class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">compare</span><span class="params">(T...a)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;进行比较&quot;</span>);</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    <span class="keyword">for</span> (T num: a) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14、泛型原理"><a href="#14、泛型原理" class="headerlink" title="14、泛型原理"></a>14、泛型原理</h3><p><strong>原理：</strong>编译器把数据存为Object，再通过泛型知道了数据的类型，自动帮我们把数据转换回来</p><p><strong>泛型多态性问题：</strong>父类被重写的方法的参数类型被擦除，不构成重写，如何保持多态？</p><p>描述：子类继承泛型父类（泛型参数string），并且重写方法create（string str），由于泛型擦除，子类父类方法参数不一致，被重载了，如何恢复原来的重写多态？</p><p>桥方法解决：实际调用父类的擦除的方法，但是此方法内部调用子类的方法，也就是说实际调用子类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很明显是两个不同的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">Demo1</span>&lt;<span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 子类本身方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从父类继承的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会在Demo2里面生成一个新的桥方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setSecond((Date) second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>协变问题：</strong>非继承关系下自动继承Object，泛型擦除导致的方法重复</p><p>解决：JVM会采用重写的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CLone........</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="comment">// Employee会有两个clone类,称为有协变的返回类型</span></span></span><br><span class="line"><span class="function">Employee <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">clone</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="15、泛型局限性"><a href="#15、泛型局限性" class="headerlink" title="15、泛型局限性"></a>15、泛型局限性</h3><ol><li><p><strong>不能使用基本类型实例化参数</strong>：基本类无法转换成Object</p></li><li><p><strong>无法使用instanceof判断泛型类型：</strong>类型被转换成Object，无法判断</p></li><li><p><strong>不能创建参数化类型的数组：</strong>数组不知道里面具体要加入的类型，但是由于Obejct[] 是父类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数化类型的数组</span></span><br><span class="line">Demo1&lt;String&gt;[] demo1 = <span class="keyword">new</span> Demo1&lt;String&gt;[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 泛型擦除之后，可以转换成object</span></span><br><span class="line">Demo1[] demo1 = <span class="keyword">new</span> Demo1[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把demo1赋值给Object数组</span></span><br><span class="line">Object[] object = demo1;   <span class="comment">// 相当于Object[] object = new Demo1[5];</span></span><br><span class="line"><span class="comment">// 数组记录了类型为demo1,但是因为泛型擦除，不知道应该为Demo1&lt;String&gt;，所以下面编译通过</span></span><br><span class="line">object[<span class="number">0</span>] = <span class="keyword">new</span> Demo1&lt;String&gt;();</span><br><span class="line">object[<span class="number">1</span>] = <span class="keyword">new</span> Demo1&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于object和demo1的引用指向一个对象，所以等效为,于是编译通过，但是报错</span></span><br><span class="line">demo1[<span class="number">0</span>] = <span class="keyword">new</span> Demo1&lt;String&gt;();</span><br><span class="line">demo1[<span class="number">1</span>] = <span class="keyword">new</span> Demo1&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原因</span></span><br><span class="line">Employee  是Manage 的 父类</span><br><span class="line">但是 Demo1&lt; Employee &gt; 不是 Demo1&lt; Manage &gt;的父类</span><br><span class="line"></span><br><span class="line">Employee  是Manage 的 父类</span><br><span class="line">Employee[]  是Manage[] 的 父类</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>不能 new 泛型变量：</strong>new不知道要创建的具体类型，无法直到调用哪个构造器。</p></li><li><p><strong>不能 new 泛型数组：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] create(<span class="keyword">int</span> length)&#123;</span><br><span class="line">    T[] result = <span class="keyword">new</span> T[length];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型擦除后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparable[] create(<span class="keyword">int</span> length)&#123;</span><br><span class="line">Comparable[] result = <span class="keyword">new</span> Comparable[length];</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 若T为User实现了接口，获取结果时 (User[]) result ，不安全，因为很明显Comparable对象不含User对象的属性和方法</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不能捕获抛出泛型类实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类不能捕获</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// catch语句不能使用泛型</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T) t;</span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">    &#125;<span class="keyword">catch</span> (T t)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型类的泛型变量不能使用static：静态变量初始化时无法获得变量类型</p></li><li><p>擦除后和Object的方法冲突：只能改名字或者不用泛型</p></li><li><p>继承多个泛型类会出现冲突：生成的桥方法冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt; ....</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Manage</span>&gt;.....</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">// 泛型擦除后，编译能通过    </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>....</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>..... </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">// 但是使用会报错,由于继承，所以会生成两个桥方法，而这两个桥方法完全一致，所以报错</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">int</span> <span class="title">compareTo</span>(<span class="title">Object</span> <span class="title">object</span>)</span>&#123;  </span><br><span class="line">    <span class="comment">// 调用Comparable&lt;Employee&gt;的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object object)</span></span>&#123;  </span><br><span class="line">    <span class="comment">// 调用Comparable&lt;Manage&gt;的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="16、通配符"><a href="#16、通配符" class="headerlink" title="16、通配符"></a>16、通配符</h3><p><strong>作用：</strong>对泛型类的使用进行优化，把其中的泛型参数替换成 ? </p><p><strong>泛型继承规则带来的局限</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Demo1&lt;Employee&gt; demo)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Manage 为 Employee 的子类，根据泛型继承规则</span></span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Employee&gt;());  <span class="comment">// 编译通过</span></span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Manage&gt;()); </span><br><span class="line"><span class="comment">// 报错，因为Demo1&lt;Manage&gt; 不是 Demo1&lt;Employee&gt;的子类</span></span><br></pre></td></tr></table></figure><p><strong>使用泛型通配符解决局限性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样限定范围之后，就可以解决上述问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Demo1&lt;? extends Employee&gt; demo)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型 ArrayList&lt;Demo2&gt; 是ArrayList&lt;? extends Demo1&gt;的子类</span></span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Employee&gt;()); </span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Manage&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然,不使用通配符也可以，只是麻烦一些</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Employee&gt; <span class="function">Demo1&lt;T&gt; <span class="title">print</span><span class="params">(Demo1&lt;T&gt; demo)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> demo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java对泛型通配符的限定</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Demo1是一个泛型类Demo1&lt;T&gt; ,里面有泛型属性 T first</span><br><span class="line"></span><br><span class="line">Demo1&lt;? extends Employee&gt; e = m;  <span class="comment">// 里面变成 ? first</span></span><br><span class="line">e.setFirst(<span class="keyword">new</span> Manage());         <span class="comment">// 编译不通过,因为不知道? 代表的类型</span></span><br><span class="line">e.setFirst(<span class="keyword">new</span> Employee());       <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure><p><strong>通配符捕获，解决对泛型通配符的限定</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Demo1&lt;?&gt; demo1)</span></span>&#123;</span><br><span class="line">   swapHelper(demo1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Demo1&lt;T&gt; demo1)</span></span>&#123;</span><br><span class="line">T t = demo1.getFirst();</span><br><span class="line">demo1.setFirst(demo1.getSecond());</span><br><span class="line">demo1.setSecond(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17、异常层次结构"><a href="#17、异常层次结构" class="headerlink" title="17、异常层次结构"></a>17、异常层次结构</h3><p>Throwable类是所有<strong>异常类</strong>的 ‘ 祖先’ ，即所有异常类都是由Throwable继承而来</p><p>Throwable有两个子类：Error（错误，处理不了）、Exception（异常）</p><p>Exception有两个子类：：IOException 和 RuntimeException（非受检查型异常，可以不处理）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span>     <span class="comment">// 返回关于发生的异常的详细信息。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Throwable <span class="title">getCause</span><span class="params">()</span>    <span class="comment">// 返回一个Throwable 对象代表异常原因。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span>  <span class="comment">// 打印toString()结果和栈层次到System.err，即错误输出流。</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StackTraceElement [] <span class="title">getStackTrace</span><span class="params">()</span>          </span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</span></span></span><br></pre></td></tr></table></figure><h3 id="18、异常处理"><a href="#18、异常处理" class="headerlink" title="18、异常处理"></a>18、异常处理</h3><ul><li>try-catch-finally处理：注意一般情况 finally 都会执行，甚至 finally的返回值 可以覆盖 try </li><li>throws 把异常向上抛出</li></ul><h3 id="19、自定义异常"><a href="#19、自定义异常" class="headerlink" title="19、自定义异常"></a>19、自定义异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常类必须继承现有的异常类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line">    <span class="comment">// 初始化，给money赋初始值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取剩余的钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 抛出 自定义异常类的对象</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MyException(balance - <span class="keyword">this</span>.balance);</span><br><span class="line">&#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">    <span class="comment">// 根据捕获的对象，我们可以获取money信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;缺少&quot;</span>+e.getMoney()+<span class="string">&quot;元钱&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20、元注解"><a href="#20、元注解" class="headerlink" title="20、元注解"></a>20、元注解</h3><ol><li><p><code>@Target</code>：描述注解的使用范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">- TYPE : 类、接口或<span class="class"><span class="keyword">enum</span>声明</span></span><br><span class="line"><span class="class">- <span class="title">FIELD</span>: 域(属性)声明</span></span><br><span class="line"><span class="class">- <span class="title">METHOD</span>: 方法声明</span></span><br><span class="line"><span class="class">- <span class="title">PARAMETER</span>: 参数声明</span></span><br><span class="line"><span class="class">- <span class="title">CONSTRUCTOR</span>: 构造方法声明 <span class="title">LOCAL_VARIABLE</span>:局部变量声明</span></span><br><span class="line"><span class="class">- <span class="title">ANNOTATION_TYPE</span>:注释类型声明</span></span><br><span class="line"><span class="class">- <span class="title">PACKAGE</span>: 包声明</span></span><br></pre></td></tr></table></figure></li><li><p><code>@Rentention</code>：描述该注解的生命周期，即在什么时候有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">- SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃</span><br><span class="line">- CLASS:在<span class="class"><span class="keyword">class</span>文件中有效（即<span class="title">class</span>保留） ， 当运行 <span class="title">Java</span> 程序时, <span class="title">JVM</span>不会保留注解</span></span><br><span class="line"><span class="class">- <span class="title">RUNTIME</span>:在运行时有效（即运行时保留），当运行 <span class="title">Java</span>程序, <span class="title">JVM</span>会保留注释，此时可以通过反射获取注解。</span></span><br></pre></td></tr></table></figure></li><li><p><code>@Document</code>：说明该注解将被包含在Javadoc中</p></li><li><p><code>@Inherited</code>：说明子类可以继承父类中的注解</p></li></ol><h3 id="21、注解简单使用"><a href="#21、注解简单使用" class="headerlink" title="21、注解简单使用"></a>21、注解简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> &quot;20&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnnotation(age = &quot;30&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22、反射"><a href="#22、反射" class="headerlink" title="22、反射"></a>22、反射</h3><p><strong>反射：</strong>类加载器加载完类之后，堆里面就会生成<strong>一个Class类型的对象</strong>（一个类只有一个Class对象，JVM创建，每个类的实例都会记得自己是由哪个 Class 实例所生成），这个对象包含类的<strong>完整信息</strong>，通过这个对象来访问类的过程就是反射</p><ul><li>正常方式： 引入包名—-&gt;new实例化——&gt;取得实例化对象</li><li>反射方式： 实例化对象—–&gt;getClass()方法——-&gt;得到完整的”包类”名称</li></ul><p><strong>反射用途：</strong></p><ul><li>运行时取得类的<strong>内部信息</strong>，</li><li>运行时检查对象，直接操作对象的内部属性和方法。</li><li>实现泛型数组操作代码</li></ul><p><strong>获取Class对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class 类实际是一个泛型类</span></span><br><span class="line">Class c = User.class;           <span class="comment">// 通过类名,可以为基本数据类型 int.class</span></span><br><span class="line">Class c = user.getClass();      <span class="comment">// 通过对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">&quot;com.xxx.reflection.User&quot;</span>);   <span class="comment">//通过类的全限定名</span></span><br><span class="line">Class c = <span class="keyword">int</span>.TYPE;             <span class="comment">// 通过包装类</span></span><br></pre></td></tr></table></figure><h3 id="23、反射API操作类"><a href="#23、反射API操作类" class="headerlink" title="23、反射API操作类"></a>23、反射API操作类</h3><p>Java.lang.reflect 包有3个类 Field、method、Constructor 分别获取属性、方法、构造器（不含父类的方法）</p><ul><li>获取类名，包名（Class对象方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>;              <span class="comment">// 获取包名 + 类名</span></span><br><span class="line"><span class="function">String <span class="title">getSimpleName</span><span class="params">()</span></span>;        <span class="comment">// 只获得类名</span></span><br><span class="line"><span class="function">String <span class="title">getPackageName</span><span class="params">()</span></span>;</span><br><span class="line">Class[] getInterfaces();       <span class="comment">// 获得接口</span></span><br></pre></td></tr></table></figure><ul><li> 获取Feild对象及FeildAPI</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Field对象</span></span><br><span class="line">Field[] getFields();               <span class="comment">// 获取public的类变量，返回数组</span></span><br><span class="line">Field[] getDeclaredFields();       <span class="comment">// 获取全部类变量，包括private</span></span><br><span class="line"></span><br><span class="line">Field[] getField(Strning name);</span><br><span class="line">Field[] getDeclaredField(Strning name);    <span class="comment">// 获取指定名称的 </span></span><br></pre></td></tr></table></figure><ul><li>获取method对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method[] getMethods();              <span class="comment">// 获取public的method</span></span><br><span class="line">Method[] getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">Method[] getMethod(String name,String.class...);  <span class="comment">// 要指定方法名和参数的类型</span></span><br><span class="line">Method[] getDeclaredMethod(String name,<span class="keyword">null</span>);     <span class="comment">// 无参可以使用null或者不填</span></span><br></pre></td></tr></table></figure><ul><li>获取Constructor对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] getConstructors();</span><br><span class="line">Constructor[] getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">Constructor[] getDeclaredConstructor(String.class...); <span class="comment">// 需要指定参数类型</span></span><br><span class="line">Constructor[] getConstructor();             <span class="comment">// 无参则不填</span></span><br></pre></td></tr></table></figure><p>三个类对象常用API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>                   <span class="comment">// 返回的 Field对象表示的字段的名称。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>         <span class="comment">// 比较这 Field与指定对象。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span>                 <span class="comment">// 返回的 对构造器、方法、字段的修饰符的描述</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>;     <span class="comment">// 操作私有的必须设置为true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field  </span></span><br><span class="line"><span class="function">Class <span class="title">getType</span><span class="params">()</span>                    <span class="comment">// 返回类型  </span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object obj)</span>             <span class="comment">// 传入对象，获取该对象的属性  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span> <span class="comment">// 传入对象，把该字段设置为该值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// Method 和 Constructor通用</span></span></span><br><span class="line"><span class="function">Class <span class="title">getReturnType</span><span class="params">()</span>      <span class="comment">// 返回类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParameterCount</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">Class[] <span class="title">getParameterTypes</span><span class="params">()</span>  <span class="comment">// 返回参数类型</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// Method</span></span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span>  <span class="comment">// 调用方法,需要传入对象和参数</span></span></span><br><span class="line"><span class="function"><span class="comment">// Constructor </span></span></span><br><span class="line"><span class="function"><span class="title">newInstance</span><span class="params">(Object... initargs)</span>  <span class="comment">// 调用构造器创建对象,需要传入参数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//扩展 通过Class对象调用newInstance是调用无参构造    </span></span></span><br></pre></td></tr></table></figure><h3 id="24、反射API操作注解"><a href="#24、反射API操作注解" class="headerlink" title="24、反射API操作注解"></a>24、反射API操作注解</h3><p>API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] getAnnotations();  <span class="comment">// 获取注解</span></span><br><span class="line">Annotation[] getAnnotation(Annotation annotation);  <span class="comment">// 根据注解类型获取</span></span><br><span class="line">Annotation[] getDeclaredAnnotation();</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>可以获得类对象，然后调用方法；获得类对象在获得Method对象，调用方法；或者获得类对象再获得Field对象，再获得字段注解</p><h3 id="25、IO分类"><a href="#25、IO分类" class="headerlink" title="25、IO分类"></a>25、IO分类</h3><blockquote><p>按照数据单位分类</p></blockquote><ul><li><strong>字节流（8bit）</strong>：处理一个字节</li><li><strong>字符流（16bit）</strong>：面向字节的流不便于处理Unicode形式的信息，而一个字符16字节专门处理Unicode字符</li></ul><blockquote><p>按照数据流向</p></blockquote><ul><li><strong>输入流：</strong>可以读取一个字节序列</li><li><strong>输出流：</strong>可以写入一个字节序列</li></ul><blockquote><p>安装流的角色</p></blockquote><ul><li>节点流</li><li>处理流</li></ul><h3 id="26、API"><a href="#26、API" class="headerlink" title="26、API"></a>26、API</h3><p>字节输入流：InputStream</p><p>注意：InputStream是父类抽象类，有些方法没有具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据到输入流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>              <span class="comment">// 读取并返回一个字节到输入流，末尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;     <span class="comment">// 读取所有数据并且放到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="comment">// off开始，读到len</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readNBytes</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span>[] <span class="title">readAllBytes</span><span class="params">()</span> <span class="comment">// 读所有字节到输入流并返回数组</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 对输入流进行操作和分析    </span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(OutputStream out)</span> <span class="comment">// 转换成输出流并返回字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span>                 <span class="comment">// 输入流跳过n个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">available</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 标记 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span>   <span class="comment">// 在输入流当前位置打上标记</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span>               <span class="comment">// 返回到最后一个标记重写读取数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span>       <span class="comment">// 是否支持标记    </span></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> close    </span></span><br></pre></td></tr></table></figure><p>字符输入流：Read</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">// 读取单个字符，范围在0 到65535之间,已到末尾返回-1 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 将字符读入数组。返回读取的数量，如果已到达流的末尾，则返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">//  将字符读入数组的某一部分。从off处开始存储，最多读len个字</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException  <span class="comment">// 关闭</span></span></span><br></pre></td></tr></table></figure><p>字节输出流：OutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> n)</span>  <span class="comment">// 写出一个字节数据给n</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span>        <span class="comment">// 写出所有数据给字节数据byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,<span class="keyword">int</span> len)</span>  <span class="comment">// 最多写出len个字节 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;  <span class="comment">// 需要先刷新，再关闭</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>字符输出流：Writer</p><ul><li>Writer 可以用字符串来替换字符数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span>     <span class="comment">// 写入字符数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span>                 <span class="comment">// 写入字符串。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="comment">// 写入一部分到字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="comment">//刷新该流的缓冲，则立即将它们写入预期目标。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><h3 id="27、File类"><a href="#27、File类" class="headerlink" title="27、File类"></a>27、File类</h3><p>创建File对象：目录或文件的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以pathname为路径创建File对象，可以是**绝对路径或者相对路径，如果是相对路径，则默认的当前路径在系统属性user.dir中存储。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent,String child)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以parent为父路径，child为子路径创建File对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent,String child)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">// 根据一个父File对象和子文件路径创建File对象    </span></span></span><br></pre></td></tr></table></figure><ul><li>获取功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getAbsolutePath</span><span class="params">()</span> <span class="comment">// 获取绝对路径</span></span></span><br><span class="line"><span class="function">String <span class="title">getPath</span><span class="params">()</span>         <span class="comment">// 获取路径</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>         <span class="comment">// 获取名称</span></span></span><br><span class="line"><span class="function">String <span class="title">getParent</span><span class="params">()</span>       <span class="comment">// 获取上层文件目录路径。若无，返回null</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span>         <span class="comment">// 获取文件长度，不能是目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span>   <span class="comment">// 获取最后一次的修改时间，毫秒值</span></span></span><br><span class="line"><span class="function">String[] <span class="title">list</span><span class="params">()</span>       <span class="comment">// 目录下的所有文件或者目录的名称数组</span></span></span><br><span class="line"><span class="function">File[] <span class="title">listFiles</span><span class="params">()</span>    <span class="comment">// File数组</span></span></span><br></pre></td></tr></table></figure><ul><li>判断功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span>  <span class="comment">// 判断是否是文件目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span>       <span class="comment">// 判断是否是文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span>       <span class="comment">// 判断是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span>      <span class="comment">// 判断是否可读</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span>     <span class="comment">// 判断是否可写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span>     <span class="comment">// 判断是否隐藏</span></span></span><br></pre></td></tr></table></figure><ul><li>创建功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="comment">// 创建文件。若存在，则返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span>  <span class="comment">// 上层目录存在，file对象的目录不存在时创建</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> <span class="comment">// 创建文件目录。如果上层文件目录不存在，一并创建</span></span></span><br></pre></td></tr></table></figure><ul><li>修改功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span>  <span class="comment">// 把文件重命名为指定的文件路径</span></span></span><br></pre></td></tr></table></figure><ul><li>删除功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span>     <span class="comment">// 不进windows的回收站</span></span></span><br></pre></td></tr></table></figure><h3 id="28、常见的IO流"><a href="#28、常见的IO流" class="headerlink" title="28、常见的IO流"></a>28、常见的IO流</h3><ul><li><p>文件流：FileInputStream 和  FileOutputStream、FileReader 和 FileWriter</p></li><li><p>缓冲流：转换其他流 BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</p></li><li><p>转换流：把字节流转换成字符流</p><ul><li><p>InputStreamReader：将InputStream转换为Reader、</p></li><li><p>OutputStreamWriter：将Writer转换为OutputStream</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public InputStreamReader(InputStream in)    </span><br><span class="line">public InputSreamReader(InputStream in,String charsetName)</span><br><span class="line">// 参数二为字符集</span><br><span class="line">    </span><br><span class="line">public OutputStreamWriter(OutputStream out)</span><br><span class="line">public OutputSreamWriter(OutputStream out,String charsetName)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>标准输入输出流：System.out 、System.in</p></li><li><p>对象流：ObjectInputStream和OjbectOutputSteam，通常和序列化反序列化配合使用</p></li><li><p>管道流：在单线程里面使用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件字节流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件对象</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取文件流</span></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">    in.read(bytes);  <span class="comment">// 文件里的数据放到bytes里了</span></span><br><span class="line"></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\2.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出流</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file2);</span><br><span class="line">    <span class="comment">// 把数据写到输出流里面</span></span><br><span class="line">    out.write(bytes);</span><br><span class="line">    in.close();</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件字符流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得输入流</span></span><br><span class="line">    FileReader reader = <span class="keyword">new</span> FileReader(file1);</span><br><span class="line">    <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="comment">// 把内容写入到字符数组</span></span><br><span class="line">    reader.read(ch);</span><br><span class="line"></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\2.txt&quot;</span>);</span><br><span class="line">    FileWriter writer = <span class="keyword">new</span> FileWriter(file2);</span><br><span class="line">    <span class="comment">// 可以传入字符串，也可以传入字符数组</span></span><br><span class="line">    writer.write(ch);</span><br><span class="line">    writer.close();</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="29、同步、异步，阻塞和非阻塞"><a href="#29、同步、异步，阻塞和非阻塞" class="headerlink" title="29、同步、异步，阻塞和非阻塞"></a>29、同步、异步，阻塞和非阻塞</h3><p><strong>异步同步关心的是消息通信机制</strong></p><ul><li>同步：发出一个请求时，在没有得到结果之前，该请求就<strong>不返回</strong>直到得到结果</li><li>异步：请求后，这个调用就<strong>直接返回</strong>了，等结果出来后通过回调函数、通知等方法 返回结果。</li></ul><p><strong>阻塞非阻塞关心的是程序的状态</strong></p><ul><li>阻塞：发出一个请求，得到结果之前，会一直被阻塞。</li><li>非阻塞：发出一个请求，得到结果之前，自己可以做其他事情。</li></ul><h3 id="30、BIO、NIO、和AIO"><a href="#30、BIO、NIO、和AIO" class="headerlink" title="30、BIO、NIO、和AIO"></a>30、BIO、NIO、和AIO</h3><p><strong>BIO：</strong>同步阻塞式IO，服务器实现模式为<strong>一个连接一个线程（多线程）</strong>，即客户端有连接请求时服务器端就需要启动一个线程进行 IO 操作。虽然此时服务器具备了高并发能力，但是随着开启的线程数目增多，将会消耗过多的内存资源，导致服务器变慢甚至崩溃，NIO可以一定程度解决这个问题。 </p><p><strong>NIO：</strong>同步非阻塞式IO，服务器实现模式为 IO 多路复用，<strong>只需要开启一个线程</strong>就可以处理来自多个客户端的IO事件，客户端发送的连接请求都会<code>注册到多路复用器</code>上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 </p><ul><li>若服务端监听到客户端连接请求，便为其建立通信套接字(java中就是通道)，然后返回继续监听，若同时有多个客户端连接请求到来也可以全部收到，依次为它们都建立通信套接字。</li><li>若服务端监听到来自已经创建了通信套接字的客户端发送来的数据，就会调用对应接口处理接收到的数据，若同时有多个客户端发来数据也可以依次进行处理。 </li><li> 监听多个客户端的连接请求和接收数据请求同时还能监听自己时候有数据要发送。 </li></ul><p><strong>AIO(NIO.2)：</strong>异步非阻塞式IO，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p><blockquote><p>总结</p></blockquote><ul><li>NIO适合处理连接数目特别多，但是连接比较短（轻操作）的场景，Jetty，Mina，ZooKeeper等都是基于java nio实现。</li><li>BIO方式适用于连接数目比较小且固定的场景，这种方式对服务器资源要求比较高，并发局限于应用中。</li></ul><h3 id="31、序列化"><a href="#31、序列化" class="headerlink" title="31、序列化"></a>31、序列化</h3><ul><li><strong>序列化：</strong>用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</li><li><strong>反序列化：</strong>用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制</li></ul><p>注意：不能序列化static和transient修饰的成员变量</p><p><strong>目的：</strong>实现Java对象的运输和存储，如果不序列化，存储Java对象，然后再取出来可能会乱码。</p><p><strong>实现：</strong>让某个类是可序列化的，该类必须实现如下两个接口之一。Serializable  Externalizable</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID;  // 序列化版本标识符的静态变量</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(十):JDBC</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E5%8D%81%20)%20JDBC/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E5%8D%81%20)%20JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="1、数据库驱动"><a href="#1、数据库驱动" class="headerlink" title="1、数据库驱动"></a>1、数据库驱动</h1><p>驱动：声卡、显卡、数据库</p><h1 id="2、JDBC"><a href="#2、JDBC" class="headerlink" title="2、JDBC"></a>2、JDBC</h1><p>sun公司为了简化开发人员对数据库统一的操作，提供了java对数据库的统一规范，俗称JDBC</p><p>规定的具体实现由具体的厂商去做</p><h1 id="3、第一个JDBC程序"><a href="#3、第一个JDBC程序" class="headerlink" title="3、第一个JDBC程序"></a>3、第一个JDBC程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.wzh;</span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Connection;</span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Statement;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcdemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1：加载驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2：获取连接对象</span></span><br><span class="line">            conn = (Connection)                 </span><br><span class="line">conn = (Connection) DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/school?useUnicode=true&amp;characterEncoding=utf8&amp;userSSL=true&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);        </span><br><span class="line">            <span class="comment">//3：声明sql语句</span></span><br><span class="line">            String sql = <span class="string">&quot;SELECT * FROM student WHERE id = 1&quot;</span>;</span><br><span class="line">            <span class="comment">//4：创建处理对象</span></span><br><span class="line">            stmt = (Statement) conn.createStatement();</span><br><span class="line">            <span class="comment">//5：发送sql语句获取结果集(如果是查询操作才存在结果集)</span></span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="comment">//6. 迭代结果集</span></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="comment">//7：分析结果集</span></span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//8：关闭资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>URL</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/school?useUnicode=true&amp;characterEncoding=utf8&amp;userSSL=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 协议://主机地址：端口号/数据库名</span></span><br></pre></td></tr></table></figure><blockquote><p>Connection对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conn = (Connection) DriverManager.getConnection(url,name,password); </span><br><span class="line"><span class="comment">//connection代表数据库，所以conn是数据库的对象</span></span><br><span class="line"></span><br><span class="line">conn.rollback();           <span class="comment">//回滚</span></span><br><span class="line">conn.commit();             <span class="comment">//提交</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>); <span class="comment">//把每条数据自动提交关闭，即开启手动提交事务</span></span><br></pre></td></tr></table></figure><blockquote><p>Statement对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行SQL语句的对象</span></span><br><span class="line">stmt = (Statement) conn.createStatement();</span><br><span class="line">                </span><br><span class="line">stmt.executeQuery(sql);      <span class="comment">//查询操作，返回结果集</span></span><br><span class="line">stmt.execute(sql);           <span class="comment">//都可以，但是效率慢</span></span><br><span class="line">stmt.executeUpdate(sql);     <span class="comment">//增删改，返回受影响行数</span></span><br><span class="line">stmt.executeBatch(sql);      <span class="comment">//批处理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>ResultSet对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得结果集</span></span><br><span class="line">rs = stmt.executeQuery(sql);</span><br><span class="line"><span class="comment">//遍历结果集</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));   <span class="comment">// 获取名为name的String类型数据</span></span><br><span class="line">    System.out.println(rs.getString(<span class="number">1</span>));        <span class="comment">// 获取第1列数据</span></span><br><span class="line">    System.out.println(rs.findColumn(<span class="string">&quot;name&quot;</span>));  <span class="comment">// 获取name在第几列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>释放资源：必须做</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs.close();</span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h1 id="4、Statement和preparedStatement的对比"><a href="#4、Statement和preparedStatement的对比" class="headerlink" title="4、Statement和preparedStatement的对比"></a>4、Statement和preparedStatement的对比</h1><blockquote><p>创建方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Statement,不需要sql</span></span><br><span class="line">stmt = (Statement) Connection.createStatement(); </span><br><span class="line">rs = stmt.executeQuery(sql); </span><br><span class="line"><span class="comment">//PreparedStatement,需要sql</span></span><br><span class="line">stmt = (Statement)Connection.preparedStatement(sql);</span><br><span class="line">rs = stmt.executeQuery(); </span><br></pre></td></tr></table></figure><blockquote><p> 安全性</p></blockquote><ul><li>Statement：不能防止sql注入</li><li>PreparedStatement：可以防止SQL注入</li></ul><blockquote><p> 效率</p></blockquote><ul><li>Statement ：不会初始化，没有预处理，每次都是从0开始执行SQL</li><li>PreparedStatement：会先初始化SQL，先把这个SQL提交到数据库中进行预处理，多次使用可提高效率</li></ul><blockquote><p> 可读性</p></blockquote><ul><li>Statement：当多次执行参数不同的语句时，需要不断的拼接字符串，使得阅读变得极为耗时以及费力。</li><li>PreparedStatement ：通过SetXXX()这样的方式，提高了阅读性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT * FROM student WHERE id = ?&quot;</span>;</span><br><span class="line">PreparedStatement  stmt = conn.prepareStatement(sql);</span><br><span class="line">stmt.setInt(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><p>性能</p></blockquote><ul><li>Statement ：没有预编译的过程，每次都需要在DB中重新编译一下</li><li>PreparedStatement：语句被db的编译器编译后的执行代码就会被缓存下来， 那么下次调用时只要相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行就可以。 相当于一个函数 ， 对于整个db来说，只有预编译的语句和缓存中匹配，那么任何时候，就可以不需要再次编译从而直接执行。并不是所有的预编译语句都会被缓存起来，数据库本身会用一种策略，频繁使用的语句可能被缓存起来，以保存有更多的空间存储新的预编译语句。</li></ul><h1 id="5、SQL注入问题"><a href="#5、SQL注入问题" class="headerlink" title="5、SQL注入问题"></a>5、SQL注入问题</h1><p>在用户登录的时候，我们往往需要输入账号和密码，通过账号和密码和数据库中保存的账号密码进行匹配，匹配成功则登录成功，但是在匹配的时候会存在注入攻击的安全隐患，在输入账号和密码的时候，在末尾加上 “or” 再接上任何为真的语句，这样一来，有真就为真，这样也能登录成功。</p><p> 解决办法：使用PrepareStatement</p><h1 id="6、编写工具类"><a href="#6、编写工具类" class="headerlink" title="6、编写工具类"></a>6、编写工具类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用preparement方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明获取值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String uname = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String pwd = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//通过静态代码块将配置文件信息加载进来，保证加载驱动只需要执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建配置对象</span></span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">//获取输入流读取</span></span><br><span class="line">            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">            <span class="comment">//读取数据信息</span></span><br><span class="line">            properties.load(in);</span><br><span class="line">            <span class="comment">//通过方法获取配置文件中的数据信息</span></span><br><span class="line">            driver = properties.getProperty(<span class="string">&quot;mysql-driver&quot;</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">&quot;mysql-url&quot;</span>);</span><br><span class="line">            uname = properties.getProperty(<span class="string">&quot;mysql-username&quot;</span>);</span><br><span class="line">            pwd = properties.getProperty(<span class="string">&quot;mysql-password&quot;</span>);</span><br><span class="line">            <span class="comment">//加载驱动,只用一次</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取连接对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn = (Connection) DriverManager.getConnection(url,uname,pwd);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    //创建Statement对象</span></span><br><span class="line"><span class="comment">//    public static PreparedStatement getPreparedStatement(Connection conn,String sql) &#123;</span></span><br><span class="line"><span class="comment">//        if(conn==null) &#123;</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;连接为空&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        PreparedStatement stmt = null;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            stmt = (PreparedStatement) conn.prepareStatement(sql);</span></span><br><span class="line"><span class="comment">//        &#125; catch (SQLException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;创建Statement对象失败&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return stmt;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//关闭所有资源  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement stmt, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM student WHERE id = 1&quot;</span>;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JdbcUtils.getConn();</span><br><span class="line">            pstmt = (PreparedStatement) conn.prepareStatement(sql);</span><br><span class="line">            rs = pstmt.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、事务及批处理"><a href="#7、事务及批处理" class="headerlink" title="7、事务及批处理"></a>7、事务及批处理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用前面封装的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;UPDATE student set age = 15 WHERE id = ?&quot;</span>;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JdbcUtils.getConn();</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);              <span class="comment">//开启事务</span></span><br><span class="line">            pstmt = conn.prepareStatement(sql);     <span class="comment">//获得prepareStatement对象</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                pstmt.setInt(<span class="number">1</span>,i);</span><br><span class="line">                pstmt.addBatch();                   <span class="comment">//不断添加到批处理里面</span></span><br><span class="line">            &#125;</span><br><span class="line">            pstmt.executeBatch();                   <span class="comment">//批处理执行</span></span><br><span class="line">            conn.commit();                          <span class="comment">//提交事务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8、数据库连接池"><a href="#8、数据库连接池" class="headerlink" title="8、数据库连接池"></a>8、数据库连接池</h1><p>数据库连接—-&gt;执行—–&gt;释放 </p><p>该过程十分消耗资源</p><p>池化技术：准备一些预先的资源，过来就连接预先准备好的</p><ul><li>最小连接数：大小和常用连接数差不多</li><li>最大连接数：业务承载上限</li><li>等待超时：超过最大连接数时等待，等待过一定时间就超时，</li></ul><p>编写连接池：实现DataSource的接口</p><p>常见开源数据源：</p><ul><li>DBCP</li><li>C3P0</li><li>Druid：阿里巴巴</li></ul><p>使用了这些数据库连接池后，我们在项目开发中就不需要编写连接数据库的代码了</p><blockquote><p>DBCP</p></blockquote><p>需要coomos-dbcp-1.4    commos-pool-1.6包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.wzh;</span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Connection;</span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Statement;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcpconfig.properties&quot;</span>);</span><br><span class="line">            properties.load(in);</span><br><span class="line">            <span class="comment">//创建数据源 工厂模式</span></span><br><span class="line">            dataSource = BasicDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取连接对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> dataSource.getConnection(); <span class="comment">//从数据源获取连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement stmt, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>C3P0</p></blockquote><p>​      </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(九):Java的时间日期API使用</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%B9%9D%20)%20%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E4%B9%9D%20)%20%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1、JDK8之前"><a href="#1、JDK8之前" class="headerlink" title="1、JDK8之前"></a>1、JDK8之前</h2><h3 id="1-1、-时间戳"><a href="#1-1、-时间戳" class="headerlink" title="1.1、 时间戳"></a>1.1、 时间戳</h3><ul><li>java.lang.System类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差</span></span></span><br></pre></td></tr></table></figure><h3 id="1-2、-Date对象"><a href="#1-2、-Date对象" class="headerlink" title="1.2、 Date对象"></a>1.2、 Date对象</h3><ul><li><p>java.util.Date类</p></li><li><p>表示特定的瞬间，精确到毫秒</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器</span></span><br><span class="line">Date()          <span class="comment">// 取本地当前时间。</span></span><br><span class="line">Date(<span class="keyword">long</span> date) <span class="comment">// 通过时间戳获得时间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 常用方法    </span></span><br><span class="line">getTime()       <span class="comment">// 返回时间戳</span></span><br><span class="line">toString()    </span><br><span class="line"><span class="comment">// 把Date 对象转换为:dow mon ddhh:mm:ss zzz yyyy </span></span><br><span class="line"><span class="comment">// Sun Jun 06 11:57:16 CST 2021</span></span><br><span class="line"><span class="comment">// dow 是一周中的某一天 zzz是时间标准。</span></span><br></pre></td></tr></table></figure><h3 id="1-3、-格式化Date"><a href="#1-3、-格式化Date" class="headerlink" title="1.3、 格式化Date"></a>1.3、 格式化Date</h3><ul><li>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</li><li>它允许进行格式化：日期–&gt;文本、解析：文本–&gt;日期</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式化</span></span><br><span class="line">SimpleDateFormat()   <span class="comment">// 默认的模式和语言环境创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDateFormat</span><span class="params">(String pattern)</span><span class="comment">// 参数pattern格式创建对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(Date date)</span>        <span class="comment">// 方法格式化时间对象date</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 解析</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 按照给定的SimpleDateFormat格式解析字符串    </span></span></span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(time);</span><br><span class="line">    SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 EEE HH:mm:ss&quot;</span>);</span><br><span class="line">    System.out.println(format.format(date));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>格式化编码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">G<span class="comment">// 纪元标记AD</span></span><br><span class="line">y<span class="comment">// 四位年份2001</span></span><br><span class="line">M<span class="comment">// 月份July or 07</span></span><br><span class="line">d<span class="comment">// 一个月的日期10</span></span><br><span class="line">h<span class="comment">// A.M./P.M. (1~12)格式小时12</span></span><br><span class="line">H<span class="comment">// 一天中的小时 (0~23)22</span></span><br><span class="line">m<span class="comment">// 分钟数30</span></span><br><span class="line">s<span class="comment">// 秒数55</span></span><br><span class="line">S<span class="comment">// 毫秒数234</span></span><br><span class="line">E<span class="comment">// 星期几Tuesday</span></span><br><span class="line">D<span class="comment">// 一年中的日子360</span></span><br><span class="line">F<span class="comment">// 一个月中第几周的周几2 (second Wed. in July)</span></span><br><span class="line">w<span class="comment">// 一年中第几周40</span></span><br><span class="line">W<span class="comment">// 一个月中第几周1</span></span><br><span class="line">a<span class="comment">// vA.M./P.M. 标记PM</span></span><br><span class="line">k<span class="comment">// 一天中的小时(1~24)24</span></span><br><span class="line">K<span class="comment">// A.M./P.M. (0~11)格式小时10</span></span><br><span class="line">z<span class="comment">// 时区Eastern Standard Time</span></span><br><span class="line"><span class="string">&#x27;// 文字定界符Delimiter</span></span><br><span class="line"><span class="string">&quot;// 单引号</span></span><br></pre></td></tr></table></figure><h3 id="1-4、字符串格式化"><a href="#1-4、字符串格式化" class="headerlink" title="1.4、字符串格式化"></a>1.4、字符串格式化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">String s = String.format(<span class="string">&quot;%te&quot;</span>,date); <span class="comment">// 返回当天是几号</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日期格式化  </span></span><br><span class="line">%te  <span class="comment">// 几号</span></span><br><span class="line">%tb  <span class="comment">// 月份简称   %tB  全称</span></span><br><span class="line">%ta  <span class="comment">// 星期简称   %tA  全称    </span></span><br><span class="line">%tc  <span class="comment">// 全部日期和时间信息   星期二 二月 25 13:37:22 CST 2008</span></span><br><span class="line">%tY  <span class="comment">// 四位年份    %ty  二位年份   %tj   当年的第几天  085</span></span><br><span class="line">%tm  <span class="comment">// 月份     03    %tm:当月第几天   02</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  时间格式化</span></span><br><span class="line">%tH或者%tK   <span class="comment">// 2位数字的24时制的小时         </span></span><br><span class="line">%tI或者%tl   <span class="comment">// 2位数字的12时制的小时    </span></span><br><span class="line">%tM   <span class="comment">// 2位数字的分钟                      </span></span><br><span class="line">%tS   <span class="comment">// 2位数字的秒数   </span></span><br><span class="line">%tL   <span class="comment">// 3位数字的毫秒              </span></span><br><span class="line">%tN   <span class="comment">// 9位数字的毫秒  </span></span><br><span class="line">%tp   <span class="comment">// 上午或下午                     </span></span><br><span class="line">%tZ   <span class="comment">// 时区缩写形式的字符串</span></span><br><span class="line">%tz   <span class="comment">// 相对于GMT RFC 82 格式的数字时区偏移量    +0800</span></span><br><span class="line">%ts   <span class="comment">// 从1970年1月1日0时到现在经过的秒数      %tQ:毫秒数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 常见的日期时间组合</span></span><br><span class="line">%tF   <span class="comment">// 年-月-日   2008-03-25             </span></span><br><span class="line">%tD   <span class="comment">// 月/日/年   03/25/08</span></span><br><span class="line">%tc   <span class="comment">// 全部日期和时间信息   星期二 二月 25 13:37:22 CST 2008</span></span><br><span class="line">%tr   <span class="comment">// 时:分:秒 上午   12小时制    03:22:06下午         </span></span><br><span class="line">%tT   <span class="comment">// 时:分:秒 24小时制     %tR:时:分:秒 12小时制</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 常规类型格式化</span></span><br><span class="line">%b、%B  <span class="comment">// 结果格式化为布尔类型                </span></span><br><span class="line">%h、%H  <span class="comment">// 散列码              </span></span><br><span class="line">%s、%S  <span class="comment">// 字符串类型           </span></span><br><span class="line">%c、%C  <span class="comment">// 字符类型          </span></span><br><span class="line">%d      <span class="comment">// 十进制整数                </span></span><br><span class="line">%o      <span class="comment">// 八进制整数         </span></span><br><span class="line">%x、%X  <span class="comment">// 十</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 进制整数      </span></span><br><span class="line">%e  <span class="comment">// 科学计算法表示的十进制整数       1.700000e+01</span></span><br><span class="line">%a  <span class="comment">// 带有有效位和指数的十六进制浮点数  0X1.C0000000000001P4</span></span><br><span class="line">%n  <span class="comment">// 行分隔符                        %%:输出%</span></span><br></pre></td></tr></table></figure><h3 id="1-5、日历类"><a href="#1-5、日历类" class="headerlink" title="1.5、日历类"></a>1.5、日历类</h3><ul><li>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</li></ul><p><strong>创建对象</strong></p><ul><li> 使用Calendar.getInstance()方法</li><li> 调用它的子类GregorianCalendar的构造器。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar1 = Calendar.getInstance();</span><br><span class="line">Calendar calendar2 = new GregorianCalendar();</span><br></pre></td></tr></table></figure><p><strong>操作时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date)</span>    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title">getTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(Date date)</span></span></span><br></pre></td></tr></table></figure><ul><li>实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    calendar.set(<span class="number">2021</span>,<span class="number">6</span>,<span class="number">6</span>);    <span class="comment">// 设置时间</span></span><br><span class="line">    calendar.set(Calendar.AM,<span class="number">1</span>);        <span class="comment">// 设置一个字段</span></span><br><span class="line">    calendar.add(Calendar.DATE,-<span class="number">1</span>);  <span class="comment">// 推迟-1天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6、GregorianCalendar类"><a href="#1-6、GregorianCalendar类" class="headerlink" title="1.6、GregorianCalendar类"></a>1.6、GregorianCalendar类</h3><p>Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GregorianCalendar()  <span class="comment">// 默认</span></span><br><span class="line">GregorianCalendar(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date) </span><br><span class="line">GregorianCalendar(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date, <span class="keyword">int</span> hour, <span class="keyword">int</span> min) </span><br><span class="line">GregorianCalendar(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date, <span class="keyword">int</span> hour, <span class="keyword">int</span> min, <span class="keyword">int</span> sec) </span><br><span class="line"></span><br><span class="line">GregorianCalendar(Locale aLocale)  <span class="comment">// 指定语言环境和当前时间</span></span><br><span class="line">GregorianCalendar(TimeZone zone)   <span class="comment">// 给定时区</span></span><br><span class="line">GregorianCalendar(TimeZone zone, Locale aLocale) </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> amount)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">computeFields</span><span class="params">()</span>        <span class="comment">// 转换UTC毫秒值为时间域值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">computeTime</span><span class="params">()</span>          <span class="comment">// 覆盖Calendar ，转换时间域值为UTC毫秒值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>  <span class="comment">// 比较此 GregorianCalendar 与指定的 Object。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getActualMaximum</span><span class="params">(<span class="keyword">int</span> field)</span> <span class="comment">// 返回当前日期，给定字段的最大值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getActualMinimum</span><span class="params">(<span class="keyword">int</span> field)</span> <span class="comment">// 返回当前日期，给定字段的最小值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGreatestMinimum</span><span class="params">(<span class="keyword">int</span> field)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 GregorianCalendar 实例给定日历字段的最高的最小值。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Date <span class="title">getGregorianChange</span><span class="params">()</span> <span class="comment">// 获得格里高利历的更改日期。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLeastMaximum</span><span class="params">(<span class="keyword">int</span> field)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 GregorianCalendar 实例给定日历字段的最低的最大值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaximum</span><span class="params">(<span class="keyword">int</span> field)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 GregorianCalendar 实例的给定日历字段的最大值。</span></span></span><br><span class="line"><span class="function">Date <span class="title">getTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取日历当前时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getTimeInMillis</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获取用时间戳</span></span></span><br><span class="line"><span class="function">TimeZone <span class="title">getTimeZone</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获取时区。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinimum</span><span class="params">(<span class="keyword">int</span> field)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回给定字段的最小值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 重写hashCode.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">int</span> year)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 确定给定的年份是否为闰年。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">roll</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">boolean</span> up)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 用给定的值设置时间字段。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 设置年、月、日的值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 设置年、月、日、小时、分钟的值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 设置年、月、日、小时、分钟、秒的值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGregorianChange</span><span class="params">(Date date)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 设置 GregorianCalendar 的更改日期。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(Date date)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 用给定的日期设置Calendar的当前时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTimeInMillis</span><span class="params">(<span class="keyword">long</span> millis)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 用给定的long型毫秒数设置Calendar的当前时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTimeZone</span><span class="params">(TimeZone value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 用给定时区值设置当前时区。</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回代表日历的字符串。</span></span></span><br></pre></td></tr></table></figure><h2 id="2、JDK8之后"><a href="#2、JDK8之后" class="headerlink" title="2、JDK8之后"></a>2、JDK8之后</h2><p><strong>Calendar并不比Date好多少。它们面临的问题是：</strong></p><ul><li>可变性：像日期和时间这样的类应该是不可变的。</li><li>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</li><li>格式化：格式化只对Date有用，Calendar则不行。</li><li>此外，它们也不是线程安全的；不能处理闰秒等。</li></ul><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了日期时间和本地化的管理。</p><p><strong>新时间日期API</strong></p><ul><li>java.time – 包含值对象的基础包</li><li>java.time.chrono – 提供对不同的日历系统的访问</li><li>java.time.format – 格式化和解析时间和日期</li><li>java.time.temporal – 包括底层框架和扩展特性</li><li>java.time.zone – 包含时区支持的类</li></ul><h3 id="2-1、时间日期"><a href="#2-1、时间日期" class="headerlink" title="2.1、时间日期"></a>2.1、时间日期</h3><p>LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。 </p><ul><li>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。</li><li>LocalTime表示一个时间，而不是日期。 </li><li>LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">now() /  now(ZoneId zone)  <span class="comment">// 静态方法，根据当前时间创建对象/指定时区的对象</span></span><br><span class="line">of()                   <span class="comment">// 静态方法，根据指定日期/时间创建对象</span></span><br><span class="line">getDayOfMonth()/getDayOfYear() 获得月份天数(<span class="number">1</span>-<span class="number">31</span>) /获得年份天数(<span class="number">1</span>-<span class="number">366</span>)</span><br><span class="line">getDayOfWeek() 获得星期几(返回一个 DayOfWeek 枚举值)</span><br><span class="line">getMonth() 获得月份, 返回一个 Month 枚举值</span><br><span class="line">getMonthValue() / getYear() 获得月份(<span class="number">1</span>-<span class="number">12</span>) /获得年份</span><br><span class="line">getHour()/getMinute()/getSecond() 获得当前对象对应的小时、分钟、秒</span><br><span class="line">withDayOfMonth()/withDayOfYear()/</span><br><span class="line">withMonth()/withYear() 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</span><br><span class="line">plusDays(), plusWeeks(), </span><br><span class="line">plusMonths(), plusYears(),plusHours() 向当前对象添加几天、几周、几个月、几年、几小时</span><br><span class="line">minusMonths() / minusWeeks()/</span><br><span class="line">minusDays()/minusYears()/minusHours() 从当前对象减去几月、几周、几天、几年、几小时</span><br></pre></td></tr></table></figure><h3 id="2-2、瞬时"><a href="#2-2、瞬时" class="headerlink" title="2.2、瞬时"></a>2.2、瞬时</h3><p>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">now()   <span class="comment">// 静态方法，返回默认UTC时区的Instant类的对象</span></span><br><span class="line">ofEpochMilli(<span class="keyword">long</span> epochMilli) </span><br><span class="line"><span class="comment">// 静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象</span></span><br><span class="line">atOffset(ZoneOffset offset) <span class="comment">//结合即时的偏移来创建一个 OffsetDateTime</span></span><br><span class="line">toEpochMilli()              <span class="comment">//返回时间戳</span></span><br></pre></td></tr></table></figure><h3 id="2-3、格式化"><a href="#2-3、格式化" class="headerlink" title="2.3、格式化"></a>2.3、格式化</h3><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p><ul><li>预定义：如ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</li><li>本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)</li><li>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ofPattern(String pattern)  <span class="comment">// 指定字符串格式</span></span><br><span class="line">format(TemporalAccessor t) <span class="comment">// 格式化一个日期、时间，返回字符串</span></span><br><span class="line">parse(CharSequence text)   <span class="comment">// 将指定格式的字符序列解析为一个日期、时间</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(八):流式编程</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E5%85%AB%20)%20%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E5%85%AB%20)%20%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念及步骤"><a href="#1、概念及步骤" class="headerlink" title="1、概念及步骤"></a>1、概念及步骤</h2><p><strong>概念：</strong>可以对指定的集合执行非常复杂的查找、过滤和映射数据等操作</p><p><strong>使用步骤：</strong></p><ol><li>创建 Stream：一个数据源（如：集合、数组），获取一个流</li><li>中间操作：一个中间操作链，对数据源的数据进行处理</li><li>终止操作(终端操作) 一旦执行终止操作，就执行中间操作链，并产生结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(list.stream().filter((value)-&gt; value==<span class="string">&quot;1&quot;</span>).count());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、流的创建"><a href="#2、流的创建" class="headerlink" title="2、流的创建"></a>2、流的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、Collection方法 list.stream()</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span>          <span class="comment">// 返回一个顺序流</span></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span>  <span class="comment">// 返回一个并行流</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 2、Stream类的方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span>     <span class="comment">// 传入数组或者数组列表</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">empty</span><span class="params">()</span>             <span class="comment">// 产生空流</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span>    <span class="comment">// 函数式接口生成流</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T t)</span>     <span class="comment">// 创建只有一个元素的流</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// T作为函数式接口的参数,调用方法成为参数，这样无限递归    </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed,UnaryOperator&lt;T&gt; f)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，第二个函数用于判断是否结束流的创建    </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed,predicate&lt;? <span class="keyword">super</span> T&gt; hashNext ,UnaryOperator&lt;T&gt; f)</span>     </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 3、Arrays的方法   </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span>   <span class="comment">// 可以增加参数，让部分变成流</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 利用Stream的静态方法，把数组变成流</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(strs);</span><br><span class="line">        <span class="comment">// 利用Arrays的静态方法，把数组变成流，可以选择范围</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = Arrays.stream(strs,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建无限流方式1</span></span><br><span class="line">        Stream&lt;String&gt; stream3 = Stream.generate(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(Math.random());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建无限流方式2 ： 第一个元素f(n)，第二个f(f(n))，n为&quot;1&quot;</span></span><br><span class="line">        Stream&lt;String&gt; stream4 = Stream.iterate(<span class="string">&quot;1&quot;</span>,(n)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> n + <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建无限流方式3 ： 两个函数，函数1判断为false就结束流</span></span><br><span class="line">        Stream&lt;String&gt; stream5 = Stream.iterate(<span class="string">&quot;1&quot;</span>,(n)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(n.length()&lt;<span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,(n)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> n + <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、流的转换"><a href="#3、流的转换" class="headerlink" title="3、流的转换"></a>3、流的转换</h2><p><strong>流的转换会产生一个新流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选与切片</span></span><br><span class="line">filter(Predicate p)    <span class="comment">// 参数为lambda表达式，对流进行筛选</span></span><br><span class="line">distinct()             <span class="comment">// 根据流生成元素的hashcode和equals方法来去重</span></span><br><span class="line">limit(<span class="keyword">long</span> maxSieze)   <span class="comment">// 截断流让元素不超过一定数量</span></span><br><span class="line">skip(<span class="keyword">long</span> n)           <span class="comment">// 去除前n个元素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">sorted()               <span class="comment">// 按自然排序</span></span><br><span class="line">sorted(Comparator com) <span class="comment">// 按比较器排序，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射</span></span><br><span class="line">map(Function f)      <span class="comment">// 函数返回一个值，该值替换参数</span></span><br><span class="line">flatMap(Function f)  <span class="comment">//  函数返回一个流，把结果流拼接起来</span></span><br><span class="line">mapToDouble()        <span class="comment">// 同上，但是返回类型不同</span></span><br><span class="line">mapToInt()        </span><br><span class="line">mapToLong() </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">concat(Stream s1,Stream s2)</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><ul><li><p>filter：过滤不符合条件的，函数返回boolean类型</p></li><li><p>map：定义映射，函数返回类型为流里面数据的类型</p></li><li><p>floatmap：定义映射，函数返回类型为流</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">toStream</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            list.add(str.substring(i,i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;T,o,m&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;J,a,c,k&quot;</span>);</span><br><span class="line"><span class="comment">// 过滤长度小于1的</span></span><br><span class="line">        list.stream().filter((i)-&gt; &#123; </span><br><span class="line">            <span class="keyword">return</span> i.length() &gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 让所有参数加上1这个字符串                     </span></span><br><span class="line">        ).map((i)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="comment">// 把所有参数逗号分割开，结果转换成流    </span></span><br><span class="line">        &#125;).flatMap(str-&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> toStream(str);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>takewhile(function)：和 filter一样</li><li>dropwhile(function)：取所有不符合标准的</li></ul><h2 id="4、最终结果"><a href="#4、最终结果" class="headerlink" title="4、最终结果"></a>4、最终结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配与查找</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate p)</span>    <span class="comment">//检查是否匹配全部元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findFirst</span><span class="params">()</span>    <span class="comment">// 返回第一个元素</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findAny</span><span class="params">()</span>      <span class="comment">// 返回任意元素</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span>                        <span class="comment">// 返回总数</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">max</span><span class="params">(Comparator c)</span>    <span class="comment">// 传入比较器</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">min</span><span class="params">(Comparator c)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 过滤    </span></span></span><br><span class="line"><span class="function"><span class="title">mapping</span><span class="params">(Function f)</span>   <span class="comment">// 函数返回一个值，该值替换参数</span></span></span><br><span class="line"><span class="function"><span class="title">flatMap</span><span class="params">(Function f)</span>   <span class="comment">// 函数返回一个流，把结果流拼接起来</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 归约 t1,t2 -&gt; return</span></span></span><br><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T iden, BinaryOperator b)</span>   <span class="comment">// 把iden添加到流里计算</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator b)</span> </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 迭代  t -&gt; void</span></span></span><br><span class="line"><span class="function">Interator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span>    <span class="comment">// 产生迭代器    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(function)</span></span>;  </span><br><span class="line"><span class="comment">// 转换成数组</span></span><br><span class="line">Object[] toArray()</span><br><span class="line">T[] toArray(T[]::<span class="keyword">new</span>);   <span class="comment">// 传入构造器</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用Collectors的转换成集合  </span></span><br><span class="line">collect(Collectors.toList());  </span><br><span class="line">toList / toSet / toCollection</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Collectors计算 </span></span><br><span class="line"><span class="function">Long <span class="title">counting</span><span class="params">()</span>          <span class="comment">// 计算数量</span></span></span><br><span class="line"><span class="function">Integer <span class="title">summingInt</span><span class="params">()</span>     <span class="comment">// 对流中元素的整数属性求和</span></span></span><br><span class="line"><span class="function">Double <span class="title">veragingInt</span><span class="params">()</span>  <span class="comment">// 计算流中元素Integer属性的平均值</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">maxBy</span><span class="params">(Coompator)</span> <span class="comment">// 传入比较器</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">minBy</span><span class="params">(Coompator)</span></span></span><br><span class="line"><span class="function">String <span class="title">joining</span><span class="params">()</span>             <span class="comment">// 连接流中每个字符串 </span></span></span><br><span class="line"><span class="function"><span class="title">reducing</span><span class="params">()</span>                   <span class="comment">// 规约</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 映射到Map里面</span></span></span><br><span class="line"><span class="function">Map <span class="title">toMap</span><span class="params">(funcation1,function2)</span> <span class="comment">// 分别生成键和值  t-&gt; return   </span></span></span><br><span class="line"><span class="function">Map <span class="title">toConcurrentMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 分组</span></span></span><br><span class="line"><span class="function">Map&lt;K, List&lt;T&gt;&gt; <span class="title">groupingBy</span><span class="params">(function)</span> <span class="comment">// t-&gt;return 根据结果分组</span></span></span><br><span class="line"><span class="function">Map&lt;K, List&lt;T&gt;&gt; <span class="title">groupingByConcurrent</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">Map&lt;Boolean, List&lt;T&gt;&gt; <span class="title">partitioningBy</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 下游收集器，针对分组后里面的List处理 </span></span></span><br><span class="line"><span class="function">Map&lt;K, List&lt;T&gt;&gt; <span class="title">groupingBy</span><span class="params">(function,Collectors.方法()</span>)</span></span><br><span class="line"><span class="function"><span class="comment">// 先把结果进行处理，在执行方法 t -&gt; return    </span></span></span><br><span class="line"><span class="function">Collectors.<span class="title">collectingAndThen</span><span class="params">(Coolectors.方法()</span>,function)</span></span><br><span class="line"><span class="function">Collectors.<span class="title">counting</span><span class="params">()</span></span>;</span><br><span class="line">Collectors.summmingInt()</span><br><span class="line">Collectors.maxBy()</span><br><span class="line">Collectors.counting()</span><br></pre></td></tr></table></figure><ul><li>映射Map实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.stream().collect(Collectors.toMap((i)-&gt;&#123; </span><br><span class="line">        <span class="keyword">return</span> i.toString(); </span><br><span class="line">    &#125;,(i)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> i +<span class="number">1</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>collectingAndThen实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.stream().collect(Collectors.groupingBy((k)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;,Collectors.collectingAndThen(Collectors.counting(),(i)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、Optinal类型"><a href="#5、Optinal类型" class="headerlink" title="5、Optinal类型"></a>5、Optinal类型</h2><p>Optional<T>对象是一种包装器对象，要么包装了T的对象，要么没有包装任何对象，<strong>使用Optional可以很好的处理结果含有null的情况，</strong>通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">Optional.of(T t)  <span class="comment">// 创建一个 Optional 实例，t必须非空</span></span><br><span class="line">Optional.empty()  <span class="comment">// 创建一个空的 Optional 实例</span></span><br><span class="line">Optional.ofNullable(T t)  <span class="comment">// 可以为null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断对象是否包含值</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span>       <span class="comment">// 判断是否包含对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifresent</span><span class="params">(function)</span>   <span class="comment">// 不空执行函数，有参，有返回值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifPresentOrElse</span><span class="params">(function1,function2)</span></span>; <span class="comment">// 为空执行函数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤对象</span></span><br><span class="line"><span class="function">Optional <span class="title">map</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Optional <span class="title">flatMap</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function">Optional <span class="title">filter</span><span class="params">()</span>      <span class="comment">// 这三个函数与前面用法一致</span></span></span><br><span class="line"><span class="function">Optional <span class="title">or</span><span class="params">(function)</span>  <span class="comment">// 为空，使用函数(无参，有返回值)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 获取结果</span></span></span><br><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span>        <span class="comment">// 没有值抛出异常</span></span></span><br><span class="line"><span class="function">T <span class="title">orElse</span><span class="params">(T t)</span>  <span class="comment">// 没有值返回t</span></span></span><br><span class="line"><span class="function">T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span>  <span class="comment">// 没有值返回函数结果</span></span></span><br><span class="line"><span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSUpplier)</span>         </span></span><br></pre></td></tr></table></figure><h3 id="5-1、获取Optional值"><a href="#5-1、获取Optional值" class="headerlink" title="5.1、获取Optional值"></a>5.1、获取Optional值</h3><ul><li>供给函数式接口，无参，有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span>        <span class="comment">// 没有值抛出异常</span></span></span><br><span class="line"><span class="function">T <span class="title">orElse</span><span class="params">(T t)</span>  <span class="comment">// 没有值返回t</span></span></span><br><span class="line"><span class="function">T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span>  <span class="comment">// 没有值返回函数结果</span></span></span><br><span class="line"><span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSUpplier)</span>     </span></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 返回5</span></span><br><span class="line">    list.stream().max(Integer::compareTo).orElse(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 返回函数结果1</span></span><br><span class="line">    list.stream().max(Integer::compareTo).orElseGet(</span><br><span class="line">            ()-&gt;&#123; <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 返回一个异常</span></span><br><span class="line">    list.stream().max(Integer::compareTo).orElseThrow(</span><br><span class="line">            ()-&gt;&#123; <span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">&quot;没有数据&quot;</span>); &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2、判断Optional值"><a href="#5-2、判断Optional值" class="headerlink" title="5.2、判断Optional值"></a>5.2、判断Optional值</h3><ul><li>消费型函数式接口，有参，无返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span>       <span class="comment">// 判断是否包含对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifresent</span><span class="params">(function)</span>   <span class="comment">// 有参，有返回值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifPresentOrElse</span><span class="params">(function1,function2)</span></span>;</span><br><span class="line"><span class="comment">// 值为空，执行消费型函数function1，否则执行function2</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 不为空则输出i</span></span><br><span class="line">    list.stream().max(Integer::compareTo).ifPresent((i)-&gt;&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 不为空执行函数1，为空执行2</span></span><br><span class="line">    list.stream().max(Integer::compareTo).ifPresentOrElse((i)-&gt;&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;,()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="number">4</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3、处理Optional值"><a href="#5-3、处理Optional值" class="headerlink" title="5.3、处理Optional值"></a>5.3、处理Optional值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional <span class="title">map</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Optional <span class="title">flatMap</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">Optional <span class="title">filter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Optional <span class="title">or</span><span class="params">(function)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 为空，使用函数(无参，有返回值)产生一个新Optional</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.stream().max(Integer::compareTo).map((i)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    list.stream().max(Integer::compareTo).filter((i)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    list.stream().max(Integer::compareTo).or(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4、创建Optinal"><a href="#5-4、创建Optinal" class="headerlink" title="5.4、创建Optinal"></a>5.4、创建Optinal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional.of(T t)  <span class="comment">// 创建一个 Optional 实例，t必须非空</span></span><br><span class="line">Optional.empty()  <span class="comment">// 创建一个空的 Optional 实例</span></span><br><span class="line">Optional.ofNullable(T t)  <span class="comment">// 可以为null</span></span><br></pre></td></tr></table></figure><h3 id="5-5、转换成流"><a href="#5-5、转换成流" class="headerlink" title="5.5、转换成流"></a>5.5、转换成流</h3><p>通过stream() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = list.stream().max(Integer::compareTo).or(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(<span class="number">1</span>);</span><br><span class="line">&#125;).stream();</span><br></pre></td></tr></table></figure><h2 id="6、基本类型流"><a href="#6、基本类型流" class="headerlink" title="6、基本类型流"></a>6、基本类型流</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(七):IO流</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%83%20)%20IO%E6%B5%81/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%83%20)%20IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1、IO流分类简介"><a href="#1、IO流分类简介" class="headerlink" title="1、IO流分类简介"></a>1、IO流分类简介</h2><h3 id="1-1、分类"><a href="#1-1、分类" class="headerlink" title="1.1、分类"></a>1.1、分类</h3><blockquote><p>按照数据单位分类</p></blockquote><ul><li><strong>字节流（8bit）</strong>：处理一个字节</li><li><strong>字符流（16bit）</strong>：面向字节的流不便于处理Unicode形式的信息，而一个字符16字节专门处理Unicode字符</li></ul><blockquote><p>按照数据流向</p></blockquote><ul><li><strong>输入流：</strong>可以读取一个字节序列</li><li><strong>输出流：</strong>可以写入一个字节序列</li></ul><blockquote><p>安装流的角色</p></blockquote><ul><li>节点流</li><li>处理流</li></ul><h3 id="1-2、Java流分类"><a href="#1-2、Java流分类" class="headerlink" title="1.2、Java流分类"></a>1.2、Java流分类</h3><p><img src="/img/JavaSE/6.jpg"></p><h3 id="1-3、字节输入流：InputStream"><a href="#1-3、字节输入流：InputStream" class="headerlink" title="1.3、字节输入流：InputStream"></a>1.3、字节输入流：InputStream</h3><p>注意：InputStream是父类抽象类，有些方法没有具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据到输入流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>              <span class="comment">// 读取并返回一个字节到输入流，末尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;     <span class="comment">// 读取所有数据并且放到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="comment">// off开始，读到len</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readNBytes</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span>[] <span class="title">readAllBytes</span><span class="params">()</span> <span class="comment">// 读所有字节到输入流并返回数组</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 对输入流进行操作和分析    </span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(OutputStream out)</span> <span class="comment">// 转换成输出流并返回字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span>                 <span class="comment">// 输入流跳过n个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">available</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 标记 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span>   <span class="comment">// 在输入流当前位置打上标记</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span>               <span class="comment">// 返回到最后一个标记重写读取数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span>       <span class="comment">// 是否支持标记    </span></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> close    </span></span><br></pre></td></tr></table></figure><h3 id="1-4、字符输入流：Read"><a href="#1-4、字符输入流：Read" class="headerlink" title="1.4、字符输入流：Read"></a>1.4、字符输入流：Read</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">// 读取单个字符，范围在0 到65535之间,已到末尾返回-1 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 将字符读入数组。返回读取的数量，如果已到达流的末尾，则返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">//  将字符读入数组的某一部分。从off处开始存储，最多读len个字</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException  <span class="comment">// 关闭</span></span></span><br></pre></td></tr></table></figure><h3 id="1-5、字节输出流：OutputStream"><a href="#1-5、字节输出流：OutputStream" class="headerlink" title="1.5、字节输出流：OutputStream"></a>1.5、字节输出流：OutputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> n)</span>  <span class="comment">// 写出一个字节数据给n</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span>        <span class="comment">// 写出所有数据给字节数据byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,<span class="keyword">int</span> len)</span>  <span class="comment">// 最多写出len个字节 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;  <span class="comment">// 需要先刷新，再关闭</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="1-6、字符输出流：Writer"><a href="#1-6、字符输出流：Writer" class="headerlink" title="1.6、字符输出流：Writer"></a>1.6、字符输出流：Writer</h3><ul><li>Writer 可以用字符串来替换字符数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span>     <span class="comment">// 写入字符数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span>                 <span class="comment">// 写入字符串。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="comment">// 写入一部分到字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="comment">//刷新该流的缓冲，则立即将它们写入预期目标。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><h3 id="1-7、注意点"><a href="#1-7、注意点" class="headerlink" title="1.7、注意点"></a>1.7、注意点</h3><p>Java流都实现了Closeable接口，可以使用 try-with-resource方式</p><h2 id="2、File类使用"><a href="#2、File类使用" class="headerlink" title="2、File类使用"></a>2、File类使用</h2><p><strong>File的作用：</strong></p><ul><li>文件和文件目录路径的抽象表示形式，与平台无关</li><li>新建、删除、重命名文件和目录</li><li>作为参数传递给流的构造器</li></ul><h3 id="2-1、创建File对象"><a href="#2-1、创建File对象" class="headerlink" title="2.1、创建File对象"></a>2.1、创建File对象</h3><ul><li>目录：</li><li>文件的路径：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以pathname为路径创建File对象，可以是**绝对路径或者相对路径，如果是相对路径，则默认的当前路径在系统属性user.dir中存储。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent,String child)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以parent为父路径，child为子路径创建File对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent,String child)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">// 根据一个父File对象和子文件路径创建File对象    </span></span></span><br></pre></td></tr></table></figure><ul><li>实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 根据路径创建File对象</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据父路径创建File对象</span></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo&quot;</span>,<span class="string">&quot;test\\1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据父File对象创建File对象</span></span><br><span class="line">    File file3 = <span class="keyword">new</span> File(file1,<span class="string">&quot;test\\2.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里不是文件名，所以会抛出异常</span></span><br><span class="line">    file1.createNewFile();</span><br><span class="line">    <span class="comment">// 创建文件</span></span><br><span class="line">    file2.createNewFile();</span><br><span class="line">    file3.createNewFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、File类方法"><a href="#2-2、File类方法" class="headerlink" title="2.2、File类方法"></a>2.2、File类方法</h3><ul><li>获取功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getAbsolutePath</span><span class="params">()</span> <span class="comment">// 获取绝对路径</span></span></span><br><span class="line"><span class="function">String <span class="title">getPath</span><span class="params">()</span>         <span class="comment">// 获取路径</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>         <span class="comment">// 获取名称</span></span></span><br><span class="line"><span class="function">String <span class="title">getParent</span><span class="params">()</span>       <span class="comment">// 获取上层文件目录路径。若无，返回null</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span>         <span class="comment">// 获取文件长度，不能是目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span>   <span class="comment">// 获取最后一次的修改时间，毫秒值</span></span></span><br><span class="line"><span class="function">String[] <span class="title">list</span><span class="params">()</span>       <span class="comment">// 目录下的所有文件或者目录的名称数组</span></span></span><br><span class="line"><span class="function">File[] <span class="title">listFiles</span><span class="params">()</span>    <span class="comment">// File数组</span></span></span><br></pre></td></tr></table></figure><ul><li>判断功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span>  <span class="comment">// 判断是否是文件目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span>       <span class="comment">// 判断是否是文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span>       <span class="comment">// 判断是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span>      <span class="comment">// 判断是否可读</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span>     <span class="comment">// 判断是否可写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span>     <span class="comment">// 判断是否隐藏</span></span></span><br></pre></td></tr></table></figure><ul><li>创建功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="comment">// 创建文件。若存在，则返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span>  <span class="comment">// 上层目录存在，file对象的目录不存在时创建</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> <span class="comment">// 创建文件目录。如果上层文件目录不存在，一并创建</span></span></span><br></pre></td></tr></table></figure><ul><li>修改功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span>  <span class="comment">// 把文件重命名为指定的文件路径</span></span></span><br></pre></td></tr></table></figure><ul><li>删除功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span>     <span class="comment">// 不进windows的回收站</span></span></span><br></pre></td></tr></table></figure><h2 id="3、文件流"><a href="#3、文件流" class="headerlink" title="3、文件流"></a>3、文件流</h2><h3 id="3-1、字节流"><a href="#3-1、字节流" class="headerlink" title="3.1、字节流"></a>3.1、字节流</h3><ul><li><p>FileInputStream 和  FileOutputStream</p></li><li><p>取出 1.txt  的内容写入到  2.txt</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件对象</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取文件流</span></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">    in.read(bytes);  <span class="comment">// 文件里的数据放到bytes里了</span></span><br><span class="line"></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\2.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出流</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file2);</span><br><span class="line">    <span class="comment">// 把数据写到输出流里面</span></span><br><span class="line">    out.write(bytes);</span><br><span class="line">    in.close();</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、字符流"><a href="#3-2、字符流" class="headerlink" title="3.2、字符流"></a>3.2、字符流</h3><ul><li>FileReader 和 FileWriter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得输入流</span></span><br><span class="line">    FileReader reader = <span class="keyword">new</span> FileReader(file1);</span><br><span class="line">    <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="comment">// 把内容写入到字符数组</span></span><br><span class="line">    reader.read(ch);</span><br><span class="line"></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\2.txt&quot;</span>);</span><br><span class="line">    FileWriter writer = <span class="keyword">new</span> FileWriter(file2);</span><br><span class="line">    <span class="comment">// 可以传入字符串，也可以传入字符数组</span></span><br><span class="line">    writer.write(ch);</span><br><span class="line">    writer.close();</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、缓冲流"><a href="#4、缓冲流" class="headerlink" title="4、缓冲流"></a>4、缓冲流</h2><p>为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类</p><p>时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。</p><p><strong>根据数据操作单位可以把缓冲流分为：</strong></p><ul><li>BufferedInputStream</li><li>BufferedOutputStream</li><li>BufferedReader </li><li>BufferedWriter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    FileReader inputStream = <span class="keyword">new</span> FileReader(file1);</span><br><span class="line">    <span class="comment">// 缓存流需要其他流的转换</span></span><br><span class="line">    BufferedReader in = <span class="keyword">new</span> BufferedReader(inputStream,<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">16</span>];</span><br><span class="line">    in.read(ch);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">        System.out.println(ch[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、转换流"><a href="#5、转换流" class="headerlink" title="5、转换流"></a>5、转换流</h2><p><strong>Java API提供了两个转换流：</strong></p><ul><li>InputStreamReader：将InputStream转换为Reader</li><li>OutputStreamWriter：将Writer转换为OutputStream</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in)</span>    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputSreamReader</span><span class="params">(InputStream in,String charsetName)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 参数二为字符集</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutputSreamWriter</span><span class="params">(OutputStream out,String charsetName)</span>    </span></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line"><span class="comment">// 把字节流转换成字符流</span></span><br><span class="line">    InputStreamReader in = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br><span class="line">    <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">16</span>];</span><br><span class="line">    in.read(ch);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">        System.out.println(ch[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字符编码</p></blockquote><p><strong>编码表：</strong></p><p>计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表，这就是编码表</p><p><strong>常见的编码表</strong></p><ul><li>ASCII：美国标准信息交换码。 用一个字节的7位可以表示。</li><li>ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。</li><li>GB2312：中国的中文编码表。最多两个字节编码所有字符</li><li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字</li><li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。<strong>所有的文字都用两个字节</strong>来表示。</li><li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</li></ul><p><strong>注意：</strong></p><ul><li>GBK等双字节编码方式，用最高位是1或0表示两个字节和一个字节</li><li>Unicode只是一种全球标准的字符集，定义了字符的集合和唯一编号，但是实际传输并没有使用，<strong>主要是使用是UTF-8和UTF-16</strong>，这是Unicode编码集的实现。</li></ul><p>编码：字符串     —-&gt;  字节数组</p><p>解码：字节数组  —-&gt; 字符串</p><h2 id="6、-标准输入、输出流"><a href="#6、-标准输入、输出流" class="headerlink" title="6、 标准输入、输出流"></a>6、 标准输入、输出流</h2><p><strong>标准输入输出流</strong></p><ul><li>System.in的类型是InputStream</li><li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</li></ul><p><strong>重定向</strong>：通过<strong>System类的setIn，setOut方法</strong>对默认设备进行改变</p><ul><li>public static void setIn(InputStream in)</li><li>public static void setOut(PrintStream out)</li></ul><p><strong>通过Scanner接收数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取密码可以通过Console,这样输入不可见。并且一次只能读一行</span></span><br><span class="line">    Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="comment">// 获取一行的输入 输入 124 d 读取 124 d</span></span><br><span class="line">    String str1 = in.nextLine();</span><br><span class="line">    System.out.println(str1);</span><br><span class="line">    <span class="comment">// 读取到空格 输入 124 d 读取 124</span></span><br><span class="line">    String str2 = in.next();</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">    <span class="comment">// 判断数据是否还有其他词 true</span></span><br><span class="line">    System.out.println(in.hasNext());</span><br><span class="line">    <span class="comment">// 直接获取下一个</span></span><br><span class="line">    System.out.println(in.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 BufferedReader</span></span><br><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();    </span><br></pre></td></tr></table></figure><p><strong>把输入流转换成其他流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入信息(退出输入e或exit):&quot;</span>);</span><br><span class="line">    <span class="comment">// 把&quot;标准&quot;输入流(键盘输入)这个字节流包装成字符流,再包装成缓冲流</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    String s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">// 读取用户输入的一行数据 --&gt; 阻塞程序</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(s) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;安全退出!!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="comment">// 将读取到的整行字符串转成大写输出</span></span><br><span class="line">            System.out.println(<span class="string">&quot;--&gt;:&quot;</span> + s.toUpperCase());</span><br><span class="line">            System.out.println(<span class="string">&quot;继续输入信息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                br.close(); <span class="comment">// 关闭过滤流时,会关闭它包装的底层节点流</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、打印流"><a href="#7、打印流" class="headerlink" title="7、打印流"></a>7、打印流</h2><p><strong>PrintStream</strong>和<strong>PrintWriter</strong></p><ul><li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li><li>PrintStream和PrintWriter的输出不会抛出IOException异常</li><li>PrintStream和PrintWriter有自动flush功能</li></ul><h2 id="8、数据流"><a href="#8、数据流" class="headerlink" title="8、数据流"></a>8、数据流</h2><ul><li>方便地操作Java语言的基本数据类型和String的数据</li><li>数据流有两个类：(用于读取和写出基本数据类型、String类型DataInputStream 和 DataOutputStream分别套接在 InputStream和OutputStream子类的流上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataInputStream中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span>  <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span>        <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span>    <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span>        <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">readUTF</span><span class="params">()</span>       <span class="keyword">void</span> <span class="title">readFully</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span></span><br><span class="line"><span class="function"><span class="comment">// DataOutputStream中的方法,换成write   </span></span></span><br></pre></td></tr></table></figure><h2 id="9、对象流"><a href="#9、对象流" class="headerlink" title="9、对象流"></a>9、对象流</h2><p><strong>ObjectInputStream和OjbectOutputSteam</strong></p><ul><li>用于存储和读取<strong>基本数据类型</strong>数据或<strong>对象</strong>的处理流。</li><li>可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li></ul><h3 id="9-1、序列化"><a href="#9-1、序列化" class="headerlink" title="9.1、序列化"></a>9.1、序列化</h3><ul><li><strong>序列化：</strong>用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</li><li><strong>反序列化：</strong>用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制</li></ul><p>注意：不能序列化static和transient修饰的成员变量</p><p><strong>优点：</strong></p><ul><li>把内存中的Java对象转换成<strong>平台无关</strong>的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。</li><li>可将任何实现了Serializable接口的对象转化为<strong>字节数据</strong>，使其在保存和传输时可被还原</li></ul><p><strong>实现</strong>：</p><p>​        必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。</p><ul><li>Serializable</li><li>Externalizable</li></ul><p><strong>原理：</strong></p><ul><li><p>实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID;</span><br><span class="line"><span class="comment">// 表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容</span></span><br><span class="line"><span class="comment">// 值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明</span></span><br></pre></td></tr></table></figure></li><li><p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，<strong>如果相同就认为是一致的，可以进行反序列化</strong>，否则就会出现序列化版本不一致的异常。(InvalidCastException)</p></li></ul><h3 id="9-2、使用对象流序列化对象"><a href="#9-2、使用对象流序列化对象" class="headerlink" title="9.2、使用对象流序列化对象"></a>9.2、使用对象流序列化对象</h3><p>序列化写入文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    out.writeObject(user);  <span class="comment">// 把对象写入</span></span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">User user = (User) in.readObject();</span><br><span class="line">System.out.println(user); <span class="comment">// 获取对象</span></span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、NIO"><a href="#10、NIO" class="headerlink" title="10、NIO"></a>10、NIO</h2><h3 id="10-1、简介"><a href="#10-1、简介" class="headerlink" title="10.1、简介"></a>10.1、简介</h3><ul><li>NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。</li><li>NIO将以更加高效的方式进行文件的读写操作。</li><li>Java API中提供了两套NIO，<strong>一套是针对标准输入输出NIO，另一套就是网络编程NIO</strong></li><li>JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。</li></ul><h3 id="10-2、Path、Paths和Files核心API"><a href="#10-2、Path、Paths和Files核心API" class="headerlink" title="10.2、Path、Paths和Files核心API"></a>10.2、Path、Paths和Files核心API</h3><ul><li>FIle的功能不足，并且不会提供异常信息</li><li>Path接口：可以看成是File类的升级，代表一个平台无关的平台路径</li></ul><p><strong>Paths方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Path <span class="title">get</span><span class="params">(String first, String … more)</span> <span class="comment">// 用于将多个字符串串连成路径</span></span></span><br><span class="line"><span class="function">Path <span class="title">get</span><span class="params">(URI uri)</span>    <span class="comment">// 返回指定uri对应的Path路径</span></span></span><br></pre></td></tr></table></figure><p><strong>Path方法：获取信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span>  <span class="comment">// 返回调用 Path 对象的字符串表示形式</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String path)</span> <span class="comment">// 判断是否以 path 路径开始</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String path)</span> <span class="comment">// 判断是否以 path 路径结束</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAbsolute</span><span class="params">()</span> <span class="comment">// 判断是否是绝对路径</span></span></span><br><span class="line"><span class="function">Path <span class="title">getParent</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"><span class="comment">// 返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</span></span></span><br><span class="line"><span class="function">Path <span class="title">getRoot</span><span class="params">()</span>        <span class="comment">// 返回调用 Path 对象的根路径</span></span></span><br><span class="line"><span class="function">Path <span class="title">getFileName</span><span class="params">()</span>    <span class="comment">// 返回与调用 Path 对象关联的文件名</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNameCount</span><span class="params">()</span>    <span class="comment">// 返回Path 根目录后面元素的数量</span></span></span><br><span class="line"><span class="function">Path <span class="title">getName</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="comment">// 返回指定索引位置 idx 的路径名称</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Path <span class="title">toAbsolutePath</span><span class="params">()</span> <span class="comment">// 作为绝对路径返回调用 Path 对象</span></span></span><br><span class="line"><span class="function">Path <span class="title">resolve</span><span class="params">(Path p)</span>  <span class="comment">// 合并两个路径，返回合并后的路径对应的Path对象</span></span></span><br><span class="line"><span class="function">File <span class="title">toFile</span><span class="params">()</span>         <span class="comment">// 将Path转化为File类的对象</span></span></span><br></pre></td></tr></table></figure><p><strong>Files类：用于操作文件或目录的工具类</strong></p><ul><li>常用方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="function">Path <span class="title">createDirectory</span><span class="params">(Path path, FileAttribute&lt;?&gt; … attr)</span>  <span class="comment">// 目录  </span></span></span><br><span class="line"><span class="function">Path <span class="title">createFile</span><span class="params">(Path path, FileAttribute&lt;?&gt; … arr)</span>        <span class="comment">// 文件</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Path path)</span>         <span class="comment">// 删除一个文件/目录，不存在则报错</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteIfExists</span><span class="params">(Path path)</span> <span class="comment">// 不存在不报错</span></span></span><br><span class="line"><span class="function"><span class="comment">// 移动</span></span></span><br><span class="line"><span class="function">Path <span class="title">copy</span><span class="params">(Path src, Path dest, CopyOption … how)</span> <span class="comment">// 文件的复制    </span></span></span><br><span class="line"><span class="function">Path <span class="title">move</span><span class="params">(Path src, Path dest, CopyOption…how)</span> <span class="comment">// 移动到 dest</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">size</span><span class="params">(Path path)</span>           <span class="comment">// 返回 path 指定文件的大小</span></span></span><br></pre></td></tr></table></figure><ul><li>判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(Path path, LinkOption … opts)</span>        <span class="comment">// 是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">(Path path, LinkOption … opts)</span>   <span class="comment">// 是否是目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRegularFile</span><span class="params">(Path path, LinkOption … opts)</span> <span class="comment">// 是否是文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">(Path path)</span>   <span class="comment">// 判断是否是隐藏文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">(Path path)</span> <span class="comment">// 判断文件是否可读</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">(Path path)</span> <span class="comment">// 判断文件是否可写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">notExists</span><span class="params">(Path path, LinkOption … opts)</span> <span class="comment">// 是否不存在</span></span></span><br></pre></td></tr></table></figure><ul><li>操作内容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SeekableByteChannel <span class="title">newByteChannel</span><span class="params">(Path path, OpenOption…how)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获取与指定文件的连接，how 指定打开方式。</span></span></span><br><span class="line"><span class="function">DirectoryStream&lt;Path&gt; <span class="title">newDirectoryStream</span><span class="params">(Path path)</span> :</span></span><br><span class="line"><span class="function"><span class="comment">// 打开 path 指定的目录</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">newInputStream</span><span class="params">(Path path, OpenOption…how)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">// 获取 InputStream 对象</span></span></span><br><span class="line"><span class="function">OutputStream <span class="title">newOutputStream</span><span class="params">(Path path, OpenOption…how)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获取 OutputStream 对象</span></span></span><br></pre></td></tr></table></figure><h2 id="11、BIO、NIO、和AIO"><a href="#11、BIO、NIO、和AIO" class="headerlink" title="11、BIO、NIO、和AIO"></a>11、BIO、NIO、和AIO</h2><p><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写⼊必须阻塞在⼀个线程内等待其完<br>成。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型是⽐᫾不错的，可以<br>让每⼀个连接专注于⾃⼰的 I/O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问<br>题。线程池本身就是⼀个天然的漏⽃，可以缓冲⼀些系统处理不了的连接或请求。但是，当<br>⾯对⼗万甚⾄百万级连接的时候，传统的 BIO 模型是⽆能为⼒的。因此，我们需要⼀种更⾼<br>效的 I/O 处理模型来应对更⾼的并发量。<br><strong>NIO (Non-blocking/New I/O):</strong> NIO 是⼀种同步⾮阻塞的 I/O 模型，在 Java 1.4 中引⼊了<br>NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以<br>理解为 Non-blocking，不单纯是 New。它⽀持⾯向缓冲的，基于通道的 I/O 操作⽅法。<br>NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和<br>ServerSocketChannel 两种不同的套接字通道实现,两种通道都⽀持阻塞和⾮阻塞两种模式。<br>阻塞模式使⽤就像传统中的⽀持⼀样，⽐᫾简单，但是性能和可靠性都不好；⾮阻塞模式正<br>好与之相反。对于低负载、低并发的应⽤程序，可以使⽤同步阻塞 I/O 来提升开发速率和更<br>好的维护性；对于⾼负载、⾼并发的（⽹络）应⽤，应使⽤ NIO 的⾮阻塞模式来开发<br><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引⼊了 NIO 的改进版 NIO 2,它<br>是异步⾮阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应⽤操作之后会直<br>接返回，不会堵塞在那⾥，当后台处理完成，操作系统会通知相应的线程进⾏后续的操作。<br>AIO 是异步 IO 的缩写，虽然 NIO 在⽹络操作中，提供了⾮阻塞的⽅法，但是 NIO 的 IO ⾏<br>为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就<br>由这个线程⾃⾏进⾏ IO 操作，IO 操作本身是同步的。查阅⽹上相关资料，我发现就⽬前来<br>说 AIO 的应⽤还不是很⼴泛，Netty 之前也尝试使⽤过 AIO，不过⼜放弃了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(六):注解</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E5%85%AD%20)%20%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E5%85%AD%20)%20%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><ul><li>JDK5.0开始引入</li><li>作用类似于注释，可以对程序<strong>作出解释</strong>，这些信息可以在编译、类加载、运行时被读取</li><li>通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息，现在的主流Java框架均大量使用注解，可以这么说：<strong>框架 = 注解 + 反射 + 设计模式</strong></li></ul><h2 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h2><h3 id="2-1、内置注解："><a href="#2-1、内置注解：" class="headerlink" title="2.1、内置注解："></a>2.1、内置注解：</h3><p>​        比如@Override、@Depercated、@SuppressWarnings等等，在Java代码能经常看到</p><p>​        如**@Override**就是表明该方法是重写了父类的方法。</p><h3 id="2-2、元注解："><a href="#2-2、元注解：" class="headerlink" title="2.2、元注解："></a>2.2、元注解：</h3><p>​        负责<strong>注解其他注解</strong>，为meta-annotation类型，一共有4个，通过元注解就可以自定义注解，上面提到的Java内置注解其实就是Java预先用元注解帮我们定义好的，基本的4个元注解的作用如下</p><ol><li><code>@Target</code>：描述注解的使用范围</li><li><code>@Rentention</code>：描述该注解的生命周期，即在什么时候有效</li><li><code>@Document</code>：说明该注解将被包含在Javadoc中</li><li><code>@Inherited</code>：说明子类可以继承父类中的注解</li></ol><p><strong>@Target、@Rentention都是有参数的，各参数的定义如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="comment">// 形式：ElementType. 后面加上参数</span></span><br><span class="line"><span class="comment">// 当然也可以直接写参数 TYPE，不写前面的ElementType，不过需要import 静态常量</span></span><br></pre></td></tr></table></figure><ul><li><code>TYPE</code> : 类、接口或enum声明</li><li><code>FIELD</code>: 域(属性)声明</li><li><code>METHOD</code>: 方法声明</li><li><code>PARAMETER</code>: 参数声明</li><li><code>CONSTRUCTOR</code>: 构造方法声明 LOCAL_VARIABLE:局部变量声明</li><li><code>ANNOTATION_TYPE</code>:注释类型声明</li><li><code>PACKAGE</code>: 包声明</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br></pre></td></tr></table></figure><ul><li><code>SOURCE</code>:在源文件中有效（即源文件保留），编译器直接丢弃</li><li><code>CLASS</code>:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM不会保留注解</li><li><code>RUNTIME</code>：在运行时有效（即运行时保留），当运行 Java程序, JVM会保留注释，此时可以通过反射获取注解。</li></ul><h3 id="2-3、自定义注解"><a href="#2-3、自定义注解" class="headerlink" title="2.3、自定义注解"></a>2.3、自定义注解</h3><h2 id="3、自定义注解"><a href="#3、自定义注解" class="headerlink" title="3、自定义注解"></a>3、自定义注解</h2><h3 id="3-1、实例："><a href="#3-1、实例：" class="headerlink" title="3.1、实例："></a>3.1、实例：</h3><p>定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> &quot;20&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(age = &quot;30&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、分析"><a href="#3-2、分析" class="headerlink" title="3.2、分析"></a>3.2、分析</h3><p>注解的格式： public @interface 注解名 {   定义体  }     <strong>并且再加上元注解</strong></p><p><strong>这里我们先：</strong></p><ol><li>使用  <strong>@Retention(RetentionPolicy.RUNTIME)</strong>   表明 该注解是在 运行时 有效的</li><li>使用  <strong>@Target(ElementType.TYPE)</strong>  表明该接口定义在  类、接口或enum上</li><li>指定名称为  MyAnnotation</li></ol><p><strong>接着定义方法体的内容：</strong></p><ul><li>String age() default “20”; 表明定义了一个参数，名字为age，类型为String，默认值为20(可以不用默认值)</li></ul><p><strong>使用：</strong></p><ul><li>@MyAnnotation(age = “30”) 使用注解，给参数age赋值30并且标记在test<strong>类</strong>上面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法体里面的类型是数组时</span></span><br><span class="line">String[] value();</span><br><span class="line"><span class="meta">@MyAnnotation(&#123;&quot;4&quot;,&quot;1&quot;&#125;)</span></span><br><span class="line">myAnnotation.value()[<span class="number">0</span>];   <span class="comment">// myAnnotation为通过反射获取的注解对象</span></span><br></pre></td></tr></table></figure><blockquote><p>注意点</p></blockquote><ul><li>类型只能是基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组</li><li>没有成员定义的 Annotation 称为<strong>标记</strong>; 包含成员变量的 Annotation 称为<strong>元数据</strong> Annotation</li><li>如果只有一个注解，可以这么定义：String value() default “20”  ，这样使用时可以@MyAnnotation(“30”)</li></ul><h2 id="4、Java8新增特性"><a href="#4、Java8新增特性" class="headerlink" title="4、Java8新增特性"></a>4、Java8新增特性</h2><h3 id="4-1、可重复注解"><a href="#4-1、可重复注解" class="headerlink" title="4.1、可重复注解"></a>4.1、可重复注解</h3><p>​        在 Java 8 之前我们不能在<code>同一个类</code>、<code>同一方法</code>上重复使用同一个注解，在 JDK 8 中引入了一个注解<code> @Repeatable</code> 来标识某个注解是可被重复使用的，但是需要一个容器注解</p><p><strong>使用：</strong></p><p>定义可重复的注解容器注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(MyTests.class)</span></span><br><span class="line"><span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个可以重复的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyTests &#123;</span><br><span class="line">    MyTest[] value();       <span class="comment">//这是重复的容器注解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyTest(&quot;1&quot;)</span></span><br><span class="line"><span class="meta">@MyTest(&quot;2&quot;)</span></span><br><span class="line"><span class="meta">@MyTest(&quot;3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射获取注解并输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test表示使用注解的那个类</span></span><br><span class="line">    <span class="comment">// 反射是通过MyTest来获取，而不是通过容器注解来获取</span></span><br><span class="line">    MyTest[] annotationsByType = test.class.getAnnotationsByType(MyTest.class);</span><br><span class="line">    <span class="keyword">for</span> (MyTest myTest: annotationsByType) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类上的注解:&quot;</span>+myTest.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的理解：</p><ul><li>要让A注解支持重复注解，需要新定义B注解，里面属性的名为value，返回数组，类型为A注解。</li></ul><h3 id="4-2、类型注解"><a href="#4-2、类型注解" class="headerlink" title="4.2、类型注解"></a>4.2、类型注解</h3><p>DK 8 为 @Target 元注解新增了两种类型：<code>TYPE_PARAMETER</code>、<code>TYPE_USE</code></p><ol><li><p><code>TYPE_PARAMETER</code>：表示该注解能够写在 声明为 <code>泛型</code> 的语句中，类型参数声明如：<T>、&lt;T extends 某个类&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.TYPE_PARAMETER:表示注解能够放在泛型上面</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_PARAMETER)</span></span><br><span class="line"><span class="meta">@interface</span> TypeParam&#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用，</span></span><br><span class="line"><span class="keyword">public</span> &lt;<span class="meta">@TypeParam</span> T&gt; <span class="function">T <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>TYPE_USE</code>：表示注解可以用在[任何用到类型]的地方使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示注解可以用在[任何用到类型]的地方使用</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_USE)</span></span><br><span class="line"><span class="meta">@interface</span> NotNull&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@NotNull</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(五):异常处理</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%BA%94%20)%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E4%BA%94%20)%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1、处理错误"><a href="#1、处理错误" class="headerlink" title="1、处理错误"></a>1、处理错误</h2><p>Java程序运行区间，可能会出现错误，出现错误后，导致任务没有完成，程序应该：</p><ul><li>返回安全状态，让程序能运行其他命令</li><li>允许用户保存所有工作的结果，并以妥善的方式终止程序</li></ul><p>但是通常情况下很难实现，因为出现错误的代码，离实现上述功能的代码之间没有联系，依次引入了异常处理，异常处理就是将控制权从产生错误的地方<strong>转移到能正常处理这种情况的错误处理器</strong></p><p>为了能正确处理错误，需要考虑以下问题：</p><ul><li>用户输入错误</li><li>设备错误：硬件可能出现问题</li><li>物理限制：如堆内存溢出oom</li><li>代码错误：</li></ul><p>通常对于错误是返回一个错误码，如读取不到文件返回 - 1，但是并不是任何情况都能够返回一个错误码，所以异常处理机制没有采用返回值，而是选择遇到错误时，会通过一个路径退出方法，该方法抛出一个<strong>封装了错误信息</strong>的对象，需要注意的是，该方法会立即退出，并且原调用该方法的代码不会接着执行，而是会搜索能够处理这种异常状态的<strong>异常处理器</strong></p><h2 id="2、异常分类"><a href="#2、异常分类" class="headerlink" title="2、异常分类"></a>2、异常分类</h2><p>Throwable类是所有<strong>异常类</strong>的 ‘ 祖先’ ，即所有异常类都是由Throwable继承而来</p><p>Throwable有两个子类：Error（错误）、Exception（异常）</p><p>Exception有两个子类：：IOException 和 RuntimeException</p><p><strong>注意点</strong>：</p><ul><li>Error：不必处理，因为处理不了</li><li>RuntimeException：主要是由编程导致的异常，如数组越界，一般情况下是由于代码导致的，也就是其实可以通过良好的代码避免的，所以<strong>不要求强制处理</strong></li></ul><p>因此：Java把Error和RuntimeException划分为 <strong>非检查型异常，</strong>不一定要处理。但是其他的<strong>检查性异常则必须处理</strong>，一般都是处理IOException。</p><blockquote><p>异常方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span>     <span class="comment">// 返回关于发生的异常的详细信息。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Throwable <span class="title">getCause</span><span class="params">()</span>    <span class="comment">// 返回一个Throwable 对象代表异常原因。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span>  <span class="comment">// 打印toString()结果和栈层次到System.err，即错误输出流。</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StackTraceElement [] <span class="title">getStackTrace</span><span class="params">()</span>          </span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</span></span></span><br></pre></td></tr></table></figure><h2 id="3、异常处理"><a href="#3、异常处理" class="headerlink" title="3、异常处理"></a>3、异常处理</h2><h3 id="2-1、try-catch-finally处理"><a href="#2-1、try-catch-finally处理" class="headerlink" title="2.1、try-catch-finally处理"></a>2.1、try-catch-finally处理</h3><p>try中的代码发生异常时，若发生的异常包含在catch块中(catch块的参数),会转到catch代码块执行，执行完catch后，<code>跳过try剩余的代码，继续往后执行</code>，finally 无论是否发生异常，都会被执行。</p><p><strong>注意：</strong>当 try 语句和 finally 语句中都有 return 语句时，在⽅法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;Access element three :&quot;</span> + a[<span class="number">3</span>]);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 很明显数组越界，出现异常</span></span><br><span class="line">输出结果：java.lang.ArrayIndexOutOfBoundsException: <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>在try/catch 后面添加 finally 块并非强制性要求的。</li><li>try, catch, finally 块之间不能添加任何代码。</li><li>程序发生异常时，会生成异常对象，捕获得是异常对象（此例中的e）</li><li>catch捕获的异常对象，可以是具体的们<code>也可以是其父类</code>，所以Exception e万能</li><li><strong>重写方法不能抛出比被重写方法范围更大的异常类型</strong>。</li></ol><blockquote><p>finally不会被执行的情况</p></blockquote><ul><li>线程死亡</li><li>外部原因：如CPU出问题等等</li><li>在 try 或 finally 块中⽤了 System.exit(int) 退出程序。但是，如果 System.exit(int) 在异常语句之后， finally 还是会被执⾏</li></ul><p><strong>多重捕获异常</strong>：一个 try 代码块后面跟随多个 catch 代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、throws-把异常向上抛出"><a href="#2-2、throws-把异常向上抛出" class="headerlink" title="2.2、throws 把异常向上抛出"></a>2.2、throws 把异常向上抛出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把异常用throws抛出</span></span><br><span class="line"><span class="comment">// 格式：throws + 异常类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>抛出并不能从根本解决问题，如本例中eat方法被调用时，调用者必须<code>捕获异常</code>，或者继续抛出。</li><li>如果一直到main方法里，还继续抛出的话，发生异常就会由JVM处理，导致程序中断</li></ol><h2 id="4、自定义异常"><a href="#4、自定义异常" class="headerlink" title="4、自定义异常"></a>4、自定义异常</h2><p><strong>throws 是把异常向上抛出</strong></p><p><strong>throw   是人为抛出异常</strong>：使用throw关键字人为的抛出一个异常，程序执行到throw语句时立即停止，抛出时直接抛出<strong>异常类的实例化对象</strong>即可</p><p><strong>案例1：抛出异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 人为抛出的异常也需要捕获</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line">输出结果：java.lang.Exception: 抛出异常</span><br></pre></td></tr></table></figure><p><strong>案例2：自定义异常</strong></p><ul><li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li><li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类</li></ul><p><strong>自定义异常类：</strong>该类含有money的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常类必须继承现有的异常类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line">    <span class="comment">// 初始化，给money赋初始值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取剩余的钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义银行类：</strong>定义抛出异常的规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="comment">// 模拟取钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getmoney</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果余额笔要去的大，就可以取出，不然抛出自定义异常</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.balance&gt;balance)&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = <span class="keyword">this</span>.balance - balance;</span><br><span class="line">            System.out.println(<span class="string">&quot;取了&quot;</span>+balance);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;钱不够&quot;</span>);</span><br><span class="line">            <span class="comment">// 此处也要捕获异常</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 并抛出 自定义异常类的对象</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MyException(balance - <span class="keyword">this</span>.balance);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">                <span class="comment">// 根据捕获的对象，我们可以获取money信息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;缺少&quot;</span>+e.getMoney()+<span class="string">&quot;元钱&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟存钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmoney</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = <span class="keyword">this</span>.balance + balance;</span><br><span class="line">        System.out.println(<span class="string">&quot;存了&quot;</span> + balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bank bank = <span class="keyword">new</span> Bank(<span class="number">1</span>);</span><br><span class="line">bank.setmoney(<span class="number">3000</span>);   <span class="comment">// 存钱</span></span><br><span class="line">bank.getmoney(<span class="number">3001</span>);   <span class="comment">// 取钱超过存钱，触发抛出异常</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>注意抛出的是对象，所以可以通过<code>e.getMoney获取</code>到money的值</li><li>同理抛出异常对象的时候，由于自定义异常类只有有参构造，所以必须传参</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(四):泛型</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E5%9B%9B%20)%20%E6%B3%9B%E5%9E%8B/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E5%9B%9B%20)%20%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1、泛型简介"><a href="#1、泛型简介" class="headerlink" title="1、泛型简介"></a>1、泛型简介</h2><p>泛型程序设计，意味着编写的代码可以对多种不同的类型的对象重用，例如ArrayList不仅可以存String，还可以存Integer等等多种类型。</p><p><strong>泛型之前：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义，没有指定数据类型</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p>ArrayList维护了一个Object类型的数组，再这个数组上进行操作，但是存在问题</p><ul><li>获取值必须要转换类型</li><li>没有类型检查，可以向 Object[] 数组添加任何数据，但是这样取数据就会出错</li></ul><p><strong>泛型之后</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定数据类型</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>编译器通过泛型知道了数据的类型，就无须进行类型转换了，并且可以检查加入数据的类型是否正确</li><li>让程序更加易读，更加安全</li></ul><p><strong>通配符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个员工类</span></span><br><span class="line">ArrayList&lt;Employee&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 定义一个经理类，经理继承子员工</span></span><br><span class="line">ArrayList&lt;Manage&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>很显然，如果要把 list2 的数据添加到 list1 中，是可以的，Manage可以向上转型成 Employee，但是反过来则不行，泛型通配符就可以解决这一问题</p><h2 id="1-2、简单泛型类"><a href="#1-2、简单泛型类" class="headerlink" title="1.2、简单泛型类"></a>1.2、简单泛型类</h2><ul><li>Java内置库使用E表示集合的元素类型，K、V表示键、值，T表示任意类型</li><li>泛型类相当于普通类的工厂</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样就不必为了存储什么类型而担忧了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.second = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo1</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 省略get、set方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化需要指定类型</span></span><br><span class="line">Demo1&lt;String&gt; demo1 = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="1-3、泛型方法"><a href="#1-3、泛型方法" class="headerlink" title="1.3、泛型方法"></a>1.3、泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T...a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(Demo1.&lt;Integer&gt;getMiddle(a)); <span class="comment">// 实际可以把&lt;Integer&gt;省略</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Demo1.getMiddle(<span class="number">1.4</span>,<span class="number">1.3</span>,<span class="number">2</span>) <span class="keyword">instanceof</span> Double);</span><br></pre></td></tr></table></figure><ul><li>若为这种形式，编译器会自动装箱成Double，Double，Integer，然后转成Double</li></ul><h2 id="1-4、类型变量的限定"><a href="#1-4、类型变量的限定" class="headerlink" title="1.4、类型变量的限定"></a>1.4、类型变量的限定</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限定只有实现了Comparable接口的才能排序,注意这里使用extends并不代表一定是继承</span></span><br><span class="line"><span class="comment">// T extends A &amp; B      多个限定这种形式，注意继承的话要放第一个</span></span><br><span class="line"><span class="comment">// T extends Comparable,R extends String   多个用这种形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">compare</span><span class="params">(T...a)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;进行比较&quot;</span>);</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    <span class="keyword">for</span> (T num: a) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">9</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Demo1.compare(a);</span><br></pre></td></tr></table></figure><h2 id="1-5、泛型原理"><a href="#1-5、泛型原理" class="headerlink" title="1.5、泛型原理"></a>1.5、泛型原理</h2><blockquote><p>类型擦除</p></blockquote><p>无论何时定义一个泛型类型，都会自动提供一个相应的原始类型，原始类型就是去掉泛型参数后的泛型类型名，<strong>类型变量会被擦除</strong>，并替换为其限定类型</p><p><strong>原理：</strong></p><ul><li>编译器会检查 数据类型的一致性，若不一致，则编译不通过，无法编译</li><li>若编译通过，代表类型一致，进行泛型擦除</li></ul><p><strong>1.2中的Demo1类在擦除后</strong>：</p><ul><li>Demo1 底层会把 T <strong>全部转换成Object</strong></li><li>添加数据时，编译器会做数据类型校验，若指定的是 Demo1<String>，只有String类型才能通过编译。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为T是一个没有限定的变量，所以直接用Object替代</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.second = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo1</span><span class="params">(Object first, Object second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 省略get、set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.4中如下</p><ul><li>底层会把 T <strong>全部转换成Comparable</strong></li><li>添加数据时，编译器会做数据类型校验，<ul><li>首先指定的类型必须实现Comparable接口，</li><li>接着若指定的是 Demo1<String>，只有String类型才能通过编译。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来限定必须实现Comparable接口，擦除后直接把T替换成Comparable</span></span><br><span class="line"><span class="comment">// 编译器判断数据是不是 Comparable 的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(Comparable...a)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;进行比较&quot;</span>);</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    <span class="keyword">for</span> (Comparable num: a) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>转换泛型表达式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原本这么定义</span></span><br><span class="line">Demo1&lt;String&gt; demo1 = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br><span class="line">String name = demo.getFirst(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实getFirst()返回的是Object类型，但是编译器会帮我们转换</span></span><br><span class="line">String name = (String) demo.getFirst();</span><br></pre></td></tr></table></figure><blockquote><p>泛型方法多态性保证</p></blockquote><p><strong>方法类型擦除后会造成一些问题，如下所示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo2继承了Demo1类，并且泛型为Date类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">Demo1</span>&lt;<span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 因为指定父类了父类类型Date才能这么做，不然会报错</span></span><br><span class="line">        Date date = getFirst();</span><br><span class="line">        System.out.println(date +<span class="string">&quot; &quot;</span> + second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 擦除类型后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显然Demo2除了自己的方法，还有继承而来的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很明显是两个不同的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">Demo1</span>&lt;<span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 子类本身方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从父类继承的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试成功通过，输出子类方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo1&lt;Date&gt; demo1 = <span class="keyword">new</span> Demo2();</span><br><span class="line">        demo1.setSecond(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式在普通代码能实现多态，<strong>但是泛型类里要考虑一个问题</strong>，就是父子类的参数不同，不构成重写，这样本来应该两个类冲突的，但是为什么没有冲突，又是如何保持多态的？<strong>桥方法解决</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会在Demo2里面生成一个新的桥方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setSecond((Date) second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 Demo2 的方法 嵌套进 Demo1 的方法 里面，这样调用的是实际是Dmeo 2 的方法</p><blockquote><p>泛型擦除后的方法重复问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入定义的是这样</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子类方法&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 很显然，类型擦除后Demo2 会有两个方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子类方法&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 来自父类Demo1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，由于返回值不构成重载，这被认为是一个方法，但是为什么不报错？</p><p><strong>原因：</strong>JVM虚拟机<strong>会根据返回值判断</strong>是不是同一个方法</p><blockquote><p>桥方法解决协变问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 桥方法适用广泛</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CLone........</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Employee会有两个clone类,称为有协变的返回类型</span></span></span><br><span class="line"><span class="function">Employee <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 这种情况，桥方法会使用新的方法</span></span><br></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><ul><li>虚拟机没有泛型，只有普通类和方法</li><li>所有泛型参数会被替换成限定类型，若没有则替换成Object</li><li><strong>会合成桥方法来保证多态</strong></li><li>保证类安全，必要时会插入强制类型转换</li></ul><h2 id="1-6、局限性"><a href="#1-6、局限性" class="headerlink" title="1.6、局限性"></a>1.6、局限性</h2><h3 id="1、不能使用基本类型实例化参数"><a href="#1、不能使用基本类型实例化参数" class="headerlink" title="1、不能使用基本类型实例化参数"></a>1、不能使用基本类型实例化参数</h3><p><strong>原因：</strong>Object不能存储基本类型的值，而泛型擦除后都是Object或者限定类存储</p><h3 id="2、无法使用instanceof判断泛型类型"><a href="#2、无法使用instanceof判断泛型类型" class="headerlink" title="2、无法使用instanceof判断泛型类型"></a>2、无法使用instanceof判断泛型类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于泛型擦除，所以String变为Object，永远成立,无法缺点a的泛型类型</span></span><br><span class="line"><span class="keyword">if</span>(<span class="function">a <span class="keyword">instanceof</span> <span class="title">Demo1</span><span class="params">(String)</span>)</span></span><br><span class="line"><span class="function">    </span></span><br></pre></td></tr></table></figure><h3 id="3、不能创建参数化类型的数组"><a href="#3、不能创建参数化类型的数组" class="headerlink" title="3、不能创建参数化类型的数组"></a>3、不能创建参数化类型的数组</h3><ul><li>由于数组的劣势，任何数组都可以转换成 Object[] 数组，然而转换之后，由于泛型擦除，object只能知道要加入 Demo1 类型，不知道要加入 Demo1&lt; String &gt; 类型，从而报错</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数化类型的数组</span></span><br><span class="line">Demo1&lt;String&gt;[] demo1 = <span class="keyword">new</span> Demo1&lt;String&gt;[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 泛型擦除之后，可以转换成object</span></span><br><span class="line">Demo1[] demo1 = <span class="keyword">new</span> Demo1[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把demo1赋值给Object数组</span></span><br><span class="line">Object[] object = demo1;   <span class="comment">// 相当于Object[] object = new Demo1[5];</span></span><br><span class="line"><span class="comment">// 数组记录了类型为demo1,但是因为泛型擦除，不知道应该为Demo1&lt;String&gt;，所以下面编译通过</span></span><br><span class="line">object[<span class="number">0</span>] = <span class="keyword">new</span> Demo1&lt;String&gt;();</span><br><span class="line">object[<span class="number">1</span>] = <span class="keyword">new</span> Demo1&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于object和demo1的引用指向一个对象，所以等效为,于是编译通过，但是报错</span></span><br><span class="line">demo1[<span class="number">0</span>] = <span class="keyword">new</span> Demo1&lt;String&gt;();</span><br><span class="line">demo1[<span class="number">1</span>] = <span class="keyword">new</span> Demo1&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常情况</span></span><br><span class="line">Demo1&lt;String&gt; demo1 = <span class="keyword">new</span> Demo1();</span><br><span class="line">Object object = demo1; <span class="comment">// 转换成Object类型之后，会丢失方法</span></span><br><span class="line">demo1.setSecond(<span class="string">&quot;1&quot;</span>);  <span class="comment">// 由于不存在该方法，编译器会检查出错误，从而避免类型不一致</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>数组强转Object[] ，原来数组存储的对象的方法还在</li><li>对象强转Object类型，会丢失方法</li></ul><h3 id="4、Varargs警告"><a href="#4、Varargs警告" class="headerlink" title="4、Varargs警告"></a>4、Varargs警告</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义如下方法，注意参数实际是一个数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(ArrayList&lt;T&gt; coll, T...ts)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (T t:ts) &#123;</span><br><span class="line">coll.add(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Demo1&lt;String&gt;&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Demo1&lt;String&gt; demo1 = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br><span class="line">Demo1&lt;String&gt; demo2 = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br><span class="line"><span class="comment">// 注意到，这里建立了Demo1&lt;String&gt;数组，这种情况规则会放松，不会报错，但是会警告</span></span><br><span class="line">Demo2.addAll(collection,demo1,demo2);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用其中之一的注解注释在方法上，可以取消警告</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@SafeVarargs</span>  <span class="comment">//该注解只能使用再static、final或Java9中private的构造器和方法</span></span><br></pre></td></tr></table></figure><h3 id="5、不能-new-泛型变量"><a href="#5、不能-new-泛型变量" class="headerlink" title="5、不能 new 泛型变量"></a>5、不能 new 泛型变量</h3><p><strong>原因：</strong></p><ul><li>new T()是必须要有运行时类型信息的，否则运行时不知道实例的类型，而泛型擦除后，一律创建的是Object类型或者限定类型，<strong>无法获得类的信息</strong></li><li>T t 表示的只是某个实例，所以可以运行时自动推测类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把Demo1的构造方法更改成如下，会报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.first = <span class="keyword">new</span> T();</span><br><span class="line">    <span class="keyword">this</span>.second = <span class="keyword">new</span> T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原因：泛型擦除后变为Object，创建的类型是Object</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.first = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">this</span>.second = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6、不能-new-泛型数组"><a href="#6、不能-new-泛型数组" class="headerlink" title="6、不能 new 泛型数组"></a>6、不能 new 泛型数组</h3><p><strong>原因：</strong></p><ul><li>泛型擦除后，为Comparable[] 数组</li><li>假设返回类型可能为User[] 数组 ，就必须要向下转型，不安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] create(<span class="keyword">int</span> length)&#123;</span><br><span class="line">    T[] result = <span class="keyword">new</span> T[length];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型擦除后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] create(<span class="keyword">int</span> length)&#123;</span><br><span class="line">Object[] result = <span class="keyword">new</span> Object[length];</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 若T为User实现了接口，获取结果时 (User[]) result ，不安全，因为很明显Comparable对象不含User对象的属性和方法</span></span><br></pre></td></tr></table></figure><h3 id="7、泛型类的泛型变量不能使用static"><a href="#7、泛型类的泛型变量不能使用static" class="headerlink" title="7、泛型类的泛型变量不能使用static"></a>7、泛型类的泛型变量不能使用static</h3><p><strong>原因：</strong>静态变量初始化时无法获得变量类型，所以失败</p><h3 id="8、不能捕获抛出泛型类实例"><a href="#8、不能捕获抛出泛型类实例" class="headerlink" title="8、不能捕获抛出泛型类实例"></a>8、不能捕获抛出泛型类实例</h3><p><strong>原因：</strong></p><ul><li>内部被擦除称为Object 类型，JVM不知道应该抛出哪个异常</li></ul><blockquote><p>取消对检查型异常的检查</p></blockquote><ul><li>接收收到的异常，然后转换成 RuntimeException 异常</li><li>注意这里泛型的作用仅仅表明需要转换的类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T) t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写就可以把异常转换成编译器认为的非检查型异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">Demo2.&lt;RuntimeException&gt;throwAs(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实战：</strong>让多线程不抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            Demo2.&lt;RuntimeException&gt;throwAs(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9、擦除后的冲突"><a href="#9、擦除后的冲突" class="headerlink" title="9、擦除后的冲突"></a>9、擦除后的冲突</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这个equals泛型擦除后会和Object的方法冲突，<strong>参数，名称，返回值完全一致</strong>，注意这里因为没有继承，所以不会有桥方法，所以只能改名字或者不用泛型。</p><h3 id="10、多实现的冲突"><a href="#10、多实现的冲突" class="headerlink" title="10、多实现的冲突"></a>10、多实现的冲突</h3><p>一个类定义为泛型类，则该类的因为类型不同会有多个衍生类，这些衍生类最多只能有一个作为<strong>某一个类的父类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt; ....</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Manage</span>&gt;.....</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">// 泛型擦除后，编译能通过    </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>....</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>..... </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">// 但是使用会报错,由于继承，所以会生成两个桥方法，而这两个桥方法完全一致，所以报错</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">int</span> <span class="title">compareTo</span>(<span class="title">Object</span> <span class="title">object</span>)</span>&#123;  </span><br><span class="line">    <span class="comment">// 调用Comparable&lt;Employee&gt;的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object object)</span></span>&#123;  </span><br><span class="line">    <span class="comment">// 调用Comparable&lt;Manage&gt;的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7、泛型类的继承规则"><a href="#1-7、泛型类的继承规则" class="headerlink" title="1.7、泛型类的继承规则"></a>1.7、泛型类的继承规则</h2><h4 id="1、子类问题"><a href="#1、子类问题" class="headerlink" title="1、子类问题"></a>1、子类问题</h4><ul><li>Employee  是Manage 的 父类</li><li>但是 Demo1&lt; Employee &gt; 不是 Demo1&lt; Manage &gt;的父类</li></ul><h4 id="2、数组的子类问题"><a href="#2、数组的子类问题" class="headerlink" title="2、数组的子类问题"></a>2、数组的子类问题</h4><ul><li>Employee  是Manage 的 父类</li><li>Employee[]  是Manage[] 的 父类</li></ul><p><strong>这个是为什么不能创建泛型参数化类型数组的核心原因</strong></p><h4 id="3、泛型类可以转换成原始类"><a href="#3、泛型类可以转换成原始类" class="headerlink" title="3、泛型类可以转换成原始类"></a>3、泛型类可以转换成原始类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo1&lt;User&gt; demo1 = <span class="keyword">new</span> Demo1();</span><br><span class="line">        Demo1 demo2 = demo1;</span><br><span class="line">        demo2.setSecond(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">// 原始类型，编译器会自动帮我们寻找类型</span></span><br><span class="line">        System.out.println(demo2.getSecond() <span class="keyword">instanceof</span> String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、通配符"><a href="#8、通配符" class="headerlink" title="8、通配符"></a>8、通配符</h2><h3 id="8-1、概念"><a href="#8-1、概念" class="headerlink" title="8.1、概念"></a>8.1、概念</h3><p><strong>通配符类型中，允许类型参数发生变化，如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Demo1&lt;? extends Employee&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用通配符如下定义之后    </span></span><br><span class="line">Demo1&lt;?&gt; demo1 = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br><span class="line"><span class="comment">// 里面的方法也会变成?</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.first = first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? first)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.first = first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于无法获得具体的类型，setFirst会拒绝接收任何参数</span></span><br><span class="line"><span class="comment">// 该方法是设置里面的属性Second</span></span><br><span class="line">demo1.setSecond(demo1.getFirst());  <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><h3 id="8-2、解决泛型继承规则带来的局限"><a href="#8-2、解决泛型继承规则带来的局限" class="headerlink" title="8.2、解决泛型继承规则带来的局限"></a>8.2、解决泛型继承规则带来的局限</h3><p><strong>继承规则引起的局限</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Demo1&lt;Employee&gt; demo)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Manage 为 Employee 的子类，根据泛型继承规则</span></span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Employee&gt;());  <span class="comment">// 编译通过</span></span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Manage&gt;()); </span><br><span class="line"><span class="comment">// 报错，因为Demo1&lt;Manage&gt; 不是 Demo1&lt;Employee&gt;的子类</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>通配符解决问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样限定范围之后，就可以解决上述问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Demo1&lt;? extends Employee&gt; demo)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型 ArrayList&lt;Demo2&gt; 是ArrayList&lt;? extends Demo1&gt;的子类</span></span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Employee&gt;()); </span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Manage&gt;());</span><br></pre></td></tr></table></figure><p><strong>并且不会带来安全隐患</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo1&lt;Manage&gt; m = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br><span class="line">        Demo1&lt;? extends Employee&gt; e = m;</span><br><span class="line">        e.setFirst(<span class="keyword">new</span> Manage());    <span class="comment">// 编译不通过</span></span><br><span class="line">        e.setFirst(<span class="keyword">new</span> Employee());  <span class="comment">// 编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// setFirst方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.first = first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// setFirst需要的参数为 capture of ? extends Employee ,因为只知道是需要子类，但是不清楚具体类型，所以拒绝接收任何类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，也可以不使用通配符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Employee&gt; <span class="function">Demo1&lt;T&gt; <span class="title">print</span><span class="params">(Demo1&lt;T&gt; demo)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> demo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3、超类型限定"><a href="#8-3、超类型限定" class="headerlink" title="8.3、超类型限定"></a>8.3、超类型限定</h3><p>限定参数必须是超类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo1&lt;? <span class="keyword">super</span> Manage&gt;</span><br></pre></td></tr></table></figure><h3 id="8-4、无限定通配符"><a href="#8-4、无限定通配符" class="headerlink" title="8.4、无限定通配符"></a>8.4、无限定通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Demo1&lt;?&gt; demo1)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> demo1.getFirst() == <span class="keyword">null</span> || demo1.getSecond()==<span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Demo1&lt;String&gt; demo1 = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br><span class="line">       demo1.setSecond(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">       System.out.println(check(demo1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-5、通配符捕获"><a href="#8-5、通配符捕获" class="headerlink" title="8.5、通配符捕获"></a>8.5、通配符捕获</h3><p><strong>概念：</strong>泛型参数 如T捕获通配符</p><p>定义一个方法，实现交换值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">swap</span><span class="params">(Demo1&lt;?&gt; demo1)</span></span>&#123;</span><br><span class="line">   <span class="comment">// 然而这种写法是错误的</span></span><br><span class="line">   ? t = demo1.getFirst();</span><br><span class="line">    <span class="comment">// 这种方式也不能通过编译</span></span><br><span class="line">   demo1.setFirst(demo1.getSecond());</span><br><span class="line">   demo1.setSecond(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用泛型方法中转，这种情况下参数T捕获通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Demo1&lt;?&gt; demo1)</span></span>&#123;</span><br><span class="line">   swapHelper(demo1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Demo1&lt;T&gt; demo1)</span></span>&#123;</span><br><span class="line">T t = demo1.getFirst();</span><br><span class="line">demo1.setFirst(demo1.getSecond());</span><br><span class="line">demo1.setSecond(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通配符捕获只有在非常限定的情况下成立，<strong>编译器必须保证通配符表示单个能确定的类型，</strong>如ArrayList&lt;Demo1<T>&gt;就永远不能捕获ArrayList&lt;Demo1<T>&gt;的通配符，列表可以保存两个Demo1&lt;?&gt;，其中 ？ 分别具有不同的类型</p><h2 id="9、泛型和反射"><a href="#9、泛型和反射" class="headerlink" title="9、泛型和反射"></a>9、泛型和反射</h2><h3 id="9-1、泛型Class类型"><a href="#9-1、泛型Class类型" class="headerlink" title="9.1、泛型Class类型"></a>9.1、泛型Class类型</h3><p>Class类是泛型类，String.class 就是Class<String>类的唯一对象</p><p>API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">()</span>     <span class="comment">// 返回无参构造的一个新实例</span></span></span><br><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">(Object... parameters)</span>   </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">T <span class="title">cast</span><span class="params">(Object obj)</span>  <span class="comment">// 若obj为null或能转换成T类型，返回T，否则抛出异常</span></span></span><br><span class="line"><span class="function">T[] <span class="title">getEnumConstants</span><span class="params">()</span> <span class="comment">// 若T为枚举类型，则返回所有值组成的数组，否则null</span></span></span><br><span class="line"><span class="function">Class&lt;? <span class="keyword">super</span> T&gt; <span class="title">getSuperClass</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 返回这个类的超类，若T不是一个类或者Object类，返回null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class... parameterTypes)</span> <span class="comment">// </span></span></span><br></pre></td></tr></table></figure><h3 id="9-2、使用Class-参数进行类型匹配"><a href="#9-2、使用Class-参数进行类型匹配" class="headerlink" title="9.2、使用Class 参数进行类型匹配"></a>9.2、使用Class<T> 参数进行类型匹配</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Person&lt;T&gt; <span class="title">makeUser</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将T同Employee匹配，编译器推断返回Person&lt;Employee&gt;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person&lt;T&gt;(c.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        Person person = makeUser(Employee.class);</span><br><span class="line">        Employee employee = (Employee) person.getT();</span><br><span class="line">        employee.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;员工&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3、虚拟机的泛型信息"><a href="#9-3、虚拟机的泛型信息" class="headerlink" title="9.3、虚拟机的泛型信息"></a>9.3、虚拟机的泛型信息</h3><p>Java泛型会进行擦除，但是仍然保留关于泛型的信息，比如Demo1 直到它来自于泛型类 Demo1<T> ，尽管虚拟机不会直到它来自Demo1<String> 还是 其他</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; min(T[] a)</span><br><span class="line"><span class="comment">// 泛型擦除后    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">min</span><span class="params">(Cimparale[] a)</span></span></span><br></pre></td></tr></table></figure><p><strong>通过反射API可以确定</strong></p><ul><li>泛型方法有一个名为T的参数</li><li>这个类型参数有一个子限定类型，其自身又是一个泛型类型</li><li>这个限定类型有一个通配符参数</li><li>这个通配符参数有一个超类型限定</li><li>这个泛型方法有一个泛型数组参数</li></ul><p><strong>Java.lang.reflect 包中的接口Type，含有以下子类</strong></p><ul><li>Class类，描述具体类型</li><li>TypeVarible 接口 ： 描述类型变量</li><li>WildcardTyepe接口：描述通配符</li><li>ParameterizedType：描述泛型类或接口类型，比如collection<String></li><li>GenericArrayTye接口：描述泛型数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class方法</span></span><br><span class="line">TypeVariable[] getTypeParameters() </span><br><span class="line"><span class="comment">// 如果类型被声明为泛型类型，则获得泛型类型变量，否则获得长度为0的数组  </span></span><br><span class="line">Type[] getGenericSuperClass();   <span class="comment">// 获得声明超类的泛型类型</span></span><br><span class="line">Type[] getGenericInterfaces();   <span class="comment">// 获得这个类型所声明接口的泛型类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// method方法</span></span><br><span class="line">TypeVariable[] getTypeParameters() </span><br><span class="line">Type[] getGenericParameterTypes()  <span class="comment">// 获得泛型参数，</span></span><br><span class="line"><span class="function">Type <span class="title">getGenericReturnType</span><span class="params">()</span>        <span class="comment">// 获得泛型返回值类型。 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// TypeVariable方法</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Type[] <span class="title">getBounds</span><span class="params">()</span>   <span class="comment">// 获得变量的子类限定</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// wildcardType方法     </span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getUpperBounds</span><span class="params">()</span>    <span class="comment">// 获得这个类型变量的子类限定</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getLowerBounds</span><span class="params">()</span>   <span class="comment">// 超类限定</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ParameterizedType</span></span></span><br><span class="line"><span class="function">Type <span class="title">getRawType</span><span class="params">()</span>    <span class="comment">//获得原始类型</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getActualTypeArguments</span><span class="params">()</span>    <span class="comment">// 获得这个参数化类型声明的类型参数</span></span></span><br><span class="line"><span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span>     <span class="comment">//  返回外部类型，是顶层则返回null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// GenericArrayType</span></span></span><br><span class="line"><span class="function">Type <span class="title">getGenericComponentType</span><span class="params">()</span> <span class="comment">// 获得这个数组类型声明的泛型元素类型 </span></span></span><br></pre></td></tr></table></figure><h3 id="9-4、类型字面量"><a href="#9-4、类型字面量" class="headerlink" title="9.4、类型字面量"></a>9.4、类型字面量</h3><p>有时，希望通过值来决定程序的行为，不过，如果有泛型类，擦除会带来问题，比如ArrayList<String>、ArrayList<Integer> 擦除后都为ArrayList。</p><ul><li>可以通过反射捕获类型，然后根据类型执行不同的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="keyword">new</span> TypeLiteral&lt;ArrayList&lt;Integer&gt;&gt;()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeLiteral 构造器会捕获泛型超类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeLiteral</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TypeLiteral&#123;</span><br><span class="line">        Type parentType = getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span>(parentType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(三):集合框架</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%89%20)%20%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%89%20)%20%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1、集合框架概述"><a href="#1、集合框架概述" class="headerlink" title="1、集合框架概述"></a>1、集合框架概述</h2><h3 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h3><p>在学习Java的集合框架之前，都是通过数组来存放数组，但是数组有一些弊端</p><ul><li>数组初始化以后，长度就确定了</li><li>数组中提供的属性和方法少，不便于进行添加、删除、插入等操作</li><li>存储数据的特点单一，即都是有序可重复的</li></ul><p><strong>Java集合类可以弥补数组在存储数据方面的不足</strong></p><h3 id="1-2、分类"><a href="#1-2、分类" class="headerlink" title="1.2、分类"></a>1.2、分类</h3><p>Java 集合可分为 Collection 和 Map 两种体系</p><p>Collection接口：单列数据，定义了存取一组对象的方法的集合</p><ul><li><strong>List</strong>：元素有序、可重复的集合</li><li><strong>Set</strong>：元素无序、不可重复的集合</li></ul><p>Map接口：双列数据，保存具有映射关系“key-value对”的集合</p><p><img src="/img/JavaSE/1.jpg"></p><p><img src="/img/JavaSE/2.jpg"></p><h2 id="2、Collection-接口"><a href="#2、Collection-接口" class="headerlink" title="2、Collection 接口"></a>2、<strong>Collection</strong> 接口</h2><h3 id="2-1、简介"><a href="#2-1、简介" class="headerlink" title="2.1、简介"></a>2.1、简介</h3><p>1、Collection 接口是 List、Set 和 Queue 接口的父接口</p><p>2、该接口方法<strong>可以用于List、set、Queue集合</strong></p><p>3、JDK不提供此接口的任何<strong>直接实现</strong>，而是提供更具体的子接口实现</p><h3 id="2-2、主要方法"><a href="#2-2、主要方法" class="headerlink" title="2.2、主要方法"></a>2.2、主要方法</h3><p>由于List、Set 和 Queue 都是collection的子类，所以都可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add(Object obj)、addAll(Collection coll)                         <span class="comment">// 添加</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span>、<span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection coll)</span>： <span class="comment">// 删除</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span>：       <span class="comment">// 判断是否包含某个元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection c)</span>：  <span class="comment">// 通过元素的equals方法比较</span></span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span>                   <span class="comment">// 转换成数组</span></span></span><br><span class="line"><span class="function"><span class="title">iterator</span><span class="params">()</span>                           <span class="comment">// 返回迭代器对象，用于集合遍历</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>          <span class="comment">// 清空集合</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>     <span class="comment">// 判断是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>            <span class="comment">// 获取有效元素个数</span></span></span><br><span class="line"><span class="function"><span class="title">hashCode</span><span class="params">()</span>            <span class="comment">// 获取集合哈希值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>        <span class="comment">// 是否相等</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection c)</span>： <span class="comment">// 获取交集，结果放在当前集合</span></span></span><br></pre></td></tr></table></figure><h3 id="2-3、Iterator迭代器接口"><a href="#2-3、Iterator迭代器接口" class="headerlink" title="2.3、Iterator迭代器接口"></a>2.3、Iterator迭代器接口</h3><p>概述：</p><ul><li>Collection接口实现了迭代器接口</li><li>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素</li><li>Iterator 仅用于<code>遍历集合</code>，集合对象每次调用iterator()方法都得到<code>全新</code>的迭代器对象</li><li>集合添加，插入数据都是靠迭代器来遍历到指定的位置的</li><li><strong>迭代器的位置是位于两个元素之间的</strong></li></ul><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hasNext()     <span class="comment">// 判断是否还有元素</span></span><br><span class="line">next()        <span class="comment">// 返回当前值，同时执行后一位</span></span><br><span class="line">remove()      <span class="comment">// 调用集合对象本身的remove方法</span></span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator(); <span class="comment">// 获取迭代器</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">        <span class="comment">// 指向下一个元素的同时返回值</span></span><br><span class="line">System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了迭代器遍历，还有其他遍理方式，如foreach</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通方法</span></span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8特性</span></span><br><span class="line">list.forEach(System.out::println);  </span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line">list.forEach((str)-&gt;&#123;System.out.println(str);&#125;);</span><br></pre></td></tr></table></figure><h2 id="3、Collection的子接口：list"><a href="#3、Collection的子接口：list" class="headerlink" title="3、Collection的子接口：list"></a>3、Collection的子接口：list</h2><p><strong>概述：</strong></p><ul><li>我们通常使用List替代数组，list集合的长度是<code>动态</code>的，与数组不同</li><li>list集合中的元素都是<code>有序，可重复的</code>，每个元素都有其对应的顺序索引</li><li>中List接口的实现类常用的有：ArrayList、LinkedList和Vector</li></ul><p><strong>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加。更改、移除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span>:             <span class="comment">// 在index位置插入ele元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection eles)</span>:  <span class="comment">// 从index位置开始将插入集合</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span>:                       <span class="comment">// 移除index位置的元素，返回此元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Function)</span>               <span class="comment">// 函数返回true，就删除</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection c1,Collection c2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection c1,Collection c2)</span>  <span class="comment">// 两个相反</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span>:           <span class="comment">// 更改指定index位置的元素为ele</span></span></span><br><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span>:    <span class="comment">// 截断list</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取信息</span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>:        <span class="comment">// 获取指定index位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span>:      <span class="comment">// 返回obj在集合中首次出现的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object obj)</span>:  <span class="comment">// 返回obj在当前集合中末次出现的位置</span></span></span><br></pre></td></tr></table></figure><h3 id="3-1、List接口的迭代器：ListIterator"><a href="#3-1、List接口的迭代器：ListIterator" class="headerlink" title="3.1、List接口的迭代器：ListIterator"></a>3.1、List接口的迭代器：ListIterator</h3><p><strong>迭代器：</strong>若迭代器A、B同时操作一个集合，但是A改变了结构，这样B就会混乱</p><p><strong>List规定：</strong>若一个迭代器发现他的集合被修改了，就会抛出异常。因此，建议给一个集合关联多个迭代器时，建议限定这些迭代器只能读；或者只使用一个迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it1 = list.iterator(); <span class="comment">// 获取迭代器</span></span><br><span class="line">Iterator&lt;String&gt; it2 = list.iterator();</span><br><span class="line">it1.next();</span><br><span class="line">it1.remove();</span><br><span class="line">it2.next();  <span class="comment">//  java.util.ConcurrentModificationException</span></span><br></pre></td></tr></table></figure><p><strong>方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it2 = list.iterator(n); <span class="comment">// 获得位置在n处的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;      <span class="comment">// 在当前位置前插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(E element)</span></span>;      <span class="comment">// 在当前位置更改插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hashPrevious</span><span class="params">()</span></span>;   <span class="comment">// 判断前面是否有元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hashNext</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function">E <span class="title">previous</span><span class="params">()</span></span>;             <span class="comment">// 返回前面的一个集合</span></span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span></span>;          <span class="comment">// 返回下一次调用next方法时将返回的元素所有</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2、List实现类之一：ArrayList"><a href="#3-2、List实现类之一：ArrayList" class="headerlink" title="3.2、List实现类之一：ArrayList"></a>3.2、List实现类之一：ArrayList</h3><p><strong>本质：</strong></p><p>ArrayList是对象引用的一个”变长”数组</p><ul><li>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组</li><li>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</li></ul><p>Arrays.asList(…) 返回值是一个<code>固定长度</code>的 List 集合，不能增加数据</p><p><strong>特点：</strong>从数据中间删除、增添元素开销很大，但是访问速度快</p><h3 id="3-3、List实现类之一：LinkedList"><a href="#3-3、List实现类之一：LinkedList" class="headerlink" title="3.3、List实现类之一：LinkedList"></a>3.3、List实现类之一：LinkedList</h3><p><strong>本质：</strong></p><ul><li>是一个双向链表，内部没有声明数组。</li><li>因为是链表结构，所以<code>频繁的插入或删除元素</code>的操作，会比ArrayList更快</li><li>可以当成栈、队列来使用</li><li>get方法做了优化，会自动选择从尾部或者头部遍历，不过</li></ul><p><strong>结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">E item;</span><br><span class="line">Node&lt;E&gt; next;  </span><br><span class="line">Node&lt;E&gt; prev;</span><br><span class="line">Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line"><span class="keyword">this</span>.item = element;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line"><span class="keyword">this</span>.prev = prev;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新增方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Object obj)</span>  <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function">Object <span class="title">getFirst</span><span class="params">()</span>          Object <span class="title">getLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">removeFirst</span><span class="params">()</span>       Object <span class="title">removeLast</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="3-4、List-实现类之三：Vector"><a href="#3-4、List-实现类之三：Vector" class="headerlink" title="3.4、List 实现类之三：Vector"></a>3.4、List 实现类之三：Vector</h3><p><strong>特点：</strong></p><p>​        大多数操作与ArrayList相同，区别之处在于Vector是<code>线程安全</code>的。</p><p><strong>新增方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(Object obj)</span>     <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(Object obj,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(Object obj,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(Object obj)</span>  <span class="keyword">void</span> <span class="title">removeAllElements</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="4、Collection子接口：Set"><a href="#4、Collection子接口：Set" class="headerlink" title="4、Collection子接口：Set"></a>4、Collection子接口：Set</h2><ul><li>Set接口是Collection的子接口，set接口没有提供额外的方法</li><li>Set 集合<code>不允许包含相同</code>的元素，如果试把两个相同的元素加入同一个，会失败</li></ul><h3 id="4-1、Set实现类之一：HashSet"><a href="#4-1、Set实现类之一：HashSet" class="headerlink" title="4.1、Set实现类之一：HashSet"></a>4.1、Set实现类之一：HashSet</h3><p><strong>特点：</strong></p><ol><li>按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能</li><li><code>无序</code>、<code>线程不安全</code>、集合元素可以为<code>null</code></li><li>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类</li><li>底层是<strong>数组+散列算法</strong>，也就是说Hashset是通过数组存放数据的</li></ol><p><strong>注意点：</strong></p><p>​    若是在Set容器中存放对象，则对象的那个类必须要重写  equals 方法和 hashcode 方法，即保证equals相等的对象，hashcode也必须相等，以实现对象相等规则。<strong>相等的对象必须具有相等的散列码。</strong></p><p><strong>添加元素的过程</strong></p><ol><li>调用 方法获取哈希值，并根据哈希值判断通过<strong>散列函数</strong>判断在底层数组的存储位置。</li><li>判断 hashcode 值是否已经存在，若已经存在，则再通过 equals 方式判断</li><li>若 equals 返回 true ，则添加失败；若为false ，则<code>通过链表的方式继续链接</code>，保证唯一性</li></ol><p><strong>底层结构</strong>：</p><p>​        底层是数组，初始容量为16，当如果使用率超过0.75，就会扩大容量为原来的2倍</p><p><strong>创建方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;&gt;(list);</span><br><span class="line">HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> HashSet&lt;String&gt;(<span class="number">16</span>,<span class="number">0.8f</span>);</span><br></pre></td></tr></table></figure><blockquote><p>HashSet扩展:LinkedHashSet</p></blockquote><p><strong>特点：</strong></p><ol><li>LinkedHashSet 是 HashSet 的子类，不允许元素重复，</li><li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表按照插入顺序<strong>维护元素的次序</strong></li><li>LinkedHashSet插入性能略低于 HashSet，但是迭代访问性能好一些</li></ol><h3 id="4-2、Set实现类之二：TreeSet"><a href="#4-2、Set实现类之二：TreeSet" class="headerlink" title="4.2、Set实现类之二：TreeSet"></a>4.2、Set实现类之二：TreeSet</h3><p><strong>特点</strong>：</p><p>1、TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素<code>处于排序状态。</code></p><p>2、TreeSet底层使用<code>红黑树结构</code>存储数据，正常情况不能存null</p><p>3、有序的，查询速度比List快</p><p>4、通过compare判断重复与否，只要返回的不是0，就可以增添，<strong>不再通过hashcode</strong></p><p><strong>新增方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Comparator <span class="title">comparator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">E <span class="title">first</span><span class="params">()</span> E <span class="title">pollFirst</span><span class="params">()</span></span>;            </span><br><span class="line"><span class="function">E <span class="title">last</span><span class="params">()</span>  E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function">E <span class="title">lower</span><span class="params">(E e)</span>     E <span class="title">higher</span><span class="params">(E e)</span> <span class="comment">// 比e更大的值中的最小值</span></span></span><br><span class="line"><span class="function">SortedSet <span class="title">subSet</span><span class="params">(fromElement, toElement)</span></span></span><br><span class="line"><span class="function">SortedSet <span class="title">headSet</span><span class="params">(toElement)</span></span></span><br><span class="line"><span class="function">SortedSet <span class="title">tailSet</span><span class="params">(fromElement)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span>  <span class="comment">// 递减的迭代器    </span></span></span><br></pre></td></tr></table></figure><h4 id="1、排序方法一：自然排序"><a href="#1、排序方法一：自然排序" class="headerlink" title="1、排序方法一：自然排序"></a>1、排序方法一：自然排序</h4><p><strong>概念：</strong></p><p>​        通过继承Comparable 接口，实现compareTo方法，来比较对象的顺序。</p><p><strong>实例：</strong></p><ul><li>实体类实现接口，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        User user = (User) o;</span><br><span class="line">        <span class="keyword">if</span>(user.getId()==<span class="keyword">this</span>.id)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 相等返回0</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(user.getId()&gt;<span class="keyword">this</span>.id)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果参数对象想排到后面，就返回 -1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里省略 get 、set方法和tostring 、构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Set&lt;User&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">User user1 = <span class="keyword">new</span> User(<span class="number">1</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User(<span class="number">2</span>);</span><br><span class="line">User user3 = <span class="keyword">new</span> User(<span class="number">3</span>);</span><br><span class="line">set.add(user2);</span><br><span class="line">set.add(user1);</span><br><span class="line">set.add(user3);</span><br><span class="line">set.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、排序方法二：定制排序"><a href="#2、排序方法二：定制排序" class="headerlink" title="2、排序方法二：定制排序"></a>2、排序方法二：定制排序</h4><p><strong>概念：</strong></p><ol><li>通过Comparator接口来实现。需要重写compare(T o1,T o2)方法</li><li>实现定制排序需要把实现接口的类的对象放到Tree的形参里、</li><li><strong>目的是为了不改变实体类的结构</strong></li></ol><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">// 这里省略 get 、set方法和tostring 、构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建set对象时需要把实现Comparator接口到的类传入其中这里使用匿名内部类对象</span></span><br><span class="line">        Set&lt;User&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User u1, User u2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(u1.getId()== u2.getId())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(u1.getId()&gt; u2.getId())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="number">1</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">2</span>);</span><br><span class="line">        User user3 = <span class="keyword">new</span> User(<span class="number">3</span>);</span><br><span class="line">        set.add(user2);</span><br><span class="line">        set.add(user1);</span><br><span class="line">        set.add(user3);</span><br><span class="line">        set.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>既然使用了匿名内部类，那么自然可以使用lambda表达式替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;User&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;((u1,u2)-&gt;&#123; </span><br><span class="line">    <span class="keyword">if</span>(u1.getId()== u2.getId())&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(u1.getId()&gt; u2.getId())&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-3、Set实现类之三：EnumSet"><a href="#4-3、Set实现类之三：EnumSet" class="headerlink" title="4.3、Set实现类之三：EnumSet"></a>4.3、Set实现类之三：EnumSet</h3><p><strong>构造：</strong>只能通过静态工程方式构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Festival</span> </span>&#123;</span><br><span class="line">    Spring,Summer,Winter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EnumSet&lt;Festival&gt; enumSet1 = EnumSet.allOf(Festival.class);</span><br><span class="line"><span class="comment">// 初始为全部</span></span><br><span class="line">EnumSet&lt;Festival&gt; enumSet2 = EnumSet.noneOf(Festival.class);</span><br><span class="line"><span class="comment">// 初始为空</span></span><br><span class="line">EnumSet&lt;Festival&gt; enumSet3 = EnumSet.range(Festival.Spring,Festival.Summer);</span><br><span class="line"><span class="comment">// 两个值之前的所有值(包括两边)</span></span><br><span class="line">EnumSet&lt;Festival&gt; enumSet4 = EnumSet.of(Festival.Winter);</span><br><span class="line"><span class="comment">// 调用set集合的方法操作数据</span></span><br><span class="line">enumSet4.add(Festival.Summer);</span><br></pre></td></tr></table></figure><h2 id="5、Map接口"><a href="#5、Map接口" class="headerlink" title="5、Map接口"></a>5、Map接口</h2><p><strong>概述：</strong></p><ol><li>Map与Collection并列存在。用于保存具有映射关系的数据:key-value</li><li>Map 中的 key 和 value 都可以是<code>任何引用类型</code>的数据</li><li>Map 中的 <code>key 用Set来存放</code>，不允许重复（重复则会覆盖值），value可以重复</li></ol><p><strong>常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增添,已存在则替换</span></span><br><span class="line"><span class="function">Object <span class="title">put</span><span class="params">(Object key,Object value)</span></span></span><br><span class="line"><span class="function">    Object <span class="title">putAbsent</span><span class="params">(Object key,Object value)</span> <span class="comment">// 已存在，则不覆盖 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map m)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 删除</span></span></span><br><span class="line"><span class="function">    <span class="title">remove</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询：</span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object key)</span>：            <span class="comment">// 获取指定key对应的value</span></span></span><br><span class="line"><span class="function">    Object <span class="title">get</span><span class="params">(Object key,Object value)</span> <span class="comment">// 设置取不到的默认值    </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 元视图操作的方法：</span></span></span><br><span class="line"><span class="function">Set <span class="title">keySet</span><span class="params">()</span>        <span class="comment">// 返回所有key构成的Set集合</span></span></span><br><span class="line"><span class="function">Collection <span class="title">values</span><span class="params">()</span> <span class="comment">// 返回所有value构成的Collection集合</span></span></span><br><span class="line"><span class="function">Set <span class="title">entrySet</span><span class="params">()</span>      <span class="comment">// 返回所有key-value对构成的Set集合</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function"><span class="comment">// 初始化，通用可以选择大小，负载因子的参数               </span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射关系改变</span></span><br><span class="line"><span class="function">Object <span class="title">merge</span><span class="params">(Object key,Object value,Function)</span> </span></span><br><span class="line"><span class="function">    <span class="comment">// 若键值在集合中，则值更新为函数返回值</span></span></span><br><span class="line"><span class="function">Object <span class="title">compute</span><span class="params">(key,Function)</span> </span></span><br><span class="line"><span class="function">    <span class="comment">// 若key对应的值与函数的返回值相等，或者函数结果为null，则删除键值对</span></span></span><br><span class="line"><span class="function">Object <span class="title">computeIfPresent</span><span class="params">(key,Function)</span>  <span class="comment">// 要求map里的值不能为null</span></span></span><br><span class="line"><span class="function">Object <span class="title">computeIfAbsent</span><span class="params">(key,Function)</span>   <span class="comment">// 已存在则不覆盖  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(Function)</span> <span class="comment">// 符合映射规则的都删除</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Test </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      HashMap&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      hashMap.put(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        Integer merge = hashMap.merge(<span class="number">1</span>, <span class="number">2</span>, (k, v) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> v + <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(merge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代Map集合</strong></p><ul><li>通过Map.keySet()遍历key和value</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keySet获取map集合key的集合 然后在foreach遍历key即可</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">String value = map.get(key).toString();</span><br><span class="line">System.out.println(<span class="string">&quot;key:&quot;</span> + key + <span class="string">&quot;  value:&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">map.keySet().forEach((key)-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;key:&quot;</span> + key + <span class="string">&quot;  value:&quot;</span> + map.get(key));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Map.keySet()使用iterator遍历key和value</span></span><br><span class="line">Iterator&lt;String&gt; iter = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">String key = iter.next();</span><br><span class="line">Object value = map.get(key);</span><br><span class="line">System.out.println(<span class="string">&quot;key:&quot;</span> + key + <span class="string">&quot;  value:&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过Map.entrySet()遍历集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过foreach方式</span></span><br><span class="line">map.entrySet().forEach((m)-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;key:&quot;</span> + m.getKey() + <span class="string">&quot;  value:&quot;</span> + m.getValue());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry e : hashMap.entrySet()) &#123;</span><br><span class="line">System.out.println(e.getKey()+<span class="string">&quot;&quot;</span> +e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Map.keyentry()使用iterator遍历key和value</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">System.out.println(<span class="string">&quot;key:&quot;</span> + entry.getKey() + <span class="string">&quot;  value:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1、Map实现类之一：HashMap"><a href="#5-1、Map实现类之一：HashMap" class="headerlink" title="5.1、Map实现类之一：HashMap"></a>5.1、Map实现类之一：HashMap</h3><p><strong>特点：</strong></p><ol><li><p>允许使用<code>null键和null值</code>，与HashSet一样，不保证映射的顺序。</p></li><li><p>key构成的集合是Set:无序的、不可重复的，重写：equals()和hashCode()</p></li><li><p>判断Key相等：equals和hashcode    value只通过equals判断</p></li><li><p>哈希表的大小为 2 的次方，会根据传来的参数调整，但是无论如何都是2的次方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组下标的计算⽅法是“ (n - <span class="number">1</span>) &amp; hash ”</span><br><span class="line">为<span class="number">2</span>的次方,这样n -<span class="number">1</span> 就是 <span class="number">1</span> <span class="number">3</span> <span class="number">7</span> 转换成二进制依次 <span class="number">1</span> <span class="number">11</span> <span class="number">111</span> 这样进行位运算更合适</span><br></pre></td></tr></table></figure></li></ol><p><strong>底层结构：</strong></p><ol><li>JDK 7及以前版本：HashMap是<code>数组+链表</code>结构(即为链地址法)</li><li>JDK 8版本发布以后：HashMap是<code>数组+链表+红黑树</code>实现。</li></ol><p><strong>原理探究(JDK1.8)：</strong></p><ol><li>实例化一个HashMap时，会初始化initialCapacity（默认容量）和<code>loadFactor（填充因子）</code></li><li><strong>put数据时，才会</strong>根据默认容量（JDK8为16）创建Node数组，数组存放数据的地方成为bucket（桶），每个bucket都有自己的<code>索引</code>，所以查找速度非常快</li><li>每个bucket存一个Node对象，里面含有指向下一个元素的next引用变量，所以一个bucket可能形成<code>Node链</code>，或者是<code>TreeNode树</code>，而新添加的元素作为链表的last，或树的叶子结点</li></ol><p><strong>哈希函数：</strong></p><ul><li>JDK7：通过<strong>扰动函数处理</strong>过后得到 hash值，然后通过 (n - 1) &amp; hash判断当前元素存放的位置</li><li>JDK8：优化了代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK7</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK8</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line"> <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line"> <span class="comment">// ^ ：按位异或</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;:⽆符号右移，忽略符号位，空位都以0补⻬</span></span><br><span class="line"> <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩容情况</strong>：</p><ol><li><p>HashMap的元素个数大于 initialCapacity（默认容量）*  loadFactor（填充因子）时，就会扩大一倍。</p></li><li><p>扩容时会重新计算每个元素的位置，消耗资源，所以可以预设大小，减少资源消耗</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap(<span class="number">15</span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>树形化</strong>：</p><p>​        若是一个 Node 链 里面的元素超过了8个（容量小于64则会优先先尝试扩大容量减少哈希冲突），就会尝试树形化，然后数节点<code>由Node类型变为TreeNode类型</code>，当然，映射关系移除后，若小于6个，重新变回Node链</p><p>​        <strong>也就是说，桶里的Node链  &gt;  8 ，hashMap 容量 &gt; 64时，实际上才会发生树形化</strong></p><p><strong>loadFactor（填充因子）的理解</strong></p><ol><li>负载因子越大，数据密度越大，发生碰撞的几率越高，数组中的链表越容易长，查询或插入时的比较次数多，性能下降</li><li>负载因子越小越容易扩容，容易浪费空间</li><li>最好设置为0.7~0.75</li></ol><h4 id="5-1-1、HashMap扩展：LinkedHashMap"><a href="#5-1-1、HashMap扩展：LinkedHashMap" class="headerlink" title="5.1.1、HashMap扩展：LinkedHashMap"></a>5.1.1、HashMap扩展：LinkedHashMap</h4><ul><li>LinkedHashMap 是 HashMap 的子类</li><li>在HashMap基础上使用了一对<code>双向链表</code>来记录添加元素的顺序</li><li>LinkedHashMap 可以维护 Map 的迭代顺序：与迭代顺序插入顺序一致</li></ul><p><strong>HashMap中的内部类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Node&lt;K,V&gt; next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedHashMap中的内部类：Entry</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">Entry&lt;K,V&gt; before, after;</span><br><span class="line">Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2、HashMap扩展：IdentityHashMap"><a href="#5-1-2、HashMap扩展：IdentityHashMap" class="headerlink" title="5.1.2、HashMap扩展：IdentityHashMap"></a>5.1.2、HashMap扩展：IdentityHashMap</h4><p>重新定义了hashcode的取值方法：System.identityHashCode(Object obj)</p><ul><li>实际调用的是Object的 hashcode方法，比较地址</li><li>两个对象比较相等是不再使用 equals 而是使用 == </li><li>也是就说，只要是两个对象，永远不会相等</li></ul><h4 id="5-1-3、HashMap扩展：WeakHashMap"><a href="#5-1-3、HashMap扩展：WeakHashMap" class="headerlink" title="5.1.3、HashMap扩展：WeakHashMap"></a>5.1.3、HashMap扩展：WeakHashMap</h4><ul><li><p>使用的是弱引用，随时可能被回收</p></li><li><p>用途：缓存等</p></li></ul><h3 id="5-2、Map实现类之二：TreeMap"><a href="#5-2、Map实现类之二：TreeMap" class="headerlink" title="5.2、Map实现类之二：TreeMap"></a>5.2、Map实现类之二：TreeMap</h3><ul><li><code>同hashset</code>，实现了自动排序，红黑树底层</li><li>实现了SortedMap集合</li></ul><h3 id="5-3、Map实现类之三：EnumMap"><a href="#5-3、Map实现类之三：EnumMap" class="headerlink" title="5.3、Map实现类之三：EnumMap"></a>5.3、Map实现类之三：EnumMap</h3><p>键的值为枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Festival为枚举类，括号内一定要指定类型</span></span><br><span class="line">EnumMap&lt;Festival,String&gt; enumMap = <span class="keyword">new</span> EnumMap&lt;Festival, String&gt;(Festival.class);</span><br></pre></td></tr></table></figure><h3 id="5-4、Map实现类之四：Hashtable"><a href="#5-4、Map实现类之四：Hashtable" class="headerlink" title="5.4、Map实现类之四：Hashtable"></a>5.4、Map实现类之四：Hashtable</h3><ul><li>线程<code>安全</code>，不允许使用 null 作为 key 和 value，其他和HashMap基本一致</li><li>默认大小为11，每次扩大为 2n + 1</li></ul><h3 id="5-5、Map实现类之五：Properties"><a href="#5-5、Map实现类之五：Properties" class="headerlink" title="5.5、Map实现类之五：Properties"></a>5.5、Map实现类之五：Properties</h3><p><strong>特点：</strong></p><ol><li>Properties 类是 Hashtable 的子类，该对象用于<code>处理属性文件</code></li><li>Key和value都是<code>字符串类型</code></li><li>setProperty(String key,String value)方法和getProperty(String key)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key,String <span class="keyword">default</span>)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">setProperty</span><span class="params">(String key,String value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException  <span class="comment">// 从输入流加载属性映射</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(OutputStream out,String header)</span>  <span class="comment">// 将属性映射保存到输出流    </span></span></span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties pros = <span class="keyword">new</span> Properties();      <span class="comment">// 创建对象</span></span><br><span class="line">pros.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdbc.properties&quot;</span>));  <span class="comment">// 加载文件</span></span><br><span class="line">String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);   <span class="comment">// 获取user的值</span></span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure><h2 id="6、队列"><a href="#6、队列" class="headerlink" title="6、队列"></a>6、队列</h2><ul><li>队列允许在头部删除元素，在尾部添加数据，双端队列允许在头尾自由添加和删除数据</li><li>Java6引入了双端队列（Deque接口），ArrayDeque和LinkedList都实现了这个接口</li></ul><blockquote><p>队列API</p></blockquote><p>Queue是一个队列接口，需要自己去实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>; <span class="comment">// 若队列没满，则添加到队尾，不然抛出异常，返回false</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>; <span class="comment">// 若队列没空，则从队首取出，不然抛出异常，返回false</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">peak</span><span class="params">()</span></span>; <span class="comment">// 获取队首的元素,失败抛出异常</span></span><br></pre></td></tr></table></figure><blockquote><p>双端队列API</p></blockquote><p>Deque是一个双端队列接口，需要自己去实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Object obj)</span>       <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(Object obj)</span>  <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 移除数据</span></span></span><br><span class="line"><span class="function">Object <span class="title">removeFirst</span><span class="params">()</span>           Object <span class="title">removeLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">pollFirst</span><span class="params">(Object obj)</span>   Object <span class="title">pollLast</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 获得数据</span></span></span><br><span class="line"><span class="function">Object <span class="title">getFirst</span><span class="params">()</span>               Object <span class="title">getLast</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">Object <span class="title">peekFirst</span><span class="params">()</span>              Object <span class="title">peekLast</span><span class="params">()</span>   </span></span><br></pre></td></tr></table></figure><blockquote><p>ArrayDeque<E></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayDeque()</span><br><span class="line">ArrayDeque(<span class="keyword">int</span> size)</span><br></pre></td></tr></table></figure><blockquote><p>优先队列</p></blockquote><p><strong>使用了堆进行存储</strong>，堆进行添加和删除会让最小的元素移动到根，这样就不必进行排序了，默认实现了Comparator接口，当然也可以自己重写覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue()</span><br><span class="line">PriorityQueue(<span class="keyword">int</span> size)</span><br><span class="line">PriorityQueue(<span class="keyword">int</span> size,Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span><br></pre></td></tr></table></figure><h2 id="7、Collections工具类：增强集合"><a href="#7、Collections工具类：增强集合" class="headerlink" title="7、Collections工具类：增强集合"></a>7、Collections工具类：增强集合</h2><h3 id="7-1、同步集合"><a href="#7-1、同步集合" class="headerlink" title="7.1、同步集合"></a>7.1、同步集合</h3><p>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合<code>包装成线程同步的集合</code>，从而可以解决多线程并发访问集合时的线程安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection()</span><br><span class="line"><span class="comment">// 把Collection替换成下面的即可</span></span><br><span class="line">List/Map/Set/SortedSet/SortedMap/NavigableSet/NavigableMap</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 示例    </span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();        </span><br><span class="line">List&lt;String&gt; sy = Collections.synchronizedList(list);   </span><br></pre></td></tr></table></figure><h3 id="7-2、小集合"><a href="#7-2、小集合" class="headerlink" title="7.2、小集合"></a>7.2、小集合</h3><p>Java9引入静态方法，可以生成给定元素的集或者列表，<strong>在Java8相当于Arrays.asList</strong></p><ul><li>注意这些也是固定大小，而且不能增添、删除、修改内容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能有null值</span></span><br><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">Set&lt;Integer&gt; set = Set.of(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">Map&lt;String,Integer&gt; map = Map.of(<span class="string">&quot;wzh&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">// map也可以传入entry</span></span><br><span class="line">map = Map.ofEntries(Map.entry(<span class="string">&quot;Tom&quot;</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure><h3 id="7-3、子集合"><a href="#7-3、子集合" class="headerlink" title="7.3、子集合"></a>7.3、子集合</h3><ul><li>可以把集合分解成子集合</li><li>注意子集合并没有和父集合分离，子集合上的操作会在父集合上同步执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arrays类</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; List &lt;E&gt; asList(E...array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// List类的静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> firstIncluded,<span class="keyword">int</span> firstExcluded)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SortedSet、SortedMap(Map方法把set换成Map即可)</span></span><br><span class="line">subset(E firstIncluded,E firstExcluded);</span><br><span class="line">headSet(E firstExcluded);</span><br><span class="line">tailSet(E firstExcluded); </span><br><span class="line"></span><br><span class="line"><span class="comment">// NavigableSet、Map</span></span><br><span class="line">subset(E from, <span class="keyword">boolean</span> f,E to,<span class="keyword">boolean</span> t);</span><br><span class="line">headSet(E to,<span class="keyword">boolean</span> t);       <span class="comment">// boolean参数是表示是否包括边界</span></span><br><span class="line">tailSet(E to,<span class="keyword">boolean</span> t); </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">30</span>);</span><br><span class="line">        list.add(<span class="number">15</span>);</span><br><span class="line">        list.add(<span class="number">10</span>);</span><br><span class="line">        List&lt;Integer&gt; son = list.subList(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        son.add(<span class="number">3</span>);</span><br><span class="line">        list.forEach((v)-&gt;&#123;System.out.println(v);&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4、不可修改的视图"><a href="#7-4、不可修改的视图" class="headerlink" title="7.4、不可修改的视图"></a>7.4、不可修改的视图</h3><p>这些视图对现有集合增加了一个运行时检查，如果发现修改了，就抛出一个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.unmodifiableCollection()  <span class="comment">// 用法</span></span><br><span class="line"><span class="comment">// 把Collection替换成下面的即可</span></span><br><span class="line">List/Map/Set/SortedSet/SortedMap/NavigableSet/NavigableMap</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; l = (ArrayList&lt;Integer&gt;) Collections.unmodifiableList(list);</span><br><span class="line">l.add(<span class="number">3</span>);  <span class="comment">// 会抛出异常</span></span><br></pre></td></tr></table></figure><h3 id="7-5、严格检查集合"><a href="#7-5、严格检查集合" class="headerlink" title="7.5、严格检查集合"></a>7.5、严格检查集合</h3><ul><li>编译器有时候对于集合中添加错误的情况，没能指示出来</li><li>这样定义之后就会进行严格的检查</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collections.checkedCollection()</span><br><span class="line">List/Map/Set/SortedSet/SortedMap/NavigableSet/NavigableMap</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 示例    </span></span><br><span class="line">List&lt;String&gt; safe = Collections.checkedList(list,String.class);    </span><br></pre></td></tr></table></figure><h2 id="8、Collections工具类：计算属性"><a href="#8、Collections工具类：计算属性" class="headerlink" title="8、Collections工具类：计算属性"></a>8、Collections工具类：计算属性</h2><h3 id="8-1、排序"><a href="#8-1、排序" class="headerlink" title="8.1、排序"></a>8.1、排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List)</span>          <span class="comment">// 反转 List 中元素的顺序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List)</span>          <span class="comment">// 对 List 集合元素进行随机排序</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List)</span>             <span class="comment">// 根据元素的自然顺序对按升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List，Comparator)</span> <span class="comment">// </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List，<span class="keyword">int</span>， <span class="keyword">int</span>)</span>  <span class="comment">// 将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span></span><br></pre></td></tr></table></figure><h3 id="8-2、查找和替换"><a href="#8-2、查找和替换" class="headerlink" title="8.2、查找和替换"></a>8.2、查找和替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最值</span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection)</span>             <span class="comment">// 自然排序，或者自己实现接口</span></span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection,Comparator)</span>  <span class="comment">// 传入一个实现排序接口的对象</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection)</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection，Comparator)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置值    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span>      <span class="comment">// 将src中的内容复制到dest中 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List dest,Object value)</span>  <span class="comment">// 所有值变为value </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c,T...values)</span> <span class="comment">// 把所有值添加到集合里面    </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list,Object old,Object new)</span>  <span class="comment">// 替换</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">// 查询    </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection，Object o)</span>        <span class="comment">// 返回指定集合中指定元素的出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">disjoint</span><span class="params">(Collection c1,Collection c2)</span>   <span class="comment">// 没有公共元素，返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List father,List son)</span>  <span class="comment">// 返回子集合在父集合的索引索引 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfSubList</span><span class="params">(List father,List son)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 批操作    </span></span></span><br></pre></td></tr></table></figure><h2 id="9、其他集合"><a href="#9、其他集合" class="headerlink" title="9、其他集合"></a>9、其他集合</h2><h3 id="9-1、遗留的集合"><a href="#9-1、遗留的集合" class="headerlink" title="9.1、遗留的集合"></a>9.1、遗留的集合</h3><p><strong>Hashtable</strong></p><p><strong>枚举</strong></p><p>遗留的集合使用Enumeration遍历集合，有两个方法</p><ul><li>hasMoreElements</li><li>hasNextElement</li></ul><h3 id="9-2、栈Stack"><a href="#9-2、栈Stack" class="headerlink" title="9.2、栈Stack"></a>9.2、栈Stack</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E push(E item)</span><br><span class="line">E pop()</span><br><span class="line">E peek()</span><br></pre></td></tr></table></figure><h3 id="9-3、位集"><a href="#9-3、位集" class="headerlink" title="9.3、位集"></a>9.3、位集</h3><ul><li>用来存储位序列，把位包装在字节里，比Boolean对象的ArrayList更加高效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BistSet(<span class="keyword">int</span> size)  <span class="comment">// 定义size位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> bit)</span>   <span class="comment">// 看第bit位是1还是0  </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bit)</span>   <span class="comment">// 设置第bit位为1</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> bit)</span> <span class="comment">// 清除第bit位</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">and</span><span class="params">(BitSet set)</span>    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">or</span><span class="params">(BitSet set)</span>    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xor</span><span class="params">(BitSet set)</span>   <span class="comment">// 异或</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">andNot</span><span class="params">(BitSet set)</span>    <span class="comment">// 清0</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BitSet bitSet1 = new BitSet(4);</span><br><span class="line">        BitSet bitSet2 = new BitSet(4);</span><br><span class="line">        bitSet1.set(1);</span><br><span class="line">        bitSet1.set(2);</span><br><span class="line">        bitSet2.set(3);</span><br><span class="line">        bitSet1.or(bitSet2);</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            System.out.println(bitSet1.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(二):类和对象</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%BA%8C%20)%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E4%BA%8C%20)%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="1、类和对象概念"><a href="#1、类和对象概念" class="headerlink" title="1、类和对象概念"></a>1、类和对象概念</h2><h3 id="1-1、面向对象与面向过程"><a href="#1-1、面向对象与面向过程" class="headerlink" title="1.1、面向对象与面向过程"></a>1.1、面向对象与面向过程</h3><p><strong>面向对象与面向过程</strong></p><ul><li>面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。</li><li>面向对象，<code>将功能封装进对象</code>，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li></ul><p>面向过程性能高，但是面向对象<strong>易维护、易复用、易扩展。</strong></p><p><strong>Java 性能差</strong>：主要原因并不是因为它是⾯向对象语言，而是 Java 是半编译语⾔，最终的执行代码并不是可以直接被 CPU 执⾏的⼆进制机械码。而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它⼀些面向过程的脚本语⾔性能也并不⼀定比 Java 好</p><p><strong>面向对象三大特征：</strong></p><ul><li>封装</li><li>继承</li><li>多态</li></ul><p><strong>面向对象思想：</strong>程序员从面向过程的执行者转化成了面向对象的指挥者</p><h3 id="1-2、类"><a href="#1-2、类" class="headerlink" title="1.2、类"></a>1.2、类</h3><p><strong>概念：</strong>构造对象的模板和蓝图，由类构造对象的过程成为<strong>创建类的实例</strong></p><p><strong>封装：</strong>又成为<strong>数据隐藏</strong>，是处理对象的一个重要概念。就是把数据和行为组合在一起，并对对象的使用者隐藏起来，只提供一个接口让使用者操作。对象的数据称为实例字段，操作数据的过程称为方法。、</p><h3 id="1-3、对象"><a href="#1-3、对象" class="headerlink" title="1.3、对象"></a>1.3、对象</h3><ul><li>对象的行为：对象的各种方法</li><li>对象的状态：每个对象的字段的得集合就是<strong>对象的状态</strong></li><li>对象的标识：</li></ul><h3 id="1-4、类之间的关系"><a href="#1-4、类之间的关系" class="headerlink" title="1.4、类之间的关系"></a>1.4、类之间的关系</h3><ul><li>依赖：类A对象需要调用类B对象的方法</li><li>聚合：类A对象包含一些类B的对象</li><li>继承：继承让多态得以提醒</li></ul><h3 id="1-5、分析对象与对象变量"><a href="#1-5、分析对象与对象变量" class="headerlink" title="1.5、分析对象与对象变量"></a>1.5、分析对象与对象变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date deadline;                     <span class="comment">// 此时deadline不是一个对象</span></span><br><span class="line">Date birthday = <span class="keyword">new</span> Date();        <span class="comment">// 通过new构造对象</span></span><br><span class="line">deadline = birthday;               <span class="comment">// 通过引用构造对象</span></span><br><span class="line"><span class="comment">// 此时二者是一个对象，hashcode相同</span></span><br><span class="line">System.out.println(deadline.hashCode());</span><br><span class="line">System.out.println(birthday.hashCode());</span><br></pre></td></tr></table></figure><ul><li>通过上面可以认识到，<strong>对象变量只是引用了一个对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deadline = <span class="keyword">null</span>;            <span class="comment">// 此时没有引用任何对象</span></span><br><span class="line">System.out.println(deadline.hashCode());   <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure><h2 id="2、类和对象的使用"><a href="#2、类和对象的使用" class="headerlink" title="2、类和对象的使用"></a>2、类和对象的使用</h2><h3 id="2-1、构造器"><a href="#2-1、构造器" class="headerlink" title="2.1、构造器"></a>2.1、构造器</h3><ul><li>构造对象需要<strong>调用构造器</strong>（默认有一个无参构造）</li><li>构造器必须配合new来使用，与类同名</li><li>构造器没有参数限制，没有返回值</li></ul><h3 id="2-2、属性"><a href="#2-2、属性" class="headerlink" title="2.2、属性"></a>2.2、属性</h3><ul><li><strong>属性分为成员变量和局部变量</strong></li></ul><table><thead><tr><th></th><th><strong>成员变量</strong></th><th><strong>局部变量</strong></th></tr></thead><tbody><tr><td>声明的位置</td><td>直接声明在类中</td><td>方法形参或内部、代码块内、构造器内等</td></tr><tr><td>修饰符</td><td>用权限修饰符修饰</td><td>只能使用final</td></tr><tr><td>初始化值</td><td>有默认值</td><td>没有默认值</td></tr><tr><td>内存加载位置</td><td><strong>堆空间或静态域内</strong></td><td><strong>栈空间</strong></td></tr></tbody></table><blockquote><p>用Var定义局部变量</p></blockquote><ul><li>Java10中，若可以从初始值推断类型，则可以使用var来修饰</li><li>var只能使用于<strong>方法中的局部变量</strong></li></ul><blockquote><p>使用Null引用</p></blockquote><ul><li>使用Null表示没有引用对象，如果调用类方法就会<strong>产生NullPointerException异常</strong></li><li>上述的name为String对象，若传进来的值为null，则会触发异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee employee = <span class="keyword">new</span> Employee(<span class="keyword">null</span>,<span class="number">75000</span>,<span class="number">1987</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">System.out.println(employee.getName().length());</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、构造器加入判断</span></span><br><span class="line"><span class="keyword">if</span>(name==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、拒绝创建null</span></span><br><span class="line"><span class="keyword">this</span>.name = Objects.requireNonNull(name,<span class="string">&quot;不允许null&quot;</span>);</span><br><span class="line"><span class="comment">// 3、类似1</span></span><br><span class="line"><span class="keyword">this</span>.name = Objects.requireNonNullElse(name,<span class="string">&quot;unknown&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-3、方法"><a href="#2-3、方法" class="headerlink" title="2.3、方法"></a>2.3、方法</h3><blockquote><p>定义</p></blockquote><ul><li>方法是类或对象<strong>行为特征的抽象</strong>，用来完成某个功能操作。</li><li>方法中只能调用方法或属性，不可以在方法内部定义方法。</li></ul><blockquote><p>参数传递机制</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> raise = salary * byPercent /<span class="number">100</span>;</span><br><span class="line">    salary = salary + raise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>显式参数：byPercent 即括号里的参数</li><li>隐式参数：调用这个方法的对象，salary 等于 employee.salary</li></ul><blockquote><p>参数传递机制</p></blockquote><p>Java里方法的<strong>参数传递</strong>方式只有一种：值传递。 </p><p><strong>将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。</strong> </p><blockquote><p>方法重载</p></blockquote><ul><li>概念：允许存在一个以上的<strong>同名方法</strong>，只要它们的参数个数或者参数类型不同即可，static和非static之间不能构成重载</li><li>特点：<strong>与返回值类型无关</strong>，仅仅返回值类型不同算一个方法。</li><li><strong>所以，参数和方法名构成了一个方法的签名</strong></li></ul><blockquote><p>可变参数</p></blockquote><ul><li>Java1.5之后，支持传递同类型的可变参数给一个方法</li><li>在方法声明中，在指定参数类型后加一个省略号(…)</li><li>一个方法只能指定一个可变参数，且必须放在最后</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>...nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>访问器方法和更改器方法</p></blockquote><ul><li>更改器方法：改变</li><li>访问器方法：不改变原来类的结构</li></ul><h3 id="2-4、this关键字"><a href="#2-4、this关键字" class="headerlink" title="2.4、this关键字"></a>2.4、this关键字</h3><ol><li>方法内部使用，即这个方法所属对象的引用</li><li>构造器内部使用，表示该构造器<code>正在初始化</code>的对象</li><li>可以用this来区分<code>属性和局部变量</code></li></ol><p><strong>注意：</strong></p><ol><li>在构造器里面使用this关键字调用<strong>其他构造器</strong>，但只能声明一个，参考上面的内容</li><li>this调用其他构造器的代码，必须声明在<strong>类的构造器的首行</strong></li></ol><h3 id="2-5、final"><a href="#2-5、final" class="headerlink" title="2.5、final"></a>2.5、final</h3><ul><li>成员变量定义为final之后，可以通过构造器赋予值，之后不能再修改</li><li><strong>final方法可以被重载</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6、static"><a href="#2-6、static" class="headerlink" title="2.6、static"></a>2.6、static</h3><p><strong>静态字段：</strong>被static修饰的静态字段，将不再属于某个对象，而是属于类被共享，<strong>可以同时被类和对象调用</strong></p><p>注意：Java叫做类字段，静态字段只是沿用了C++的叫法</p><p><strong>静态常量：</strong></p><p><strong>静态方法：</strong>同上，静态方法常用于工厂方法的实现，main方法也是一个静态方法，可以被类调用，由于独立于类，所以不能使用this和super，除此之外，静态方法不能调用非静态字段。</p><h3 id="2-7、代码块"><a href="#2-7、代码块" class="headerlink" title="2.7、代码块"></a>2.7、代码块</h3><p>三种初始化数据字段的方法</p><ul><li>构造器设置值</li><li>声明中赋值</li><li>初始化块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Block</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Block block = <span class="keyword">new</span> Block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">初始化块</span><br><span class="line">构造器方法</span><br></pre></td></tr></table></figure><p>构造器被调用后，会先判断是否调用了其他构造器</p><ul><li>若调用了，则转到另一个构造器执行</li><li>若没调用，<strong>先调用初始化块，在调用构造器剩下的部分</strong></li></ul><p><strong>静态代码块：</strong>优先于类的构造，<strong>只能对静态成员变量初始化</strong>，从上而下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//static代码块通常用于初始化static的属性</span><br><span class="line">static &#123;</span><br><span class="line">total = 100;//为total赋初值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化顺序</p></blockquote><ol><li>声明成员变量的默认初始化</li><li>显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）</li><li>构造器再对成员进行初始化操作</li><li>通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值</li></ol><h3 id="2-8、对象析构和finalize方法"><a href="#2-8、对象析构和finalize方法" class="headerlink" title="2.8、对象析构和finalize方法"></a>2.8、对象析构和finalize方法</h3><ul><li>Java会自动垃圾回收，所以Java不支持析构（构造器内放清理代码）</li><li>finalize方法用于释放资源，已经废弃，应该使用Java提供的各种类的close方法</li></ul><h2 id="3、类的继承"><a href="#3、类的继承" class="headerlink" title="3、类的继承"></a>3、类的继承</h2><h3 id="3-1、子类"><a href="#3-1、子类" class="headerlink" title="3.1、子类"></a>3.1、子类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Manage类继承了Employee类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>extends表明正在构造的新类派生于一个已经存在的类</li><li>已存在的类称为超类（基类或者父类），新类称为子类</li></ul><p>注意点：</p><ul><li>子类继承了父类的私有属性和方法，但是<strong>不能直接调用，可以间接调用</strong>（父类公有方法调用到了父类的私有属性和方法），也继承了父类的父类</li><li>子类可以通过 super() 调用父类方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类私有，只提供一个公有的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类调用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试，成功输出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Manage manage = <span class="keyword">new</span> Manage(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    manage.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、重写方法"><a href="#3-2、重写方法" class="headerlink" title="3.2、重写方法"></a>3.2、重写方法</h3><p>可以看到，上面例子中子类父类的print方法名一致，这样就是重写方法</p><p><strong>重写规则</strong></p><ul><li>方法必须具有相同的<strong>名称和参数</strong></li><li>返回值类型、异常类型要和父类一致，或为父类的子类</li><li><strong>访问权限要比父类的高或者相等</strong></li><li>无法重写static、final、private方法，因为static方法是类方法，不是成员方法</li></ul><p><strong>注意：</strong>重写发生在发生在运行期间</p><h3 id="3-3、子类构造器"><a href="#3-3、子类构造器" class="headerlink" title="3.3、子类构造器"></a>3.3、子类构造器</h3><p><strong>注意：子类初始化，必须提供父类构造的实现</strong>，几种调用方式如下</p><ul><li>父类含有无参构造时：会自动调用父类构造方法</li><li>父类不含无参构造时，子类必须调用super() 来调用父类构造方法</li><li>调用本类的其他构造方法，但是最终一定也要调用到父类构造方法</li></ul><p><strong>注意点：</strong></p><ul><li><strong>子类对象实例化时不会实例化父类对象</strong></li><li>构造器只能被调用，不能被继承</li><li>Java不支持多重继承，只支持多实现接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用其他构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4、多态与类型转换"><a href="#3-4、多态与类型转换" class="headerlink" title="3.4、多态与类型转换"></a>3.4、多态与类型转换</h3><p><strong>概念：</strong>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即⼀个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p><strong>对象类型转换</strong></p><ol><li>向上转型：父类的引用指向子类的对象</li><li>向下转型：子类的引用指向父类的对象（必须强制转换）</li></ol><p><strong>多态原理：</strong>父类的引用指向子类的对象（向上转型）</p><p><strong>引用变量类型分类：</strong></p><ul><li>编译时类型：编译时类型由声明该变量时使用的类型决定</li><li>运行时类型：运行时类型由实际赋给该变量的对象决定</li><li>编译型和运行型和不一致就导致了多态</li></ul><p><strong>注意：</strong></p><ol><li>向上转型后的父类对象 调用的是<strong>子类重载的方法</strong></li><li>向上转型后的父类对象 的其他方法和属性<strong>都是父类的</strong></li><li>本质上还是父类对象，只是方法替换成子类的</li><li><strong>向上转型是允许的、安全的，因为子类必定包含父类的所有属性和方法</strong></li><li><strong>向下转型是不安全的，因为子类含有父类不包含的属性和方法</strong>，所以需要强制转换，而且转型前需要使用instanceof进行判断</li></ol><p><strong>instanceof操作符</strong>：</p><ul><li>x instanceof A：检验x是否是A的对象或者是A<code>后代</code>的对象</li><li>向下转型时先判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据传进来的参数判断是猫还是狗</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;猫&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;狗&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat cat = <span class="keyword">new</span> Cat(<span class="string">&quot;猫&quot;</span>);</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">&quot;狗&quot;</span>);</span><br><span class="line">        Animal animal= <span class="keyword">new</span> Cat(<span class="string">&quot;动物&quot;</span>);</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.check(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组对象</p></blockquote><ul><li>数组对象向上转型可以会出现一些问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee[] employees = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">        Manage[] manages = <span class="keyword">new</span> Manage[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 父类引用指向子类对象，向上转型</span></span><br><span class="line">        employees = manages;</span><br><span class="line">        <span class="comment">// 注意此时父类子类引用同一个，相当于父类对象指向子类而没有强转，报错</span></span><br><span class="line">        employees[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        manages[<span class="number">0</span>].print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5、方法"><a href="#3-5、方法" class="headerlink" title="3.5、方法"></a>3.5、方法</h3><p><strong>通过子类的对象调用 a 方法，</strong></p><ol><li>编译器会列举所有 方法名为a，且可以访问的方法（不包括父类私有方法，注意修饰符不同的方法也不构成重载）</li><li>编译器重载解析：寻找一个与<strong>所提供的参数的类型完全匹配</strong>的方法</li><li>若发现找不到或者找到多个方法，就会报错</li></ol><p><strong>方法的签名：</strong>方法的名字和参数构成方法的签名，与返回值无关</p><ul><li>子类定义与父类签名一致的方法，则会覆盖父类的方法</li><li>签名一致的方法必须保证方法<strong>相容</strong>，不然就是语法错误</li><li>同一个类的方法签名一致，则会报错</li></ul><p><strong>方法的重写：</strong>子类覆盖父类的方法，注意<strong>无法覆盖static方法</strong></p><p><strong>方法相容规则</strong>：</p><ul><li>子类覆盖的方法返回值必须为父类的<strong>返回值或返回值的子类型</strong></li><li>子类的方法的访问权限不能小于父类的，不能重写private方法</li><li>子类方法抛出的异常不能大于父类被重写方法的异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法重载，这种写法报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Manage <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Manage(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Employee(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写方法，这种写法可以，因为Manage是Employee的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Manage(<span class="string">&quot;父类&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Manage <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Manage(<span class="string">&quot;子类&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态绑定与静态绑定</strong></p><ul><li>静态绑定：private、final、static方法，编译器会准确知道是什么方法</li><li>动态绑定：一般方法，虚拟机每次从子类寻找，找不到再从超类找，</li></ul><blockquote><p>虚拟机方法表</p></blockquote><p>虚拟机每次从子类寻找，找不到再从超类找，这样资源消耗过大</p><p>因此虚拟机定义了一个方法表，列出来<strong>所有方法的签名和要调用的实际方法</strong></p><h3 id="3-6、final"><a href="#3-6、final" class="headerlink" title="3.6、final"></a>3.6、final</h3><ul><li>final属性通过构造器赋值后就不能修改了</li><li>final类不能被继承</li><li>final方法不能被重写</li><li>final方法可以被重载</li></ul><h3 id="3-7、抽象类"><a href="#3-7、抽象类" class="headerlink" title="3.7、抽象类"></a>3.7、抽象类</h3><ul><li>抽象类：用abstract关键字来修饰一个类，这个类叫做抽象类。 </li><li>抽象方法：用abstract来修饰一个方法，该方法叫做抽象方法。</li></ul><p><strong>注意点：</strong></p><ul><li>抽象类可以不含抽象方法，含抽象方法的一定是抽象类</li><li>抽象类不能用new来实例化，只能被单继承，<strong>继承的类必须实现所有方法，不然只能继续定义为抽象类</strong></li><li>抽象类可以<strong>通过子类</strong>向上转型的方式<strong>实例化</strong></li><li><strong>抽象类相比于正常的类只是可能含有抽象方法</strong>，其他完全一致</li></ul><h3 id="3-8、访问权限修饰符"><a href="#3-8、访问权限修饰符" class="headerlink" title="3.8、访问权限修饰符"></a>3.8、访问权限修饰符</h3><table><thead><tr><th>修饰符</th><th>作用</th><th>范围</th></tr></thead><tbody><tr><td>default(即什么也不写）</td><td>在同一包内可见</td><td>类、接口、变量、方法</td></tr><tr><td>private</td><td>在同一类内可见</td><td>变量、方法</td></tr><tr><td>public</td><td>对所有类可见</td><td>类、接口、变量、方法</td></tr><tr><td>protected</td><td>对同一包内的类和所有子类可见</td><td>变量、方法</td></tr></tbody></table><h2 id="4、Object类"><a href="#4、Object类" class="headerlink" title="4、Object类"></a>4、Object类</h2><p><strong>Object类：</strong></p><ul><li><p>Object类是所有Java类的根父类</p></li><li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为Object类</p></li><li><p>Object类可以引用任何对象</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object object = new Employee(&quot;Tom&quot;);</span><br></pre></td></tr></table></figure><p><strong>Object变量只能作为各种值的泛型容器</strong>，而且必须强制类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee employee = (Employee) object;</span><br></pre></td></tr></table></figure><p><strong>Object类API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Object</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;  <span class="comment">// 唤醒线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span>;    <span class="comment">// 进入等待状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>; <span class="comment">// 设置最大等待时间并等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">getClass</span><span class="params">()</span></span>;     <span class="comment">// 获得类对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">getSuperClass</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;     <span class="comment">// 返回类名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Objects类API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title">requireNonNull</span><span class="params">(T obj)</span>     <span class="comment">// 查看指定对象是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">(Object a)</span>          <span class="comment">// null返回0，否则返回hashcode</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">(Object... objects)</span> <span class="comment">// 返回hascode组合      </span></span></span><br></pre></td></tr></table></figure><p>== ：</p><ul><li>基本数据类型比较值</li><li>引用数据类型比较地址（即是否指向同一个对象）</li></ul><p>equals：</p><ul><li>只比较引用数据类型，比较地址</li><li>String类的equals 重写了，比较的是值</li></ul><h2 id="5、包装类与自动装箱"><a href="#5、包装类与自动装箱" class="headerlink" title="5、包装类与自动装箱"></a>5、包装类与自动装箱</h2><p><strong>包装类：</strong>对八种基本数据类型定义相应的引用类型—包装类（封装类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装类对象的属性是不可以变化的</span></span><br><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">3</span>); <span class="comment">// 这种形式在Java9废弃了</span></span><br><span class="line">System.out.println(integer.hashCode());</span><br><span class="line">integer = <span class="number">5</span>;</span><br><span class="line">System.out.println(integer.hashCode());</span><br></pre></td></tr></table></figure><p><strong>装箱：</strong>基本数据类型包装成包装类的实例，<strong>如上述就是自动把5装箱</strong></p><p><strong>拆箱：</strong>包装类变成基本数据类型</p><p>注意：</p><ul><li>JDK1.5之后，支持自动装箱和自动拆箱，只要类型匹配</li><li>由于包装类是对象，所以可以为null，因此可能会出现异常</li><li>条件表示式里面混用Integer和Double类型，Integer会拆箱成int，然后转换成double，再装箱成Double</li><li><strong>自动装箱和自动拆箱是编译器优化的结果，而非虚拟机做的事情</strong></li></ul><blockquote><p>Integer类API</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;     <span class="comment">// 转换成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> radix)</span></span>;  <span class="comment">// 以radix进制显示的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span></span>;          </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s,<span class="keyword">int</span> radix)</span></span>; <span class="comment">// radix进制字符串转换成int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">ValueOf</span><span class="params">(String s)</span></span>;        <span class="comment">// 字符串转换成Integer</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">ValueOf</span><span class="params">(String s,<span class="keyword">int</span> radix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">ValueOf</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>面试题</p></blockquote><p>1、一个表达式里面，结果会变成精度最大的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">    System.out.println(o1);    <span class="comment">// 输出1.0</span></span><br><span class="line">    Object o2;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>)</span><br><span class="line">        o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">    System.out.println(o2);     <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、128以内的对象都是缓存在一个IntegerCache里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);   <span class="comment">// 不同对象</span></span><br><span class="line">    Integer m = <span class="number">1</span>;</span><br><span class="line">    Integer n = <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n);   </span><br><span class="line">    <span class="comment">// 创建的是同一个对象，这些对象已经缓存在IntegerCache里面了，因此相等</span></span><br><span class="line">    Integer x = <span class="number">128</span>;</span><br><span class="line">    Integer y = <span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y);   <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、枚举类"><a href="#6、枚举类" class="headerlink" title="6、枚举类"></a>6、枚举类</h2><ul><li>Java 枚举是一个<code>特殊的类</code>，一般表示一组常量，参数默认用<strong>public static final</strong> 修饰</li><li>枚举跟普通类一样可以有自己的变量、方法和构造函数，<strong>构造函数只能用private修饰</strong></li></ul><h3 id="6-1、简单定义和使用"><a href="#6-1、简单定义和使用" class="headerlink" title="6.1、简单定义和使用"></a>6.1、简单定义和使用</h3><ul><li>枚举类是static修饰的，所以可以通过类或者对象获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123; </span><br><span class="line">    RED, GREEN, BLUE; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Color.RED;               <span class="comment">// 直接获取</span></span><br><span class="line">Color c1 = Color.RED;    <span class="comment">// 赋给Color对象</span></span><br></pre></td></tr></table></figure><p><strong>以上的枚举类底层实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color RED = <span class="keyword">new</span> Color();  <span class="comment">// 枚举成员实际是一个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLUE = <span class="keyword">new</span> Color();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color GREEN = <span class="keyword">new</span> Color();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举类同样可以定义在一个类的内部：</strong></p><ul><li><p>本类访问：Color.BLUE;</p></li><li><p>其他类访问：外部类类名.Color.Blue</p></li></ul><h3 id="6-2、操作枚举元素"><a href="#6-2、操作枚举元素" class="headerlink" title="6.2、操作枚举元素"></a>6.2、操作枚举元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代枚举元素</span></span><br><span class="line"><span class="keyword">for</span> (Color myVar : Color.values()) &#123;</span><br><span class="line">System.out.println(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在switch中使用枚举类</span></span><br><span class="line">Color myVar = Color.BLUE;</span><br><span class="line"><span class="keyword">switch</span>(myVar) &#123;</span><br><span class="line"><span class="keyword">case</span> RED:</span><br><span class="line">System.out.println(<span class="string">&quot;红色&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>API：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">values();    <span class="comment">// 把枚举类型的成员变量实例以数组形式返回  Color[] arr = Color.values(); </span></span><br><span class="line">valueof();   <span class="comment">// 普通字符串转换为枚举实例    Color.valueOf(&quot;Blue&quot;) == Color.Blue</span></span><br><span class="line">compareTo(); <span class="comment">// 比较两个枚举对象定义的顺序，参数里面在前返回1，后面返回0</span></span><br><span class="line">ordinal();   <span class="comment">// 获取某个对象位置的索引值，从0开始</span></span><br></pre></td></tr></table></figure><h3 id="6-3、带参的枚举类成员"><a href="#6-3、带参的枚举类成员" class="headerlink" title="6.3、带参的枚举类成员"></a>6.3、带参的枚举类成员</h3><p><strong>由于枚举类成员实际上是static final 修饰的类对象，所以可以带参数</strong>，但是</p><ul><li>构造函数只能用private修饰</li><li>由于是静态的，如下有四个枚举成员，当使用Season时，会初始化这四个对象，也就是<strong>调用四次私有构造方法</strong>，同理如Season含有抽象方法，四个对象都必须实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Season</span> </span>&#123;</span><br><span class="line"><span class="comment">// 实际上等于public static final Season SPRING = new Season(&quot;春天&quot;, &quot;春暖花开&quot;);</span></span><br><span class="line"><span class="comment">// 创建了Season的一个对象，并且调用private构造器</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line"><span class="comment">// 私有变量，也是枚举成员的参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有构造方法，有四个枚举成员，所以实例化 Season时，该方法调用四次</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为是私有的变量，所以需要get方法获取参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化Season时候，会调用 n 次构造方法，n为成员数</span></span><br><span class="line">        Season season = Season.AUTUMN;</span><br><span class="line">        season.getSeasonDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、反射"><a href="#7、反射" class="headerlink" title="7、反射"></a>7、反射</h2><h3 id="7-1、概述"><a href="#7-1、概述" class="headerlink" title="7.1、概述"></a>7.1、概述</h3><p><strong>反射：</strong>类加载器加载完类之后，堆里面就会生成<strong>一个Class类型的对象</strong>（一个类只有一个Class对象），这个对象包含类的<strong>完整信息</strong>，通过这个对象来访问类的过程就是反射</p><ul><li>正常方式： 引入包名—-&gt;new实例化——&gt;取得实例化对象</li><li>反射方式： 实例化对象—–&gt;getClass()方法——-&gt;得到完整的”包类”名称</li></ul><p><strong>反射用途：</strong></p><ul><li>运行时取得类的<strong>内部信息</strong>，</li><li>运行时检查对象，直接操作对象的内部属性和方法。</li><li>实现泛型数组操作代码</li></ul><h3 id="7-2、获取Class对象"><a href="#7-2、获取Class对象" class="headerlink" title="7.2、获取Class对象"></a>7.2、获取Class对象</h3><ul><li>在程序运行期间，Java运行时系统始终为所有对象维护一个<strong>运行时类型标识</strong>，这个信息会跟踪每个对象所属的类。虚拟机利用<strong>运行时类型信息</strong>选择要执行的正确的方法。</li><li><strong>保存这些信息</strong>的类名为Class，可以通过Class对象访问这些信息。</li></ul><p><strong>注意：</strong></p><ul><li>Class 对象只能由<strong>虚拟机建立对象</strong>，一个类只有一个Class对象，所以可以用==比较</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li><li>通过Class可以完整地得到一个类中的所有被加载的结构</li></ul><p><strong>获取Class对象四种方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = User.class;           <span class="comment">// 通过类名,可以为基本数据类型 int.class</span></span><br><span class="line">Class c = user.getClass();      <span class="comment">// 通过对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">&quot;com.xxx.reflection.User&quot;</span>);   <span class="comment">//通过类的全限定名</span></span><br><span class="line">Class c = <span class="keyword">int</span>.TYPE;             <span class="comment">// 通过包装类</span></span><br></pre></td></tr></table></figure><ul><li>Class类实际上是一个<strong>泛型类</strong>，可以是类，也可以不是类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际使用都是省略类型</span></span><br><span class="line">Class&lt;User&gt; userClass = User.class;</span><br><span class="line">Class&lt;Integer&gt; integerClass = <span class="keyword">int</span>.class;</span><br></pre></td></tr></table></figure><ul><li>由于历史原因，数组输出获取名字会很奇怪</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(User[].class.getName());</span><br><span class="line">System.out.println(Integer.class.getName());</span><br><span class="line"></span><br><span class="line">[Lcom.wzh.反射.User;</span><br><span class="line">java.lang.Integer</span><br></pre></td></tr></table></figure><h3 id="7-3、获取资源"><a href="#7-3、获取资源" class="headerlink" title="7.3、获取资源"></a>7.3、获取资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">URL <span class="title">getResourceAsStream</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function">InputStream <span class="title">getResourceAsStream</span><span class="params">(String name)</span></span>;  <span class="comment">// 获取和类同一级的资源</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类对象</span></span><br><span class="line">Class c1 = Test.class;</span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// 获取输入流</span></span><br><span class="line">InputStream in = c1.getClassLoader().getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line"><span class="comment">// 读取数据信息</span></span><br><span class="line">properties.load(in);</span><br><span class="line"><span class="comment">// 获取信息</span></span><br><span class="line">String name = properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure><h3 id="7-4、操作类"><a href="#7-4、操作类" class="headerlink" title="7.4、操作类"></a>7.4、操作类</h3><p>Java.lang.reflect 包有3个类 Field、method、Constructor 分别获取属性、方法、构造器（不含父类的方法）</p><ul><li>获取类名，包名（Class对象方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>;              <span class="comment">// 获取包名 + 类名</span></span><br><span class="line"><span class="function">String <span class="title">getSimpleName</span><span class="params">()</span></span>;        <span class="comment">// 只获得类名</span></span><br><span class="line"><span class="function">String <span class="title">getPackageName</span><span class="params">()</span></span>;</span><br><span class="line">Class[] getInterfaces();       <span class="comment">// 获得接口</span></span><br></pre></td></tr></table></figure><ul><li> 获取Feild对象及FeildAPI</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Field对象</span></span><br><span class="line">Field[] getFields();               <span class="comment">// 获取public的类变量，返回数组</span></span><br><span class="line">Field[] getDeclaredFields();       <span class="comment">// 获取全部类变量，包括private</span></span><br><span class="line"></span><br><span class="line">Field[] getField(Strning name);</span><br><span class="line">Field[] getDeclaredField(Strning name);    <span class="comment">// 获取指定名称的 </span></span><br></pre></td></tr></table></figure><ul><li>获取method对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method[] getMethods();              <span class="comment">// 获取public的method</span></span><br><span class="line">Method[] getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">Method[] getMethod(String name,String.class...);  <span class="comment">// 要指定方法名和参数的类型</span></span><br><span class="line">Method[] getDeclaredMethod(String name,<span class="keyword">null</span>);     <span class="comment">// 无参可以使用null或者不填</span></span><br></pre></td></tr></table></figure><ul><li>获取Constructor对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] getConstructors();</span><br><span class="line">Constructor[] getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">Constructor[] getDeclaredConstructor(String.class...); <span class="comment">// 需要指定参数类型</span></span><br><span class="line">Constructor[] getConstructor();             <span class="comment">// 无参则不填</span></span><br></pre></td></tr></table></figure><p>三个类对象常用API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>                   <span class="comment">// 返回的 Field对象表示的字段的名称。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>         <span class="comment">// 比较这 Field与指定对象。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span>                 <span class="comment">// 返回的 对构造器、方法、字段的修饰符的描述</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>;     <span class="comment">// 操作私有的必须设置为true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field  </span></span><br><span class="line"><span class="function">Class <span class="title">getType</span><span class="params">()</span>                    <span class="comment">// 返回类型  </span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object obj)</span>             <span class="comment">// 传入对象，获取该对象的属性  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span> <span class="comment">// 传入对象，把该字段设置为该值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// Method 和 Constructor通用</span></span></span><br><span class="line"><span class="function">Class <span class="title">getReturnType</span><span class="params">()</span>      <span class="comment">// 返回类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParameterCount</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">Class[] <span class="title">getParameterTypes</span><span class="params">()</span>  <span class="comment">// 返回参数类型</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// Method</span></span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span>  <span class="comment">// 调用方法,需要传入对象和参数</span></span></span><br><span class="line"><span class="function"><span class="comment">// Constructor </span></span></span><br><span class="line"><span class="function"><span class="title">newInstance</span><span class="params">(Object... initargs)</span>  <span class="comment">// 调用构造器创建对象,需要传入参数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//扩展 通过Class对象调用newInstance是调用无参构造    </span></span></span><br></pre></td></tr></table></figure><p><strong>Modifier类API</strong></p><blockquote><p>示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">// 获得User的Class类对象</span></span><br><span class="line">        Class c = User.class;</span><br><span class="line">        <span class="comment">// 调用构造器创建对象</span></span><br><span class="line">        User user1 = (User) c.getConstructor().newInstance();</span><br><span class="line">        <span class="comment">// 调用无参构造</span></span><br><span class="line">        User user2 = (User) c.newInstance();</span><br><span class="line">        <span class="comment">// 获取私有字段</span></span><br><span class="line">        Field field = c.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="comment">// 给id设置值</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(user1,<span class="number">1</span>);</span><br><span class="line">        field.set(user2,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        Method method = c.getMethods()[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        method.invoke(user1,<span class="number">11</span>);</span><br><span class="line">        method.invoke(user2,<span class="number">88</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5、操作注解"><a href="#7-5、操作注解" class="headerlink" title="7.5、操作注解"></a>7.5、操作注解</h3><p>API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] getAnnotations();  <span class="comment">// 获取注解</span></span><br><span class="line">Annotation[] getAnnotation(Annotation annotation);  <span class="comment">// 根据注解类型获取</span></span><br><span class="line">Annotation[] getDeclaredAnnotation();</span><br></pre></td></tr></table></figure><blockquote><p>实战</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类上的注解，</span></span><br><span class="line">Annotation[] annotations = c.getAnnotations();</span><br><span class="line"><span class="keyword">for</span>(Annotation annotation:annotations)&#123;            <span class="comment">//循环注解信息</span></span><br><span class="line">    System.out.println(annotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类上的注解</span></span><br><span class="line">MyAnnotation m1 = (MyAnnotation) c.getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(m1.value());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段注解</span></span><br><span class="line">Field[] fields = c.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field f:fields) &#123;</span><br><span class="line">    MyAnnotation m2 = f.getAnnotation(MyAnnotation.class);</span><br><span class="line">    System.out.println(m2.value()); <span class="comment">// 注解定义的字段名是什么，就xxx()获取</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取方法的注解</span></span><br><span class="line">MyAnnotation m3 = c.getMethods()[<span class="number">0</span>].getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(m3.value());</span><br></pre></td></tr></table></figure><p><strong>特殊注意：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为数组时反射调用方法需要强制转换</span></span><br><span class="line">method.invoke(user,(Object) strings);</span><br></pre></td></tr></table></figure><h3 id="7-6、操作泛型"><a href="#7-6、操作泛型" class="headerlink" title="7.6、操作泛型"></a>7.6、操作泛型</h3><p>​    上述反射API获取的参数若是HashMap，则只能得到参数类型为HashMap，而无法得到HashMap里面的键和值的类型，为了通过反射操作这些类型，java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType<strong>几种类型</strong>来代表不能被归一到class类中的类型但是又和原始类型齐名的类型</p><ul><li>ParameterizedType：表示参数化类型，比如collection<String></li><li>GenericArrayType：表示一种元素类型是参数化类型或者类型变量的<strong>数组类型</strong></li><li>TypeVariable：各种类型变量的公共父接口</li><li>WinldcardType：代表一种通配符类型表达式</li></ul><p><strong>API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class方法</span></span><br><span class="line">TypeVariable[] getTypeParameters() </span><br><span class="line"><span class="comment">// 如果类型被声明为泛型类型，则获得泛型类型变量，否则获得长度为0的数组  </span></span><br><span class="line">Type[] getGenericSuperClass();   <span class="comment">// 获得声明超类的泛型类型</span></span><br><span class="line">Type[] getGenericInterfaces();   <span class="comment">// 获得这个类型所声明接口的泛型类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// method方法</span></span><br><span class="line">TypeVariable[] getTypeParameters() </span><br><span class="line">Type[] getGenericParameterTypes()  <span class="comment">// 获得泛型参数，</span></span><br><span class="line"><span class="function">Type <span class="title">getGenericReturnType</span><span class="params">()</span>        <span class="comment">// 获得泛型返回值类型。 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// TypeVariable方法</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Type[] <span class="title">getBounds</span><span class="params">()</span>   <span class="comment">// 获得变量的子类限定</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// wildcardType方法     </span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getUpperBounds</span><span class="params">()</span>    <span class="comment">// 获得这个类型变量的子类限定</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getLowerBounds</span><span class="params">()</span>   <span class="comment">// 超类限定</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ParameterizedType</span></span></span><br><span class="line"><span class="function">Type <span class="title">getRawType</span><span class="params">()</span>    <span class="comment">//获得原始类型</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getActualTypeArguments</span><span class="params">()</span>    <span class="comment">// 获得这个参数化类型声明的类型参数</span></span></span><br><span class="line"><span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span>     <span class="comment">//  返回外部类型，是顶层则返回null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// GenericArrayType</span></span></span><br><span class="line"><span class="function">Type <span class="title">getGenericComponentType</span><span class="params">()</span> <span class="comment">// 获得这个数组类型声明的泛型元素类型    </span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Map&lt;String,Integer&gt; map, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Integer&gt; <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取test1方法</span></span><br><span class="line">        Method method1 = Test.class.getMethod(<span class="string">&quot;test1&quot;</span>, Map.class,List.class);</span><br><span class="line">        <span class="comment">// 获得 所有的参数数组</span></span><br><span class="line">        Type[] genericParameterTypes = method1.getGenericParameterTypes();</span><br><span class="line">        <span class="comment">// 变量参数数组</span></span><br><span class="line">        <span class="keyword">for</span>(Type type:genericParameterTypes)&#123;</span><br><span class="line">            <span class="comment">// 输出map的所有参数和list的所有参数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;1:&quot;</span>+type);</span><br><span class="line">            <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            <span class="comment">// 把map和list整体的参数细化为String,Integer这种</span></span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class="line">                <span class="comment">// 输出具体的全部参数，如输出map里面的所有参数</span></span><br><span class="line">                <span class="keyword">for</span>(Type type1:actualTypeArguments)&#123;</span><br><span class="line">                    System.out.println(type1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取返回值参数</span></span><br><span class="line">        Method method2 = Test.class.getMethod(<span class="string">&quot;test2&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 获取返回值类型</span></span><br><span class="line">        Type genericReturnType = method2.getGenericReturnType();</span><br><span class="line">        System.out.println(genericReturnType);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type type:actualTypeArguments)&#123;</span><br><span class="line">                System.out.println(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-7、反射编写泛型数组"><a href="#7-7、反射编写泛型数组" class="headerlink" title="7.7、反射编写泛型数组"></a>7.7、反射编写泛型数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; E[] printArray( E[] inputArray )&#123;</span><br><span class="line">    Class c2 = inputArray.getClass().getComponentType();</span><br><span class="line"><span class="comment">// 调用反射方法创建数组，因为无法通过E去创建数组</span></span><br><span class="line">    E[] newArray = (E[]) Array.newInstance(c2,inputArray.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputArray.length; i++) &#123;</span><br><span class="line">        newArray[i] = inputArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、接口"><a href="#8、接口" class="headerlink" title="8、接口"></a>8、接口</h2><h3 id="8-1、简介"><a href="#8-1、简介" class="headerlink" title="8.1、简介"></a>8.1、简介</h3><ul><li><strong>只含常量值、抽象方法</strong>，变量：public static final，方法：public abstract</li><li>接口并不是类，类描述对象的属性和方法。接口则包含类要实现的方法。</li><li>接口无法被实例化，一个类可以<strong>实现多个接口</strong>，一个接口可以多继承其他接口</li><li>实现接口的类中必须提供接口中所有方法的实现，方可实例化。否则仍为抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">18</span>;              <span class="comment">// 定义成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAge</span><span class="params">()</span></span>;      <span class="comment">// 定义抽象方法</span></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购物&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现方法，使用定义的常量</span></span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以重写也可以不重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买鞋子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PersonImpl person = <span class="keyword">new</span> PersonImpl();</span><br><span class="line">        person.buy(<span class="string">&quot;衣服&quot;</span>);</span><br><span class="line">        person.buy();</span><br><span class="line">        Person.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">买衣服</span><br><span class="line">买鞋子</span><br><span class="line">吃</span><br></pre></td></tr></table></figure><p><strong>Java8新特性：</strong>可以为接口添加静态方法和默认方法（包含方法体）</p><ol><li>静态方法：使用 static 关键字修饰。可以<strong>通过接口直接调用</strong>静态方法。</li><li>默认方法：默认方法使用 default 关键字修饰。可以通过<strong>实现类对象</strong>来调用。<ul><li><strong>父类的默认方法之间可能造成冲突</strong>：类C实现了接口A和接口B，而接口A和接口B有一样的默认方法，就会造成冲突，此类C必需重写该方法。</li><li><strong>子类默认方法和父类的方法不会冲突</strong>，会调用父类方法</li></ul></li><li>私有方法：JDK9允许，私有方法必需是静态方法或者实例方法</li></ol><p>不过一般不推荐这么做，如Java就是Collection接口和CollectionS工具类提供静态方法</p><h3 id="8-2、接口和抽象"><a href="#8-2、接口和抽象" class="headerlink" title="8.2、接口和抽象"></a>8.2、接口和抽象</h3><table><thead><tr><th>区别</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>定义</td><td>可能包含抽象方法的类</td><td>主要是抽象方法和全局常量的集合</td></tr><tr><td>组成</td><td>构造方法、抽象方法、普通方法、常量、变量</td><td>常量、抽象方法、(jdk8.0:默认方法、静态方法)</td></tr><tr><td>使用</td><td>子类继承抽象类(extends)</td><td>子类实现接口(implements)</td></tr><tr><td>关系</td><td>抽象类可以实现多个接口</td><td>接口不能继承抽象类，但允许继承多个接口</td></tr><tr><td>局限</td><td>抽象类有单继承的局限</td><td>接口没有此局限</td></tr><tr><td>实际</td><td>作为一个模板</td><td>是作为一个标准或是表示一种能力</td></tr><tr><td>常见设计模式</td><td>模板方法</td><td>工厂模式、代理模式</td></tr></tbody></table><h3 id="8-3、Comparable接口"><a href="#8-3、Comparable接口" class="headerlink" title="8.3、Comparable接口"></a>8.3、Comparable接口</h3><ul><li>实现了 Comparable 接口的类，调用数组或者集合的 sort 方法·就行实现排序了</li><li>返回0表示相等，返回1表示当前类更大，返回 - 1 表示当前类更小</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4、Compator接口"><a href="#8-4、Compator接口" class="headerlink" title="8.4、Compator接口"></a>8.4、Compator接口</h3><ul><li>实现了 Comparable 接口的类，表明这是一个比较器</li><li>数组或者集合的 sort 方法 ，传入比较器的对象也能实现比较，并且不需要改动原本的类</li><li>返回0表示相等，返回1表示当前类更大，返回 - 1 表示当前类更小</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o, Object t1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如想自己定义String类的比较顺序，就只能通过传入比较器对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种方式de比较器</span></span><br><span class="line">Comparator.comparing(User::getId).thenComparing(User::getName);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入功能，比较null</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.*;</span><br><span class="line">Arrays.sort(users,comparing((User::getId),nullsFirst(naturalOrder())));</span><br><span class="line"><span class="comment">// 逆序后面加reversed()或者reverseOrder()</span></span><br></pre></td></tr></table></figure><h3 id="8-5、对象克隆"><a href="#8-5、对象克隆" class="headerlink" title="8.5、对象克隆"></a>8.5、对象克隆</h3><p><strong>问题：</strong>众所周知，把A对象赋给B对象，只是传递了引用，二者实际还是指向同一个地址，此时B对象的改变会引起A对象的改变</p><p><strong>解决</strong>：通过克隆（实现cloneable接口）可以产生一个新的对象，并且完全脱离旧对象而存在</p><ul><li>浅拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型进⾏引⽤传递般的拷⻉，此为浅拷</li><li>深拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型，创建⼀个新的对象，并复制其内容</li></ul><blockquote><p>浅克隆</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Son son = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">// Object类的clone方法是受保护的，main方法不能调用</span></span><br><span class="line">        User newUser = (User) user.clone();</span><br><span class="line">        System.out.println(user.hashCode());</span><br><span class="line">        System.out.println(newUser.hashCode());</span><br><span class="line"></span><br><span class="line">        System.out.println(user.son.hashCode());</span><br><span class="line">        System.out.println(newUser.son.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里出现了一个问题，新对象和旧对象的hashcode不同，但是他们内部属性son类却还是同一个，<strong>新对象和旧对象直接还存在联系</strong></p><ul><li>浅克隆：可能还存在一些关联</li><li>深克隆：完全不同</li></ul><blockquote><p>深克隆</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Son 实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重新编写clone方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    User user = (User) <span class="keyword">super</span>.clone();</span><br><span class="line">    user.son = (Son) <span class="keyword">this</span>.son.clone();</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><p>cloneable是一个标记接口，实际上没有任何作用，因为我们需要的clone方法是从Object类继承而来，如果一个对象克隆但是有没有实现该接口，就会生成一个检查型异常</p><h2 id="9、lambda表达式"><a href="#9、lambda表达式" class="headerlink" title="9、lambda表达式"></a>9、lambda表达式</h2><h3 id="9-1、函数式接口"><a href="#9-1、函数式接口" class="headerlink" title="9.1、函数式接口"></a>9.1、函数式接口</h3><ol><li><code>只包含一个抽象方法</code>的接口，称为函数式接口。</li><li>我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检 查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个 接口是一个函数式接口。</li><li><strong>Lambda表达式就是一个函数式接口的实例。</strong></li></ol><h3 id="9-2、Java内置四大核心函数式接口"><a href="#9-2、Java内置四大核心函数式接口" class="headerlink" title="9.2、Java内置四大核心函数式接口"></a>9.2、Java内置四大核心函数式接口</h3><p><img src="C:\Users\admin\Desktop\JavaSE\img\JavaSE\3.jpg"></p><table><thead><tr><th></th><th>参数类型</th><th>返回类型</th></tr></thead><tbody><tr><td>消费型接口</td><td>T</td><td>void</td></tr><tr><td>供给型接口</td><td>无</td><td>T</td></tr><tr><td>函数型接口</td><td>T</td><td>R</td></tr><tr><td>断定型接口</td><td>T</td><td>boolean</td></tr></tbody></table><h3 id="9-3、lambda表达式"><a href="#9-3、lambda表达式" class="headerlink" title="9.3、lambda表达式"></a>9.3、lambda表达式</h3><ol><li>Lambda 是一个匿名函数，可以把 Lambda 表达式理解为是<strong>一段可以 传递的代码</strong></li><li>Lambda表达式可以替代<strong>只有一个方法的匿名内部类</strong></li><li>本质上还是一个匿名类，所以不能引用前后的非static数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Ilike</span></span>&#123; </span><br><span class="line"><span class="function">String <span class="title">Lamada</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 匿名内部类实现</span></span><br><span class="line">        A a = <span class="keyword">new</span> A() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.index(<span class="number">5</span>);</span><br><span class="line">     <span class="comment">// lambda表达式实现   </span></span><br><span class="line">        A a1 = ((i) -&gt; &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;);</span><br><span class="line">        a1.index(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果为单个参数可以删去()，单条执行语句可以删去&#123;&#125;</span></span><br><span class="line"><span class="comment">// 简化版本</span></span><br><span class="line">A a1 = (i -&gt; System.out.println(i));</span><br><span class="line">a1.index(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><blockquote><p>变量作用域问题</p></blockquote><ul><li>lambda表达式只能获取外部的变量的值，而<strong>不能修改</strong></li><li>lambda表达式获取的外部变量，在整个作用域内<strong>不能发生改变</strong>，如下面 i 不能变化。即必须为事实最终变量</li><li>lambda表达式使用的 this 指向的是外部方法，而不是内部匿名类，并且使用this就不能定义为静态方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> j =<span class="number">0</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果定义了i++;会报错</span></span><br><span class="line">        Factory factory = ()-&gt;&#123;</span><br><span class="line">            j--;         <span class="comment">// i--会报错,因为不安全</span></span><br><span class="line">            <span class="keyword">int</span> m = j+i; <span class="comment">// 可以使用i的值，但是不能改变i</span></span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;;</span><br><span class="line">        factory.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test.fun1(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4、方法引用"><a href="#9-4、方法引用" class="headerlink" title="9.4、方法引用"></a>9.4、方法引用</h3><ul><li>当要传递给Lambda体的操作，<code>已经有实现的方法了</code>，可以使用方法引用！</li><li>简单理解：<strong>使用其他方法当做lambda表达式的方法</strong>，无须自己写方法</li></ul><p><strong>要求：</strong>实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！</p><p><strong>格式：</strong></p><ul><li><p>使用操作符 “::” 将类(或对象) 与 方法名分隔开来。</p></li><li><p>对象::实例方法名、类::静态方法名、类::实例方法名</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口：</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">big</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法调用实现,Test02类的big方法参数和返回值都和Test01的eat方法一致，所以可以调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test02 test02 = <span class="keyword">new</span> Test02();</span><br><span class="line">Test01 test01 = test02::big;   <span class="comment">//调用了方法</span></span><br><span class="line">test01.eat(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-5、构造器引用"><a href="#9-5、构造器引用" class="headerlink" title="9.5、构造器引用"></a>9.5、构造器引用</h3><p><strong>要求：</strong>构造器参数列表要与接口中抽象 方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</p><p><strong>格式：</strong>类名::new</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">createUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器引用</span></span><br><span class="line">Factory factory = User::<span class="keyword">new</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line">Test01 test01 = (()-&gt;&#123;  <span class="keyword">return</span> <span class="keyword">new</span> Bank();&#125;);</span><br></pre></td></tr></table></figure><h3 id="9-6、数组引用"><a href="#9-6、数组引用" class="headerlink" title="9.6、数组引用"></a>9.6、数组引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须要有参数指定长度</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] createArr(<span class="keyword">int</span> length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = factory.createArr(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、内部类"><a href="#10、内部类" class="headerlink" title="10、内部类"></a>10、内部类</h2><p>分类：</p><ol><li>成员内部类（static和非static，可以为public和private和protected）</li><li>局部内部类（不谈修饰符）</li><li>匿名内部类</li></ol><h3 id="9-1、成员内部类"><a href="#9-1、成员内部类" class="headerlink" title="9.1、成员内部类"></a>9.1、成员内部类</h3><ul><li>可以把内部类看做外部类的一个<strong>属性</strong>，同样有public和private和protected修饰符，<ul><li>public能在外部通过外部类创建对象，protected能在本包下创建对象，</li><li>private则只能通过<strong>外部类封装内部类的方法</strong>让外界能访问到内部类的方法</li></ul></li><li>内部类具有自己的属性和方法，但是<strong>不能定义成静态</strong>的</li><li>内部类可以获得外部类<strong>所有的</strong>方法和属性（包括私有、静态等）</li><li>内部类和外部类的属性或者方法相同时，内部类的会<strong>覆盖外部类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(String name, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String name = <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 内部类可以访问外部的所有方法和属性(包括私有的)</span></span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                System.out.println( <span class="string">&quot;访问了外部类私有数据&quot;</span>+name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// private内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner2</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String name = <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 内部类可以访问外部的所有方法和属性(包括私有的)</span></span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="comment">// 覆盖外部的name</span></span><br><span class="line">                System.out.println( <span class="string">&quot;访问了外部类私有数据&quot;</span>+name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把内部类方法封装出来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">funByInner2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner2 inner2 = <span class="keyword">new</span> Inner2();</span><br><span class="line">        inner2.fun();</span><br><span class="line">        System.out.println(inner2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public内部类对象必须通过外部类对象创建</span></span><br><span class="line">    Outer outer = <span class="keyword">new</span> Outer(<span class="string">&quot;张三&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">    Outer.Inner1 inner1 = outer.<span class="function">new <span class="title">Inner1</span><span class="params">()</span></span>;</span><br><span class="line">    inner1.fun();</span><br><span class="line">    <span class="comment">// private内部类无法在外部直接创建，只能通过外部类的方法封装内部类方法</span></span><br><span class="line">    outer.funByInner2();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2、静态内部类"><a href="#9-2、静态内部类" class="headerlink" title="9.2、静态内部类"></a>9.2、静态内部类</h3><ul><li>静态成员内部类可以定义静态属性和方法，但是有使用限制<ul><li>静态属性使用无限制，获取可以直接通过类获取，而不必new对象</li><li>静态方法只能获取静态内部类或外部类的<strong>静态属性</strong>，获取可以直接通过类获取，而不必new对象</li></ul></li><li>静态成员内部类的非静态属性和方法<ul><li>非静态属性：只能被非静态方法调用</li><li>非静态方法：只能调用外部类的静态属性和方法，内部类的所有属性和方法</li></ul></li><li>静态内部类同样有3种修饰符，</li></ul><p>总之，最大的不同就是因为是静态，所以只能获取外部的静态资源。</p><h3 id="9-3、局部内部类"><a href="#9-3、局部内部类" class="headerlink" title="9.3、局部内部类"></a>9.3、局部内部类</h3><p><strong>定义：</strong>在<strong>方法中定义</strong>，然后使用</p><p><strong>范围：</strong>只能在该方法中使用，而且必须先声明，在使用</p><p><strong>特点：</strong></p><ul><li>不能使用任何修饰符</li><li>可以访问局部变量（<strong>在方法内改变了必须从未修改过</strong>），但是不能修改</li><li>this指向的是本身</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">// this指向自己，</span></span><br><span class="line">                System.out.println(i+name+<span class="keyword">this</span>.hashCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.show();</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4、匿名内部类"><a href="#9-4、匿名内部类" class="headerlink" title="9.4、匿名内部类"></a>9.4、匿名内部类</h3><p><strong>概念：</strong>不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。</p><p><strong>特点：</strong></p><ul><li>匿名内部类必须<strong>继承父类或实现接口</strong></li><li>可以访问局部变量（<strong>在方法内改变了必须从未修改过</strong>），但是不能修改</li><li>this指向的是外部方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.eat();</span><br></pre></td></tr></table></figure><p>匿名内部类继承或者实现一个类或接口，然后调用里面的方法。</p><blockquote><p>注意</p></blockquote><p>局部和匿名内部类访问外部局部变量的原因是编译器<strong>会做变量拷贝</strong>，这也是为什么不能访问在外部发生过值变化的局部变量的原因</p><h2 id="11、代理"><a href="#11、代理" class="headerlink" title="11、代理"></a>11、代理</h2><h3 id="11-1、静态代理"><a href="#11-1、静态代理" class="headerlink" title="11.1、静态代理"></a>11.1、静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Marry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;等了这么久，终于等到你。。。 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarryCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Marry marry;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarryCompany</span><span class="params">(Marry marry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.marry = marry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        marry.toMarry();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;婚礼现场布置中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜您结婚，迈入人生第二阶段&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代理类和目标类实现同一个接口</li><li>代理类构造方法需要传入目标类</li><li>代理类的方法依次实现before方法，目标类方法，after方法</li></ul><p><strong>优点</strong></p><ul><li>真实的对象更加纯粹，不用去关注一些公共的业务</li><li>广告业务交给代理类，实现业务分工</li><li>公共业务发生拓展的时候，方便集中管理</li></ul><p><strong>缺点</strong></p><ul><li>一个真实对象会产生一个代理角色：代码量翻倍——&gt;效率低</li></ul><h3 id="11-2、动态代理（反射）"><a href="#11-2、动态代理（反射）" class="headerlink" title="11.2、动态代理（反射）"></a>11.2、动态代理（反射）</h3><ul><li>动态代理和静态代理角色一样</li><li>动态代理的代理类是动态生成的，不是直接写好的</li><li>动态代理分为两大类：基于接口和基于类<ul><li>基于接口——-JDK代理</li><li>基于类：cglib</li><li>Java字节码实现：JavaAssist</li></ul></li></ul><blockquote><p>InvocationHandler：反射包下的类，是一个接口，只有invoke方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy,方法 method,Object[] args)</span><span class="keyword">throws</span> Throwable</span></span><br></pre></td></tr></table></figure><p>定义一个动作，所有接口的方法执行都会替换成动作执行</p><blockquote><p>Proxy：</p></blockquote><p>Proxy为创建动态代理类的实例提供了静态方法，也是所有动态代理类的父类的方法创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, </span></span></span><br><span class="line"><span class="params"><span class="function">              类&lt;?&gt;[] interfaces, InvocationHandler h)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序</span></span></span><br><span class="line"><span class="function"><span class="comment">//即根据传入的父接口的子实现类，返回该父接口的对象（向上转型），通过该父接口调用子类方法</span></span></span><br></pre></td></tr></table></figure><ul><li>参数一为Loader的类加载器</li><li>参数二为代理实现的接口，Class对象数组</li><li>参数三为调用处理器，即代理类</li></ul><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Rent rent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRent</span><span class="params">(Rent rent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成得到代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),rent.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// invoke相当于执行接口的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">// 反射调用了方法，rent为对象，objects为参数</span></span><br><span class="line">        Object result = method.invoke(rent,objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真实角色</span></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        <span class="comment">//代理角色:现在没有</span></span><br><span class="line">        ProxyInvocationHandler proxyInvocationHandler = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">        <span class="comment">//传入真实角色</span></span><br><span class="line">        proxyInvocationHandler.setRent(host);</span><br><span class="line">        <span class="comment">// 获得代理类</span></span><br><span class="line">        Rent proxy = (Rent) proxyInvocationHandler.getProxy();</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE(一):基本语法</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%80%20)%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%80%20)%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h2><p><strong>按照数据类型分类：</strong></p><ul><li>基本类型：整型、浮点型、字符型、布尔型</li><li>引用类型：类、接口、数组、枚举、注解等</li></ul><p><strong>按声明的位置的不同</strong></p><ul><li>成员变量：方法体外，类体内声明的变量称为（其中被static修饰的称为<strong>类变量</strong>，其他为实例变量）</li><li>局部变量：在方法体内部声明（形参、方法内局部变量、代码块局部变量）</li></ul><p><strong>同：</strong>都有生命周期 </p><p><strong>异：</strong>局部变量除形参外，需显式初始化。</p><h3 id="1-1、整型"><a href="#1-1、整型" class="headerlink" title="1.1、整型"></a>1.1、整型</h3><p>整型表示没有小数部分的数值</p><table><thead><tr><th align="center">类型</th><th align="center">存储需求</th><th>范围</th><th>表示</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">4字节</td><td>-2 ^31 ~2^31-1(约21亿)</td><td>正常表示</td></tr><tr><td align="center">short</td><td align="center">2字节</td><td>-2 ^15 ~2^15 -1</td><td></td></tr><tr><td align="center">long</td><td align="center">8字节</td><td>-2 ^63 ~2^63-1(约21亿)</td><td>后缀有L或者l</td></tr><tr><td align="center">byte</td><td align="center">1字节</td><td>-128~127</td><td></td></tr></tbody></table><p>需要注意的是，</p><ul><li>Java的整型范围与平台无关（C/C++会自动选择最优的）</li><li>Java没有任何无符号形式的整形</li></ul><h3 id="1-2、浮点类型"><a href="#1-2、浮点类型" class="headerlink" title="1.2、浮点类型"></a>1.2、浮点类型</h3><table><thead><tr><th>类型</th><th>存储需求</th><th>范围</th><th>表示</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>-3.403E38 ~ 3.403E38</td><td>后缀有F或者f</td></tr><tr><td>double</td><td>8字节</td><td>-1.798E308 ~ 1.798E308</td><td>后缀有D或者d</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li><p>没有后缀默认为double类型</p></li><li><p>两种表示方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.1</span>   <span class="number">6.34F</span>   <span class="number">.512</span>   <span class="comment">// 十进制计数法 </span></span><br><span class="line"><span class="number">5.12e2</span> <span class="number">512E2</span> <span class="number">100E-2</span>  <span class="comment">// 科学计数法</span></span><br></pre></td></tr></table></figure></li><li><p>特殊的三个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Double.POSITIVE_INFINITY;  <span class="comment">// 表示正无穷大</span></span><br><span class="line">Double.NEGATIVE_INFINITY;  <span class="comment">// 表示负无穷大</span></span><br><span class="line">Double.NaN;                <span class="comment">// 表示不是一个数字，0/0 或者 负数平方根</span></span><br></pre></td></tr></table></figure></li><li><p>所有的浮点数直接不能比较，因为浮点数底层还是用<strong>二进制</strong>表示的，二进制无法准确的表示小数</p></li></ul><h3 id="1-3、char类型"><a href="#1-3、char类型" class="headerlink" title="1.3、char类型"></a>1.3、char类型</h3><table><thead><tr><th>类型</th><th>存储需求</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>2字节，16位</td><td>\u0000~\uFFFF</td></tr></tbody></table><ul><li>char类型用于表示<strong>单个字符</strong>，一些Unicode编码<strong>需要两个char</strong>表示</li><li>Java中的所有字符都使用Unicode编码，通常字符用一个char存储，特殊的用两个存储，如emoji表情🍺</li><li>字符型变量的三种表现形式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;       <span class="comment">// 字面量表示</span></span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">&#x27;\n&#x27;</span>;      <span class="comment">// 用转义字符‘\’来将其后的字符转变为特殊字符型常量</span></span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">&#x27;\uXXXX&#x27;</span>;  <span class="comment">// 直接使用 Unicode 值来表示字符型常量</span></span><br></pre></td></tr></table></figure><ul><li>特殊的：\u是一种<strong>转义序列</strong>，可以出现在<strong>加引号的字符常量</strong>或者<strong>字符串之外</strong>（其他转义序列不行）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String\u005B\u005D args)</span>  <span class="comment">// 可以运行</span></span></span><br></pre></td></tr></table></figure><ul><li>Unicode转义序列会在<strong>解析代码</strong>之前处理，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \u000A a        会报错,因为\u000A会转换成一个换行符 \n</span></span><br></pre></td></tr></table></figure><ul><li>char也是用二进制存储的，可以和int相互转换，但int的范围不能太大</li></ul><blockquote><p>Unicode和char类型</p></blockquote><p>​    Unicode统一了同一了世界上所有字符，每个字符都为其分配一个数字来表示，当时认为16位（65536）已经足够表示了，所以Java设计char类型时也使用16位的Uicode字符集，但是后来随着汉字和日韩语言等的加入，16位得char已经不够使用了。</p><p>​    新标准：U+0000~U+FFFF表示经典Unicode编码，其他在最前面加入一位表示<strong>代码平面</strong>，例如U+10000就表示第一个代码平面。</p><p><strong>注意：Unicode只是一种标准，一般传输数据多用UTF-8或UTF-16</strong></p><p><strong>UTF-8（Unicode的一种实现）：</strong></p><ul><li>变长字节的设计，一个字符最长4字节，最少1字节，大部分汉字3字节</li><li>用一个字节表示的字符，第一位设为0，后面七位对应字符的Unicode码点，由于128个字符的Unicode完全对照ASCII码，所以ASCII编码的文件可以用UTF-8打开不乱码</li><li>用n个字节以上表示的，则第一个字节的前n位都为1，第N+1位为0，剩下的n-1个字节前两位都设置为10，多余的位置使用该字符的Unicode二进制代码填充，不够用0填充</li></ul><p><strong>UTF-16（Java使用的编码方式）</strong>：</p><ul><li>用2个字节或者4个字节表示</li><li>4字节表示的使用两个char，2字节的使用一个char表示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">U+1D546 使用UTF-16需要两个代码单元，也就是使用两个char表示</span><br><span class="line">此时如果调用charAt(1) 获取的是第二个代码单元</span><br></pre></td></tr></table></figure><h3 id="1-4、boolean类型"><a href="#1-4、boolean类型" class="headerlink" title="1.4、boolean类型"></a>1.4、boolean类型</h3><ul><li>大小1bit（位），判断逻辑条件，不能和整形相互转换</li><li>不允许取null值</li></ul><h3 id="1-5、数值类型之间的转换"><a href="#1-5、数值类型之间的转换" class="headerlink" title="1.5、数值类型之间的转换"></a>1.5、数值类型之间的转换</h3><ul><li>自动类型转换：多数据混合运算时，会<strong>自动转换</strong>成容量最大的那种。</li><li>强制类型转换：可以把<strong>大的数据类型强制转换(casting)成小的</strong>数据类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">char</span>、<span class="keyword">byte</span>、<span class="keyword">short</span>)<span class="keyword">int</span> -&gt; <span class="keyword">long</span> -&gt; <span class="keyword">float</span> -&gt; <span class="keyword">double</span> -&gt; String</span><br><span class="line"><span class="comment">// char、byte、short运算时会自动转换成int类型   </span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>布尔类型不能转换</li><li>String类型转回基本类型需要通过基本类型的包装类</li></ul><h3 id="1-6、进制"><a href="#1-6、进制" class="headerlink" title="1.6、进制"></a>1.6、进制</h3><ul><li>Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位，即最高位</li><li>前缀0X或者0x表示十六进制，前缀0表示八进制，前缀0b或者0B表示二进制</li><li>计算机以二进制<strong>补码</strong>的形式保存所有的整数</li></ul><p><strong>三种形式：</strong>负数情况下：反码  = 127 - 原码 、  补码 = 128 - 原码</p><ul><li>原码：最高位为符号位，负数为1。</li><li>反码：正数与原码相等，负数除了最高位，其他取反</li><li>补码：正数与原码相等，负数等于反码加1。</li></ul><p><strong>特点：</strong></p><ul><li>正数的原码、反码、补码都相同</li><li>负数的补码是其反码+1</li></ul><p><strong>原因：</strong></p><p>让计算机<strong>计算符号位</strong>比较麻烦，于是人们想出了将符号位也参与运算的方法。</p><p>根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了。</p><p>1-1=1+(-1)=0000 0001(原) + 1000 0001(原) = 0000 0001(补) + 1111 1111(补) = 0000 0000(原) = 0</p><ul><li>即让 1-1  = 1 + (-1) = (1 + (128-1))%128 =  128 % 128 = 0</li></ul><h2 id="2、变量和常量"><a href="#2、变量和常量" class="headerlink" title="2、变量和常量"></a>2、变量和常量</h2><h3 id="2-1、变量"><a href="#2-1、变量" class="headerlink" title="2.1、变量"></a>2.1、变量</h3><p><strong>概念：</strong></p><ul><li>内存中的一个存储区域（保存数据），该区域的值在不断变化，</li><li>程序中最基本的存储单元，</li></ul><p><strong>声明变量：</strong>每个变量都有一个类型，声明时需要指定类型，然后是变量名，以分号结尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量名: 合法的标志符</span><br><span class="line">标识符: 以字母开头并由字母(包括下划线)或者数字构成的序列，注意不能与关键字和保留字重名</span><br><span class="line">关键字: 被Java语言赋予了特殊含义，用做专门用途的字符串（单词），都为小写</span><br><span class="line">保留字: 现在Java没用到，但是以后可能用到</span><br></pre></td></tr></table></figure><p><strong>初始化：</strong>变量必须初始化后才能使用（类的成员变量会有默认值）</p><p><strong>作用域：</strong>其定义所在的一对{ }内 </p><p><strong>分类：</strong></p><ul><li>类变量：独立于方法之外的变量，用 static 修饰。</li><li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li><li>局部变量：方法里面</li></ul><h3 id="2-2、常量"><a href="#2-2、常量" class="headerlink" title="2.2、常量"></a>2.2、常量</h3><ul><li>使用关键字 final 修饰的变量，不能被修改，</li><li>通常使用大写字母作为变量名</li></ul><h3 id="2-3、枚举对象"><a href="#2-3、枚举对象" class="headerlink" title="2.3、枚举对象"></a>2.3、枚举对象</h3><p>Java 枚举是一个<code>特殊的类</code>，一般表示一组常量，参数默认用public static final 修饰</p><h3 id="2-4、修饰符"><a href="#2-4、修饰符" class="headerlink" title="2.4、修饰符"></a>2.4、修饰符</h3><p>访问权限：</p><table><thead><tr><th>修饰符</th><th>作用</th><th>范围</th></tr></thead><tbody><tr><td><strong>default</strong></td><td>同一包内可见，不使用任何修饰符</td><td>类、接口、变量、方法</td></tr><tr><td><strong>private</strong></td><td>在同一类内可见</td><td>变量、方法、内部类</td></tr><tr><td><strong>public</strong></td><td>对所有类可见</td><td>类、接口、变量、方法</td></tr><tr><td><strong>protected</strong></td><td>对同一包内的类和所有子类可见</td><td>变量、方法、内部类</td></tr></tbody></table><p>非访问权限：</p><table><thead><tr><th><strong>修饰符</strong></th><th><strong>作用</strong></th><th><strong>范围</strong></th></tr></thead><tbody><tr><td><strong>static</strong></td><td></td><td>变量、方法</td></tr><tr><td>final</td><td>变量：赋值后，不能修改    方法：不能继承</td><td>变量、方法</td></tr><tr><td>abstract</td><td></td><td>类、方法</td></tr><tr><td>synchronized</td><td>标记为同步</td><td>方法、代码块</td></tr><tr><td>volatile</td><td>保持可见性、禁止指令重排</td><td>变量</td></tr><tr><td>transient</td><td>java 虚拟机(JVM)跳过该特定的变量不序列化</td><td>变量</td></tr></tbody></table><h2 id="3、数字计算"><a href="#3、数字计算" class="headerlink" title="3、数字计算"></a>3、数字计算</h2><h3 id="3-1、算术运算符"><a href="#3-1、算术运算符" class="headerlink" title="3.1、算术运算符"></a>3.1、算术运算符</h3><ul><li>当两个操作数含浮点数时：表示浮动除法，</li><li>全为整数时：为整数除法（自动舍弃小数点后的数）</li></ul><h3 id="3-2、数学函数与变量"><a href="#3-2、数学函数与变量" class="headerlink" title="3.2、数学函数与变量"></a>3.2、数学函数与变量</h3><ul><li>Math 类提供很多方法，提供数学计算</li><li>StrictMath 类可以保证所有平台的计算结果一致</li><li>Math.PI    Math.E  表示π</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abs  <span class="comment">// 绝对值</span></span><br><span class="line">acos,asin,atan,cos,sin,tan  <span class="comment">// 三角函数</span></span><br><span class="line">sqrt  <span class="comment">// 平方根</span></span><br><span class="line">pow(<span class="keyword">double</span> a,doble b) <span class="comment">//  a的b次幂</span></span><br><span class="line">log  <span class="comment">// 自然对数</span></span><br><span class="line">exp <span class="comment">//  e为底指数</span></span><br><span class="line">max(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span><br><span class="line">min(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span><br><span class="line">random()                  <span class="comment">// 返回0.0到1.0的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> a)</span>      <span class="comment">// double型数据a转换为long型（四舍五入）</span></span></span><br><span class="line"><span class="function"><span class="title">toDegrees</span><span class="params">(<span class="keyword">double</span> angrad)</span>  <span class="comment">// 弧度—&gt;角度</span></span></span><br><span class="line"><span class="function"><span class="title">toRadians</span><span class="params">(<span class="keyword">double</span> angdeg)</span>  <span class="comment">// 角度—&gt;弧度</span></span></span><br></pre></td></tr></table></figure><h3 id="3-4、结合赋值运算符"><a href="#3-4、结合赋值运算符" class="headerlink" title="3.4、结合赋值运算符"></a>3.4、结合赋值运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+=  *= /= %=</span><br></pre></td></tr></table></figure><h3 id="3-5、自增和自减"><a href="#3-5、自增和自减" class="headerlink" title="3.5、自增和自减"></a>3.5、自增和自减</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x++  <span class="comment">// 先使用x，再++   </span></span><br><span class="line">++x  <span class="comment">// 先++，在使用x </span></span><br><span class="line">x-- </span><br></pre></td></tr></table></figure><h3 id="3-6、位运算"><a href="#3-6、位运算" class="headerlink" title="3.6、位运算"></a>3.6、位运算</h3><p>位运算是对整形的操作，若为布尔值，则为逻辑操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;    <span class="comment">// 与：全1则1，否则0</span></span><br><span class="line">|    <span class="comment">// 或：含1则1</span></span><br><span class="line">^    <span class="comment">// 异或：不同为1，相同为0</span></span><br><span class="line">~    <span class="comment">// 非：取反</span></span><br><span class="line">&gt;&gt;   <span class="comment">// 右移：</span></span><br><span class="line">&lt;&lt;   <span class="comment">// 左移</span></span><br><span class="line">&gt;&gt;&gt;  <span class="comment">// 右移并且用0填充高位</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">System.out.println(a&lt;&lt;<span class="number">1</span>);  <span class="comment">// 6</span></span><br><span class="line">System.out.println(a&gt;&gt;<span class="number">1</span>);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="3-7、逻辑运算"><a href="#3-7、逻辑运算" class="headerlink" title="3.7、逻辑运算"></a>3.7、逻辑运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;  逻辑短路与  &amp;</span><br><span class="line">||  逻辑短路或  |</span><br><span class="line">!   取反</span><br></pre></td></tr></table></figure><h2 id="4、字符串String类型"><a href="#4、字符串String类型" class="headerlink" title="4、字符串String类型"></a>4、字符串String类型</h2><h3 id="4-1、String类"><a href="#4-1、String类" class="headerlink" title="4.1、String类"></a>4.1、String类</h3><p><strong>概念：</strong></p><ul><li>String属于引用类型</li><li>String是一个<strong>final类</strong>，代表不可变的<strong>字符序列</strong>。</li><li>String对象的字符内容是存储在一个**字符数组value[]**中的，但是不能把字符串和字符数组划上等号，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;   <span class="comment">// String 内部是一个用final定义的char[]数组</span></span><br><span class="line"><span class="comment">// JDK9 之后使用 byte数组</span></span><br></pre></td></tr></table></figure><p><strong>定义：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一，使用字面量</span></span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// 方法二，使用字符串创建</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">// 方法三，使用字符数组创建</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><ul><li>字面量形式创建的字符串是放在<code>字符串常量池</code>的</li><li>new出来的是放在<code>堆</code>中的，在常量池创建一个对象（存在即不用创建），然后引用</li></ul><p><strong>子串：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String s2 = s1.substring(<span class="number">0</span>,<span class="number">3</span>);  <span class="comment">// s2 为 s1的一个子串</span></span><br></pre></td></tr></table></figure><p><strong>拼接：</strong></p><ul><li>两个字符串拼接，只要一个不为字面量，结果就在堆中产生</li><li>拼接结果调用intern()方法，把结果放到常量池中<ul><li>JDK1.8，无论结果失败成功，都返回常量池中的对象</li><li>JDK1.6，只有成功返回常量池的对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s4 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;   <span class="comment">// 字符串常量拼接的原理是编译器优化</span></span><br><span class="line"></span><br><span class="line">String s5 = s1 + <span class="string">&quot;b&quot;</span>;   <span class="comment">// 字符串变量拼接的原理是StringBuilder，返回新对象</span></span><br><span class="line"><span class="comment">// String s5 = new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString();</span></span><br><span class="line"><span class="comment">// 并且这种情况如果在循环体内不断进行，会很浪费资源</span></span><br></pre></td></tr></table></figure><p><strong>不可变的优劣：</strong></p><p><strong>劣：</strong></p><ul><li>由于不可变，所以String每次想要改变时，只能通过定义新的字符串，这样效率低</li></ul><p><strong>优：</strong></p><ul><li>编译器可以让字符串共享（放在字符串常量池中）</li></ul><p>Java开发者认为共享更加高效，大多数情况下字符串都是比较等而很少修改</p><p><strong>空串与Null串：</strong></p><ul><li>空串：长度为0的字符串，””，本质上是一个Java对象，只是没有内容</li><li>Null串：没有和任何对象关联</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str != <span class="keyword">null</span> &amp;&amp; str.length()!=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>码点与代码单元：</strong></p><ul><li>码点：每一个char</li><li>代码单元：每个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;🍺 很牛逼&quot;</span>;</span><br><span class="line"><span class="comment">// 输出char[]数组的长度 6</span></span><br><span class="line">System.out.println(str.length()); </span><br><span class="line"><span class="comment">// 输出实际字符个数 5</span></span><br><span class="line">System.out.println(str.codePointCount(<span class="number">0</span>,str.length()));</span><br><span class="line"><span class="comment">// 输出？，而不是空格 </span></span><br><span class="line">System.out.println(str.charAt(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 输出 57210，转换成int</span></span><br><span class="line">System.out.println(str.codePointAt(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 遍历每一个码点，然后转换回字符串 🍺 很牛逼     </span></span><br><span class="line"><span class="keyword">int</span>[] codes = str.codePoints().toArray();</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(codes,<span class="number">0</span>,codes.length));</span><br></pre></td></tr></table></figure><p>常用API：</p><p><strong>转换成基本类型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = “<span class="number">43</span>”; </span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(a);</span><br></pre></td></tr></table></figure><h3 id="4-2、StringBuilder"><a href="#4-2、StringBuilder" class="headerlink" title="4.2、StringBuilder"></a>4.2、StringBuilder</h3><ul><li>StringBuilder继承了AbstractStringBuilder类</li><li>AbstractStringBuilder类定义了char数组，但是没有指定为final，这意味着可变</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(str.hashCode());</span><br><span class="line">str.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">System.out.println(str.hashCode());</span><br><span class="line"><span class="comment">// 两次的结果一致</span></span><br></pre></td></tr></table></figure><p><strong>常用API：</strong></p><ul><li>创建对象，注意<strong>只能通过new创建</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder()           <span class="comment">// 初始容量16的字符串缓冲区</span></span><br><span class="line">StringBuilder(<span class="keyword">int</span> size)   <span class="comment">// 构造指定容量的字符串缓冲区</span></span><br><span class="line">StringBuilder(String str) <span class="comment">// 将内容初始化为指定字符串内容</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBuilder <span class="title">append</span><span class="params">(xxx)</span>：               <span class="comment">// 字符串拼接</span></span></span><br><span class="line"><span class="function">StringBuilder <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>   <span class="comment">// 删除指定位置的内容</span></span></span><br><span class="line"><span class="function">StringBuilder <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span>   <span class="comment">// 替换</span></span></span><br><span class="line"><span class="function">StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, xxx)</span>     <span class="comment">// 在指定位置插入xxx</span></span></span><br><span class="line"><span class="function">StringBuilder <span class="title">reverse</span><span class="params">()</span>                   <span class="comment">// 把当前字符序列逆转</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>            <span class="comment">// 返回str出现的位置           </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> n)</span>                 <span class="comment">// 获得指定位置的字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch)</span></span></span><br></pre></td></tr></table></figure><h3 id="4-3、StringBuffer"><a href="#4-3、StringBuffer" class="headerlink" title="4.3、StringBuffer"></a>4.3、StringBuffer</h3><ul><li>线程安全</li><li>同样的继承了AbstractStringBuilder类，</li><li>大部分方法使用synchronized修饰</li></ul><blockquote><p>总结</p></blockquote><p>每次对 String 类型进⾏改变的时候，都会⽣成⼀个新的 String 对象，然后将指针指向新的 String</p><p>对象，StringBuffer 每次都会对 StringBuffer 对象本身进⾏操作，⽽不是⽣成新的对象并改变对象</p><p>引⽤。</p><ul><li>操作少量的数据: 适⽤ String</li><li>单线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder</li><li>多线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer</li></ul><h2 id="5、输入与输出"><a href="#5、输入与输出" class="headerlink" title="5、输入与输出"></a>5、输入与输出</h2><h3 id="5-1、输入"><a href="#5-1、输入" class="headerlink" title="5.1、输入"></a>5.1、输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取密码可以通过Console,这样输入不可见。并且一次只能读一行</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">// 获取一行的输入 输入 124 d 读取 124 d</span></span><br><span class="line">String str1 = in.nextLine();</span><br><span class="line">System.out.println(str1);</span><br><span class="line"><span class="comment">// 读取到空格 输入 124 d 读取 124</span></span><br><span class="line">String str2 = in.next();</span><br><span class="line">System.out.println(str2);</span><br><span class="line"><span class="comment">// 判断数据是否还有其他词 true</span></span><br><span class="line">System.out.println(in.hasNext());</span><br><span class="line"><span class="comment">// 直接获取下一个</span></span><br><span class="line">System.out.println(in.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 BufferedReader</span></span><br><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2、输出"><a href="#5-2、输出" class="headerlink" title="5.2、输出"></a>5.2、输出</h3><p><strong>格式化输出</strong>：Java沿用了C语言的printf方法</p><h2 id="6、控制流程"><a href="#6、控制流程" class="headerlink" title="6、控制流程"></a>6、控制流程</h2><h3 id="6-1、块作用域"><a href="#6-1、块作用域" class="headerlink" title="6.1、块作用域"></a>6.1、块作用域</h3><ul><li>块是指由若干条Java语句组成的语句，并且用一对大括号括起来</li><li>块定义了变量的作用域，一个块中（或者是块1中的块2）的变量<strong>不能同名</strong></li></ul><h3 id="6-2、条件语句"><a href="#6-2、条件语句" class="headerlink" title="6.2、条件语句"></a>6.2、条件语句</h3><h3 id="6-3、循环"><a href="#6-3、循环" class="headerlink" title="6.3、循环"></a>6.3、循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while()&#123;</span><br><span class="line"> 程序体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4、确定循环"><a href="#6-4、确定循环" class="headerlink" title="6.4、确定循环"></a>6.4、确定循环</h3><p>for循环等</p><h3 id="6-5、多重选择"><a href="#6-5、多重选择" class="headerlink" title="6.5、多重选择"></a>6.5、多重选择</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> choice = in.nextInt();</span><br><span class="line"><span class="keyword">switch</span> (choice)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Not in&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><ul><li>如果没有break会一直往下执行</li><li>case标签可以是如下（常量）<ul><li>char、byte、short、int的常量表达式</li><li>枚举常量</li><li>字符串<strong>字面量</strong></li></ul></li></ul><h3 id="6-6、中断控制"><a href="#6-6、中断控制" class="headerlink" title="6.6、中断控制"></a>6.6、中断控制</h3><ul><li>break</li><li>continue</li><li>goto（不建议使用）</li></ul><h2 id="7、大数"><a href="#7、大数" class="headerlink" title="7、大数"></a>7、大数</h2><p>有时候，基本的整数和浮点数不能满足需求，可以使用math包里的<strong>BigInteger</strong>和<strong>BigDecimal</strong></p><h3 id="7-1、BigInteger"><a href="#7-1、BigInteger" class="headerlink" title="7.1、BigInteger"></a>7.1、BigInteger</h3><p><strong>获取大数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bigInteger1 = BigInteger.valueOf(<span class="number">100</span>);   <span class="comment">// 通过数值</span></span><br><span class="line">BigInteger bigInteger2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;100&quot;</span>);     <span class="comment">// 通过构造方法</span></span><br></pre></td></tr></table></figure><p><strong>运算：</strong>大数运算并不能和普通的数一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">abs</span><span class="params">()</span>              <span class="comment">// 绝对值的 BigInteger。 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span>       <span class="comment">// this + val </span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span>  <span class="comment">// this - val</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span>  <span class="comment">// this * val</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span>    <span class="comment">// 除，只保留整数</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">BigInteger <span class="title">sqrt</span><span class="params">(BigInteger val)</span>      <span class="comment">// 平方根</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BigInteger</span><span class="params">(BigInteger val)</span>       <span class="comment">// 比较大小</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">BigInteger <span class="title">remainder</span><span class="params">(BigInteger val)</span>            <span class="comment">// 求余</span></span></span><br><span class="line"><span class="function">BigInteger[] <span class="title">divideAndRemainder</span><span class="params">(BigInteger val)</span> <span class="comment">// 返回数组 </span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">pow</span><span class="params">(<span class="keyword">int</span> exponent)</span>    <span class="comment">// 返回其值为 (thisexponent) 的 BigInteger。    </span></span></span><br></pre></td></tr></table></figure><h3 id="7-2、BigDecimal"><a href="#7-2、BigDecimal" class="headerlink" title="7.2、BigDecimal"></a>7.2、BigDecimal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BigDecimal</span><span class="params">(<span class="keyword">double</span> val)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BigDecimal</span><span class="params">(String val)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> val)</span>           <span class="comment">// 根据long获得</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> val,<span class="keyword">int</span> scale)</span> <span class="comment">// 参数依次为3,1  则结果 3.0    </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> val)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 加减乘除    </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">add</span><span class="params">(BigDecimal augend)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">subtract</span><span class="params">(BigDecimal subtrahend)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">multiply</span><span class="params">(BigDecimal multiplicand)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">divide</span><span class="params">(BigDecimal divisor, <span class="keyword">int</span> scale, <span class="keyword">int</span> roundingMode)</span></span></span><br></pre></td></tr></table></figure><h2 id="8、数组"><a href="#8、数组" class="headerlink" title="8、数组"></a>8、数组</h2><h3 id="8-1、概念"><a href="#8-1、概念" class="headerlink" title="8.1、概念"></a>8.1、概念</h3><ol><li>数组(Array)，是多个<strong>相同类型数据</strong>按一定顺序排列 的集合，并使用一个名字命名，并通过<strong>编号的方式管理</strong></li><li>数组本身是引用数据类型，而数组中的元素可以是任何数据类型</li><li>数据占用连续的空间地址，长度一旦确定，就<strong>不能修改</strong></li></ol><h3 id="8-2、创建数组"><a href="#8-2、创建数组" class="headerlink" title="8.2、创建数组"></a>8.2、创建数组</h3><p><strong>声明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[];  <span class="comment">// 注意：声明数组时不能指定其长度</span></span><br><span class="line"><span class="keyword">int</span>[] a;  <span class="comment">// 这两种方式都可以</span></span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><ul><li><p><strong>动态初始化：</strong>初始化完毕再赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; arr[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">String names[];   names = <span class="keyword">new</span> String[<span class="number">3</span>];  names[<span class="number">0</span>] = “钱学森”;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态初始化：</strong>初始化时就赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;  </span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li>Java允许有长度为0的数组，与null不同</li><li>定义并<strong>用运算符new为之分配空间</strong>后，才可以引用数组中的每个元素</li><li>数组是引用类型，<strong>它的元素相当于类的成员变量</strong>，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化，初始化默认值不尽相同。<strong>默认值 基本类型大部分为0，引用类型为null</strong></li></ul><h3 id="8-3、访问数组"><a href="#8-3、访问数组" class="headerlink" title="8.3、访问数组"></a>8.3、访问数组</h3><ul><li>for循环</li><li>for each循环</li><li>Arrays.toString(a) 方法把数组转换成 [1,2,3] 这种形式的字符串</li></ul><h3 id="8-4、数组拷贝"><a href="#8-4、数组拷贝" class="headerlink" title="8.4、数组拷贝"></a>8.4、数组拷贝</h3><ul><li>调用 Arrays.copyOf ，这样新数组与原数组就没有关系了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a = Arrays.copyOf(b,<span class="number">3</span>);  <span class="comment">// 参数2为新数组长度</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">System.out.println(a[<span class="number">0</span>]);</span><br><span class="line">System.out.println(b[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h3 id="8-5、数组排序"><a href="#8-5、数组排序" class="headerlink" title="8.5、数组排序"></a>8.5、数组排序</h3><p>对应数值型的数组，可以使用 Arrays.sort() 进行排序，算法为<strong>优化的快排</strong></p><h3 id="8-6、多维数组"><a href="#8-6、多维数组" class="headerlink" title="8.6、多维数组"></a>8.6、多维数组</h3><ul><li><p>从数组底层的运行机制来看，其实<strong>没有</strong>多维数组。</p></li><li><p>二维数组[][]：数组中的数组</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态初始化：规则数组</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 动态初始化：不规则数组</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>][]; arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-7、Arrays工具类"><a href="#8-7、Arrays工具类" class="headerlink" title="8.7、Arrays工具类"></a>8.7、Arrays工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)</span>   <span class="comment">//  判断相等</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span>          </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> val)</span>        <span class="comment">// 指定值添加到数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span>                <span class="comment">// 排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> key)</span> <span class="comment">// 对排序后的数组进行二分法检索指定的值</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyOf</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> end)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyOf</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"/>
      <url>/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1、发展历史"><a href="#1、发展历史" class="headerlink" title="1、发展历史"></a>1、发展历史</h1><blockquote><p>1、单机MySQL的美好年代</p></blockquote><ul><li><p>在90年代，一个网站的访问量一般不大，用单个数据库完全可以轻松应付！</p></li><li><p>在那个时候，更多的都是静态网页，动态交互类型的网站不多。</p></li></ul><p><strong>当时数据存储的瓶颈：</strong></p><ol><li><p>数据量的总大小，一个机器放不下时</p></li><li><p>数据的索引（B+ Tree）一个机器的内存放不下时</p></li><li><p>访问量（读写混合）一个实例不能承受</p></li></ol><blockquote><p>2、Memcached（缓存）+ MySQL + 垂直拆分</p></blockquote><ul><li>访问量上升，大部分使用MySQL架构的网站在数据库上都出现性能问题</li><li>程序开始追求性能，使用缓存缓解数据库压力，优化数据库的结构和索引，</li><li>开始比较流行的是通过文件缓存，但是多台web机器通过文件缓存不能共享，大量的小文件缓存也带了比较高的IO压力，在这个时候，Memcached就自然的成为一个非常时尚的技术产品。</li></ul><blockquote><p>3、MySQL主从读写分离</p></blockquote><ul><li>Memcached只能缓解数据库的读取压力，读写集中在一个数据库上让数据库不堪重负，</li><li>使用<strong>主从复制技术</strong>来达到读写分离，提高读写性能和读库的可扩展性</li><li>MySQL的master-slave模式成为标配了。</li></ul><blockquote><p>4、分表分库 + 水平拆分 + Mysql 集群</p></blockquote><ul><li>MyISAM使用表锁，高并发下出现严重的锁问题，开始使用InnoDB引擎代替MyISAM。</li><li>流行使用分表分库来缓解写压力和数据增长的扩展问题。</li><li>MySQL推出了还不太稳定的表分区，在高可靠性上提供了非常大的保证。</li></ul><p>MyISAM：表锁，查一个数据，整个表都加锁，高并发下出现问题</p><p>INNODB：行锁</p><blockquote><p>5、MySQL 的扩展性瓶颈</p></blockquote><ul><li>MySQL数据库经常存储一些大文本的字段，使数据库表非常的大，影响速度。</li><li>把这些数据从MySQL省去，MySQL将变的非常的小，速度提升、</li><li>MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。</li></ul><blockquote><p>6、如今</p></blockquote><ul><li>今天我们可以通过第三方平台（如：Google，FaceBook等）可以很容易的访问和抓取数据。</li><li>用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加、</li><li>我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了，而NoSQL数据库的发展却能很好的处理这些大的数据！</li></ul><h1 id="2、NoSQL"><a href="#2、NoSQL" class="headerlink" title="2、NoSQL"></a>2、NoSQL</h1><h2 id="2-1、概念"><a href="#2-1、概念" class="headerlink" title="2.1、概念"></a>2.1、概念</h2><ul><li>NoSQL = Not Only SQL，意思：<strong>不仅仅是SQL；</strong></li><li>不遵循SQL标准</li><li>不支持ACID原则</li><li>性能远超SQL</li></ul><p>关系型：表格，行，列</p><p>非关系型：键值对存储，列存储，文档存储，图形数据库</p><h2 id="2-2、特点"><a href="#2-2、特点" class="headerlink" title="2.2、特点"></a>2.2、特点</h2><ul><li>易扩展，数据之间没有耦合性</li><li>细粒度的缓存，高性能    官方记录：Redis 一秒可以写8万次，读11万次！</li><li>类型多（不需要事先设计数据库，随取随用）</li></ul><p>对比：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">传统关系型数据库RDBMS </span><br><span class="line">- 高度组织化结构化数据 </span><br><span class="line">- 结构化查询语言（SQL） </span><br><span class="line">- 数据和关系都存储在单独的表中 </span><br><span class="line">- 数据操纵语言，数据定义语言 </span><br><span class="line">- 严格的一致性 </span><br><span class="line">- 基础事务 </span><br><span class="line">NoSQL </span><br><span class="line">- 代表着不仅仅是SQL </span><br><span class="line">- 没有声明性查询语言 </span><br><span class="line">- 没有预定义的模式 </span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库 </span><br><span class="line">- 最终一致性，而非ACID属性 </span><br><span class="line">- 非结构化和不可预知的数据 </span><br><span class="line">- CAP定理 （一致性、可用性、分区容忍性最多满足2个）</span><br><span class="line">- 高性能，高可用性 和 可伸缩性</span><br></pre></td></tr></table></figure><h2 id="2-3、拓展"><a href="#2-3、拓展" class="headerlink" title="2.3、拓展"></a>2.3、拓展</h2><p>大数据时代的3V ： 主要是对问题的描述</p><ul><li>海量 Volume</li><li>多样 Variety</li><li>实时 Velocity</li></ul><p>互联网需求的<strong>3高</strong> ： 主要是对程序的要求</p><ul><li>高并发</li><li>高可用</li><li>高性能</li></ul><p>当下的应用是 SQL 和 NoSQL 一起使用，技术没有高低之分，就看怎么用</p><h2 id="2-4、经典应用分析"><a href="#2-4、经典应用分析" class="headerlink" title="2.4、经典应用分析"></a>2.4、经典应用分析</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、商品基本信息</span></span><br><span class="line"><span class="string">名称、价格、出厂日期、生产厂商等</span> </span><br><span class="line"><span class="string">关系型数据库：mysql、oracle</span></span><br><span class="line"><span class="string">注意，淘宝内部用的MySQL是里面的大牛自己改造过的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、商品描述、详情、评价信息（多文字类）</span></span><br><span class="line"><span class="string">多文字信息描述类，IO读写性能变差</span> </span><br><span class="line"><span class="string">-存在文档数据库MongDB中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、商品的图片</span></span><br><span class="line"><span class="string">商品图片展现类</span> </span><br><span class="line"><span class="string">分布式文件系统中</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">淘宝自己的</span> <span class="string">TFS</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Google的</span> <span class="string">GFS</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Hadoop的</span> <span class="string">HDFS</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">阿里云的</span>  <span class="string">OSS</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、商品的关键</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">搜索引擎</span> <span class="string">solr</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">搜索引擎，淘宝内用</span> </span><br><span class="line"><span class="string">ISearch：多隆一高兴一个人开发的</span> <span class="string">所有牛逼的人在牛逼之前,肯定有一段苦逼的岁月,但只要像傻逼一样的坚持,一定终将牛逼</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、商品的波段性的热点高频信息</span></span><br><span class="line"><span class="string">内存数据库</span> </span><br><span class="line"><span class="string">Tair、Redis、Memcache等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、商品的交易，价格计算，积分累计！</span></span><br><span class="line"><span class="string">外部系统，外部第三方支付接口</span> <span class="string">支付宝</span></span><br></pre></td></tr></table></figure><p>大型互联网应用问题：</p><ul><li>数据类型的多样性</li><li>数据源多样性和变化重构</li><li>数据源改造而数据服务平台不需要大面积重构</li></ul><p>解决办法：</p><ul><li>统一数据服务层（加一层）</li></ul><h2 id="2-5、NoSQL数据模型简介"><a href="#2-5、NoSQL数据模型简介" class="headerlink" title="2.5、NoSQL数据模型简介"></a>2.5、NoSQL数据模型简介</h2><h5 id="1、KV键值对"><a href="#1、KV键值对" class="headerlink" title="1、KV键值对"></a>1、KV键值对</h5><ul><li>新浪：BerkeleyDB+redis</li><li>美团：redis+tair</li><li>阿里、百度：memcache+redis</li></ul><h5 id="2、文档型数据库（Bson比较多）"><a href="#2、文档型数据库（Bson比较多）" class="headerlink" title="2、文档型数据库（Bson比较多）"></a>2、文档型数据库（Bson比较多）</h5><ul><li>CouchDB</li><li>MongoDB<ul><li>MongoDB 是一个<strong>基于分布式文件存储的数据库</strong>。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</li><li>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</li></ul></li></ul><h5 id="3、列存储数据库："><a href="#3、列存储数据库：" class="headerlink" title="3、列存储数据库："></a>3、列存储数据库：</h5><ul><li>Cassandra, HBase</li><li>分布式文件系统</li></ul><p><strong>4、图关系数据库</strong></p><ul><li>它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统</li><li>社交网络，推荐系统等。专注于构建关系图谱</li><li>Neo4J, InfoGrid</li></ul><h2 id="2-6、CAP-BASE"><a href="#2-6、CAP-BASE" class="headerlink" title="2.6、CAP + BASE"></a>2.6、CAP + BASE</h2><blockquote><p>ACID</p></blockquote><ul><li>A：原子性</li><li>C：一致性</li><li>I：隔离性</li><li>D：持久性</li></ul><blockquote><p>CAP（分布式系统中）</p></blockquote><ul><li>C : Consistency（强一致性，在分布式系统中的所有数据备份，在同一时刻值是否相等）</li><li>A : Availability（可用性，部分节点故障后，集群整体是否还能响应请求）</li><li>P : Partition tolerance（分区容错性，分区数量越多，容错性越大，但是一致性降低）</li></ul><p><strong>在分布式系统中，最多实现其中的2个</strong>：分区数量越多，分区容错性越大，但是会降低数据的一致性，为了保持一致性，就需要花更多时间去等待数据同步，可用性就降低了。</p><p> <strong>所以NoSQL 数据库分成了满足 CA 原则、满足 CP原则和满足 AP 原则三 大类：</strong></p><ul><li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li><li>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</li><li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li></ul><p><strong>大多数web应用，其实并不需要强一致性，牺牲C换取P是分布式数据库产品主流</strong></p><blockquote><p>Base理论</p></blockquote><ul><li>无法实现强一致性，就结合业务特点等达到最终一致性。</li></ul><p><strong>概念</strong></p><ul><li>基本可用(Basically Available)： 允许损失部分可用性，保证核心可用。如电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。</li><li>软状态(Soft State)： 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状的体现。MySQL Replication 的异步复制也是一种体现</li><li>最终一致性(Eventual Consistency)： 最终一致性是指系统中的所有数据最终达到一致的状态，最终一致性是<strong>弱一致性的一种特殊情况</strong>。</li></ul><p><strong>思想</strong></p><ul><li>通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观</li></ul><h1 id="3、Redis简介"><a href="#3、Redis简介" class="headerlink" title="3、Redis简介"></a>3、Redis简介</h1><h2 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h2><blockquote><p>Redis是什么</p></blockquote><p>Redis：<code>RE</code>mote <code>DI</code>ctionary <code>S</code>erver（远程字典服务器）</p><p>是完全开源免费的，用<strong>C语言编写</strong>的，遵守BSD协议，是一个高性能<strong>分布式内存数据库</strong>，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为数据结构服务器</p><blockquote><p>相对于其他key-value缓存产品</p></blockquote><ul><li>Redis<strong>支持持久化</strong>，可以将数据存在磁盘中，重启的时候可以再次加载使用。</li><li>Redis不仅仅支持简单的 key-value 类型的数据，<strong>还支持list、set、zset、hash等数据结构</strong>的存储。</li><li>Redis支持数据的备份，即<strong>master-slave模式的数据备份</strong>。</li></ul><blockquote><p>特性</p></blockquote><ul><li>数据类型、基本操作和配置</li><li>持久化和复制，RDB、AOF</li><li>事务的控制，但是不支持ACID原则</li><li>集群</li><li>做分布式锁，甚⾄是消息队列</li></ul><h2 id="3-2、linux安装"><a href="#3-2、linux安装" class="headerlink" title="3.2、linux安装"></a>3.2、linux安装</h2><p>宝塔面板傻瓜式安装</p><p><strong>daemonize设置yes或者no区别</strong></p><ul><li><p>yes（宝塔默认）</p><p>redis采用的是<strong>单线程+多路IO复用</strong>的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfifile设置的文件中，此时redis将一直运行，除非手动kill该进程。</p></li><li><p>no（linux命令安装默认）</p><p>当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。</p></li></ul><p><strong>测试</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-cli -p 6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ping</span> </span><br><span class="line"><span class="string">PONG</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">helloworld</span> </span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k1</span> </span><br><span class="line"><span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">del</span> <span class="string">k1</span> </span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-cli -p 6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">shutdown</span></span><br><span class="line"><span class="string">not</span> <span class="string">connected&gt;</span> <span class="string">exit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示系统当前进程信息</span></span><br><span class="line"><span class="comment"># ps -ef|grep redis</span></span><br></pre></td></tr></table></figure><ul><li>6739为默认端口号</li></ul><p>6379在是手机按键上MERZ对应的号码，而MERZ取自意大利歌女<a href="http://it.wikipedia.org/wiki/Alessia_Merz">Alessia Merz</a>的名字。MERZ长期以来被antirez及其朋友当作愚蠢的代名词</p><h2 id="3-3、选择数据库"><a href="#3-3、选择数据库" class="headerlink" title="3.3、选择数据库"></a>3.3、选择数据库</h2><p>默认16个数据库，类似数组下标从零开始，初始默认使用零号库</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换数据库</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">select</span> <span class="number">0</span></span><br><span class="line"><span class="string">Ok</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379[7]&gt;</span> <span class="string">DBSIZE</span> </span><br><span class="line"><span class="string">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># 清空当前库 </span></span><br><span class="line"><span class="comment"># Flushall：清空全部的库</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">FLUSHDB</span> </span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">DBSIZE</span> </span><br><span class="line"><span class="string">(integer)</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="4、五大数据类型"><a href="#4、五大数据类型" class="headerlink" title="4、五大数据类型"></a>4、五大数据类型</h1><h2 id="4-1、简介"><a href="#4-1、简介" class="headerlink" title="4.1、简介"></a>4.1、简介</h2><blockquote><p>String （字符串类型）</p></blockquote><p><strong>结构：</strong>一个key对应一个value，即单键单值</p><p><strong>底层：</strong>为简单动态字符串（与C语言不同），可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用<code>预分配冗余空间</code>的方式来减少内存的频繁分配，最大512M。</p><p><strong>特点：</strong>可以存二进制字符串（意味着可以存任何数据），同时线程安全。</p><p><strong>应用：</strong>需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">value</span>    <span class="comment"># 设置值    mset 批量操作         </span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span>          <span class="comment"># 获得key   mget 批量操作           </span></span><br><span class="line"><span class="string">del</span> <span class="string">key</span>          <span class="comment"># 删除key       </span></span><br><span class="line"></span><br><span class="line"><span class="string">exists</span> <span class="string">key</span>       <span class="comment"># 判断 key 是否存在</span></span><br><span class="line"><span class="string">strlen</span> <span class="string">key</span>       <span class="comment"># 返回 key 所储存的字符串值的⻓度。</span></span><br><span class="line"></span><br><span class="line"><span class="string">incr</span> <span class="string">views</span>       <span class="comment"># 数字形式的值加1,incrby views 10</span></span><br><span class="line"><span class="string">decr</span> <span class="string">views</span>       <span class="comment">#  - 1          decrby views 10 </span></span><br><span class="line"></span><br><span class="line"><span class="string">setex</span> <span class="string">key</span> <span class="number">10</span> <span class="string">value</span>     <span class="comment"># 原子设置过期时间 或者设置键值对后再 expire key 10</span></span><br><span class="line"><span class="string">ttl</span> <span class="string">key</span>                <span class="comment"># 查看剩余的时间，-1 表示永不过期，-2 表示已过期</span></span><br></pre></td></tr></table></figure><blockquote><p>List（列表）</p></blockquote><p><strong>结构：</strong>一个key对应多个value，即单键多值</p><p><strong>底层：</strong>字符串双向链表，使用一块连续内存；元素少为<strong>ZipList</strong>，多为快速链表quickList</p><p><strong>特点：</strong>可以在两端操作，因此可以作为栈和队列（如消息队列）</p><p><strong>应用：</strong>发布与订阅或者说消息队列、慢查询。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Lpush/Rpush</span> <span class="string">list</span> <span class="string">&quot;one&quot;</span><span class="comment"># 将一个或多个值插入到列表头部（左）/尾部(右)</span></span><br><span class="line"><span class="string">Lpop/Rpop</span> <span class="string">list</span>          <span class="comment"># 返回并移除第一个元素。</span></span><br><span class="line"><span class="string">lset</span> <span class="string">list</span> <span class="number">1</span> <span class="string">&quot;world&quot;</span>    <span class="comment"># 更改list位置1的值</span></span><br><span class="line"><span class="string">Lrange</span> <span class="string">list</span> <span class="number">0</span> <span class="number">-1</span>        <span class="comment"># 返回指定区间内的元素，0表示第一个元素，-1表示最后一个</span></span><br><span class="line"><span class="string">Lindex</span> <span class="string">list</span> <span class="number">1</span>           <span class="comment"># 按照索引下标获得元素</span></span><br><span class="line"><span class="string">llen</span> <span class="string">list</span>               <span class="comment"># 长度</span></span><br></pre></td></tr></table></figure><blockquote><p>Hash（哈希，类似 Java里的Map）</p></blockquote><p><strong>结构：</strong>一个key对应多个 内部key，一个内部key对应一个值</p><p><strong>底层：</strong>String类型的field和value的映射表，类似Java里面的Map&lt;String,Object&gt;</p><p><strong>应用：</strong>hash特别适合用于存储对象。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hset</span> <span class="string">myhash</span> <span class="string">key1</span> <span class="string">&quot;wzh&quot;</span>   <span class="comment"># 设置myhash的键值对为key1和&quot;wzh&quot;</span></span><br><span class="line"><span class="string">hget</span> <span class="string">myhash</span> <span class="string">key1</span>         <span class="comment"># 获得myhash的key1的值</span></span><br><span class="line"><span class="string">hdel</span> <span class="string">myhash</span> <span class="string">field1</span>       <span class="comment"># 删除键</span></span><br><span class="line"><span class="string">hexists</span> <span class="string">myhash</span> <span class="string">field1</span>    <span class="comment"># 是否存在</span></span><br></pre></td></tr></table></figure><blockquote><p>Set（集合）</p></blockquote><p><strong>结构：</strong>一个 key 对应一个 value</p><p><strong>底层：</strong>value为null的hash表，</p><p><strong>特点：</strong>无序、不允许重复，添加，删除，查找的复杂度都是O(1)，可以集合关系</p><p><strong>应用：</strong>交集、并集、差集非常方便的实现如共同关注、共同喜好、二度好友等功能，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sadd</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span>          <span class="comment"># 将一个或多个成员元素加入</span></span><br><span class="line"><span class="string">sismember</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span>     <span class="comment"># 判断是否在集合里面</span></span><br><span class="line"><span class="string">srem</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span> <span class="string">&quot;xuexi&quot;</span><span class="comment"># 移除集合中的一个或多个成员</span></span><br><span class="line"><span class="string">SDIFF</span> <span class="string">key1</span> <span class="string">key2</span>    <span class="comment"># 差集 </span></span><br><span class="line"><span class="string">SINTER</span> <span class="string">key1</span> <span class="string">key2</span>   <span class="comment"># 交集 </span></span><br><span class="line"><span class="string">SUNION</span> <span class="string">key1</span> <span class="string">key2</span>   <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure><blockquote><p>Zset（sorted set：有序集合）</p></blockquote><p><strong>结构：</strong>一个 key 对应一个 value，同时每个key 关联一个 double类型的分数</p><p><strong>底层：</strong>value为null的hash表，跳跃表（排序）</p><p><strong>特点：</strong></p><ol><li>与Set基本相同；不同之处 set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2</li><li>会根据 double 类型的分数 自动排序。</li></ol><p><strong>应用：</strong>带权重的队列、排行榜取 Top、礼物、用户按权重排名</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zadd</span> <span class="string">salary</span> <span class="number">1</span> <span class="string">&quot;one&quot;</span><span class="comment"># 加入1个或者多个</span></span><br><span class="line"><span class="string">zrem</span> <span class="string">salaryt</span> <span class="string">&quot;one&quot;</span>    <span class="comment"># zrem 删除集合成员</span></span><br><span class="line"></span><br><span class="line"><span class="string">zcard</span> <span class="string">myZset</span>            <span class="comment"># 查看 sorted set 中的元素数量</span></span><br><span class="line"><span class="string">zscore</span> <span class="string">myZset</span> <span class="string">value1</span>    <span class="comment"># 查看某个 value 的权重</span></span><br><span class="line"></span><br><span class="line"><span class="string">zrange</span> <span class="string">salary</span> <span class="number">0</span> <span class="number">-1</span><span class="comment"># 顺序返回指定区间的成员</span></span><br><span class="line"><span class="string">zrevrange</span> <span class="string">myZset</span> <span class="number">0</span> <span class="number">1</span>    <span class="comment"># 逆序输出某个范围区间的元素，0 为 start 1</span></span><br></pre></td></tr></table></figure><h2 id="4-2、Redis的键"><a href="#4-2、Redis的键" class="headerlink" title="4.2、Redis的键"></a>4.2、Redis的键</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">redis-cli</span> <span class="string">-p</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="string">keys</span> <span class="string">*</span> <span class="comment"># 查看所有的key </span></span><br><span class="line"><span class="string">EXISTS</span> <span class="string">name</span>  <span class="comment"># 判断是否存在键name</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">name</span> <span class="string">wzh</span>    <span class="comment"># 设置键值对</span></span><br><span class="line"><span class="string">move</span> <span class="string">name</span> <span class="number">1</span> <span class="comment"># move key db ---&gt; 移动到其他库</span></span><br><span class="line"><span class="string">del</span> <span class="string">name</span> <span class="comment"># 删除键</span></span><br><span class="line"><span class="string">unlink</span> <span class="string">key</span>   <span class="comment"># 根据value选择非阻塞删除仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">name</span> <span class="string">wzh</span>       <span class="comment"># 设置键 name 值为 wzh</span></span><br><span class="line"><span class="string">EXPIRE</span> <span class="string">name</span> <span class="number">10</span>     <span class="comment"># 给key 设置生存时间，过期时被自动删除。</span></span><br><span class="line"><span class="string">persist</span> <span class="string">key</span>        <span class="comment"># 移除过期时间</span></span><br><span class="line"><span class="string">ttl</span> <span class="string">name</span>           <span class="comment"># 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type key 查看你的key是什么类型 </span></span><br><span class="line"><span class="string">type</span> <span class="string">name</span> </span><br></pre></td></tr></table></figure><h2 id="4-3、字符串String"><a href="#4-3、字符串String" class="headerlink" title="4.3、字符串String"></a>4.3、字符串String</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本操作</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">-p</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">value</span>    <span class="comment"># 设置值             OK</span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span>          <span class="comment"># 获得key            &quot;value1&quot; </span></span><br><span class="line"><span class="string">del</span> <span class="string">key</span>          <span class="comment"># 删除key            (integer) 1 </span></span><br><span class="line"><span class="string">keys</span> <span class="string">*</span>           <span class="comment"># 查看全部的key       (empty list or set) </span></span><br><span class="line"><span class="string">exists</span> <span class="string">key</span>       <span class="comment"># 判断 key 是否存在   (integer) 0 </span></span><br><span class="line"></span><br><span class="line"><span class="string">append</span> <span class="string">key</span> <span class="string">&quot;hello&quot;</span>    <span class="comment"># 若对不存在的 key 进行 APPEND ，等同于 SET  </span></span><br><span class="line"><span class="string">append</span> <span class="string">key</span> <span class="string">&quot;-2333&quot;</span>    <span class="comment"># 对已存在的字符串进行 APPEND，等于增加内容</span></span><br><span class="line"><span class="string">strlen</span> <span class="string">key</span>        <span class="comment"># 获取字符串的长度   </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数字进行加减操作一定要是数字</span></span><br><span class="line"><span class="string">set</span> <span class="string">views</span> <span class="number">0</span>       <span class="comment"># 设置为0     OK</span></span><br><span class="line"><span class="string">incr</span> <span class="string">views</span>        <span class="comment">#  + 1    (integer) 1 </span></span><br><span class="line"><span class="string">decr</span> <span class="string">views</span>        <span class="comment">#  - 1    (integer) 0 </span></span><br><span class="line"><span class="string">incrby</span> <span class="string">views</span> <span class="number">10</span>   <span class="comment"># +10     (integer) 10 </span></span><br><span class="line"><span class="string">decrby</span> <span class="string">views</span> <span class="number">10</span>   <span class="comment"># -10     (integer) 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范围:getrange 获取指定区间范围内的值</span></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">abcd123456</span>  <span class="comment"># 设置key2的值 </span></span><br><span class="line"><span class="string">getrange</span> <span class="string">key</span> <span class="number">0</span> <span class="number">-1</span>   <span class="comment"># 获得全部的值           &quot;abcd123456&quot;</span></span><br><span class="line"><span class="string">getrange</span> <span class="string">key</span> <span class="number">0</span> <span class="number">2</span>    <span class="comment"># 截取部分字符串 &quot;abc&quot;    &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setrange 从指定位置开始替换值</span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span>             <span class="comment">#         &quot;abcd123456&quot;</span></span><br><span class="line"><span class="string">SETRANGE</span> <span class="string">key</span> <span class="number">1</span> <span class="string">xx</span>   <span class="comment"># 替换值   (integer) 10 </span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span>             <span class="comment">#         &quot;axxd123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置过期时间</span></span><br><span class="line"><span class="string">setex</span> <span class="string">key</span> <span class="number">10</span> <span class="string">value</span>     <span class="comment"># 原子设置过期时间 或者设置键值对后再 expire key 10</span></span><br><span class="line"><span class="string">ttl</span> <span class="string">key</span>                <span class="comment"># 查看剩余的时间，-1 表示永不过期，-2 表示已过期</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件设置</span></span><br><span class="line"><span class="string">setnx</span> <span class="string">mykey</span> <span class="string">&quot;redis&quot;</span>   <span class="comment"># 如果不存在就设置，成功返回1    </span></span><br><span class="line"><span class="string">setex</span> <span class="string">mykey</span> <span class="string">&quot;mongodb&quot;</span>  <span class="comment"># 如果存在就设置，失败返回0       </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量操作</span></span><br><span class="line"><span class="string">mset</span> <span class="string">k10</span> <span class="string">v10</span> <span class="string">k11</span> <span class="string">v11</span> <span class="string">k12</span> <span class="string">v12</span> <span class="comment"># 创建多个键值对</span></span><br><span class="line"><span class="string">mget</span> <span class="string">k10</span> <span class="string">k11</span> <span class="string">k12</span> <span class="string">k13</span>         <span class="comment"># 获得多个键的值</span></span><br><span class="line"><span class="string">msetnx</span> <span class="string">k10</span> <span class="string">v10</span> <span class="string">k15</span> <span class="string">v15</span>       <span class="comment"># 原子操作，都成功返回1，否则都失败，返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统缓存对象(不是真正的缓存对象)</span></span><br><span class="line"><span class="string">mset</span> <span class="string">user:1:name</span> <span class="string">zhangsan</span> <span class="string">user:1:age</span> <span class="number">2</span> </span><br><span class="line"><span class="string">mget</span> <span class="string">user:1:name</span> <span class="string">user:1:age</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># getset（先get再set）</span></span><br><span class="line"><span class="string">getset</span> <span class="string">db</span> <span class="string">mongodb</span></span><br></pre></td></tr></table></figure><h2 id="4-4、列表List"><a href="#4-4、列表List" class="headerlink" title="4.4、列表List"></a>4.4、列表List</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">LPUSH</span> <span class="string">list</span> <span class="string">&quot;one&quot;</span><span class="comment"># 将一个或多个值插入到列表头部。（左）</span></span><br><span class="line"><span class="string">LPUSH</span> <span class="string">list</span> <span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="string">RPUSH</span> <span class="string">list</span> <span class="string">&quot;right&quot;</span><span class="comment"># rpush：将一个或多个值插入到列表尾部。（右）</span></span><br><span class="line"><span class="comment"># lrange：返回指定区间内的元素，0表示第一个元素，-1表示最后一个元素</span></span><br><span class="line"><span class="string">Lrange</span> <span class="string">list</span> <span class="number">0</span> <span class="number">-1</span>     <span class="comment">#  1) &quot;two&quot;、2) &quot;one&quot;、3) &quot;right&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">Lpop</span> <span class="string">list</span>          <span class="comment"># 返回并移除第一个元素。不存在时，返回 nil 。 </span></span><br><span class="line"><span class="string">Rpop</span> <span class="string">list</span>          <span class="comment"># 最后一个元素 </span></span><br><span class="line"></span><br><span class="line"><span class="string">Lindex</span> <span class="string">list</span> <span class="number">1</span>      <span class="comment"># 按照索引下标获得元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">Llen</span> <span class="string">list</span>          <span class="comment"># 返回列表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="string">lrem</span> <span class="string">list</span> <span class="number">1</span> <span class="string">&quot;two&quot;</span>  <span class="comment"># 移除列表里的two元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">ltrim</span> <span class="string">mylist</span> <span class="number">1</span> <span class="number">2</span><span class="comment"># 保留指定区间内的元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">rpoplpush</span> <span class="string">list</span> <span class="string">mylist</span>   <span class="comment"># 把list最后一个移到mylist里面</span></span><br><span class="line"></span><br><span class="line"><span class="string">lset</span> <span class="string">list</span> <span class="number">1</span> <span class="string">&quot;world&quot;</span><span class="comment"># 更改list的值</span></span><br><span class="line"></span><br><span class="line"><span class="string">linsert</span> <span class="string">list</span> <span class="string">before</span> <span class="string">&quot;world&quot;</span> <span class="string">&quot;hello&quot;</span>   <span class="comment"># hello 插到world前面</span></span><br></pre></td></tr></table></figure><h2 id="4-5、哈希Hash"><a href="#4-5、哈希Hash" class="headerlink" title="4.5、哈希Hash"></a>4.5、哈希Hash</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hset</span> <span class="string">myhash</span> <span class="string">key1</span> <span class="string">&quot;wzh&quot;</span>  <span class="comment"># 设置myhash的键值对为key1和&quot;wzh&quot;</span></span><br><span class="line"><span class="string">hget</span> <span class="string">myhash</span> <span class="string">key1</span>        <span class="comment"># 获得myhash的key1的值</span></span><br><span class="line"><span class="string">HMSET</span> <span class="string">myhash</span> <span class="string">field1</span> <span class="string">&quot;Hello&quot;</span> <span class="string">field2</span> <span class="string">&quot;World&quot;</span>  <span class="comment"># 设置多个</span></span><br><span class="line"><span class="string">hgetall</span> <span class="string">myhash</span>          <span class="comment"># 展示所有值，格式为键一行，值在键下一行</span></span><br><span class="line"><span class="string">hdel</span> <span class="string">myhash</span> <span class="string">field1</span>      <span class="comment"># 删除键</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">hlen</span> <span class="string">myhash</span><span class="comment"># hlen 获取哈希表长度</span></span><br><span class="line"><span class="string">hexists</span> <span class="string">myhash</span> <span class="string">field1</span>    <span class="comment"># 是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="string">hkeys</span> <span class="string">myhash</span> <span class="comment"># 获得所有域（field），键</span></span><br><span class="line"><span class="string">hvals</span> <span class="string">myhash</span><span class="comment"># 获得所有域（field）的值</span></span><br><span class="line"></span><br><span class="line"><span class="string">hincrby</span> <span class="string">myhash</span> <span class="string">nums</span> <span class="number">1</span>   <span class="comment"># myhash表的nums的值增1</span></span><br><span class="line"></span><br><span class="line"><span class="string">hsetnx</span> <span class="string">myhash</span> <span class="string">happy</span> <span class="string">&quot;hello&quot;</span> <span class="comment"># 未不存在的字段复制，存在返回0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-6、集合Set"><a href="#4-6、集合Set" class="headerlink" title="4.6、集合Set"></a>4.6、集合Set</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sadd</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span>   <span class="comment"># 将一个或多个成员元素加入</span></span><br><span class="line"><span class="string">SMEMBERS</span> <span class="string">myset</span> <span class="comment"># 返回集合中的所有的成员。</span></span><br><span class="line"><span class="string">SISMEMBER</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span> <span class="comment"># 判断是否在集合里面</span></span><br><span class="line"></span><br><span class="line"><span class="string">scard</span> <span class="string">myset</span><span class="comment"># scard，获取集合里面的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="string">srem</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span> <span class="string">&quot;xuexi&quot;</span><span class="comment"># 移除集合中的一个或多个成员</span></span><br><span class="line"></span><br><span class="line"><span class="string">srandmember</span> <span class="string">myset</span> <span class="number">2</span>  <span class="comment"># 返回2个随机元素</span></span><br><span class="line"><span class="string">spop</span> <span class="string">myset</span> <span class="number">2</span> <span class="comment"># 移除2个随机元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">smove</span> <span class="string">myset</span> <span class="string">set</span> <span class="string">&quot;hello&quot;</span> <span class="comment"># hello移到set集合李阿敏里面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合</span></span><br><span class="line"><span class="string">SDIFF</span> <span class="string">key1</span> <span class="string">key2</span>    <span class="comment"># 差集 </span></span><br><span class="line"><span class="string">SINTER</span> <span class="string">key1</span> <span class="string">key2</span>   <span class="comment"># 交集 </span></span><br><span class="line"><span class="string">SUNION</span> <span class="string">key1</span> <span class="string">key2</span>   <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure><h2 id="4-7、有序集合Zset"><a href="#4-7、有序集合Zset" class="headerlink" title="4.7、有序集合Zset"></a>4.7、有序集合Zset</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zadd</span> <span class="string">salary</span> <span class="number">1</span> <span class="string">&quot;one&quot;</span><span class="comment"># 加入1个或者多个</span></span><br><span class="line"><span class="string">zadd</span> <span class="string">salary</span> <span class="number">2</span> <span class="string">&quot;two&quot;</span> <span class="number">3</span> <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="string">zrange</span> <span class="string">salary</span> <span class="number">0</span> <span class="number">-1</span><span class="comment"># 返回指定区间的成员</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">zrangebyscore</span> <span class="string">salary</span> <span class="string">-inf</span> <span class="string">+inf</span>     <span class="comment"># 从负无穷大到正无穷大，递增显示</span></span><br><span class="line"><span class="string">zrevrange</span> <span class="string">salary</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span>   <span class="comment"># 递减排列   </span></span><br><span class="line"><span class="string">zrangebyscore</span> <span class="string">salary</span> <span class="string">-inf</span> <span class="number">2500 </span><span class="string">WITHSCORES</span>     <span class="comment"># 工资小于2500,递增</span></span><br><span class="line"></span><br><span class="line"><span class="string">zrem</span> <span class="string">salaryt</span> <span class="string">&quot;one&quot;</span><span class="comment"># zrem 删除集合成员</span></span><br><span class="line"></span><br><span class="line"><span class="string">zcard</span> <span class="string">salary</span><span class="comment"># 返回长度</span></span><br><span class="line"><span class="string">zcount</span> <span class="string">salary</span> <span class="number">10</span> <span class="number">3000</span><span class="comment"># 返回指定区间成员数量。</span></span><br><span class="line"></span><br><span class="line"><span class="string">zrank</span> <span class="string">salary</span> <span class="string">wzh</span>  <span class="comment"># 从0开始，由小到大，显示排名，即第几个</span></span><br><span class="line"><span class="string">zrevrank</span> <span class="string">salary</span> <span class="string">zk</span> <span class="comment"># 即倒数第几个</span></span><br></pre></td></tr></table></figure><h1 id="5、三种特殊数据类型"><a href="#5、三种特殊数据类型" class="headerlink" title="5、三种特殊数据类型"></a>5、三种特殊数据类型</h1><h2 id="5-1、GEO地理位置"><a href="#5-1、GEO地理位置" class="headerlink" title="5.1、GEO地理位置"></a>5.1、GEO地理位置</h2><p>Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。</p><p><strong>geo的数据类型为zset。</strong></p><p>GEO 共有六个常用命令：geoadd、geopos、geodist、georadius、georadiusbymember、gethash</p><blockquote><p>geoadd：设置地点</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">geoadd</span> <span class="string">key</span> <span class="string">longitude</span> <span class="string">latitude</span> <span class="string">member</span></span><br><span class="line"><span class="string">geoadd</span> <span class="string">china:city</span> <span class="number">116.23</span> <span class="number">40.22</span> <span class="string">北京</span></span><br><span class="line"><span class="string">geoadd</span> <span class="string">china:city</span> <span class="number">121.48</span> <span class="number">31.40</span> <span class="string">上海</span> <span class="number">113.88</span> <span class="number">22.55</span> <span class="string">深圳</span> <span class="number">120.21</span> <span class="number">30.20</span> <span class="string">杭州</span></span><br><span class="line"><span class="comment"># 将给定的空间元素(纬度、经度、名字)添加到指定的键里面。 </span></span><br><span class="line"><span class="comment"># 这些数据会以有序集he的形式被储存在键里面，从而使得georadius和georadiusbymember这样的 命令可以在之后通过位置查询取得这些元素。 </span></span><br><span class="line"><span class="comment"># geoadd命令以标准的x,y格式接受参数,所以用户必须先输入经度,然后再输入纬度。 </span></span><br><span class="line"><span class="comment"># geoadd能够记录的坐标是有限的:非常接近两极的区域无法被索引。 </span></span><br><span class="line"><span class="comment"># 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间。， 当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。</span></span><br></pre></td></tr></table></figure><blockquote><p>geopos：查找经纬度</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">geopos</span> <span class="string">key</span> <span class="string">member</span> [<span class="string">member...</span>]</span><br><span class="line"><span class="comment">#从key里返回所有给定位置元素的位置（经度和纬度）</span></span><br><span class="line"><span class="string">geopos</span> <span class="string">china:city</span> <span class="string">北京</span></span><br></pre></td></tr></table></figure><blockquote><p>geodist：查找城市间距离</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法 </span></span><br><span class="line"><span class="string">geodist</span> <span class="string">key</span> <span class="string">member1</span> <span class="string">member2</span> [<span class="string">unit</span>]</span><br><span class="line"><span class="string">geodist</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="string">上海</span></span><br><span class="line"><span class="string">geodist</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="string">上海</span> <span class="string">km</span></span><br><span class="line"><span class="comment"># 返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在,那么命令返回空值。</span></span><br><span class="line"><span class="comment"># 指定单位的参数unit必须是以下单位的其中一个： </span></span><br><span class="line"><span class="comment"># m表示单位为米 # km表示单位为千米 # mi表示单位为英里 # ft表示单位为英尺 </span></span><br><span class="line"><span class="comment"># 如果用户没有显式地指定单位参数,那么geodist默认使用米作为单位。 </span></span><br><span class="line"><span class="comment">#geodist命令在计算距离时会假设地球为完美的球形,在极限情况下,这一假设最大会造成0.5%的误 差。</span></span><br></pre></td></tr></table></figure><blockquote><p>georadius：以一点为中心查找附近城市</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">georadius</span> <span class="string">key</span> <span class="string">longitude</span> <span class="string">latitude</span> <span class="string">radius</span> <span class="string">m|km|ft|mi</span> [<span class="string">withcoord</span>][<span class="string">withdist</span>] [<span class="string">withhash</span>][<span class="string">asc|desc</span>][<span class="string">count</span> <span class="string">count</span>]</span><br><span class="line"><span class="comment"># 以给定的经纬度为中心， 找出某一半径内的元素</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cli --raw -p 6379  # 强制输出中文，不然乱码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市</span></span><br><span class="line"><span class="string">georadius</span> <span class="string">china:city</span> <span class="number">100</span> <span class="number">30</span> <span class="number">1000 </span><span class="string">km</span></span><br><span class="line"><span class="comment"># withdist 返回位置名称和中心距离</span></span><br><span class="line"><span class="string">georadius</span> <span class="string">china:city</span> <span class="number">100</span> <span class="number">30</span> <span class="number">1000 </span><span class="string">km</span> <span class="string">withdist</span></span><br><span class="line"><span class="comment"># withcoord 返回位置名称和经纬度 </span></span><br><span class="line"><span class="string">georadius</span> <span class="string">china:city</span> <span class="number">100</span> <span class="number">30</span> <span class="number">1000 </span><span class="string">km</span> <span class="string">withcoord</span></span><br><span class="line"><span class="comment"># withdist withcoord 返回位置名称 距离 和经纬度 count 限定寻找个数 </span></span><br><span class="line"><span class="string">georadius</span> <span class="string">china:city</span> <span class="number">100</span> <span class="number">30</span> <span class="number">1000 </span><span class="string">km</span> <span class="string">withcoord</span> <span class="string">withdist</span> <span class="string">count</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>georadiusbymember：以城市为中心查找附近城市</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法 </span></span><br><span class="line"><span class="string">georadiusbymember</span> <span class="string">key</span> <span class="string">member</span> <span class="string">radius</span> <span class="string">m|km|ft|mi</span> [<span class="string">withcoord</span>][<span class="string">withdist</span>] [<span class="string">withhash</span>][<span class="string">asc|desc</span>][<span class="string">count</span> <span class="string">count</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">GEORADIUSBYMEMBER</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="number">1000 </span><span class="string">km</span></span><br></pre></td></tr></table></figure><blockquote><p>geohash：经纬度转换为字符串</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法 </span></span><br><span class="line"><span class="string">geohash</span> <span class="string">key</span> <span class="string">member</span> [<span class="string">member...</span>] </span><br><span class="line"><span class="comment"># Redis使用geohash将二维经纬度转换为一维字符串，</span></span><br><span class="line"><span class="comment">#字符串越长表示位置更精确,两个字符串越相似 表示距离越近。</span></span><br><span class="line"></span><br><span class="line"><span class="string">geohash</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="string">重庆</span></span><br></pre></td></tr></table></figure><blockquote><p>zrem：删除</p></blockquote><p>GEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zrem</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="comment"># 移除元素</span></span><br></pre></td></tr></table></figure><h2 id="5-2、HyperLogLog"><a href="#5-2、HyperLogLog" class="headerlink" title="5.2、HyperLogLog"></a>5.2、HyperLogLog</h2><ul><li>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</li><li>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li><li>HyperLogLog则是一种算法，它提供了不精确的去重计数方案。</li><li>假如我要统计网页的UV（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的解决方案是使用Set来保存用户id，然后统计Set中的元素数量来获取页面UV。但这种方案只能承载少量用户，一旦用户数量大起来就需要消耗大量的空间来存储用户id。我的目的是统计用户数量而不是保存用户，这简直是个吃力不讨好的方案！而使用Redis的HyperLogLog最多需要12k就可以统计大量的用户数，尽管它大概有0.81%的错误率，但对于统计UV这种不需要很精确的数据是可以忽略不计的。</li></ul><blockquote><p>基数</p></blockquote><ul><li>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。基数估计就是在误差可接受的范围内，快速计算基数。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PFADD</span> <span class="string">mykey</span> <span class="string">a</span> <span class="string">b</span> <span class="string">c</span> <span class="string">d</span> <span class="string">e</span> <span class="string">f</span> <span class="string">g</span> <span class="string">h</span> <span class="string">i</span> <span class="string">j</span>  <span class="comment"># 添加指定元素到 HyperLogLog 中。 </span></span><br><span class="line"><span class="string">PFCOUNT</span> <span class="string">mykey</span>                    <span class="comment"># 返回给定 HyperLogLog 的基数估算值。</span></span><br><span class="line"><span class="string">PFADD</span> <span class="string">mykey2</span> <span class="string">i</span> <span class="string">j</span> <span class="string">z</span> <span class="string">x</span> <span class="string">c</span> <span class="string">v</span> <span class="string">b</span> <span class="string">n</span> <span class="string">m</span> </span><br><span class="line"><span class="string">PFMERGE</span> <span class="string">mykey3</span> <span class="string">mykey</span> <span class="string">mykey2</span>      <span class="comment"># 将多个 合并为并集计算</span></span><br><span class="line"><span class="string">PFCOUNT</span> <span class="string">mykey3</span></span><br></pre></td></tr></table></figure><h2 id="5-3、BitMap"><a href="#5-3、BitMap" class="headerlink" title="5.3、BitMap"></a>5.3、BitMap</h2><ul><li> Redis 提供了 Bitmap ，Bitmap 通过操作二进制位来进行记录，即为 0 和 1；如果要记录 365 天的打卡情况，使用 Bitmap表示的形式大概如下0101000111000111………………………，节约内存了，365 天相当于 365 bit，又 1 字节 = 8 bit , 所以相当于使用 46 个字节即可。</li><li>Bitmaps实际上它就是字符串（key-value），但是可以对字符串位操作</li></ul><blockquote><p>setbit 设置操作</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SETBIT key offset value :</span> <span class="string">设置</span> <span class="string">key</span> <span class="string">的第</span> <span class="string">offset</span> <span class="string">位为value</span> <span class="string">(1或0)</span></span><br><span class="line"><span class="comment"># value只能为0或者1</span></span><br><span class="line"><span class="comment"># 使用 bitmap 来记录上述事例中一周的打卡记录如下所示： </span></span><br><span class="line"><span class="comment"># 周一：1，周二：0，周三：0，周四：1，周五：1，周六：0，周天：0 （1 为打卡，0 为不打卡）</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">2</span> <span class="number">0</span> </span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">5</span> <span class="number">0</span> </span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">6</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><blockquote><p>getbit 获取操作</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">GETBIT</span> <span class="string">key</span> <span class="string">offset</span>  <span class="comment"># 获取offset设置的值，未设置过默认返回0</span></span><br><span class="line"></span><br><span class="line"><span class="string">getbit</span> <span class="string">sign</span> <span class="number">3</span>      <span class="comment"># 查看周四是否打卡</span></span><br></pre></td></tr></table></figure><blockquote><p>bitcount 统计操作</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计value为1的值得次数 </span></span><br><span class="line"><span class="string">bitcount</span> <span class="string">sign</span></span><br></pre></td></tr></table></figure><ul><li>僵尸粉大多，其实还不如用set集合</li></ul><h1 id="6、Redis-conf"><a href="#6、Redis-conf" class="headerlink" title="6、Redis.conf"></a>6、Redis.conf</h1><ul><li>Redis 的配置文件位于 Redis 安装目录下，文件名为 <strong>redis.conf</strong></li></ul><blockquote><p>Units 单位</p></blockquote><p><img src="/img/Redis/2.jpg"></p><ul><li>配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit</li><li>对 大小写 不敏感</li></ul><blockquote><p>INCLUDES 包含</p></blockquote><p><img src="/img/Redis/3.jpg"></p><blockquote><p>NETWORK 网络配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bind</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>     <span class="comment"># 绑定的ip,只接受本机的访问请求</span></span><br><span class="line"><span class="string">protected-mode</span> <span class="literal">yes</span> <span class="comment"># 保护模式,没密码时，只接受本机响应 </span></span><br><span class="line"><span class="string">port</span> <span class="number">6379</span>          <span class="comment"># 默认端口</span></span><br><span class="line"><span class="string">tcp-backlog</span> <span class="number">511</span>    <span class="comment"># backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列</span></span><br><span class="line"><span class="string">timeout</span> <span class="number">0</span>   <span class="comment"># 空闲的客户端维持多少秒关闭</span></span><br><span class="line"><span class="string">tcp-keepalive</span> <span class="number">300</span>  <span class="comment"># 对访问客户端的一种心跳检测，,0不检测</span></span><br></pre></td></tr></table></figure><blockquote><p>GENERAL 通用</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span> <span class="comment"># yes 开启作为守护线程</span></span><br><span class="line"><span class="string">supervised</span> <span class="literal">no</span> <span class="comment"># 可通过upstart和systemd管理Redis守护进程 </span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/var/run/redis_6379.pid</span> <span class="comment"># pid文件位置</span></span><br><span class="line"><span class="string">loglevel</span> <span class="string">notice</span> <span class="comment"># 日志级别。可选项有： </span></span><br><span class="line"><span class="comment"># debug（记录大量日志信息，适用于开发、测试阶段）；</span></span><br><span class="line">                <span class="comment"># verbose（较多日志信息）；</span></span><br><span class="line">                <span class="comment"># notice（适量日志信息，使用于生产环境）； </span></span><br><span class="line">                <span class="comment"># warning（仅有部分重要、关键信息才会被记录）。 </span></span><br><span class="line"><span class="string">logfile</span> <span class="string">&quot;&quot;</span><span class="comment"># 日志文件的位置，当指定为空字符串时，为标准输出 </span></span><br><span class="line"><span class="string">databases</span> <span class="number">16</span> <span class="comment"># 设置数据库的数目。默认的数据库是DB 0 </span></span><br><span class="line"><span class="string">always-show-logo</span> <span class="literal">yes</span> <span class="comment"># 是否总是显示logo</span></span><br></pre></td></tr></table></figure><blockquote><p>SNAPSHOPTING 快照</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） </span></span><br><span class="line"><span class="string">save</span> <span class="number">900</span> <span class="number">1</span> </span><br><span class="line"><span class="comment"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） </span></span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">10</span> </span><br><span class="line"><span class="comment"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化） </span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span> </span><br><span class="line"><span class="comment"># 持久化出现错误后，是否依然进行继续进行工作 </span></span><br><span class="line"><span class="string">stop-writes-on-bgsave-error</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 使用压缩rdb文件 yes：压缩，cpu消耗。no：不压缩，消耗磁盘空间</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 是否校验rdb文件，保存rdb文件的时 候，会有大概10%的性能损耗</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span> </span><br><span class="line"><span class="comment"># dbfilenamerdb的文件名称</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump.rdb</span> </span><br><span class="line"><span class="comment"># dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span></span><br><span class="line"><span class="string">dir</span> <span class="string">./</span> </span><br></pre></td></tr></table></figure><blockquote><p>REPLICATION 复制 </p></blockquote><ul><li>看后面的主从复制</li></ul><blockquote><p>SECURITY安全</p></blockquote><ul><li>访问密码的查看，设置和取消</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动redis </span></span><br><span class="line"><span class="comment"># 连接客户端 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得和设置密码 </span></span><br><span class="line"><span class="string">config</span> <span class="string">get</span> <span class="string">requirepass</span> </span><br><span class="line"><span class="string">config</span> <span class="string">set</span> <span class="string">requirepass</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="comment">#测试ping，发现需要验证 </span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ping</span> </span><br><span class="line"><span class="string">NOAUTH</span> <span class="string">Authentication</span> <span class="string">required.</span> </span><br><span class="line"><span class="comment"># 验证 </span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">auth</span> <span class="number">123456</span> </span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ping</span> </span><br><span class="line"><span class="string">PONG</span></span><br></pre></td></tr></table></figure><blockquote><p>LIMITS限制</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">maxclients</span> <span class="number">10000</span>   <span class="comment"># 设置能连上redis的最大客户端连接数量 </span></span><br><span class="line"><span class="string">maxmemory</span> <span class="string">&lt;bytes&gt;</span>  <span class="comment"># redis配置的最大内存容量 </span></span><br><span class="line"></span><br><span class="line"><span class="string">maxmemory-policy</span> <span class="string">noeviction</span></span><br><span class="line"><span class="comment"># maxmemory-policy 内存达到上限的处理策略 </span></span><br><span class="line"><span class="comment">#volatile-lru：利用LRU算法移除设置过过期时间的key。 </span></span><br><span class="line"><span class="comment">#volatile-random：随机移除设置过过期时间的key。 </span></span><br><span class="line"><span class="comment">#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL） </span></span><br><span class="line"><span class="comment">#allkeys-lru：利用LRU算法移除任何key。 </span></span><br><span class="line"><span class="comment">#allkeys-random：随机移除任何key。</span></span><br><span class="line">    <span class="comment">#noeviction：不移除任何key，只是返回一个写错误。</span></span><br></pre></td></tr></table></figure><blockquote><p>append only模式</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appendonly</span> <span class="literal">no</span> </span><br><span class="line"><span class="comment"># 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这种 方式在许多应用中已经足够用了</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># appendfilename AOF 文件名称 </span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span> <span class="comment"># appendfsync aof持久化策略的配置 </span></span><br><span class="line"><span class="comment"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。 </span></span><br><span class="line"><span class="comment"># always表示每次写入都执行fsync，以保证数据同步到磁盘。</span></span><br><span class="line">        <span class="comment"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br></pre></td></tr></table></figure><h1 id="7、Redis的持久化"><a href="#7、Redis的持久化" class="headerlink" title="7、Redis的持久化"></a>7、Redis的持久化</h1><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。</p><h2 id="7-1、RDB（默认）"><a href="#7-1、RDB（默认）" class="headerlink" title="7.1、RDB（默认）"></a>7.1、RDB（默认）</h2><p><strong>概念：</strong>指定的时间间隔内将内存的数据集写入<strong>dump.rdb</strong> <strong>文件</strong>（快照），恢复时读取文件</p><p><strong>执行过程：</strong>Redis单独创建（Fork）一个子进程进行持久化，先把数据写入临时文件中，结束后用临时文件替换上次的文件。</p><p><strong>优点：</strong>持久化不进行IO操作，效率高；性能比AOF更好，适合大规模、数据不敏感的情况</p><p><strong>缺点：</strong>最后一次快照后的修改易丢失；Fork的时候，克隆大致2倍的膨胀性需要考虑</p><p><strong>Fork：</strong>复制一个与当前进程完全一致一样的进程，并作为原进程的子进程</p><blockquote><p>配置位置及SNAPSHOTTING解析</p></blockquote><ul><li>默认配置</li></ul><p><img src="/img/Redis/1.jpg"></p><ul><li>可以修改触发条件机制</li><li>不设置任何save，即可禁用RDB</li><li>若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效 !</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">save</span> <span class="number">120</span> <span class="number">10</span> <span class="comment"># 120秒内修改10次则触发RDB</span></span><br><span class="line"></span><br><span class="line"><span class="string">flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</span></span><br></pre></td></tr></table></figure><ul><li>使用 bgsave 会在后台异步进行快照</li><li>lastsave 命令获取最后一次成功执行快照的时间</li></ul><blockquote><p>配置文件</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span> <span class="comment"># 存储快照后，进行压缩</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span>   <span class="comment"># 存储快照后，会开启数据检验，但会多消耗10%性能</span></span><br></pre></td></tr></table></figure><blockquote><p>恢复</p></blockquote><p>将备份文件（dump.rdb）移动到redis安装目录并启动服务即可</p><h2 id="7-2、AOF"><a href="#7-2、AOF" class="headerlink" title="7.2、AOF"></a>7.2、AOF</h2><p><strong>概念：</strong>用日志的形式， 把指令（读除外）记录下来，每次重启需要<code>重新执行指令</code>。</p><p><strong>执行过程：</strong></p><ol><li>客户端请求的命令追加到 AOF缓存区，</li><li>根据持久化策略异步的把缓存区 同步到 appendonly.aof 文件</li><li>同步后如果文件大小超过阈值（大了64M），会对appendonly.aof 文件进行重写。</li></ol><p><strong>特点：</strong>可以追加指令到文件，但是不可以改写文件</p><p><strong>同步规则：</strong>1、不设置规则让操作系统决定   2、每次修改同步    3、每秒同步（建议）   </p><p><strong>重写 rewrite</strong>：fork处一条新进程，通过读取缓存的数据，实现指令的压缩。</p><p><strong>缺点：</strong>同样容量文件AOF远大于RDB，恢复速度因此更慢</p><p><strong>优点：</strong>每次修改就保存策略可以<code>不丢失数据</code>，每秒的形式兼顾性能和效果。</p><p><strong>注意点：</strong>不同步效率和rdb相同。</p><blockquote><p>配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appendonly</span> <span class="literal">no</span> <span class="comment"># 持久化方式，</span></span><br><span class="line"><span class="comment"># 默认使用的是rdb方式持久化，这种方式在许多应用中已经足够用了 </span></span><br><span class="line"><span class="comment"># 设置成yes，开启AOF方式</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># appendfilename AOF 生成文件名称</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span> <span class="comment"># appendfsync aof持久化策略的配置 </span></span><br><span class="line"><span class="comment"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。 </span></span><br><span class="line"><span class="comment"># always表示每次写入都执行fsync，以保证数据同步到磁盘。 </span></span><br><span class="line"><span class="comment"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br><span class="line"></span><br><span class="line"><span class="literal">no</span><span class="string">-appendfsync-on-rewrite</span> <span class="literal">no</span> </span><br><span class="line"><span class="comment"># 重写时是否可以运用Appendfsync，用默认no即可保证数据安全性</span></span><br><span class="line"><span class="comment"># yes：不写入aof文件只写入缓存，用户请求不会阻塞</span></span><br><span class="line"><span class="comment"># no，会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="string">Auto-aof-rewrite-min-size</span>        <span class="comment"># 设置重写的基准值 </span></span><br><span class="line"><span class="string">Auto-aof-rewrite-percentage</span>      <span class="comment"># 设置重写的基准值</span></span><br></pre></td></tr></table></figure><blockquote><p>数据恢复</p></blockquote><p><strong>正常恢复：</strong></p><ul><li>启动：修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录</li><li>恢复：重启redis然后重新加载</li></ul><p><strong>异常恢复：</strong></p><ul><li>启动：修改默认的appendonly no，改为yes</li><li>故意破坏 appendonly.aof 文件！</li><li>修复： redis-check-aof –fix appendonly.aof 进行修复</li><li>恢复：重启 redis 然后重新加载</li></ul><h2 id="7-3、总结"><a href="#7-3、总结" class="headerlink" title="7.3、总结"></a>7.3、总结</h2><p><strong>RDB：</strong>性能高，但是容易丢失修改的操作。</p><p><strong>AOF：</strong>性能低，但是对文件的修改保存的更好。</p><p><strong>使用建议：</strong>同时开启 RDB 和 AOF</p><ol><li>Redis 重启 优先加载 AOF，因为AOF往往记录更加完整。</li><li>RDB 作为后备用途，更适合用于备份数据库（AOF在不断变化不好备份）。</li></ol><p><strong>性能建议</strong></p><ul><li>RDB文件只用作后备用途，建议只在Slave（从机）上持久化RDB文件，而且只要15分钟备份一次就够了，保留 save 900 1 这条规则。</li><li>如果开启AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li><li>如果不开启 AOF ，仅靠 Master-Slave Repllcation （主从复制）实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li></ul><h1 id="8、Redis事务"><a href="#8、Redis事务" class="headerlink" title="8、Redis事务"></a>8、Redis事务</h1><p><strong>本质</strong>：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令</p><p><strong>特点：</strong>不存在隔离级别，ACID原则，回滚</p><ol><li>事务开启并不会执行命令，而是放入缓存；命令会被序列化，等提交后依次执行。</li><li>在执行事务之前，事务支持被打断（类似<code>乐观锁机制</code>）</li></ol><p><strong>原子性：</strong>可以使用Lua语言来实现原子性。</p><p><strong>Redis事务的三个阶段</strong>：1、开始事务  2、命令入队  3、执行事务</p><p><strong>Redis事务相关命令</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">watch</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">...</span> <span class="comment">#监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则 事务被打断(类似乐观锁)</span></span><br><span class="line"><span class="string">multi</span>    <span class="comment"># 标记一个事务块的开始(queued) 标记之后，结束之前指令会加入队列但不执行。</span></span><br><span class="line"><span class="string">exec</span>     <span class="comment"># 执行所有事务块的命令(一旦执行exec后，之前加的监控锁都会被取消掉) </span></span><br><span class="line"></span><br><span class="line"><span class="string">discard</span>  <span class="comment"># 取消事务，放弃事务块中的所有命令 </span></span><br><span class="line"><span class="string">unwatch</span>  <span class="comment"># 取消watch对所有key的监控</span></span><br></pre></td></tr></table></figure><blockquote><p>正常执行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">multi       # 开始事务</span><br><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">get k2</span><br><span class="line">set k3 v3</span><br><span class="line">exec        # 执行事务</span><br></pre></td></tr></table></figure><blockquote><p>放弃事务</p></blockquote><ul><li>全部都不执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multi       # 开始事务</span><br><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">discard     # 放弃事务</span><br><span class="line">exec        # 执行事务</span><br></pre></td></tr></table></figure><blockquote><p>事务出现命令错误，语法对</p></blockquote><ul><li>执行阶段发生错误，错误的不执行，其他都执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multi       # 开始事务</span><br><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">get k3 v3   # 错误命令</span><br><span class="line">exec        # 执行事务</span><br></pre></td></tr></table></figure><blockquote><p>事务出现语法错误</p></blockquote><ul><li>执行阶段前发生错误，全部都不执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multi       # 开始事务</span><br><span class="line">set k1      # 语法错误</span><br><span class="line">set k2 v2</span><br><span class="line">exec        # 执行事务</span><br></pre></td></tr></table></figure><blockquote><p>Watch监控：实现乐观锁</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现乐观锁机制</span></span><br><span class="line"><span class="string">set</span> <span class="string">balance</span> <span class="number">100</span>  <span class="comment"># 余额100</span></span><br><span class="line"><span class="string">set</span> <span class="string">debt</span> <span class="number">0</span>       <span class="comment"># 欠款0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用watch检测balance，事务期间balance数据未变动，事务执行成功</span></span><br><span class="line"><span class="string">watch</span> <span class="string">balance</span>          <span class="comment"># 开启监控</span></span><br><span class="line"><span class="string">MULTI</span>                  <span class="comment"># 开始事务</span></span><br><span class="line"><span class="string">decrby</span> <span class="string">balance</span> <span class="number">20</span>      <span class="comment"># 减少余额20</span></span><br><span class="line"><span class="string">incrby</span> <span class="string">debt</span> <span class="number">20</span>         <span class="comment"># 增加欠款20</span></span><br><span class="line"><span class="string">exec</span>                   <span class="comment"># 执行事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若中途balance有变化，就会执行失败</span></span><br></pre></td></tr></table></figure><ul><li>一但执行 EXEC 开启事务的执行后， WARCH 对变量的监控就会被取消。</li><li>所以事务失败后，需要重新使用watch变量监视</li></ul><h1 id="9、发布订阅"><a href="#9、发布订阅" class="headerlink" title="9、发布订阅"></a>9、发布订阅</h1><p><strong>概念：</strong></p><ul><li>Redis 发布订阅(pub/sub)是一种消息通信模式：</li><li>发送者(pub)发送消息，订阅者(sub)接收消息。</li><li>Redis 客户端可以订阅任意数量的频道。</li><li>每当有新消息通过publish命令发送给频道时，消息就会发送给所有客户端</li></ul><blockquote><p>命令</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅一个或多个符合给定模式的频道。</span></span><br><span class="line"><span class="string">PSUBSCRIBE</span> <span class="string">pattern</span> [<span class="string">pattern</span> <span class="string">...</span>] </span><br><span class="line"><span class="comment"># 查看订阅与发布系统状态。</span></span><br><span class="line"><span class="string">PUBSUB</span> <span class="string">subcommand</span> [<span class="string">argument</span> [<span class="string">argument</span> <span class="string">...</span>]] </span><br><span class="line"><span class="string">PUBSUB</span> <span class="string">Channels</span> <span class="string">myChat</span></span><br><span class="line"><span class="comment"># 将信息发送到指定的频道。</span></span><br><span class="line"><span class="string">PUBLISH</span> <span class="string">channel</span> <span class="string">message</span> </span><br><span class="line"><span class="comment"># 退订所有给定模式的频道。</span></span><br><span class="line"><span class="string">PUNSUBSCRIBE</span> [<span class="string">pattern</span> [<span class="string">pattern</span> <span class="string">...</span>]] </span><br><span class="line"><span class="comment"># 订阅给定的一个或多个频道的信息。</span></span><br><span class="line"><span class="string">SUBSCRIBE</span> <span class="string">channel</span> [<span class="string">channel</span> <span class="string">...</span>] </span><br><span class="line"><span class="comment"># 指退订给定的频道。</span></span><br><span class="line"><span class="string">UNSUBSCRIBE</span> [<span class="string">channel</span> [<span class="string">channel</span> <span class="string">...</span>]] </span><br></pre></td></tr></table></figure><blockquote><p>实战</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建订阅频道名字为myChat</span></span><br><span class="line"><span class="string">SUBSCRIBE</span> <span class="string">myChat</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 新开一个客户端连接redis，同一个频道myChat发布消息</span></span><br><span class="line"><span class="string">publish</span> <span class="string">myChat</span> <span class="string">&quot;hello,redis&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个客户端就能收到信息</span></span><br></pre></td></tr></table></figure><blockquote><p>原理</p></blockquote><p><strong>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能</strong></p><ul><li> SUBSCRIBE 命令订阅某频道后，redis-server 里会维护了一个字典，字典的键就是一个个 channel（频道），而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中</li><li>PUBLISH 命令向订阅者发送消息，根据链表发送给所有客户端</li></ul><blockquote><p>使用场景</p></blockquote><ul><li>Pub/Sub构建实时消息系统</li></ul><h1 id="10、主从复制"><a href="#10、主从复制" class="headerlink" title="10、主从复制"></a>10、主从复制</h1><h2 id="10-1、概念"><a href="#10-1、概念" class="headerlink" title="10.1、概念"></a>10.1、概念</h2><ul><li>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。</li><li>前者称为主节点(master/leader)，后者称为从节点(slave/follower)；</li><li>数据的复制是<strong>单向的，只能由主到从</strong>。Master以写为主，Slave 以读为主。</li><li>默认情况下，每台Redis服务器都是主节点，一个从节点只能有一个主节点。</li></ul><h2 id="10-2、-优点"><a href="#10-2、-优点" class="headerlink" title="10.2、 优点"></a>10.2、 优点</h2><ul><li>数据冗余：主从复制实现了数据的<strong>热备份</strong>，是持久化外的一种数据冗余方式</li><li>故障恢复：当主节点出现问题时，可以由从节点故障恢复；服务的冗余。</li><li>负载均衡：配合读写分离，可以由主节点提供写服务，由从节点提供读服务分担服务器负载；大大提高Redis服务器的并发量。</li><li>高可用基石：主从复制是<strong>哨兵</strong>和<strong>集群</strong>能够实施的基础。</li></ul><h2 id="10-3、环境配置"><a href="#10-3、环境配置" class="headerlink" title="10.3、环境配置"></a>10.3、环境配置</h2><ul><li>准备</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前库的信息</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">info</span> <span class="string">replication</span></span><br><span class="line"><span class="string">role:master</span>            <span class="comment"># 角色，主机</span></span><br><span class="line"><span class="string">connected_slaves:0</span>     <span class="comment"># 从机  0 个</span></span><br></pre></td></tr></table></figure><h3 id="1、启动三个redis"><a href="#1、启动三个redis" class="headerlink" title="1、启动三个redis"></a>1、启动三个redis</h3><ul><li>复制启动文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cp</span> <span class="string">redis.conf</span> <span class="string">redis79.conf</span>  <span class="comment"># 依次复制三份</span></span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">vim</span> <span class="string">redis79.conf</span>   <span class="comment"># 先进入配置文件</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/www/server/redis/redis6379.pid</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">&quot;/www/server/redis/redis6379.log&quot;</span>  <span class="comment">#日志文件修改</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump6379.rdb</span>   <span class="comment"># 默认持久化文件名修改</span></span><br><span class="line"></span><br><span class="line"><span class="string">vim</span> <span class="string">redis80.conf</span>   <span class="comment"># 先进入配置文件</span></span><br><span class="line"><span class="string">port</span> <span class="number">6380</span>          <span class="comment"># 修改端口号</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/www/server/redis/redis6380.pid</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">&quot;/www/server/redis/redis6380.log&quot;</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump6380.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次配置81</span></span><br></pre></td></tr></table></figure><ul><li>启动redis</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/www/server/redis/src/redis-server /www/server/redis/redis.conf</span><br><span class="line"></span><br><span class="line">/www/server/redis/src/redis-server /www/server/redis/redis79.conf</span><br><span class="line">redis-cli -p 6379</span><br><span class="line"></span><br><span class="line">/www/server/redis/src/redis-server /www/server/redis/redis80.conf</span><br><span class="line">/www/server/redis/src/redis-server /www/server/redis/redis81.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>查看进程信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure><h3 id="2、暂时配置主从"><a href="#2、暂时配置主从" class="headerlink" title="2、暂时配置主从"></a>2、暂时配置主从</h3><ul><li>开始配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">info</span> <span class="string">replication</span>  <span class="comment"># 默认都是主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置79 为主机 80 81为从机</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6380&gt;</span> <span class="string">slaveof</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span>  <span class="comment"># 设置认 6379 当做主机</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6380&gt;</span> <span class="string">info</span> <span class="string">replication</span>        <span class="comment"># 此时信息显示该为从机</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6381&gt;</span> <span class="string">slaveof</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span>  <span class="comment"># 设置认 6379 当做主机</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6381&gt;</span> <span class="string">info</span> <span class="string">replication</span>        <span class="comment"># 此时信息显示该为从机</span></span><br></pre></td></tr></table></figure><h3 id="3、永久配置主从"><a href="#3、永久配置主从" class="headerlink" title="3、永久配置主从"></a>3、永久配置主从</h3><ul><li>再配置文件中找到replication修改</li></ul><p><img src="/img/Redis/4.jpg"></p><ul><li>去掉注释 &lt;&gt; 里面写入内容即可</li><li>地址 主机IP      replicaof 127.0.0.1 6379</li><li>主机密码</li></ul><h3 id="4、关闭服务"><a href="#4、关闭服务" class="headerlink" title="4、关闭服务"></a>4、关闭服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown save</span><br></pre></td></tr></table></figure><h3 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h3><ul><li>在主机设置值，在从机都可以取到！从机不能写值</li></ul><h2 id="10-4、测试"><a href="#10-4、测试" class="headerlink" title="10.4、测试"></a>10.4、测试</h2><h3 id="1、正常读写"><a href="#1、正常读写" class="headerlink" title="1、正常读写"></a>1、正常读写</h3><ul><li>在主机设置值，在从机都可以取到（增量复制）！从机不能写值</li></ul><h3 id="2、宕机"><a href="#2、宕机" class="headerlink" title="2、宕机"></a>2、宕机</h3><ul><li><p>主机宕机后，从机还是从机，不会变为主机</p></li><li><p>主机宕机恢复后，从机会自动重新连接，获取主机新操作</p></li><li><p>从机宕机恢复后，会自动同步主机的信息（全量复制）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Slave 启动成功连接到 master 后会发送一个sync命令</span><br><span class="line">Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行</span><br><span class="line">完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</span><br><span class="line">全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内中。</span><br><span class="line">增量复制：Master继续将新的所有收集到的修改命令依次传给slave完成同步、</span><br><span class="line"></span><br><span class="line">但是只要是重新连接master，一次完全同步（全量复制）将被自动执行</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、谋权篡位"><a href="#3、谋权篡位" class="headerlink" title="3、谋权篡位"></a>3、谋权篡位</h3><ul><li>一主二从的情况下，主机长时间宕机了怎么办？</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用命令将自己改为主机,原来同步所得的数据集不会被丢弃</span></span><br><span class="line"><span class="string">SLAVEOF</span> <span class="literal">NO</span> <span class="string">ONE</span> </span><br></pre></td></tr></table></figure><ul><li>若此时原主机再恢复，会成为一个独立的机</li></ul><h3 id="4、薪火相传"><a href="#4、薪火相传" class="headerlink" title="4、薪火相传"></a>4、薪火相传</h3><ul><li>B从机在当A的从机时还充当C的主机，可以减少主机压力</li><li>不过B主机作为从机仍然是不能写入的</li></ul><h2 id="10-5、哨兵模式"><a href="#10-5、哨兵模式" class="headerlink" title="10.5、哨兵模式"></a>10.5、哨兵模式</h2><ul><li><strong>谋权篡位</strong>的自动版</li><li>后台监控主机，主机故障了就<strong>根据投票数</strong>自动将从库转换为主库。</li><li>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，</li><li>哨兵是一个独立的进程，作为进程，它会独立运行。</li></ul><h3 id="1、原理："><a href="#1、原理：" class="headerlink" title="1、原理："></a>1、原理：</h3><ul><li>哨兵通过发送命令，等待Redis服务器响应，监控运行的多个Redis实例。</li><li>哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改<strong>配置文件</strong>（永久更改），让它们切换主机</li><li>原主机回来之后<code>自动变为从机</code></li></ul><h3 id="2、多哨兵模式："><a href="#2、多哨兵模式：" class="headerlink" title="2、多哨兵模式："></a>2、多哨兵模式：</h3><ul><li>一个哨兵可能会出现问题，所以可以使用多个哨兵互相监控。</li><li>哨兵1检测到主机宕机，不会立即选取新主机，这个现象成为<strong>主观下线</strong></li><li>后面的哨兵也检测到主服务器不可用，且达到一定数量时，会进行投票</li><li>投票的结果由一个哨兵发起，进行failover[故障转移]操作，选择新主机，并且通过发布订阅模式，让哨兵通知监视的从机修改配置切换成新主机，该过程成为<strong>客观下线</strong></li></ul><h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><ul><li><p>设置一主二从，79主机，80、81从机</p></li><li><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cd</span> <span class="string">/www/server/redis/</span>  <span class="comment"># 进入目录</span></span><br><span class="line"><span class="string">vim</span> <span class="string">sentinel.conf</span>      <span class="comment"># 进入文件</span></span><br><span class="line"></span><br><span class="line"><span class="string">port</span> <span class="number">26379</span>   <span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line"><span class="string">dir</span> <span class="string">/tmp</span>     <span class="comment"># 哨兵sentinel的工作目录 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line"><span class="comment"># 哨兵sentinel      主机名(自己取) 地址  主机端口号</span></span><br><span class="line"><span class="comment"># 1个哨兵认为宕机就宕机</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379 </span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line"><span class="comment"># 哨兵sentinel   监控 mymaster     连接主机的密码</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">auth-pass</span> <span class="string">mymaster</span> <span class="string">MySUPER--secret-0123passw0rd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; </span></span><br><span class="line"><span class="comment"># 30毫秒之后 主节点没有应答哨兵sentinel ，哨兵就主观上认为主节点下线 </span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">30000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发生failover主备切换时同时只能有1个从机可以对新的主机同步</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; sentinel </span></span><br><span class="line"><span class="string">parallel-syncs</span> <span class="string">mymaster</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间设置为 3分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">180000</span></span><br></pre></td></tr></table></figure></li><li><p>启动哨兵</p><p>/www/server/redis/src/redis-sentinel /www/server/redis/sentinel.conf</p></li><li><p>关闭主机</p></li><li><p>新主机被自动选举出来</p></li><li><p>原主机重新回来后，只能当从机（永久性的改变）</p></li></ul><h3 id="4、优缺点"><a href="#4、优缺点" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点</strong></p><ol><li><p>哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。</p></li><li><p>主从可以切换，故障可以转移，系统可用性更好。</p></li><li><p>哨兵模式是主从模式的升级，系统更健壮，可用性更高。</p></li></ol><p><strong>缺点</strong></p><ol><li><p>Redis<strong>较难支持在线扩容</strong>，在集群容量达到上限时在线扩容会变得很复杂。</p></li><li><p>实现哨兵模式的配置也不简单，甚至可以说有些繁琐</p></li></ol><h1 id="11、Redis集群"><a href="#11、Redis集群" class="headerlink" title="11、Redis集群"></a>11、Redis集群</h1><h2 id="11-1、概念"><a href="#11-1、概念" class="headerlink" title="11.1、概念"></a>11.1、概念</h2><ul><li>对Redis的水平扩容，即启动N个redis主节点，将整个数据库<code>均匀分布</code>存储在这N个主节点中，每个主节点存储总数据的1/N。</li><li>无中心节点，各个主节点之间保持联系</li><li>每个主节点可以有多个从节点</li></ul><h2 id="11-2、配置"><a href="#11-2、配置" class="headerlink" title="11.2、配置"></a>11.2、配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先复制六份配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后配置文件配置 redis.conf</span></span><br><span class="line"><span class="string">cluster-enabled</span> <span class="literal">yes</span>                  <span class="comment"># 打开集群模式</span></span><br><span class="line"><span class="string">cluster-config-file</span> <span class="string">nodes-6379.conf</span>  <span class="comment"># 设定节点配置文件名</span></span><br><span class="line"><span class="string">cluster-node-timeout</span> <span class="number">15000</span>   </span><br><span class="line"><span class="comment"># 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着配置完之后启动六个redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将六个节点合成一个集群</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">--cluster</span> <span class="string">create</span> <span class="string">--cluster-replicas</span> <span class="number">1</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6379</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6380</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6381</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6389</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6390</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6391</span></span><br><span class="line"></span><br><span class="line"><span class="string">不要用127.0.0.1，</span> <span class="string">请用真实IP地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-3、登录"><a href="#11-3、登录" class="headerlink" title="11.3、登录"></a>11.3、登录</h2><p><strong>普通方式登陆</strong></p><ul><li>可能直接进入<strong>读主机</strong>，存储数据时，会出现MOVED重定向操作</li><li>所以，应该以集群方式登录。</li></ul><p><strong>集群方式登录：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 6379</span><br></pre></td></tr></table></figure><ul><li>-c 采用集群策略连接，设置数据会自动切换到相应的写主机</li></ul><p><strong>查看集群信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure><h2 id="11-4、节点分配问题"><a href="#11-4、节点分配问题" class="headerlink" title="11.4、节点分配问题"></a>11.4、节点分配问题</h2><ul><li>一个集群至少要有三个主节点</li><li>选项 –cluster-replicas 1 表示我们希望为集群中的<code>每个主节点创建一个从节点</code></li><li>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</li></ul><h2 id="11-5、Slot插槽"><a href="#11-5、Slot插槽" class="headerlink" title="11.5、Slot插槽"></a>11.5、Slot插槽</h2><ul><li>一个 Redis 集群包含 16384 个插槽（hash slot），</li><li> 数据库中的每个键都属于这 16384 个插槽的其中一个</li><li>集群每个主节点负责一部分插槽，存取值时根据 key(插槽)去对应节点</li><li>上面使用   - c  连接后会自动根据插槽，<strong>重定向到合适的主机</strong></li></ul><p><strong>注意：</strong></p><ul><li><p>不是一个插槽下的值，不能使用<strong>mget,mset</strong>等多键操作</p></li><li><p>不过可以通过  {  } 来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset k1&#123;cust&#125; v1 k2&#123;cust&#125; v2</span><br></pre></td></tr></table></figure></li></ul><p><strong>查询值</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">CLUSTER</span> <span class="string">GETKEYSINSLOT</span> <span class="string">&lt;slot&gt;&lt;count&gt;</span></span><br><span class="line"><span class="string">cluster</span> <span class="string">keyslot</span> <span class="string">cust</span> <span class="comment"># 返回插槽cust的一个值</span></span><br><span class="line"><span class="string">cluster</span> <span class="string">keyslot</span> <span class="string">cust</span>  <span class="number">10</span> <span class="comment"># 返回插槽cust的十个值</span></span><br></pre></td></tr></table></figure><h2 id="11-6、故障"><a href="#11-6、故障" class="headerlink" title="11.6、故障"></a>11.6、故障</h2><ul><li>如果主节点下线：从节点自动升为主节点</li><li>如果主节点恢复：主节点变成了从节点</li></ul><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，只是<strong>该插槽部分不能使用</strong>，也无法存储。</p><h2 id="11-7、缺点"><a href="#11-7、缺点" class="headerlink" title="11.7、缺点"></a>11.7、缺点</h2><ul><li>多键操作是不被支持的 </li><li>多键的Redis事务是不被支持的。lua脚本不被支持</li></ul><h1 id="12、Jedis"><a href="#12、Jedis" class="headerlink" title="12、Jedis"></a>12、Jedis</h1><h3 id="1、依赖"><a href="#1、依赖" class="headerlink" title="1、依赖"></a>1、依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;121.41.4.48&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="comment">//查看服务是否运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要先修改</span></span><br><span class="line"><span class="comment">bind 182.100.29.183 </span></span><br><span class="line"><span class="comment">bind 127.0.0.1</span></span><br><span class="line"><span class="comment">protected-mode no</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3、其他代码"><a href="#3、其他代码" class="headerlink" title="3、其他代码"></a>3、其他代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>); </span><br><span class="line"><span class="comment">//验证密码，如果没有设置密码这段代码省略 </span></span><br><span class="line"><span class="comment">// jedis.auth(&quot;password&quot;);</span></span><br><span class="line"></span><br><span class="line">jedis.connect(); <span class="comment">//连接 </span></span><br><span class="line">jedis.disconnect(); <span class="comment">//断开连接 </span></span><br><span class="line">jedis.flushAll(); <span class="comment">//清空所有的key</span></span><br></pre></td></tr></table></figure><h3 id="4、操作事务"><a href="#4、操作事务" class="headerlink" title="4、操作事务"></a>4、操作事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建客户端连接服务端，redis服务端需要被开启 </span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>); </span><br><span class="line">jedis.flushDB();</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启事务 </span></span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//向redis存入一条数据 </span></span><br><span class="line">    multi.set(<span class="string">&quot;json&quot;</span>, result); </span><br><span class="line">    <span class="comment">//再存入一条数据 </span></span><br><span class="line">    multi.set(<span class="string">&quot;json2&quot;</span>, result); </span><br><span class="line">    <span class="comment">//这里引发了异常，用0作为被除数 </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>/<span class="number">0</span>; </span><br><span class="line">    <span class="comment">//如果没有引发异常，执行进入队列的命令</span></span><br><span class="line">    multi.exec(); </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">    <span class="comment">//如果出现异常，放弃 </span></span><br><span class="line">    multi.discard(); </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123; </span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json2&quot;</span>)); </span><br><span class="line">    <span class="comment">//最终关闭客户端 </span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、集群情况下"><a href="#5、集群情况下" class="headerlink" title="5、集群情况下"></a>5、集群情况下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JedisCluster jedisCluster=new JedisCluster(set);</span><br><span class="line">jedisCluster.set(&quot;k1&quot;, &quot;v1&quot;);</span><br></pre></td></tr></table></figure><h1 id="13、SpringBoot整合"><a href="#13、SpringBoot整合" class="headerlink" title="13、SpringBoot整合"></a>13、SpringBoot整合</h1><h2 id="13-1、分析"><a href="#13-1、分析" class="headerlink" title="13.1、分析"></a>13.1、分析</h2><ul><li><p>SpringBoot2之后，jedis变成了lettuce</p><ul><li>jedis采用的直连，多线程不安全，需要使用连接池</li><li>lettuce采用的netty，实例可以再多个线程中共享</li></ul></li><li><p>在SpringBoot中一般使用<strong>RedisTemplate提供的方法</strong>来操作Redis。</p></li><li><p>RedisAutoConfiguration类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>   <span class="comment">//不存在bean才生效，所以可以自定义</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认的RedisTemplate 没有过多的设置，redis对象需要序列化</span></span><br><span class="line">    <span class="comment">// 两个泛型都是object，我们后使用需要强转</span></span><br><span class="line">   RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">   template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">   <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span> <span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认的序列化配置（通过JDK序列化，使字符串转义）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer keySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer valueSerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashKeySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashValueSerializer = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="13-2、简单测试"><a href="#13-2、简单测试" class="headerlink" title="13.2、简单测试"></a>13.2、简单测试</h2><ul><li>确保有如下依赖</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>yaml（可以查看 RedisProperties 分析）</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">121.41</span><span class="number">.4</span><span class="number">.48</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    opsForValue() 操作字符串 </span></span><br><span class="line"><span class="comment">    opsForList()  操作list</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;myKey&quot;</span>,<span class="string">&quot;myValue&quot;</span>);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;myKey&quot;</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取redis连接对象</span></span><br><span class="line">     RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        connection.flushAll();</span><br></pre></td></tr></table></figure><h2 id="13-3、深入测试"><a href="#13-3、深入测试" class="headerlink" title="13.3、深入测试"></a>13.3、深入测试</h2><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">    connection.flushAll();</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;wzh&quot;</span>);</span><br><span class="line">    <span class="comment">//直接传对象会报错，转换成json字符串</span></span><br><span class="line">    <span class="comment">// 或者user对象继承serializable类序列化</span></span><br><span class="line">    String jsonUser = <span class="keyword">new</span> ObjectMapper().writeValueAsString(user);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>, jsonUser);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xac\xed\x00\x05t\x00\x04user&quot;</span>  JDK序列化会显示成这样</span><br></pre></td></tr></table></figure><ul><li>编写自定义Redistemplate，自定义序列化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemp</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">//序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer); </span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer); </span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer); </span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">     template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14、常见面试题"><a href="#14、常见面试题" class="headerlink" title="14、常见面试题"></a>14、常见面试题</h1><h2 id="14-1、-Redis-和-Memcached"><a href="#14-1、-Redis-和-Memcached" class="headerlink" title="14.1、 Redis 和 Memcached"></a>14.1、 Redis 和 Memcached</h2><p><strong>共同点</strong> ：</p><ul><li>都是基于内存的数据库，⼀般都用来来当做缓存使⽤。</li><li>都有过期策略。</li><li>两者的性能都非常⾼。</li></ul><p><strong>区别</strong> ：</p><ol><li>Redis的类型丰富，Memcached只支持最简单的 K / V</li><li>Redis 支持持久化，可以有灾难恢复机制，Memcached不支持</li><li>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。Memcached则报异常。</li><li>Redis 支持原生的集群模式，Memcached没有，需要依靠客户端实现集群中分片写入数据。</li><li>Redis 单线程，多路IO复用模型；Memcached多线程，非阻塞 的IO 复用的网络类型。</li><li>Redis 支持发布订阅模型、Lua脚本、事务；Memcached不支持</li><li>Redis 同时使用了惰性删除与定期删除；Memcached过期数据的删除策略只用了惰性删除。</li></ol><p>所以现在一般选用 Redis 作为缓存数据库。</p><h2 id="14-2、-缓存数据处理流程"><a href="#14-2、-缓存数据处理流程" class="headerlink" title="14.2、 缓存数据处理流程"></a>14.2、 缓存数据处理流程</h2><p><img src="/img/Redis/5.jpg"></p><h2 id="14-3、为什么要用Redis-缓存数据库"><a href="#14-3、为什么要用Redis-缓存数据库" class="headerlink" title="14.3、为什么要用Redis/缓存数据库"></a>14.3、为什么要用Redis/缓存数据库</h2><blockquote><p>高性能</p></blockquote><p><strong>作用：</strong>使用缓存主要是为了提升用户体验以及应对更多的用户</p><p><strong>第一次读取：</strong>从数据库取出数据较慢，然后同时更新缓存</p><p><strong>第二次读取：</strong>直接从缓存读取，很快。</p><p><strong>注意：</strong>当数据库的数据改变后，要同步改变缓存中的数据才可以。</p><blockquote><p>高并发</p></blockquote><p><strong>QPS（Query Per Second）：</strong>服务器每秒可以执行的查询次数；</p><p>⼀般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使⽤ Redis 缓存之后很容易达到 10w+，甚⾄最⾼能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p><ul><li></li></ul><h2 id="14-4、Redis单线程模型"><a href="#14-4、Redis单线程模型" class="headerlink" title="14.4、Redis单线程模型"></a>14.4、Redis单线程模型</h2><p><strong>事件处理模型：</strong>Redis基于 Reactor 模式设计开发的 <code>文件事件处理器</code>，文件事件处理器基于单线程运行，使用 IO 多路复用技术来同时监听多个套接字。</p><p><strong>IO多路复用模型</strong>：Redis 通过 IO 多路复用程序监听来自客户端的大量连接，它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生，这样 Redis 就不需要 额外创建多余的线程来监听客户端了，降低了资源的消耗。（类似 NIO 的 Selector组件）</p><p><strong>多路IO复用技术</strong>：异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</p><ul><li>文件事件处理器会同时监听多个套接字（Socket），根据套接字执行的任务来<code>匹配不同事件处理器</code></li><li>被监听的套接字<code>准备进行 IO 操作</code>时，文件事件处理器就会返回，然后调用匹配的事件处理器。如果一直，没有响应，文件事件处理器就会阻塞</li></ul><blockquote><p>Redis单线程为什么这么快？</p></blockquote><ul><li>Redis基于内存操作的，所以速度快</li><li>数据结构简单，操作节省时间</li><li>多路复用io阻塞机制</li></ul><h2 id="14-5、Redis单线程？4-0加入多线程？"><a href="#14-5、Redis单线程？4-0加入多线程？" class="headerlink" title="14.5、Redis单线程？4.0加入多线程？"></a>14.5、Redis单线程？4.0加入多线程？</h2><p><strong>单线程：</strong>指处理我们的网络请求的时候只有一个线程来处理。</p><blockquote><p>Redis6.0 之前 为什么不使⽤多线程？</p></blockquote><ol><li>单线程编程容易并且更容易维护；</li><li>Redis 基于内存处理，所以性能瓶颈不再 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol><p><strong>总结：</strong>不需要靠多线程提高CPU速度，反而多线程会带来问题。</p><blockquote><p>Redis6.0 之后 为什么 加入多线程</p></blockquote><p><strong>原因：</strong>提高网络IO 读写性能，因为这个算是 Redis 中的⼀个性能瓶颈</p><p><strong>因此：</strong>Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此不需要担心线程安全问题。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要修改 redis 配置⽂件开启多线程</span></span><br><span class="line"><span class="string">io-threads-do-reads</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">io-threads</span> <span class="number">4</span> <span class="comment">#官⽹建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure><h2 id="14-6、Redis缓存数据过期问题"><a href="#14-6、Redis缓存数据过期问题" class="headerlink" title="14.6、Redis缓存数据过期问题"></a>14.6、Redis缓存数据过期问题</h2><blockquote><p>为什么要设计过期时间？</p></blockquote><p>如果不设置过期时间，很容易内存溢出。</p><p><strong>注意：</strong>只有字符串有 setex 命令， 其他都得通过 expire设置，persist移除过期时间。</p><blockquote><p>Redis如何判断过期的</p></blockquote><p>Redis 通过⼀个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是⼀个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line"> ...</span><br><span class="line"> dict *dict; //数据库键空间,保存着数据库中所有键值对</span><br><span class="line"> dict *expires // 过期字典,保存着键的过期时间</span><br><span class="line"> ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><blockquote><p>删除策略</p></blockquote><p><strong>惰性删除</strong>：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。</p><p><strong>定期删除</strong>： 每隔⼀段时间抽取⼀批 key执行删除过期key操作。并且，Redis 底层会通过限制删除操作执行和时长和频率来减少删除操作对CPU时间的影响。</p><p><strong>Redis：</strong>两者结合使用</p><blockquote><p>内存淘汰机制</p></blockquote><p><strong>问题：</strong>如果有大量的键值对没有设置过期时间，仍然容易 out of memory，需要自动删除。</p><p>MySQL 有 2000w 数据，Redis 中只存 20w ，如何保证 Redis 中的数据都是热点数据?</p><p><strong>八种内存淘汰机制</strong></p><ol><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。  </li><li>volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。  </li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰  </li><li>allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。  </li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰  </li><li> no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。  </li></ol><p><strong>总结：</strong>这八种大体上可以分为4种，lru、lfu、random、ttl。</p><p><strong>即最近最少使用、将要过期、频率最低、任意选择 四种</strong></p><h2 id="14-7、缓存穿透"><a href="#14-7、缓存穿透" class="headerlink" title="14.7、缓存穿透"></a>14.7、缓存穿透</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><ul><li>用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，</li><li>于是向持久层数据库查询。发现也没有，于是本次查询失败。</li><li>当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了<strong>缓存穿透</strong></li></ul><h3 id="2、解决"><a href="#2、解决" class="headerlink" title="2、解决"></a>2、解决</h3><blockquote><p>布隆过滤器：</p></blockquote><p><strong>原理：</strong>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，通过它我们可以非常方便地判断⼀个给定数据是否存在于海量数据中。</p><p><strong>流程：</strong>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程</p><blockquote><p>缓存空对象：</p></blockquote><p><strong>流程：</strong>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p><p><strong>缺点：</strong>需要更大的缓存空间，可能导致缓存大量无用的key；缓存层和存储层的数据还是会有一段时间窗口的不一致，影响一致性</p><h2 id="14-8、缓存雪崩-穿透"><a href="#14-8、缓存雪崩-穿透" class="headerlink" title="14.8、缓存雪崩/ 穿透"></a>14.8、缓存雪崩/ 穿透</h2><h3 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h3><p><strong>雪崩：</strong>在某一个时间段，缓存集中过期失效，访问都落到了数据库上。</p><p><strong>穿透：</strong>单个缓存</p><h3 id="2、解决-1"><a href="#2、解决-1" class="headerlink" title="2、解决"></a>2、解决</h3><blockquote><p>针对Redis服务不可用的情况</p></blockquote><ol><li>使用Redis集群，避免某个Redis主机挂掉</li><li>限流降级：通过加锁或者队列来控制读数据库写缓存的线程数量。</li></ol><blockquote><p>针对热点缓存失效的情况</p></blockquote><ol><li>热点永不失效</li><li>不同的缓存数据设置不同的过期时间</li><li>数据预热：针对高峰访问期间，先访问一遍数据，避免失效。</li></ol><h2 id="14-9、保证缓存和数据库数据的⼀致性"><a href="#14-9、保证缓存和数据库数据的⼀致性" class="headerlink" title="14.9、保证缓存和数据库数据的⼀致性"></a>14.9、保证缓存和数据库数据的⼀致性</h2><blockquote><p>Cache Aside Pattern（旁路缓存模式）</p></blockquote><p>更新 DB，然后直接删除 cache 。如果缓存删除失败</p><ol><li><strong>缓存失效时间变短（不推荐，治标不治本） ：</strong>我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加cache更新重试机制（常⽤）：</strong> 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔⼀段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li></ol><h2 id="14-10、Redis实现分布式锁"><a href="#14-10、Redis实现分布式锁" class="headerlink" title="14.10、Redis实现分布式锁"></a>14.10、Redis实现分布式锁</h2><h3 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h3><ul><li>分布式系统中，不同的系统不能识别同一把锁</li></ul><h3 id="2、实现方式（基于Redis）"><a href="#2、实现方式（基于Redis）" class="headerlink" title="2、实现方式（基于Redis）"></a>2、实现方式（基于Redis）</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">setnx</span> <span class="string">users</span> <span class="number">10</span>  <span class="comment"># 成功</span></span><br><span class="line"><span class="string">setnx</span> <span class="string">users</span> <span class="number">20</span>  <span class="comment"># 失败,注意如果用set仍然可以设置</span></span><br><span class="line"><span class="string">del</span> <span class="string">users</span>    <span class="comment"># 只在键不存在时，才对键进行设置操作</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">sku:1:info</span> <span class="string">“OK”</span> <span class="string">NX</span> <span class="string">PX</span> <span class="number">10000</span></span><br><span class="line"><span class="comment"># EX second:设置键的过期时间为 second 秒(EX可以省略)</span></span><br><span class="line"><span class="comment"># PX millisecond ：设置键的过期时间为 毫秒(PX可以省略)</span></span><br><span class="line"><span class="comment"># 注意 px 写在key和value之间，ex写在value之后 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过expire设置过期时间，</span></span><br><span class="line"><span class="comment"># 但是如果在setnx和expire之间出现异常，锁也无法释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NX:只在键不存在时，才对键进行设置操作。（setnx也可以） </span></span><br><span class="line"><span class="comment"># XX:只在键已经存在时，才对键进行设置操作。</span></span><br></pre></td></tr></table></figure><ul><li>通过修改成功，可以判断是否被<strong>逻辑上上锁了</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1获取锁，setne</span></span><br><span class="line">    <span class="comment">// (&quot;lock&quot;, &quot;111&quot;,3，TimeUnit.SENCONDS); 设置过期时间</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(lock)&#123;</span><br><span class="line">      <span class="comment">// 2业务代码</span></span><br><span class="line">        <span class="comment">// 3释放锁，del</span></span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 4获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、优化之UUID防误删"><a href="#3、优化之UUID防误删" class="headerlink" title="3、优化之UUID防误删"></a>3、优化之UUID防误删</h3><ul><li>业务代码执行时间<strong>小于</strong>锁释放的时间，</li><li>导致业务代码执行后，删除的是其他业务的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">String uuid = UUID.randonUUID().toString();</span><br><span class="line">Boolean lock = <span class="keyword">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">if</span>(uuid.equals((String)redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>)))&#123;</span><br><span class="line">    <span class="keyword">this</span>.redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="4、LUA脚本保证原子性"><a href="#4、LUA脚本保证原子性" class="headerlink" title="4、LUA脚本保证原子性"></a>4、LUA脚本保证原子性</h3><ul><li>查询uuid相等到删除操作之间可能被其他进程插入，导致释放错锁</li><li>因为没有原子性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
      <url>/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="1、数据库基本概念"><a href="#1、数据库基本概念" class="headerlink" title="1、数据库基本概念"></a>1、数据库基本概念</h1><h2 id="1-1、数据库基本概念"><a href="#1-1、数据库基本概念" class="headerlink" title="1.1、数据库基本概念"></a>1.1、数据库基本概念</h2><ul><li><p><strong>数据库</strong>（DB，DataBase）：相关互联的数据集合</p></li><li><p><strong>数据库管理系统</strong>（DBMS）：数据库系统核心部分，位于用户和os之间</p></li><li><p><strong>数据库系统</strong>（DBS）：由DB、DBMS、应用系统、DBA（数据库管理员）组成</p></li><li><p><strong>数据库应用系统</strong>（DBAS）：实现业务逻辑的应用程序</p></li></ul><h2 id="1-2、数据库分类"><a href="#1-2、数据库分类" class="headerlink" title="1.2、数据库分类"></a>1.2、数据库分类</h2><p><strong>关系型数据库</strong>：(SQL)</p><ul><li>代表：MySQL、Oracle、SQL Server</li><li>通过表和表、行和列之间的关系进行数据库的存储</li></ul><p> <strong>非关系型数据库</strong>：(NoSQL) Not Only</p><ul><li><p>代表：Redis、MongDB</p></li><li><p>特点：对象存储</p></li></ul><h2 id="1-3、数据模型"><a href="#1-3、数据模型" class="headerlink" title="1.3、数据模型"></a>1.3、数据模型</h2><blockquote><p><strong>根据抽象级别定义4种模型</strong></p></blockquote><ul><li><p><strong>概念模型：</strong>从用户角度描述数据库整体结构，现在常用E-R图表示</p><p>实体间联系：1对1、1对多、多对多</p></li><li><p><strong>逻辑模型：</strong>表达数据库逻辑结构，包括层次模型、网状模型、关系模型</p></li><li><p><strong>外部模型：</strong>逻辑模型的一个逻辑子集，根据业务特点设计</p></li><li><p><strong>内部模型：</strong>又称物理模型，描述在磁盘的存储方式</p></li></ul><blockquote><p><strong>关系模型</strong></p></blockquote><p><strong>概念：</strong>包括 数据结构、数据操作、数据的完整性约束</p><ul><li>关系型数据模型的数据结构<ul><li>关系：一个关系就是<strong>一张规范的二维表</strong>，表中的每一列<strong>不可再分</strong>（不能有表中表）</li><li>元组：表中的一行</li><li>主键：能唯一识别元组的最小属性集合，<strong>只能有一个</strong></li><li>候选键：可以有多个，和主键一样非空唯一</li><li>属性：表中的一列即为一个属性，每个属性有一个属性名</li><li>域：列（属性）的取值范围</li><li>关系模式：关系名即表名（属性1，属性2……，属性n）</li></ul></li><li>关系数据库模型的操作：增删改查</li><li>完整性约束<ul><li>实体完整性：主键不能为null</li><li>参照完整性：外键为空或为被参照关系中主键的某个值</li><li>用户定义完整性</li></ul></li></ul><h2 id="1-4、数据库体系结构"><a href="#1-4、数据库体系结构" class="headerlink" title="1.4、数据库体系结构"></a>1.4、数据库体系结构</h2><ul><li>外模式（子模式、用户模式）：又称用户<strong>视图</strong>，用户能直接看到，可以有多个</li><li>概念模式（模式、逻辑模式）：数据库全体数据的逻辑结构和特征的描述，只能有一个</li><li>内模式（存储、物理模式）：物理结构和存储方式的描述，只能有一个</li></ul><p><strong>数据独立性</strong>：</p><ul><li>物理独立性：内模式—–概念模式实现，程序和数据的独立</li><li>逻辑独立性：外模式—–概念模式实现，程序和逻辑的独立</li></ul><h2 id="1-5、SQL语言组成"><a href="#1-5、SQL语言组成" class="headerlink" title="1.5、SQL语言组成"></a>1.5、SQL语言组成</h2><ul><li><strong>数据定义语言DDL：</strong>数据定义语句，定义、修改、删除数据库中的对象<ul><li>包括CREATE、ALTER、DROP、RENAME以及删除TRUNCATE</li></ul></li><li><strong>数据操纵语言DML：</strong>数据操纵语句，增删改查</li><li><strong>数据控制语言DCL：</strong>数据控制语句，定义用户的访问权限和安全级别<ul><li>事务：ROLLBACK、COMMIT、SAVEPOINT</li><li>权限管理：GRANT、REMOVE</li><li>锁定数据库表实现并发控制：LOCKTABLE</li></ul></li></ul><blockquote><p>DCL</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>      <span class="comment">-- 授予访问权限</span></span><br><span class="line"><span class="keyword">REVOKE</span>     <span class="comment">-- 撤销访问权限</span></span><br><span class="line"><span class="keyword">COMMIT</span>     <span class="comment">-- 提交事务处理</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>   <span class="comment">-- 事务处理回退</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span>  <span class="comment">-- 设置保存点</span></span><br><span class="line">LOCK       <span class="comment">-- 对数据库的特定部分进行锁定</span></span><br></pre></td></tr></table></figure><h1 id="2、MySQL的安装"><a href="#2、MySQL的安装" class="headerlink" title="2、MySQL的安装"></a>2、MySQL的安装</h1><h2 id="2-1、环境安装"><a href="#2-1、环境安装" class="headerlink" title="2.1、环境安装"></a>2.1、环境安装</h2><blockquote><p>Windows环境</p></blockquote><ol><li><p>配置环境变量：下载安装包解压</p></li><li><p>创建my.ini文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">basedir=D:\mysql-5.7.33\</span><br><span class="line">datadir=D:\mysql-5.7.33\data\</span><br><span class="line">port=3306</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure></li><li><p>管理员运行DOC窗口转到bin目录下</p></li><li><p>输入mysqld -install安装</p></li><li><p>输入mysqld –initialize-insecure –console</p></li><li><p>输入net start mysql启动mysql</p></li><li><p>输入mysql -uroot -p     进入mysql</p></li><li><p>输入update mysql.user set authentication_string=password(‘123456’) where user=’root’and Host=’localhost’;       修改密码</p></li><li><p>输入flush privileges; 刷新权限</p></li><li><p>net stop mysql</p></li><li><p>net start mysql</p></li></ol><p><strong>Sqlyog创建数据库：</strong>选utf-8和utf8_general_ci   创建表：引擎选InnoDB</p><blockquote><p>Linux环境：使用docker</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看Linux服务器上是否安装过MySQL</span></span><br><span class="line">rpm -qa | grep -i mysql # 查询出所有mysql依赖包</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、拉取镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、创建实例并启动</span></span><br><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /root/mysql/log:/var/log/mysql \</span><br><span class="line">-v /root/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /root/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=333 \</span><br><span class="line">-d mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、mysql配置 /root/mysql/conf/my.conf</span></span><br><span class="line">[client]</span><br><span class="line"><span class="meta">#</span><span class="bash">mysqlde utf8字符集默认为3位的，不支持emoji表情及部分不常见的汉字，故推荐使用utf8mb4</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta">#</span><span class="bash">设置client连接mysql时的字符集,防止乱码</span></span><br><span class="line">init_connect=&#x27;SET collation_connection = utf8_general_ci&#x27;</span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">数据库默认字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">数据库字符集对应一些排序等规则，注意要和character-set-server对应</span></span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 跳过mysql程序起动时的字符参数设置 ，使用服务器端字符集设置</span></span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！</span></span><br><span class="line">skip-name-resolve</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、重启mysql容器</span></span><br><span class="line">docker restart mysql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、进入到mysql容器</span></span><br><span class="line">docker exec -it mysql /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6、查看修改的配置文件</span></span><br><span class="line">cat /etc/mysql/my.conf</span><br></pre></td></tr></table></figure><p><strong>安装位置：</strong></p><p><code>Docker</code>容器就是一个小型的<code>Linux</code>环境，进入到<code>MySQL</code>容器中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p><code>Linux</code>环境下<code>MySQL</code>的安装目录。</p><table><thead><tr><th>路径</th><th>解释</th></tr></thead><tbody><tr><td><code>/var/lib/mysql</code></td><td>MySQL数据库文件存放位置</td></tr><tr><td><code>/usr/share/mysql</code></td><td>错误消息和字符集文件配置</td></tr><tr><td><code>/usr/bin</code></td><td>客户端程序和脚本</td></tr><tr><td><code>/etc/init.d/mysql</code></td><td>启停脚本相关</td></tr></tbody></table><h2 id="2-2、修改字符集"><a href="#2-2、修改字符集" class="headerlink" title="2.2、修改字符集"></a>2.2、修改字符集</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、进入到mysql数据库并查看字符集</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> show variables like <span class="string">&#x27;character%&#x27;</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> show variables like <span class="string">&#x27;%char%&#x27;</span>;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show variables like <span class="string">&#x27;character%&#x27;</span>;</span></span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show variables like <span class="string">&#x27;%char%&#x27;</span>;</span></span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p><code>MySQL5.7</code>配置文件位置是<code>/etc/my.cnf</code>或者<code>/etc/mysql/my.cnf</code>，如果字符集不是<code>utf-8</code>直接进入配置文件修改即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置client连接mysql时的字符集,防止乱码</span></span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line">init_connect=&#x27;SET collation_connection = utf8_general_ci&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据库默认字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">数据库字符集对应一些排序等规则，注意要和character-set-server对应</span></span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 跳过mysql程序起动时的字符参数设置 ，使用服务器端字符集设置</span></span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！</span></span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><p><strong>注意：安装<code>MySQL</code>完毕之后，第一件事就是修改字符集编码。</strong></p><h2 id="2-3、配置文件"><a href="#2-3、配置文件" class="headerlink" title="2.3、配置文件"></a>2.3、配置文件</h2><p><strong><code>MySQL</code>配置文件讲解：<a href="https://www.cnblogs.com/gaoyuechen/p/10273102.html">https://www.cnblogs.com/gaoyuechen/p/10273102.html</a></strong></p><p>1、二进制日志<code>log-bin</code>：主从复制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> my,cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启mysql binlog功能</span></span><br><span class="line">log-bin=mysql-bin</span><br></pre></td></tr></table></figure><p>2、错误日志<code>log-error</code>：默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> my,cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据库错误日志文件</span></span><br><span class="line">log-error = error.log</span><br></pre></td></tr></table></figure><p>3、查询日志<code>log</code>：默认关闭，记录查询的<code>sql</code>语句，如果开启会降低<code>MySQL</code>整体的性能，因为记录日志需要消耗系统资源。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> my,cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 慢查询sql日志设置</span></span><br><span class="line">slow_query_log = 1</span><br><span class="line">slow_query_log_file = slow.log</span><br></pre></td></tr></table></figure><p>4、数据文件。</p><ul><li><code>frm文件</code>：存放表结构。</li><li><code>myd</code>文件：存放表数据。</li><li><code>myi</code>文件：存放表索引。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mysql5.7 使用.frm文件来存储表结构</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 .ibd文件来存储表索引和表数据</span></span><br><span class="line">-rw-r-----  1 mysql mysql   8988 Jun 25 09:31 pms_category.frm</span><br><span class="line">-rw-r-----  1 mysql mysql 245760 Jul 21 10:01 pms_category.ibd</span><br></pre></td></tr></table></figure><p><code>MySQL5.7</code>的<code>Innodb</code>存储引擎可将所有数据存放于<code>ibdata*</code>的共享表空间，也可将每张表存放于独立的<code>.ibd</code>文件的独立表空间。<br>共享表空间以及独立表空间都是针对数据的存储方式而言的。</p><ul><li>共享表空间: 某一个数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在<code>data</code>目录下。 默认的文件名为<code>:ibdata1</code> 初始化为<code>10M</code>。</li><li>独立表空间: 每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个<code>.frm</code>表描述文件，还有一个<code>.ibd</code>文件。 其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下它的存储位置也是在表的位置之中。在配置文件<code>my.cnf</code>中设置： <code>innodb_file_per_table</code>。</li></ul><h1 id="3、MySQL的基本概念"><a href="#3、MySQL的基本概念" class="headerlink" title="3、MySQL的基本概念"></a>3、MySQL的基本概念</h1><h2 id="3-1、MySQL逻辑架构"><a href="#3-1、MySQL逻辑架构" class="headerlink" title="3.1、MySQL逻辑架构"></a>3.1、MySQL逻辑架构</h2><p><img src="/img/MySQL/1.jpg"></p><ul><li><p><code>Connectors</code>：指的是不同语言中与SQL的交互。</p></li><li><p><code>Connection Pool</code>：管理缓冲用户连接，线程处理等需要缓存的需求。<strong>MySQL数据库的连接层。</strong></p></li><li><p><code> Management Serveices &amp; Utilities</code>：系统管理和控制工具。备份、安全、复制、集群等等。。</p></li><li><p><code>SQL Interface</code>：接受用户的SQL命令，并且返回用户需要查询的结果。</p></li><li><p><code>Parser</code>：SQL语句解析器。</p></li><li><p><code>Optimizer</code>：查询优化器，SQL语句在查询之前会使用查询优化器对查询进行优化。<strong>就是优化客户端请求query</strong>，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果。<strong>For Example</strong>： <code>select uid,name from user where gender = 1;</code>这个<code>select </code>查询先根据<code>where </code>语句进行选取，而不是先将表全部查询出来以后再进行<code>gender</code>过滤；然后根据<code>uid</code>和<code>name</code>进行属性投影，而不是将属性全部取出以后再进行过滤。最后将这两个查询条件联接起来生成最终查询结果。</p></li><li><p><code>Caches &amp; Buffers</code>：查询缓存。</p></li><li><p><code>Pluggable Storage Engines</code>：<strong>存储引擎接口。MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎(注意：存储引擎是基于表的，而不是数据库)。</strong></p></li><li><p><code>File System</code>：数据落地到磁盘上，就是文件的存储。</p></li></ul><p>MySQL数据库和其他数据库相比，MySQL有点与众不同，主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需求选择合适的存储引擎。</p><blockquote><p>逻辑架构分层</p></blockquote><p><img src="/img/MySQL/2.jpg"></p><ul><li><p>连接层：最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于<code>tcp/ip</code>的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于<code>SSL</code>的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p></li><li><p>服务层：MySQL的核心服务功能层，该层是MySQL的核心，包括查询缓存，解析器，解析树，预处理器，查询优化器。主要进行查询解析、分析、查询缓存、内置函数、存储过程、触发器、视图等，select操作会先检查是否命中查询缓存，命中则直接返回缓存数据，否则解析查询并创建对应的解析树。</p></li><li><p>引擎层：存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p></li><li><p>存储层：数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p></li></ul><h2 id="3-2、MySQL的引擎"><a href="#3-2、MySQL的引擎" class="headerlink" title="3.2、MySQL的引擎"></a>3.2、MySQL的引擎</h2><p><code>show engines;</code>命令查看MySQL5.7支持的存储引擎。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show engines;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200801170442428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70" alt="存储引擎"></p><p><code>show variables like &#39;default_storage_engine%&#39;;</code>查看当前数据库正在使用的存储引擎。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show variables like <span class="string">&#x27;default_storage_engine%&#x27;</span>;</span></span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| default_storage_engine | InnoDB |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p>InnoDB和MyISAM对比</p></blockquote><table><thead><tr><th></th><th>MYISAM</th><th>INNODB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持</td><td>支持</td></tr><tr><td>数据表锁定</td><td>支持</td><td>支持</td></tr><tr><td>外键约束</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表空间大小</td><td>较小</td><td>较大，约为2倍</td></tr></tbody></table><ul><li>MYISAM：节约空间，速度较快，每次查询具有原子性</li><li>INNODB：安全性高，支持事务处理，回滚，崩溃修复能力，事务安全ACID</li></ul><blockquote><p>在物理空间的位置：</p></blockquote><p><strong>所有数据库文件都在data目录下，一个文件夹对应一个数据库，本质还是文件的存储</strong></p><p><strong>INNODB：</strong></p><ul><li>数据库表中只有一个*.frm文件，以及上级目录的ibdata1文件</li></ul><p><strong>MYISAM：</strong></p><ul><li>*.frm： 表数据库的定义文件</li><li>*.MYD：数据文件</li><li>*.MYI： 索引文件</li></ul><h2 id="3-3、数据库的字段类型"><a href="#3-3、数据库的字段类型" class="headerlink" title="3.3、数据库的字段类型"></a>3.3、数据库的字段类型</h2><blockquote><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a><strong>整型</strong></h4></blockquote><ul><li>tinyint：        很小的数据  1字节</li><li>smallint：     较小数据   2字节</li><li>mediumint：中等大小   3字节</li><li>int：              标准整数   4字节</li><li>bigint：         较大的数据  8字节</li></ul><blockquote><p><strong>小数</strong></p></blockquote><ul><li>float：           浮点数    4字节</li><li>double</li><li>decimal          字符串形式浮点数 金融计算的时候一般是使用decaimal</li></ul><blockquote><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h4></blockquote><ul><li>char         字符串固定大小   0~255</li><li>varcahr    可变字符串           0~6535</li><li>tingtext   微型文本                2^8-1</li><li>text          文本串                   2^16-1</li></ul><blockquote><p><strong>二进制字符串</strong></p></blockquote><ul><li>binary</li><li>varbinary</li></ul><blockquote><h4 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h4></blockquote><ul><li>date           YYYY-MM-DD         日期</li><li>time           HH：mm：ss       时间格式</li><li>datatime         日期时间(最常用)</li><li>timestamp      时间戳，1970.1.1到现在的毫秒数</li><li>year                 年份表示</li></ul><blockquote><h4 id="4、Null"><a href="#4、Null" class="headerlink" title="4、Null"></a>4、Null</h4></blockquote><ul><li>没有值</li></ul><h2 id="3-4、数据库的字段属性"><a href="#3-4、数据库的字段属性" class="headerlink" title="3.4、数据库的字段属性"></a>3.4、数据库的字段属性</h2><ul><li><p>Unsigned： 无符号<strong>整数</strong>，不能为负数</p></li><li><p>Zerofill：  不足的位数使用0来填充</p></li><li><p>自增：   自动在上一条记录的基础上+1，必须整数类型，可以设计起始值和步长</p></li><li><p>非空：   </p></li><li><p>默认：   默认值</p></li></ul><h2 id="3-5、MySQL常用函数"><a href="#3-5、MySQL常用函数" class="headerlink" title="3.5、MySQL常用函数"></a>3.5、MySQL常用函数</h2><h3 id="1、MySQL常量"><a href="#1、MySQL常量" class="headerlink" title="1、MySQL常量"></a>1、MySQL常量</h3><ul><li>字符串：         单引号’ ‘ 或双引号”   “</li><li>数值：             直接用</li><li>日期和时间： 单引号’ ‘ </li><li>布尔                 1表示true   0表示false</li><li>NULL                NULL参与运算，结果仍为NULL</li></ul><h3 id="2、常用函数"><a href="#2、常用函数" class="headerlink" title="2、常用函数"></a>2、常用函数</h3><blockquote><p>数学运算</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ABS</span>(<span class="number">-8</span>)            <span class="comment">-- 绝对值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEILING</span>(<span class="number">9.4</span>)       <span class="comment">-- 下上取整</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">9.4</span>)         <span class="comment">-- 向下</span></span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">45.926</span>, <span class="number">2</span>)   <span class="comment">-- 四舍五入 45.3</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">1600</span>, <span class="number">300</span>)     <span class="comment">-- 求余数 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> RAND()             <span class="comment">-- 0~1的绝对值</span></span><br><span class="line"><span class="keyword">SELECT</span> SIGN(<span class="number">10</span>)           <span class="comment">-- 判断符号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">3.14159</span>,<span class="number">2</span>)  <span class="comment">-- 截取前面2位</span></span><br></pre></td></tr></table></figure><blockquote><p>字符串</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOWER</span>()                       <span class="comment">-- 小写</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">UPPER</span>()                       <span class="comment">-- 大写</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>()                 <span class="comment">-- 长度</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;是&#x27;</span>)              <span class="comment">-- 拼接字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;HelloWorld&#x27;</span>,<span class="number">1</span>,<span class="number">5</span>)      <span class="comment">-- 截取字符串,第1个开始截取5个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INSERT</span>(<span class="string">&#x27;我爱学习&#x27;</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">&#x27;不&#x27;</span>)    <span class="comment">-- 替换字符串，返回  我不习</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;wzh&#x27;</span>,<span class="string">&#x27;h&#x27;</span>)              <span class="comment">-- 返回h第一次出现的索引</span></span><br><span class="line"><span class="keyword">SELECT</span> REPLACE(<span class="string">&#x27;坚持学习&#x27;</span>,<span class="string">&#x27;学习&#x27;</span>,<span class="string">&#x27;吃&#x27;</span>) <span class="comment">-- 替换</span></span><br></pre></td></tr></table></figure><blockquote><p>时间和日期</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span>()    <span class="comment">-- 当前日期</span></span><br><span class="line"><span class="keyword">SELECT</span> CURDATE()         <span class="comment">-- 当前日期</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW()             <span class="comment">-- 当前时间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOCALTIME</span>()       <span class="comment">-- 本地时间</span></span><br><span class="line"><span class="keyword">SELECT</span> SYSDATE()         <span class="comment">-- 系统时间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(NOW())       <span class="comment">-- 年份</span></span><br></pre></td></tr></table></figure><h3 id="3、聚合函数"><a href="#3、聚合函数" class="headerlink" title="3、聚合函数"></a>3、聚合函数</h3><ul><li>COUNT()  计数  //不会忽略null值</li><li>SUM()   求和</li><li>AVG()   p平均值</li><li>MAX()   最大值</li><li>MIN()   最小值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不能在where中使用，可以在having中使用</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(id) <span class="keyword">FROM</span> student         <span class="comment">-- 会忽略NULL值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student          <span class="comment">-- 不会忽略NULL值，本质是计算行数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> student          <span class="comment">-- 不会忽略NULL值，本质是计算行数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(age) <span class="keyword">AS</span> 年龄 <span class="keyword">FROM</span> student   <span class="comment">-- 计算总和</span></span><br></pre></td></tr></table></figure><h3 id="4、MD5加密"><a href="#4、MD5加密" class="headerlink" title="4、MD5加密"></a>4、MD5加密</h3><p>MD5加密是<strong>不可逆</strong>的过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">插入后加密：</span><br><span class="line">UPDATE student <span class="keyword">SET</span> `pwd` <span class="operator">=</span> MD5(`pwd`) <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">插入时加密：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (id,`name`,`pwd`,`sex`)<span class="keyword">VALUES</span>(<span class="number">9</span>,<span class="string">&#x27;李三啊&#x27;</span>,MD5(<span class="number">1258</span>),<span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>检验：</strong>将用户传递进来的密码，进行MD5加密然后对比加密的值</p><h2 id="3-6、SQL性能下降的原因"><a href="#3-6、SQL性能下降的原因" class="headerlink" title="3.6、SQL性能下降的原因"></a>3.6、SQL性能下降的原因</h2><ul><li>查询语句写的差。</li><li>索引失效：索引建了，但是没有用上。</li><li>关联 查询太多<code>join</code>（设计缺陷或者不得已的需求）。</li><li>服务器调优以及各个参数的设置（缓冲、线程数等）。</li></ul><h1 id="4、DDL结构化语句"><a href="#4、DDL结构化语句" class="headerlink" title="4、DDL结构化语句"></a>4、DDL结构化语句</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>   <span class="comment">-- 创建数据库表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>    <span class="comment">-- 更改表结构、添加、删除、修改列长度</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>     <span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX   <span class="comment">-- 在表上建立索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX     <span class="comment">-- 删除索引</span></span><br></pre></td></tr></table></figure><h2 id="4-1、DDL之创建数据库"><a href="#4-1、DDL之创建数据库" class="headerlink" title="4.1、DDL之创建数据库"></a>4.1、DDL之创建数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Show</span> databases;             <span class="comment">-- 展示所有数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> school;    <span class="comment">-- 创建school数据库</span></span><br><span class="line">USE school;                 <span class="comment">-- 使用school数据库</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE school;       <span class="comment">-- 删除数据库</span></span><br></pre></td></tr></table></figure><h2 id="4-2、DDL之创建表"><a href="#4-2、DDL之创建表" class="headerlink" title="4.2、DDL之创建表"></a>4.2、DDL之创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `student` (          <span class="comment">-- 创建student表</span></span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;学号&#x27;</span>,  <span class="comment">-- 自增</span></span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;张三&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">`pwd` <span class="type">VARCHAR</span>(<span class="number">20</span>),              <span class="comment">-- COMMENT  </span></span><br><span class="line">`sex` <span class="type">VARCHAR</span>(<span class="number">2</span>),               <span class="comment">-- DEFAULT 默认值</span></span><br><span class="line">`birthday` DATETIME,            <span class="comment">-- NOT NULL 非空</span></span><br><span class="line">`addrss` <span class="type">VARCHAR</span>(<span class="number">100</span>),          <span class="comment">-- AUTO_INCREMENT 自增</span></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8            <span class="comment">-- 设置引擎和编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student2 <span class="keyword">as</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student    <span class="comment">-- 子查询创建表</span></span><br><span class="line">USE student;                                      <span class="comment">-- 选择student表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 扩展</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE school    <span class="comment">-- 显示数据库的sql语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student      <span class="comment">-- 显示创建表的sql语句</span></span><br><span class="line"><span class="keyword">DESC</span> student                   <span class="comment">-- 显示表结构</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> student               <span class="comment">-- 显示表结构</span></span><br></pre></td></tr></table></figure><h2 id="4-3、DDL之表的修改"><a href="#4-3、DDL之表的修改" class="headerlink" title="4.3、DDL之表的修改"></a>4.3、DDL之表的修改</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表添加列（字段）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` <span class="keyword">ADD</span> age <span class="type">INT</span>(<span class="number">3</span>)<span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;18&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> studtnet          <span class="comment">-- 删除student表，表结构不在</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> student       <span class="comment">-- 截断student表，表结构仍在</span></span><br><span class="line">                                       <span class="comment">-- 注意截断的表不能回滚，删除的可以</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` <span class="keyword">DROP</span> age1        <span class="comment">-- 删除字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` RENAME <span class="keyword">AS</span> s               <span class="comment">-- 重命名表名 </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` <span class="keyword">to</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` CHANGE age age1 <span class="type">INT</span>(<span class="number">2</span>)    <span class="comment">-- 重命名字段名,必须指定类型和大小</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` MODIFY age <span class="type">VARCHAR</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;18&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span> </span><br></pre></td></tr></table></figure><h2 id="4-4、数据约束"><a href="#4-4、数据约束" class="headerlink" title="4.4、数据约束"></a>4.4、数据约束</h2><p><strong>注意到：</strong>创建表之后字段后面跟的一大堆就是对字段的约束</p><ul><li>为了保证数据的一致性和完整性，SQL规范以约束的方式对表数据进行额外的条件限制</li><li>约束是表级的强制规定</li><li>可以在创建表时规定约束、或者在表创建之后</li></ul><p><strong>六种约束</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NOT</span> <span class="keyword">NULL</span>       <span class="comment">-- 非空约束，规定某个字段不能为空</span></span><br><span class="line"><span class="keyword">UNIQUE</span>         <span class="comment">-- 唯一约束，规定某个字段在整个表中是唯一的</span></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY    <span class="comment">-- 主键(非空且唯一) </span></span><br><span class="line"><span class="keyword">FOREIGN</span> KEY    <span class="comment">-- 外键</span></span><br><span class="line"><span class="keyword">CHECK</span>          <span class="comment">-- 检查约束  -- 可以使用但是mysql没有效果</span></span><br><span class="line"><span class="keyword">DEFAULT</span>        <span class="comment">-- 默认值</span></span><br></pre></td></tr></table></figure><p><strong>分类：</strong></p><ul><li>列级：只能约束单个字段</li><li>表级：可以约束多个字段</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- not null 非空约束</span></span><br><span class="line">id <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>                                <span class="comment">-- 建表时添加</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp MODIFY sex <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;   <span class="comment">-- 增加约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp MODIFY sex <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span>;       <span class="comment">-- 取消约束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- UNIQUE 唯一约束默认创建唯一索引，注意不同字段直接可以重复</span></span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>;</span><br><span class="line"><span class="keyword">CONSTRAINT</span> uk_name_pwd <span class="keyword">UNIQUE</span>(NAME)                 <span class="comment">-- 建表时添加，用户名不能重复</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(NAME,PASSWORD);         <span class="comment">-- 增加约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> uk_name_pwd <span class="keyword">UNIQUE</span>(NAME,PASSWORD);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> MODIFY NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> INDEX uk_name_pwd;   <span class="comment">-- 删除约束,没自定义名字的话为字段名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 主键约束 一个表只能有一个</span></span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT        <span class="comment">-- 建表时添加主键</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> id <span class="keyword">PRIMARY</span> KEY(id,name)         <span class="comment">-- 表级才能定义多个子弹和定义别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;               <span class="comment">-- 删除约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(name,pwd);      <span class="comment">-- 添加约束，已存在就不能添加</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> MODIFY id <span class="type">INT</span>(<span class="number">2</span>) <span class="keyword">PRIMARY</span> KEY;   <span class="comment">-- 修改约束，已存在就不能修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外键约束 FOREIGN KEY </span></span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (`gradeid`) REFERNECES `grade`(`id`)   <span class="comment">-- 关联年级表(grade)的id字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` <span class="keyword">ADD</span> 加上                      <span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY emp_dept_id_fk;   <span class="comment">-- 删除外键</span></span><br></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- not null  default</span></span><br><span class="line">id <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">20</span>;                    <span class="comment">-- 建表时添加</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp MODIFY sex <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;   <span class="comment">-- MODIFY修改字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 主键 PRIMARY KEY、唯一约束 UNIQUE</span></span><br><span class="line">id <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">UNIQUE</span><span class="operator">/</span><span class="keyword">PRIMARY</span>;     <span class="comment">-- 建表时列级范围添加</span></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY<span class="operator">/</span><span class="keyword">UNIQUE</span>(name,pwd);  <span class="comment">-- 建表时标记范围添加  取别名 CONSTRAINT 名字 </span></span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (`gradeid`) REFERNECES `grade`(`id`)   <span class="comment">-- 外键关联年级表(grade)的id字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">ADD</span> 形式<span class="number">2</span><span class="operator">/</span><span class="number">3</span>;             <span class="comment">-- ADD添加约束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> INDEX 约束名称;      <span class="comment">-- DROP删除约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 约束名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Modifty 不建议使用</span></span><br></pre></td></tr></table></figure><h2 id="4-5、索引入门"><a href="#4-5、索引入门" class="headerlink" title="4.5、索引入门"></a>4.5、索引入门</h2><h3 id="1、索引的定义"><a href="#1、索引的定义" class="headerlink" title="1、索引的定义"></a>1、索引的定义</h3><p><strong>官方定义：</strong>索引（INDEX）是帮助MySQL高效获取数据的数据结果。</p><p><strong>索引的本质：</strong>索引是排好序的快速查找数据结构。</p><p><strong>举例：</strong>索引的目的在于提高查询效率，可以类比字典的目录。如果要查<code>mysql</code>这个这个单词，我们肯定要先定位到<code>m</code>字母，然后从上往下找<code>y</code>字母，再找剩下的<code>sql</code>。如果没有索引，那么可能需要<code>a---z</code>，这样全字典扫描，如果我想找<code>Java</code>开头的单词呢？如果我想找<code>Oracle</code>开头的单词呢？？？</p><p><strong>重点：</strong>索引会影响到<code>MySQL查找(WHERE的查询条件)和排序(ORDER BY)</code>两大功能！</p><p><strong>结构：</strong>数据库维护着一个满足特定查找算法的<code>数据结构</code>，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们平时所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种数据结构的索引之外，还有哈希索引（Hash Index）等。</span><br></pre></td></tr></table></figure><p><strong>位置：</strong>索引往往以索引文件的形式存储在磁盘上。</p><h3 id="2、索引的优劣"><a href="#2、索引的优劣" class="headerlink" title="2、索引的优劣"></a>2、索引的优劣</h3><p><strong>优势：</strong></p><ul><li>查找：类似大学图书馆的书目索引，提高数据检索的效率，降低数据库的IO成本。</li><li>排序：通过索引対数据进行排序，降低数据排序的成本，降低了CPU的消耗。</li></ul><p><strong>劣势：</strong></p><ul><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，也要占用空间的。</li><li>虽然索引大大提高了查询速度，但是同时会<strong>降低表的更新速度</strong>，因为表更新，索引也得更新。索引文件每次更新添加的索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li></ul><h3 id="3、索引的分类"><a href="#3、索引的分类" class="headerlink" title="3、索引的分类"></a>3、索引的分类</h3><blockquote><p>根据索引的类型</p></blockquote><ul><li><strong>主键索引 PRIMARY KEY</strong>： 自动创建，主键不可重复，只能有一个列作为主键</li><li><strong>唯一索引 UNIQUE KEY：</strong>可以有多个，索引列本列的值是唯一的，为可以空</li><li><strong>外键索引 FOREIGN KEY：</strong>MySQL会自动添加索引</li><li><strong>普通索引 KEY/INDEX ：</strong></li><li><strong>全文索引FULLTEXT ：</strong>特定的数据库引擎（MYISAM）才有</li></ul><blockquote><p>根据索引的列多少</p></blockquote><ul><li><strong>单值索引：</strong>一个索引只包含单个列，一个表可以有多个单列索引。</li><li><strong>复合索引：</strong>一个索引包含多个字段。</li></ul><blockquote><p>按照数据结构分类</p></blockquote><ul><li><code>BTree</code>索引。</li><li><code>Hash</code>索引。</li><li><code>Full-text</code>全文索引。</li><li><code>R-Tree</code>索引。</li></ul><p>B树索引的原理：</p><p><img src="/img/MySQL/4.jpg"></p><h3 id="4、约束和索引的区别"><a href="#4、约束和索引的区别" class="headerlink" title="4、约束和索引的区别"></a>4、约束和索引的区别</h3><blockquote><p>唯一约束和唯一索引</p></blockquote><ul><li>创建唯一约束 会 自动创建唯一索引；二者都能实现对数据的唯一性约束</li><li>单独创建的唯一索引可以单独删除；唯一约束自动创建的唯一索引，唯一索引不能单独删除</li><li>想作为外键必须要有唯一约束</li></ul><blockquote><p>主键和外键</p></blockquote><p>索引都是伴随约束出现的，不能单独创建。这里不确定，个人猜测。</p><h3 id="5、创建、删除索引"><a href="#5、创建、删除索引" class="headerlink" title="5、创建、删除索引"></a>5、创建、删除索引</h3><p><strong>建议：</strong>一张表建的索引最好不要超过5个！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1、创建索引 [UNIQUE]表示唯一索引 */</span></span><br><span class="line">[<span class="keyword">UNIQUE</span>] INDEX sex1(sex)                        <span class="comment">-- 建表时为sex添加索引sex1</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] INDEX indexName <span class="keyword">ON</span> tabName(columnName(length));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、删除索引 */</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX [indexName] <span class="keyword">ON</span> tabName;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、查看索引 */</span></span><br><span class="line"><span class="comment">/* 加上\G就可以以列的形式查看了 不加\G就是以表的形式查看 */</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> tabName \G;</span><br></pre></td></tr></table></figure><h3 id="6、索引使用建议"><a href="#6、索引使用建议" class="headerlink" title="6、索引使用建议"></a>6、索引使用建议</h3><blockquote><p>不要建索引的情况</p></blockquote><ul><li><p>记录太少的表。</p></li><li><p>经常增删改的表、频繁更新的字段不适合创建索引。</p></li><li><p>Where条件里用不到的字段不创建索引。</p></li><li><p>一个字段在整列中的属性值大部分都一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假如一个表有10万行记录，有一个字段A只有true和false两种值，并且每个值的分布概率大约为50%，那么对A字段建索引一般不会提高数据库的查询速度。索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>需要建索引的情况</p></blockquote><ul><li>主键自动建立主键索引（唯一 + 非空）。</li><li>频繁作为查询条件的字段应该创建索引。</li><li>查询中与其他表关联的字段，<code>外键关系</code>建立索引，（MySQL外键字段添加索引，不加索引导致死锁）</li><li>查询中排序（order by）的字段</li><li>查询中统计或者分组字段（group by也和索引有关）。</li></ul><blockquote><p>多表Join语句优化</p></blockquote><ul><li>尽可能减少<code>JOIN</code>语句中的<strong>嵌套循环</strong>的总次数：<strong>永远都是小的结果集驱动大的结果集</strong>。</li><li>左连接右边表建索引,</li><li>优先优化<code>NestedLoop</code>的内层循环。</li><li>保证<code>JOIN</code>语句中被驱动表上<code>JOIN</code>条件字段已经被索引。</li><li>当无法保证被驱动表的<code>JOIN</code>条件字段被索引且内存资源充足的前提下，不要太吝惜<code>Join Buffer</code> 的设置。</li></ul><h1 id="5、DML增删改查"><a href="#5、DML增删改查" class="headerlink" title="5、DML增删改查"></a>5、DML增删改查</h1><h2 id="5-1、DML语言之增删改"><a href="#5-1、DML语言之增删改" class="headerlink" title="5.1、DML语言之增删改"></a>5.1、DML语言之增删改</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 增</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (id,name,pwd,sex)<span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;wzh&#x27;</span>,<span class="number">123456</span>,<span class="string">&#x27;男&#x27;</span>)   </span><br><span class="line"><span class="comment">-- 增加操作，可以只增加部分值，剩下的不写，或者写NULL</span></span><br><span class="line"><span class="comment">-- 插入的值 可以用子查询的数据替代</span></span><br><span class="line"><span class="comment">-- 插入的数据可以用 NOW() 等函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改</span></span><br><span class="line">UPDATE student <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;zk&#x27;</span>,pwd<span class="operator">=</span><span class="number">234</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>                </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>                     <span class="comment">-- 清空表后自增列不变</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="number">9</span><span class="operator">+</span><span class="number">2</span>)          <span class="comment">-- 可以利用子查询删除</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> student                     <span class="comment">-- 清空表会重新设置自增列，不会影响事务</span></span><br></pre></td></tr></table></figure><p> DELETE删除后重启数据库：    </p><ul><li>INNODB：自增列从1开始(存在内存中)</li><li>MYISAM：继续从上一个自增量开始</li></ul><h2 id="5-2、DML语言之查"><a href="#5-2、DML语言之查" class="headerlink" title="5.2、DML语言之查"></a>5.2、DML语言之查</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> <span class="operator">|</span> DISTINCTROW <span class="operator">|</span> TOP ] </span><br><span class="line">&#123;<span class="operator">*</span><span class="operator">|</span>talbe.<span class="operator">*</span><span class="operator">|</span>[table.]field1[<span class="keyword">AS</span> alias1][,[table.]field2[<span class="keyword">AS</span> alias2][,…]]&#125;   <span class="comment">--- 查的字段</span></span><br><span class="line"><span class="keyword">FROM</span> 表名[<span class="keyword">as</span> 别名]    <span class="comment">-- 从哪些表中选择</span></span><br><span class="line">[<span class="keyword">left</span> <span class="operator">|</span> <span class="keyword">right</span> <span class="operator">|</span> <span class="keyword">inner</span> <span class="keyword">join</span> 表名<span class="number">2</span> ]  <span class="comment">-- 联合查询</span></span><br><span class="line">[<span class="keyword">IN</span> externaldatabase] </span><br><span class="line">[<span class="keyword">WHERE</span>…]       <span class="comment">--  结果满足的条件</span></span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span>…]    <span class="comment">-- 按照那些字段分组</span></span><br><span class="line">[<span class="keyword">HAVING</span>…]      <span class="comment">-- 过滤分组记录满足的条件</span></span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span>…]    <span class="comment">-- 结果排序</span></span><br><span class="line">[limit ]       <span class="comment">-- 分页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--注意： 必须严格按照顺序来</span></span><br></pre></td></tr></table></figure><blockquote><p>1、查询全部</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `student`</span><br></pre></td></tr></table></figure><blockquote><p>2、查询指定的字段（使用别名）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.`id` <span class="keyword">AS</span> ID <span class="keyword">FROM</span> `student` <span class="keyword">AS</span> s  <span class="comment">-- 字段使用``</span></span><br><span class="line"><span class="keyword">SELECT</span> s.`id` <span class="string">&#x27;ID&#x27;</span> <span class="keyword">FROM</span> `student` `s`    <span class="comment">-- 字段别名&#x27;&#x27;,表取别名``</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id ID <span class="keyword">FROM</span> student s            <span class="comment">-- 不用任何字符</span></span><br></pre></td></tr></table></figure><blockquote><p>3、concat函数</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;学号:&#x27;</span>,id) <span class="keyword">AS</span> ID <span class="keyword">FROM</span> student <span class="comment">-- 拼接字符串</span></span><br></pre></td></tr></table></figure><blockquote><p>4、对结果操作</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age<span class="operator">+</span><span class="number">1</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">11</span> </span><br></pre></td></tr></table></figure><blockquote><p>5、去重</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> `id` <span class="keyword">FROM</span> student    <span class="comment">-- 使用 DISTINCT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> age,id <span class="keyword">FROM</span> <span class="keyword">USER</span>     <span class="comment">-- DISTINCT作用于所有列，如这里，只有id和age均相同，才会被去重 </span></span><br></pre></td></tr></table></figure><blockquote><p>6、where筛选</p></blockquote><ul><li>算数运算判断：&lt;    &lt;    =   &gt;   &gt;=     !=    =     &lt;&gt;(name &lt;&gt; ‘张三’ 即名字不为张三)</li><li>逻辑比较判断：AND或者&amp;&amp;    OR或者||     NOT或者！</li><li>之间判断：        BETWEEN   AND</li><li>之内判断：       IN</li><li>模糊匹配：       LIKE</li><li>空值判断：       IS   [NOT]  NULL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mysql 优先计算And 其次计算 or</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">18</span> <span class="comment">-- id为6 或者 id为3且age为18</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> (id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">3</span>) <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">18</span>  <span class="comment">-- id为6或3 且 age为18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL的 NOT 支持对 BETWEEN、IN、EXISTS 搭配使用 </span></span><br></pre></td></tr></table></figure><blockquote><p>7、模糊查询：比较运算符</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">12</span> <span class="comment">-- 查询区间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;张%&#x27;</span>      <span class="comment">-- %表示任意字符,表示张....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;张_&#x27;</span>      <span class="comment">-- _表示一个字符,表示张x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="keyword">IN</span>(<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>)      <span class="comment">-- 查询id为11、12、13之内的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> addrss <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>   <span class="comment">-- 查询address不为空</span></span><br></pre></td></tr></table></figure><blockquote><p>8、使用正则表达式查询</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> NAME REGEXP <span class="string">&#x27;1000&#x27;</span>  <span class="comment">-- 使用正则表达式，匹配包含1000的字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> NAME REGEXP <span class="string">&#x27;1000|2000&#x27;</span>  <span class="comment">--  与</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> NAME REGEXP <span class="string">&#x27;[JT]&#x27;</span>       <span class="comment">-- 字符为J或者T 等于 J|T</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> NAME REGEXP <span class="string">&#x27;[^J]&#x27;</span>       <span class="comment">-- 字符不为J</span></span><br></pre></td></tr></table></figure><blockquote><p>9、相等连接（内连接）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接student表和teacher表中id相等的行</span></span><br><span class="line"><span class="keyword">SELECT</span> s.name <span class="keyword">FROM</span> student s,teacher t <span class="keyword">WHERE</span> s.id<span class="operator">=</span>t.id              <span class="comment">-- 使用where</span></span><br><span class="line"><span class="keyword">SELECT</span> s.name <span class="keyword">FROM</span> student s <span class="keyword">INNER</span> <span class="keyword">JOIN</span> teacher t <span class="keyword">ON</span> s.id<span class="operator">=</span>t.id   <span class="comment">-- 使用join连接</span></span><br><span class="line">                          <span class="comment">-- INNER可以省略</span></span><br></pre></td></tr></table></figure><blockquote><p>10、高级连接</p></blockquote><ul><li>左连接：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.name,t.pwd <span class="keyword">FROM</span> student s <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> teacher t <span class="keyword">ON</span> s.id<span class="operator">=</span>t.id</span><br><span class="line"><span class="comment">-- 把student表的所有字段和teacher表的中满足条件的连接起来</span></span><br><span class="line"><span class="comment">-- 没有的字段会显示null</span></span><br><span class="line"><span class="comment">-- 此语句中会显示所有student表中的数据，满足内连接条件的会有t.pwd的值，其他都会显示为null</span></span><br><span class="line"><span class="comment">-- 直接left join也可以</span></span><br></pre></td></tr></table></figure><ul><li>右连接：左连接反过来</li><li>全连接：MySQL目前不支持</li><li>自连接</li></ul><blockquote><p>11、子查询:where语句中嵌套select语句，最多嵌套255层</p></blockquote><ul><li>返回单值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.name <span class="keyword">FROM</span> student s <span class="keyword">WHERE</span> s.id <span class="operator">=</span> (<span class="keyword">SELECT</span> t.id <span class="keyword">FROM</span> teacher t <span class="keyword">WHERE</span> t.name<span class="operator">=</span><span class="string">&#x27;李三&#x27;</span>)</span><br><span class="line"><span class="comment">-- &lt;  &gt; 等等</span></span><br></pre></td></tr></table></figure><ul><li><p>返回多值：必须使用多值比较运算符</p><p><strong>IN</strong></p><p><strong>ALL</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.name <span class="keyword">FROM</span> student s <span class="keyword">WHERE</span> s.age <span class="operator">&gt;</span><span class="keyword">ALL</span>(<span class="keyword">SELECT</span> t.age <span class="keyword">FROM</span> teacher t <span class="keyword">WHERE</span> t.id<span class="operator">&gt;</span><span class="number">3</span>)                         <span class="comment">-- s.age必须大于所有返回的结果</span></span><br></pre></td></tr></table></figure><p><strong>ANY</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.name <span class="keyword">FROM</span> student s <span class="keyword">WHERE</span> s.age <span class="operator">&gt;</span><span class="keyword">ANY</span>(<span class="keyword">SELECT</span> t.age <span class="keyword">FROM</span> teacher t <span class="keyword">WHERE</span> t.id<span class="operator">&gt;</span><span class="number">3</span>)                         <span class="comment">-- s.age大于其中某一个即可</span></span><br></pre></td></tr></table></figure><p><strong>EXISTS</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">-- 将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则EXISTS子句返回TRUE，这一行行可作为外查询的结果行，否则不能作为结果。</span></span><br><span class="line"><span class="keyword">SELECT</span> s.age <span class="keyword">FROM</span> student s <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher t <span class="keyword">WHERE</span> s.id<span class="operator">=</span>t.id)</span><br></pre></td></tr></table></figure></li></ul><p><strong>子查询的作用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="number">3</span> <span class="keyword">AS</span> id)                  <span class="comment">-- 过滤数据 </span></span><br><span class="line"><span class="keyword">SELECT</span> id,NAME,(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> o <span class="keyword">WHERE</span> o.id <span class="operator">=</span> c.id) <span class="keyword">FROM</span> c <span class="comment">-- 作为计算字段</span></span><br></pre></td></tr></table></figure><blockquote><p>12.合并查询结果</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 语句<span class="number">1</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> 语句<span class="number">2</span></span><br><span class="line"><span class="comment">-- 语句1和语句2查询的结果必须完全一致，Union自动去重</span></span><br><span class="line"><span class="comment">-- 只能使用一条order by 语句且在最后一条语句后面</span></span><br></pre></td></tr></table></figure><blockquote><p>13、分组过滤：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,pwd <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> name,id <span class="keyword">HAVING</span> id <span class="operator">&gt;</span><span class="number">4</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br><span class="line"><span class="comment">-- 所有相同的name的分成一组，每组的结果只选第一个</span></span><br><span class="line"><span class="comment">-- 可以按照多列分组</span></span><br><span class="line"><span class="comment">-- having只能和group by 一直使用，作用是进一步筛选</span></span><br><span class="line"><span class="comment">-- 通常配合聚合函数使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配合聚合函数</span></span><br></pre></td></tr></table></figure><blockquote><p>14、排序</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span>   <span class="comment">--  升序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span>  <span class="comment">--  降序</span></span><br></pre></td></tr></table></figure><blockquote><p>15、分页</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span> LIMIT <span class="number">10</span>,<span class="number">3</span>  <span class="comment">-- 从第11行开始显示，每页3个数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span> LIMIT <span class="number">10</span>    <span class="comment">-- 前10条语句</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span> LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">3</span>; <span class="comment">-- 相当于 limit 3,10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span> LIMIT <span class="number">10</span>,<span class="number">-1</span>  <span class="comment">-- 检索到最后一条数据</span></span><br></pre></td></tr></table></figure><h2 id="4-3、七种JOIN理论总结"><a href="#4-3、七种JOIN理论总结" class="headerlink" title="4.3、七种JOIN理论总结"></a>4.3、七种JOIN理论总结</h2><p><img src="/img/MySQL/3.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A INNER JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key WHERE B.Key IS NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"><span class="comment">/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 1+2 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key</span><br><span class="line">UNION</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL OR B.Key IS NULL;</span><br><span class="line"><span class="comment">/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 4+5 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key WHERE B.Key IS NULL;</span><br><span class="line">UNION</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL;</span><br></pre></td></tr></table></figure><h1 id="6、DCL语句"><a href="#6、DCL语句" class="headerlink" title="6、DCL语句"></a>6、DCL语句</h1><h2 id="6-1、DCL：事务"><a href="#6-1、DCL：事务" class="headerlink" title="6.1、DCL：事务"></a>6.1、DCL：事务</h2><h3 id="1、事务原则"><a href="#1、事务原则" class="headerlink" title="1、事务原则"></a>1、事务原则</h3><ul><li>原子性：要么都成功，要么都失败</li><li>一致性：事务执行前后都满足**数据库的完整性约束 **，如A、B转账前后总和不变</li><li>隔离性：多个事务互不影响</li><li>持久性：事务完成后，持久化</li></ul><h3 id="2、手动执行事务"><a href="#2、手动执行事务" class="headerlink" title="2、手动执行事务"></a>2、手动执行事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>   <span class="comment">-- 关闭事务，MySQL时默认开始事务提交的，要手动操作必须先关闭事务</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">1</span>   <span class="comment">-- 开启事务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">START</span> TRANSACTION    <span class="comment">-- 事务开始</span></span><br><span class="line"><span class="keyword">COMMIT</span>               <span class="comment">-- 事务提交，一旦提交就持久化了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名               <span class="comment">-- 记录保存点，可以回滚到改点</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> 保存点名   <span class="comment">-- 回滚</span></span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名       <span class="comment">-- 撤销保存点名</span></span><br></pre></td></tr></table></figure><h3 id="3、并发问题"><a href="#3、并发问题" class="headerlink" title="3、并发问题"></a>3、并发问题</h3><ul><li><strong>读脏数据：</strong>     事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li><strong>不可重复读：</strong> 一个事务对同一数据两次读到的<strong>值</strong>不同</li><li><strong>幻影读：</strong>        事务B对表 table 进行读取，在此过程中事务A对表 table 增加了一条数据，事务B修改完毕后发现<strong>还有一条数据没有读取</strong>，好像发生了环境</li></ul><blockquote><p>事务隔离级别</p></blockquote><table><thead><tr><th>级别</th><th>约束</th></tr></thead><tbody><tr><td>READ UNCOMMITTED（未提交读）</td><td>没有限制</td></tr><tr><td>READ COMMITTED（提交读）</td><td>不允许读未提交的数据，但是数据仍然可能在事务结束前被修改</td></tr><tr><td>REPEATABLE READ（可重复读）</td><td>保证一个事务中重复读到的数据保持同样的值，但允许其他用户将新幻影行插入数据集</td></tr><tr><td>SERIALIZABLE（可串行读）</td><td>不允许其他用户在事务完成前更新数据集或者将行插入到数据集</td></tr></tbody></table><table><thead><tr><th>隔离级别</th><th>丢失更新</th><th>读脏数据</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED（未提交读）</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>READ COMMITTED（已提交读）</td><td>否</td><td>否</td><td>是</td><td>是</td></tr><tr><td>REPEATABLE READ（可重复度）</td><td>否</td><td>否</td><td>否</td><td>是</td></tr><tr><td>SERIALIZABLE（可串行读）</td><td>否</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置MySQL连接的隔离级别</span></span><br><span class="line"><span class="keyword">set</span> transaction isolation level read committed;</span><br><span class="line"><span class="comment">-- 设置数据库系统的全局的隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE  <span class="comment">-- 设置可串行读</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION    <span class="comment">-- 事务开始</span></span><br><span class="line"><span class="keyword">COMMIT</span>               <span class="comment">-- 事务提交</span></span><br></pre></td></tr></table></figure><h3 id="4、MySQL的表级锁（偏读）"><a href="#4、MySQL的表级锁（偏读）" class="headerlink" title="4、MySQL的表级锁（偏读）"></a>4、MySQL的表级锁（偏读）</h3><blockquote><p>特点</p></blockquote><p>偏向<code>MyISAM</code>存储引擎，开销小，加锁快，<strong>无死锁</strong>，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><blockquote><p>使用</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lcok TABLES student READ;    <span class="comment">-- 上锁，读锁    WRITE为写锁</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES;            <span class="comment">-- 查看数据库表锁的命令</span></span><br><span class="line">UNLOCK <span class="keyword">TABLE</span>;                <span class="comment">-- 解锁</span></span><br></pre></td></tr></table></figure><blockquote><p>案例说明</p></blockquote><p><strong>案例说明—-读锁：</strong>打开两个会话，<code>SESSION1</code>为<code>mylock</code>表添加读锁。</p><ul><li>SESSION1 可以读mylock表、不可以修改mylock表、不可以读其他的表</li><li>SESSION2 可以读mylock表、修改mylock表会被阻塞，需要等待SESSION1释放mylock表、可以读其他表</li></ul><p><strong>案例说明—-写锁：</strong>打开两个会话，<code>SESSION1</code>为<code>mylock</code>表添加写锁。</p><ul><li>SESSION1 可以读mylock的表、可以修改mylock表、不可以读其他的表</li><li>SESSION2 可以读mylock表、修改mylock表会被阻塞，需要等待SESSION1释放mylock表、可以读其他表</li></ul><blockquote><p>结论</p></blockquote><p><strong><code>MyISAM</code>引擎在执行查询语句<code>SELECT</code>之前，会自动给涉及到的所有表加读锁，在执行增删改之前，会自动给涉及的表加写锁。</strong></p><p>MySQL的表级锁有两种模式：</p><ul><li><p>表共享读锁（Table Read Lock）。</p></li><li><p>表独占写锁（Table Write Lock）。</p></li></ul><p>対<code>MyISAM</code>表进行操作，会有以下情况：</p><ul><li>対<code>MyISAM</code>表的读操作（加读锁），不会阻塞其他线程対同一表的读操作，但是会阻塞其他线程対同一表的写操作。只有当读锁释放之后，才会执行其他线程的写操作。</li><li>対<code>MyISAM</code>表的写操作（加写锁），会阻塞其他线程対同一表的读和写操作，只有当写锁释放之后，才会执行其他线程的读写操作。</li></ul><p><strong>此外，<code>MyISAM</code>的读写锁调度是写优先，这也是<code>MyISAM</code>不适合作为主表的引擎。因为写锁后，其他线程不能进行任何操作，大量的写操作会使查询很难得到锁，从而造成永远阻塞。</strong></p><h3 id="5、MySQL的行级锁（偏写）"><a href="#5、MySQL的行级锁（偏写）" class="headerlink" title="5、MySQL的行级锁（偏写）"></a>5、MySQL的行级锁（偏写）</h3><blockquote><p>特点</p></blockquote><p>偏向<code>InnoDB</code>存储引擎，开销大，加锁慢；会出现<strong>死锁</strong>；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p><ul><li>MyISAM采用表级锁(table-level locking)。</li><li>InnoDB⽀持行级锁(row-level locking)和表级锁,默认为行级锁</li></ul><blockquote><p>使用</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION    <span class="comment">-- 事务开启</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;     <span class="comment">-- 共享锁（读锁）、允许其他会话读</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> UPDATE;             <span class="comment">-- 排他锁（写锁）、禁止其他会话读</span></span><br><span class="line"><span class="comment">-- 增删改语句MySQL会自动加上隐式排它锁、select不会加锁</span></span><br><span class="line"><span class="keyword">commit</span>               <span class="comment">---提交后自动解锁</span></span><br></pre></td></tr></table></figure><blockquote><p>案例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 案例1</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `b` <span class="operator">=</span> <span class="string">&#x27;88&#x27;</span> <span class="keyword">WHERE</span> `a` <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- SESSION1写操作，但是没有commit。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test_innodb_lock`;      <span class="comment">-- SESSION2是读不到SESSION1未提交的数据的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `b` <span class="operator">=</span> <span class="string">&#x27;99&#x27;</span> <span class="keyword">WHERE</span> `a` <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">-- SESSION1写操作，但是没有commit</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `b` <span class="operator">=</span> <span class="string">&#x27;asdasd&#x27;</span> <span class="keyword">WHERE</span> `a` <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- SESSION2写操作会阻塞到1执行完</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例3</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `b` <span class="operator">=</span> <span class="string">&#x27;8976&#x27;</span> <span class="keyword">WHERE</span> `a` <span class="operator">=</span> <span class="number">6</span>;   <span class="comment">-- SESSION1写操作，</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `b` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">WHERE</span> `a` <span class="operator">=</span> <span class="number">4</span>;  <span class="comment">-- SESSION2写操作其他行不受影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例4 索引失效行锁变表锁</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `a` <span class="operator">=</span> <span class="number">888</span> <span class="keyword">WHERE</span> `b` <span class="operator">=</span> <span class="number">8000</span>;  <span class="comment">-- `b`没有加单引号，索引失效</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `b` <span class="operator">=</span> <span class="string">&#x27;1314&#x27;</span> <span class="keyword">WHERE</span> `a` <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 操作不同行，但是阻塞</span></span><br></pre></td></tr></table></figure><blockquote><p>间隙锁</p></blockquote><p><strong>概念：</strong>当我们用范围条件而不是相等条件检索数据，并请求共享或者排他锁时，<code>InnoDB</code>会给符合条件的已有数据记录的索引项加锁，对于键值在条件范围内但并不存在的记录，叫做”间隙(GAP)”。</p><p><code>InnoDB</code>也会对这个”间隙”加锁，这种锁的机制就是所谓的”间隙锁”。</p><p><strong>危害：</strong>因为<code>Query</code>执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值不存在。</p><p>间隙锁有一个比较致命的缺点，就是<strong>当锁定一个范围的键值后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。</strong>在某些场景下这可能会対性能造成很大的危害。</p><blockquote><p>总结</p></blockquote><p><code>InnoDB</code>存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于<code>MyISAM</code>的表级锁定的。当系统并发量较高的时候，<code>InnoDB</code>的整体性能和<code>MyISAM</code>相比就会有比较明显的优势了。</p><p>但是，<code>InnoDB</code>的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让<code>InnoDB</code>的整体性能表现不仅不能比<code>MyISAM</code>高，甚至可能会更差。</p><h2 id="6-2、DCL：权限管理"><a href="#6-2、DCL：权限管理" class="headerlink" title="6.2、DCL：权限管理"></a>6.2、DCL：权限管理</h2><blockquote><p>用户管理</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> wzh<span class="variable">@localhost</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>    <span class="comment">-- 创建用户wzh，密码123456</span></span><br><span class="line">        <span class="comment">-- @后面是主机名，如果指定了那么创建的用户必须通过该主机连接</span></span><br><span class="line">        <span class="comment">-- 并且修改也必须带上@主机名</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;123456&#x27;</span>)                     <span class="comment">-- 修改本机密码</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> wzh<span class="variable">@localhost</span> <span class="operator">=</span> PASSWORD(<span class="string">&#x27;1234566&#x27;</span>)  <span class="comment">-- 指定用户修改密码</span></span><br><span class="line">RENAME <span class="keyword">USER</span> wzh<span class="variable">@localhost</span> <span class="keyword">TO</span> wzh                      <span class="comment">-- 更改用户名</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> wzh                                         <span class="comment">-- 删除用户</span></span><br></pre></td></tr></table></figure><blockquote><p>权限管理</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> wzh    <span class="comment">-- 授权对所有表的所有权限给wzh用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> school.student <span class="keyword">TO</span> wzh  <span class="comment">--只给school数据库的student表的所有权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> wzh                   <span class="comment">-- 显示用户wzh的权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> wzh <span class="comment">-- 撤销权限</span></span><br></pre></td></tr></table></figure><blockquote><p>角色管理：MySQL8.0新增</p></blockquote><p>如果用户被授予角色权限，则该用户拥有该角色的权限。</p><h1 id="7、数据库的备份"><a href="#7、数据库的备份" class="headerlink" title="7、数据库的备份"></a>7、数据库的备份</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导出  导出：多张表不要加逗号，用空格就行</span></span><br><span class="line"><span class="comment">--         主机名                      数据库  表          文件名      </span></span><br><span class="line">mysqldump <span class="operator">-</span>hlocalhost <span class="operator">-</span>uroot <span class="operator">-</span>p123456 school student <span class="operator">&gt;</span>D:<span class="operator">/</span>a.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导入</span></span><br><span class="line">source d:<span class="operator">/</span>a.sql                     <span class="comment">-- 已经登录</span></span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p123456 库名<span class="operator">&lt;</span>备份文件   <span class="comment">-- 未登录</span></span><br></pre></td></tr></table></figure><h1 id="8、MySQL索引失效"><a href="#8、MySQL索引失效" class="headerlink" title="8、MySQL索引失效"></a>8、MySQL索引失效</h1><blockquote><p>数据准备</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `staffs`(</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">24</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">`age` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">`pos` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;职位&#x27;</span>,</span><br><span class="line">`add_time` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;入职时间&#x27;</span></span><br><span class="line">)COMMENT <span class="string">&#x27;员工记录表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `staffs`(`name`,`age`,`pos`) <span class="keyword">VALUES</span>(<span class="string">&#x27;Ringo&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;manager&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `staffs`(`name`,`age`,`pos`) <span class="keyword">VALUES</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;dev&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `staffs`(`name`,`age`,`pos`) <span class="keyword">VALUES</span>(<span class="string">&#x27;李四&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;dev&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建索引 */</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_staffs_name_age_pos <span class="keyword">ON</span> `staffs`(`name`,`age`,`pos`);</span><br></pre></td></tr></table></figure><blockquote><p>索引失效的情况</p></blockquote><ul><li>最佳左前缀法则</li><li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换）</li><li>索引中范围条件右边的字段会全部失效。</li><li>尽量使用覆盖索引（只访问索引的查询，索引列和查询列一致），减少<code>SELECT *</code>。</li><li>MySQL在使用<code>!=</code>、<code>&lt;&gt;</code>、<code>is null</code>、<code>is not null</code>索引失效</li><li><code>like</code>以通配符开头<code>%abc</code>索引失效会变成全表扫描。</li><li>字符串不加单引号，容易导致类型转换，最终索引失效。</li><li>少用<code>or</code>，用它来连接时会索引失效。</li></ul><h2 id="8-1、最佳左前缀法则"><a href="#8-1、最佳左前缀法则" class="headerlink" title="8.1、最佳左前缀法则"></a>8.1、最佳左前缀法则</h2><p><strong>概念：</strong>复合索引（A，B，C），索引B生效的条件是必须用到A字段，C生效条件是必须用到A和B</p><p><strong>注意：</strong>order by 、group by算使用到，但是要严格按照顺序 where B group by A，C  不失效    C，A 失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name字段 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name, age字段 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name，age，pos字段 这是属于全值匹配的情况！！！*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 索引没用上，ALL全表扫描 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 索引没用上，ALL全表扫描 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name字段，pos字段索引失效 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;  <span class="comment">-- </span></span><br></pre></td></tr></table></figure><h2 id="8-2、索引列上不计算"><a href="#8-2、索引列上不计算" class="headerlink" title="8.2、索引列上不计算"></a>8.2、索引列上不计算</h2><p><strong>概念：</strong>where 语句后面的某条件上进行了计算，该索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span>;           <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(`name`, <span class="number">5</span>) <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span>;  <span class="comment">-- 失效</span></span><br></pre></td></tr></table></figure><h2 id="8-3、范围之后全失效"><a href="#8-3、范围之后全失效" class="headerlink" title="8.3、范围之后全失效"></a>8.3、范围之后全失效</h2><p><strong>概念：</strong>where 语句后面的某条件如 xx &gt; xx ，在这之后的语句索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name，age，pos字段 这是属于全值匹配的情况！！！*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name，age字段，pos字段索引失效 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">&gt;</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;dev&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="8-4、覆盖索引尽量用"><a href="#8-4、覆盖索引尽量用" class="headerlink" title="8.4、覆盖索引尽量用"></a>8.4、覆盖索引尽量用</h2><p><strong>覆盖索引：</strong>数据列只用从索引中就能够取得，不必从数据表中读取，即查询列要被所使用的索引覆盖。</p><p>所以在写SQL的不要使用<code>SELECT *</code>，用什么字段就查询什么字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 没有用到覆盖索引</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用到了覆盖索引</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `name`, `age`, `pos` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="8-5、不等有时会失效"><a href="#8-5、不等有时会失效" class="headerlink" title="8.5、不等有时会失效"></a>8.5、不等有时会失效</h2><p><strong>概念：</strong>where语句 使用  !=  索引有时候会失效 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> `name`, `age`, `pos` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">!=</span> <span class="string">&#x27;Ringo&#x27;</span>;  <span class="comment">-- 成功</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">!=</span> <span class="string">&#x27;Ringo&#x27;</span>;           <span class="comment">-- 失败</span></span><br></pre></td></tr></table></figure><h2 id="8-6、like百分加右边"><a href="#8-6、like百分加右边" class="headerlink" title="8.6、like百分加右边"></a>8.6、like百分加右边</h2><p><strong>概念</strong>： like  “%xxxxx” 这种形式索引会失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%ing%&#x27;</span>;    <span class="comment">-- 失败</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%ing&#x27;</span>;     <span class="comment">-- 失败</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;Rin%&#x27;</span>;     <span class="comment">-- 成功</span></span><br></pre></td></tr></table></figure><h2 id="8-7、字符要加单引号"><a href="#8-7、字符要加单引号" class="headerlink" title="8.7、字符要加单引号"></a>8.7、字符要加单引号</h2><p><strong>概念：</strong>字符串不加单引号容易发生强制类型转换，索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> `id`, `name` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="number">2000</span>;   <span class="comment">-- 使用覆盖索引，未失效</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="number">2000</span>;      <span class="comment">-- 失效</span></span><br></pre></td></tr></table></figure><h2 id="8-8、索引相关题目"><a href="#8-8、索引相关题目" class="headerlink" title="8.8、索引相关题目"></a>8.8、索引相关题目</h2><p><strong>假设index(a,b,c)</strong></p><table><thead><tr><th>Where语句</th><th>索引是否被使用</th></tr></thead><tbody><tr><td>where a = 3</td><td>Y，使用到a</td></tr><tr><td>where a = 3 and b = 5</td><td>Y，使用到a，b</td></tr><tr><td>where a = 3 and b = 5</td><td>Y，使用到a，b，c</td></tr><tr><td>where b = 3 或者 where b = 3 and c = 4 或者 where c = 4</td><td>N，没有用到a字段</td></tr><tr><td>where a = 3 and c = 5</td><td>使用到a，但是没有用到c，因为b断了</td></tr><tr><td>where a = 3 and b &gt; 4 and c = 5</td><td>使用到a，b，但是没有用到c，因为c在范围之后</td></tr><tr><td>where a = 3 and b like ‘kk%’ and c = 4</td><td>Y，a，b，c都用到</td></tr><tr><td>where a = 3 and b like ‘%kk’ and c = 4</td><td>只用到a</td></tr><tr><td>where a = 3 and b like ‘%kk%’ and c = 4</td><td>只用到a</td></tr><tr><td>where a = 3 and b like ‘k%kk%’ and c = 4</td><td>Y，a，b，c都用到</td></tr></tbody></table><h2 id="8-9、面试题分析"><a href="#8-9、面试题分析" class="headerlink" title="8.9、面试题分析"></a>8.9、面试题分析</h2><blockquote><p>数据准备</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建表 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test03`(</span><br><span class="line">`id` <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`c1` <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">`c2` <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">`c3` <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">`c4` <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">`c5` <span class="type">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;a1&#x27;</span>,<span class="string">&#x27;a2&#x27;</span>,<span class="string">&#x27;a3&#x27;</span>,<span class="string">&#x27;a4&#x27;</span>,<span class="string">&#x27;a5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;b1&#x27;</span>,<span class="string">&#x27;b22&#x27;</span>,<span class="string">&#x27;b3&#x27;</span>,<span class="string">&#x27;b4&#x27;</span>,<span class="string">&#x27;b5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>,<span class="string">&#x27;c4&#x27;</span>,<span class="string">&#x27;c5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;d1&#x27;</span>,<span class="string">&#x27;d2&#x27;</span>,<span class="string">&#x27;d3&#x27;</span>,<span class="string">&#x27;d4&#x27;</span>,<span class="string">&#x27;d5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;e1&#x27;</span>,<span class="string">&#x27;e2&#x27;</span>,<span class="string">&#x27;e3&#x27;</span>,<span class="string">&#x27;e4&#x27;</span>,<span class="string">&#x27;e5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建复合索引 */</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_test03_c1234 <span class="keyword">ON</span> `test03`(`c1`,`c2`,`c3`,`c4`);</span><br></pre></td></tr></table></figure><blockquote><p>题目</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最好索引怎么创建的，就怎么用，按照顺序使用，避免让MySQL再自己去翻译一次 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.全值匹配 用到索引c1 c2 c3 c4全字段 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">=</span> <span class="string">&#x27;a3&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">=</span> <span class="string">&#x27;a3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">=</span> <span class="string">&#x27;a3&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4.用到索引c1 c2 c3字段，c4字段失效，范围之后全失效 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">&gt;</span> <span class="string">&#x27;a3&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">&gt;</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">=</span> <span class="string">&#x27;a3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   6.用到了索引c1 c2 c3三个字段, c1和c2两个字段用于查找,  c3字段用于排序了但是没有统计到key_len中，c4字段失效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c3`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7.用到了索引c1 c2 c3三个字段，c1和c2两个字段用于查找, c3字段用于排序了但是没有统计到key_len中*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c3`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   8.用到了索引c1 c2两个字段，c4失效，c1和c2两个字段用于查找，c4字段排序产生了Using filesort说明排序没有用到c4字段 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c4`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 9.用到了索引c1 c2 c3三个字段，c1用于查找，c2和c3用于排序 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c5` <span class="operator">=</span> <span class="string">&#x27;a5&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c2`, `c3`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 10.用到了c1一个字段，c1用于查找，c3和c2两个字段索引失效，产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c5` <span class="operator">=</span> <span class="string">&#x27;a5&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c3`, `c2`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 11.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span>  `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c2, c3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 12.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span>  `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c5` <span class="operator">=</span> <span class="string">&#x27;a5&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c2, c3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   13.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 没有产生Using filesort </span></span><br><span class="line"><span class="comment">      因为之前c2这个字段已经确定了是&#x27;a2&#x27;了，这是一个常量，再去ORDER BY c3,c2 这时候c2已经不用排序了！</span></span><br><span class="line"><span class="comment">      所以没有产生Using filesort 和(10)进行对比学习！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c5` <span class="operator">=</span> <span class="string">&#x27;a5&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c3, c2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GROUP BY 表面上是叫做分组，但是分组之前必定排序。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 14.用到c1 c2 c3三个字段，c1用于查找，c2 c3用于排序，c4失效 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> `c2`,`c3`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 15.用到c1这一个字段，c4失效，c2和c3排序失效产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> `c3`,`c2`;</span><br></pre></td></tr></table></figure><p><code>GROUP BY</code>基本上都需要进行排序，索引优化几乎和<code>ORDER BY</code>一致，但是<code>GROUP BY</code>会有临时表的产生。</p><h2 id="8-10、总结"><a href="#8-10、总结" class="headerlink" title="8.10、总结"></a>8.10、总结</h2><p>索引优化的一般性建议：</p><ul><li>对于单值索引，尽量选择针对当前<code>query</code>过滤性更好的索引。</li><li>在选择复合索引的时候，当前<code>query</code>中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择复合索引的时候，尽量选择可以能够包含当前<code>query</code>中的<code>where</code>子句中更多字段的索引。</li><li>尽可能通过分析统计信息和调整<code>query</code>的写法来达到选择合适索引的目的。</li></ul><p>口诀：</p><ul><li>带头大哥不能死。</li><li>中间兄弟不能断。</li><li>索引列上不计算。</li><li>范围之后全失效。</li><li>覆盖索引尽量用。</li><li>不等有时会失效。</li><li>like百分加右边。</li><li>字符要加单引号。</li><li>一般SQL少用or。</li></ul><h1 id="9、MySQL查询优化"><a href="#9、MySQL查询优化" class="headerlink" title="9、MySQL查询优化"></a>9、MySQL查询优化</h1><h2 id="9-1、小表驱动大表"><a href="#9-1、小表驱动大表" class="headerlink" title="9.1、小表驱动大表"></a>9.1、小表驱动大表</h2><blockquote><p>优化原则：对于MySQL数据库而言，永远都是小表驱动大表。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 举个例子：可以使用嵌套的for循环来理解小表驱动大表。</span></span><br><span class="line"><span class="comment">* 以下两个循环结果都是一样的，但是对于MySQL来说不一样，</span></span><br><span class="line"><span class="comment">* 第一种可以理解为，和MySQL建立5次连接每次查询1000次。</span></span><br><span class="line"><span class="comment">* 第一种可以理解为，和MySQL建立1000次连接每次查询5次。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IN和EXISTS</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 优化原则：小表驱动大表，即小的数据集驱动大的数据集 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IN适合B表比A表数据小的情况*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `A` <span class="keyword">WHERE</span> `id` <span class="keyword">IN</span> (<span class="keyword">SELECT</span> `id` <span class="keyword">FROM</span> `B`)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* EXISTS适合B表比A表数据大的情况 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `A` <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> `B` <span class="keyword">WHERE</span> `B`.id <span class="operator">=</span> `A`.id);</span><br></pre></td></tr></table></figure><p><strong>EXISTS：</strong></p><ul><li>语法：<code>SELECT....FROM tab WHERE EXISTS(subquery);</code>该语法可以理解为：</li><li>该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（<code>true</code>或是<code>false</code>）来决定主查询的数据结果是否得以保留。</li></ul><p><strong>提示：</strong></p><ul><li><code>EXISTS(subquery)</code>子查询只返回<code>true</code>或者<code>false</code>，因此子查询中的<code>SELECT *</code>可以是<code>SELECT 1 OR SELECT X</code>，它们并没有区别。</li><li><code>EXISTS(subquery)</code>子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担心效率问题，可进行实际检验以确定是否有效率问题。</li><li><code>EXISTS(subquery)</code>子查询往往也可以用条件表达式，其他子查询或者<code>JOIN</code>替代，何种最优需要具体问题具体分析。</li></ul><h2 id="9-2、ORDER-BY优化"><a href="#9-2、ORDER-BY优化" class="headerlink" title="9.2、ORDER BY优化"></a>9.2、ORDER BY优化</h2><blockquote><p>数据准备</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `talA`(</span><br><span class="line">`age` <span class="type">INT</span>,</span><br><span class="line">`birth` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">18</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">19</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">21</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">22</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">23</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建索引 */</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_talA_age_birth <span class="keyword">ON</span> `talA`(`age`, `birth`);</span><br></pre></td></tr></table></figure><blockquote><p>案例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1.使用索引进行排序了 不会产生Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">WHERE</span> `age` <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `age`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.使用索引进行排序了 不会产生Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">WHERE</span> `age` <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `age`,`birth`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.没有使用索引进行排序 产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">WHERE</span> `age` <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `birth`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4.没有使用索引进行排序 产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">WHERE</span> `age` <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `birth`,`age`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5.没有使用索引进行排序 产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `birth`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6.没有使用索引进行排序 产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">WHERE</span> `birth` <span class="operator">&gt;</span> <span class="string">&#x27;2020-08-04 07:42:21&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `birth`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7.使用索引进行排序了 不会产生Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">WHERE</span> `birth` <span class="operator">&gt;</span> <span class="string">&#x27;2020-08-04 07:42:21&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `age`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 8.没有使用索引进行排序 产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `age` <span class="keyword">ASC</span>, `birth` <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><code>ORDER BY</code>子句，尽量使用索引排序，避免使用<code>Using filesort</code>排序（未通过索引排序）。</p><p>MySQL支持两种方式的排序，<code>FileSort</code>和<code>Index</code>，<code>Index</code>的效率高，<code>FileSort</code>方式效率较低。</p><p><code>ORDER BY</code>满足两情况，会使用<code>Index</code>方式排序：</p><ul><li><code>ORDER BY</code>语句使用索引最左前列。</li><li>使用<code>WHERE</code>子句与<code>ORDER BY</code>子句条件列组合满足索引最左前列。</li></ul><p><strong>结论：尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀原则。</strong></p><blockquote><p>如果不在索引列上，File Sort有两种算法：MySQL就要启动双路排序算法和单路排序算法</p></blockquote><p>1、双路排序算法：MySQL4.1之前使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和<code>ORDER BY</code>列，対他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。<strong>一句话，从磁盘取排序字段，在<code>buffer</code>中进行排序，再从磁盘取其他字段。</strong></p><p>取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在MySQL4.1之后，出现了改进的算法，就是单路排序算法。</p><p>2、单路排序算法：从磁盘读取查询需要的所有列，按照<code>ORDER BY</code>列在<code>buffer</code>対它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。</p><p>由于单路排序算法是后出的，总体而言效率好过双路排序算法。</p><p>但是单路排序算法有问题：如果<code>SortBuffer</code>缓冲区太小，导致从磁盘中读取所有的列不能完全保存在<code>SortBuffer</code>缓冲区中，这时候单路复用算法就会出现问题，反而性能不如双路复用算法。</p><p><strong>单路复用算法的优化策略：</strong></p><ul><li>增大<code>sort_buffer_size</code>参数的设置。</li><li>增大<code>max_length_for_sort_data</code>参数的设置。</li></ul><p><strong>提高ORDER BY排序的速度：</strong></p><ul><li><p><code>ORDER BY</code>时使用<code>SELECT *</code>是大忌，查什么字段就写什么字段，这点非常重要。在这里的影响是：</p><ul><li>当查询的字段大小总和小于<code>max_length_for_sort_data</code>而且排序字段不是<code>TEXT|BLOB</code>类型时，会使用单路排序算法，否则使用多路排序算法。</li><li>两种排序算法的数据都有可能超出<code>sort_buffer</code>缓冲区的容量，超出之后，会创建<code>tmp</code>临时文件进行合并排序，导致多次IO，但是单路排序算法的风险会更大一些，所以要增大<code>sort_buffer_size</code>参数的设置。</li></ul></li><li><p>尝试提高<code>sort_buffer_size</code>：不管使用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。</p></li><li><p>尝试提高<code>max_length_for_sort_data</code>：提高这个参数，会增加用单路排序算法的概率。但是如果设置的太高，数据总容量<code>sort_buffer_size</code>的概率就增大，明显症状是高的磁盘IO活动和低的处理器使用率。</p></li></ul><h2 id="9-3、GORUP-BY优化"><a href="#9-3、GORUP-BY优化" class="headerlink" title="9.3、GORUP BY优化"></a>9.3、GORUP BY优化</h2><ul><li><p><code>GROUP BY</code>实质是先排序后进行分组，遵照索引建的最佳左前缀。</p></li><li><p>当无法使用索引列时，会使用<code>Using filesort</code>进行排序，增大<code>max_length_for_sort_data</code>参数的设置和增大<code>sort_buffer_size</code>参数的设置，会提高性能。</p></li><li><p><code>WHERE</code>执行顺序高于<code>HAVING</code>，能写在<code>WHERE</code>限定条件里的就不要写在<code>HAVING</code>中了。</p></li></ul><h2 id="9-4、总结"><a href="#9-4、总结" class="headerlink" title="9.4、总结"></a>9.4、总结</h2><p><strong>为排序使用索引</strong></p><ul><li>MySQL两种排序方式：<code>Using filesort</code>和<code>Index</code>扫描有序索引排序。</li><li>MySQL能为排序与查询使用相同的索引，创建的索引既可以用于排序也可以用于查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建a b c三个字段的索引 */</span></span><br><span class="line">idx_table_a_b_c(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.ORDER BY 能使用索引最左前缀 */</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b, c;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">DESC</span>, b <span class="keyword">DESC</span>, c <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.如果WHERE子句中使用索引的最左前缀定义为常量，则ORDER BY能使用索引 */</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c;</span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="string">&#x27;Tangs&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c;</span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> b <span class="operator">&gt;</span> <span class="number">2000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.不能使用索引进行排序 */</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">ASC</span>, b <span class="keyword">DESC</span>, c <span class="keyword">DESC</span>;  <span class="comment">/* 排序不一致 */</span></span><br><span class="line"><span class="keyword">WHERE</span> g <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c;   <span class="comment">/* 丢失a字段索引 */</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> c;      <span class="comment">/* 丢失b字段索引 */</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, d;   <span class="comment">/* d字段不是索引的一部分 */</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="keyword">IN</span> (...) <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c;  <span class="comment">/* 对于排序来说，多个相等条件(a=1 or a=2)也是范围查询 */</span></span><br></pre></td></tr></table></figure><h1 id="10、性能分析"><a href="#10、性能分析" class="headerlink" title="10、性能分析"></a>10、性能分析</h1><h2 id="8-1-EXPLAIN简介"><a href="#8-1-EXPLAIN简介" class="headerlink" title="8.1.EXPLAIN简介"></a>8.1.EXPLAIN简介</h2><blockquote><p>EXPLAIN是什么？</p></blockquote><p>EXPLAIN：SQL的执行计划，使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的。</p><blockquote><p>EXPLAIN怎么使用？</p></blockquote><p>语法：<code>explain</code> + <code>SQL</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select * from pms_category \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1425</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>EXPLAIN能干嘛？</p></blockquote><p>可以查看以下信息：</p><ul><li><code>id</code>：表的读取顺序。</li><li><code>select_type</code>：数据读取操作的操作类型。</li><li><code>possible_keys</code>：哪些索引可以使用。</li><li><code>key</code>：哪些索引被实际使用。</li><li><code>ref</code>：表之间的引用。</li><li><code>rows</code>：每张表有多少行被优化器查询。</li></ul><h2 id="8-2-EXPLAIN字段"><a href="#8-2-EXPLAIN字段" class="headerlink" title="8.2.EXPLAIN字段"></a>8.2.EXPLAIN字段</h2><blockquote><p>id</p></blockquote><p><code>id</code>：表的读取和加载顺序。</p><p>值有以下三种情况：</p><ul><li><code>id</code>相同，执行顺序由上至下。</li><li><code>id</code>不同，如果是子查询，id的序号会递增，<strong>id值越大优先级越高，越先被执行。</strong></li><li><code>id</code>相同不同，同时存在。<strong>永远是id大的优先级最高，id相等的时候顺序执行。</strong></li></ul><blockquote><p>select_type</p></blockquote><p><code>select_type</code>：数据查询的类型，主要是用于区别，普通查询、联合查询、子查询等的复杂查询。</p><ul><li><code>SIMPLE</code>：简单的<code>SELECT</code>查询，查询中不包含子查询或者<code>UNION </code>。</li><li><code>PRIMARY</code>：查询中如果包含任何复杂的子部分，最外层查询则被标记为<code>PRIMARY</code>。</li><li><code>SUBQUERY</code>：在<code>SELECT</code>或者<code>WHERE</code>子句中包含了子查询。</li><li><code>DERIVED</code>：在<code>FROM</code>子句中包含的子查询被标记为<code>DERIVED(衍生)</code>，MySQL会递归执行这些子查询，把结果放在临时表中。</li><li><code>UNION</code>：如果第二个<code>SELECT</code>出现在<code>UNION</code>之后，则被标记为<code>UNION</code>；若<code>UNION</code>包含在<code>FROM</code>子句的子查询中，外层<code>SELECT</code>将被标记为<code>DERIVED</code>。</li><li><code>UNION RESULT</code>：从<code>UNION</code>表获取结果的<code>SELECT</code>。</li></ul><blockquote><p>type</p></blockquote><p><code>type</code>：访问类型排列。</p><p><strong>从最好到最差依次是：</strong><code>system</code>&gt;<code>const</code>&gt;<code>eq_ref</code>&gt;<code>ref</code>&gt;<code>range</code>&gt;<code>index</code>&gt;<code>ALL</code>。除了<code>ALL</code>没有用到索引，其他级别都用到索引了。</p><p>一般来说，得保证查询至少达到<code>range</code>级别，最好达到<code>ref</code>。</p><ul><li><p><code>system</code>：表只有一行记录（等于系统表），这是<code>const</code>类型的特例，平时不会出现，这个也可以忽略不计。</p></li><li><p><code>const</code>：表示通过索引一次就找到了，<code>const</code>用于比较<code>primary key</code>或者<code>unique</code>索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>列表中，MySQL就能将该查询转化为一个常量。</p></li><li><p><code>eq_ref</code>：唯一性索引扫描，读取本表中和关联表表中的每行组合成的一行，查出来只有一条记录。除 了 <code>system</code> 和<code> const</code> 类型之外, 这是最好的联接类型。</p></li><li><p><code>ref</code>：非唯一性索引扫描，返回本表和关联表某个值匹配的所有行，查出来有多条记录。</p></li><li><p><code>range</code>：只检索给定范围的行，一般就是在<code>WHERE</code>语句中出现了<code>BETWEEN</code>、<code>&lt; &gt;</code>、<code>in</code>等的查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引树的某一点，而结束于另一点，不用扫描全部索引。</p></li><li><p><code>index</code>：<code>Full Index Scan</code>，全索引扫描，<code>index</code>和<code>ALL</code>的区别为<code>index</code>类型只遍历索引树。<strong>也就是说虽然<code>ALL</code>和<code>index</code>都是读全表，但是<code>index</code>是从索引中读的，<code>ALL</code>是从磁盘中读取的。</strong></p></li><li><p><code>ALL</code>：<code>Full Table Scan</code>，没有用到索引，全表扫描。</p></li></ul><blockquote><p>possible_keys 和 key</p></blockquote><p><code>possible_keys</code>：显示可能应用在这张表中的索引，一个或者多个。查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用。</strong></p><p><code>key</code>：实际使用的索引。如果为<code>NULL</code>，则没有使用索引。查询中如果使用了覆盖索引，则该索引仅仅出现在<code>key</code>列表中。</p><blockquote><p>key_len</p></blockquote><p><code>key_len</code>：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。<code>key_len</code>显示的值为索引字段的最大可能长度，并非实际使用长度，即<code>key_len</code>是根据表定义计算而得，不是通过表内检索出的。在不损失精度的情况下，长度越短越好。</p><p><code>key_len</code>计算规则：<strong><a href="https://blog.csdn.net/qq_34930488/article/details/102931490">https://blog.csdn.net/qq_34930488/article/details/102931490</a></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> desc pms_category;</span></span><br><span class="line">+---------------+------------+------+-----+---------+----------------+</span><br><span class="line">| Field         | Type       | Null | Key | Default | Extra          |</span><br><span class="line">+---------------+------------+------+-----+---------+----------------+</span><br><span class="line">| cat_id        | bigint(20) | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name          | char(50)   | YES  |     | NULL    |                |</span><br><span class="line">| parent_cid    | bigint(20) | YES  |     | NULL    |                |</span><br><span class="line">| cat_level     | int(11)    | YES  |     | NULL    |                |</span><br><span class="line">| show_status   | tinyint(4) | YES  |     | NULL    |                |</span><br><span class="line">| sort          | int(11)    | YES  |     | NULL    |                |</span><br><span class="line">| icon          | char(255)  | YES  |     | NULL    |                |</span><br><span class="line">| product_unit  | char(50)   | YES  |     | NULL    |                |</span><br><span class="line">| product_count | int(11)    | YES  |     | NULL    |                |</span><br><span class="line">+---------------+------------+------+-----+---------+----------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select cat_id from pms_category <span class="built_in">where</span> cat_id between 10 and 20 \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY  # 用到了主键索引，通过查看表结构知道，cat_id是bigint类型，占用8个字节</span><br><span class="line">      key_len: 8        # 这里只用到了cat_id主键索引，所以长度就是8！</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 11</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>ref</p></blockquote><p><code>ref</code>：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p><blockquote><p>rows</p></blockquote><p><code>rows</code>：根据表统计信息及索引选用情况，大致估算出找到所需的记录需要读取的行数。</p><blockquote><p>Extra</p></blockquote><p><code>Extra</code>：包含不适合在其他列中显示但十分重要的额外信息。</p><ul><li><code>Using filesort</code>：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<strong>MySQL中无法利用索引完成的排序操作成为”文件内排序”。</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 排序没有使用索引</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select name from pms_category <span class="built_in">where</span> name=<span class="string">&#x27;Tangs&#x27;</span> order by cat_level \G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_name_parentCid_catLevel</span><br><span class="line">          key: idx_name_parentCid_catLevel</span><br><span class="line">      key_len: 201</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index; Using filesort</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 排序使用到了索引</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select name from pms_category <span class="built_in">where</span> name=<span class="string">&#x27;Tangs&#x27;</span> order by parent_cid,cat_level\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_name_parentCid_catLevel</span><br><span class="line">          key: idx_name_parentCid_catLevel</span><br><span class="line">      key_len: 201</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><p><code>Using temporary</code>：使用了临时表保存中间结果，MySQL在対查询结果排序时使用了临时表。常见于排序<code>order by</code>和分组查询<code>group by</code>。<strong>临时表対系统性能损耗很大。</strong></p></li><li><p><code>Using index</code>：表示相应的<code>SELECT</code>操作中使用了覆盖索引，避免访问了表的数据行，效率不错！如果同时出现<code>Using where</code>，表示索引被用来执行索引键值的查找；如果没有同时出现<code>Using where</code>，表明索引用来读取数据而非执行查找动作。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 覆盖索引</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：如果要使用覆盖索引，一定不能写SELECT *，要写出具体的字段。</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select cat_id from pms_category \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL       </span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1425</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index   # select的数据列只用从索引中就能够取得，不必从数据表中读取   </span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><code>Using where</code>：表明使用了<code>WHERE</code>过滤。</li><li><code>Using join buffer</code>：使用了连接缓存。</li><li><code>impossible where</code>：<code>WHERE</code>子句的值总是false，不能用来获取任何元组。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select name from pms_category <span class="built_in">where</span> name = <span class="string">&#x27;zs&#x27;</span> and name = <span class="string">&#x27;ls&#x27;</span>\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: NULL</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">     filtered: NULL</span><br><span class="line">        Extra: Impossible WHERE   # 不可能字段同时查到两个名字</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="11、主从复制"><a href="#11、主从复制" class="headerlink" title="11、主从复制"></a>11、主从复制</h1><h2 id="11-1、复制基本原理"><a href="#11-1、复制基本原理" class="headerlink" title="11.1、复制基本原理"></a>11.1、复制基本原理</h2><p><img src="/img/MySQL/5.jpg"></p><p>MySQL复制过程分为三步：</p><ul><li>Master将改变记录到二进制日志(Binary Log)。这些记录过程叫做二进制日志事件，<code>Binary Log Events</code>；</li><li>Slave将Master的<code>Binary Log Events</code>拷贝到它的中继日志(Replay  Log);</li><li>Slave重做中继日志中的事件，将改变应用到自己的数据库中。MySQL复制是异步且串行化的。</li></ul><h2 id="10-2、复制基本原则"><a href="#10-2、复制基本原则" class="headerlink" title="10.2、复制基本原则"></a>10.2、复制基本原则</h2><ul><li>每个Slave只有一个Master。</li><li>每个Slave只能有一个唯一的服务器ID。</li><li>每个Master可以有多个Salve。</li></ul><h2 id="10-3、一主一从配置"><a href="#10-3、一主一从配置" class="headerlink" title="10.3、一主一从配置"></a>10.3、一主一从配置</h2><blockquote><p>1、基本要求：Master和Slave的MySQL服务器版本一致且后台以服务运行。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建mysql-slave1实例</span></span><br><span class="line">docker run -p 3307:3306 --name mysql-slave1 \</span><br><span class="line">-v /root/mysql-slave1/log:/var/log/mysql \</span><br><span class="line">-v /root/mysql-slave1/data:/var/lib/mysql \</span><br><span class="line">-v /root/mysql-slave1/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=333 \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><blockquote><p>2、主从配置都是配在[mysqld]节点下，都是小写</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Master配置</span></span><br><span class="line">[mysqld]</span><br><span class="line">server-id=1 # 必须</span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin # 必须</span><br><span class="line">read-only=0</span><br><span class="line">binlog-ignore-db=mysql</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Slave配置</span></span><br><span class="line">[mysqld]</span><br><span class="line">server-id=2 # 必须</span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin</span><br></pre></td></tr></table></figure><blockquote><p>3、Master配置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;从机IP地址&#x27;</span> IDENTIFIED BY <span class="string">&#x27;password&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;172.18.0.3&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span></span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、刷新命令</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> FLUSH PRIVILEGES;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、记录下File和Position</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每次配从机的时候都要SHOW MASTER STATUS;查看最新的File和Position</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW MASTER STATUS;</span></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |      602 |              | mysql            |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>4、Slave从机配置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;172.18.0.4&#x27;,</span><br><span class="line">MASTER_USER=&#x27;zhangsan&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;123456&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.File的编号&#x27;,</span><br><span class="line">MASTER_LOG_POS=Position的最新值;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、使用用户名密码登录进Master</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CHANGE MASTER TO MASTER_HOST=<span class="string">&#x27;172.18.0.4&#x27;</span>,</span></span><br><span class="line">    -&gt; MASTER_USER=&#x27;zhangsan&#x27;,</span><br><span class="line">    -&gt; MASTER_PASSWORD=&#x27;123456&#x27;,</span><br><span class="line">    -&gt; MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,</span><br><span class="line">    -&gt; MASTER_LOG_POS=602;</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.02 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、开启Slave从机的复制</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> START SLAVE;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、查看Slave状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Slave_IO_Running 和 Slave_SQL_Running 必须同时为Yes 说明主从复制配置成功！</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW SLAVE STATUS\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event # Slave待命状态</span><br><span class="line">                  Master_Host: 172.18.0.4</span><br><span class="line">                  Master_User: zhangsan</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 602</span><br><span class="line">               Relay_Log_File: b030ad25d5fe-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 320</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes  </span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 602</span><br><span class="line">              Relay_Log_Space: 534</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: bd047557-b20c-11ea-9961-0242ac120002</span><br><span class="line">             Master_Info_File: /var/lib/mysql/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: </span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>5、测试主从复制</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Master创建数据库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create database test_replication;</span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Slave查询数据库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show databases;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test_replication   |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>6、停止主从复制功能</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、停止Slave</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> STOP SLAVE;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、重新配置主从</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MASTER_LOG_FILE 和 MASTER_LOG_POS一定要根据最新的数据来配</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CHANGE MASTER TO MASTER_HOST=<span class="string">&#x27;172.18.0.4&#x27;</span>,</span></span><br><span class="line">    -&gt; MASTER_USER=&#x27;zhangsan&#x27;,</span><br><span class="line">    -&gt; MASTER_PASSWORD=&#x27;123456&#x27;,</span><br><span class="line">    -&gt; MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,</span><br><span class="line">    -&gt; MASTER_LOG_POS=797;</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.01 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> START SLAVE;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW SLAVE STATUS\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 172.18.0.4</span><br><span class="line">                  Master_User: zhangsan</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 797</span><br><span class="line">               Relay_Log_File: b030ad25d5fe-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 320</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 797</span><br><span class="line">              Relay_Log_Space: 534</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: bd047557-b20c-11ea-9961-0242ac120002</span><br><span class="line">             Master_Info_File: /var/lib/mysql/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: </span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="11、常见面试题"><a href="#11、常见面试题" class="headerlink" title="11、常见面试题"></a>11、常见面试题</h1><blockquote><p>SQL查询缓慢</p></blockquote><p>分析：</p><p>1、观察，至少跑1天，看看生产的慢SQL情况。</p><p>2、开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。</p><p>3、explain + 慢SQL分析。</p><p>4、show Profile。</p><p>5、运维经理 OR DBA，进行MySQL数据库服务器的参数调优。</p><p>总结（大纲）：</p><p>1、慢查询的开启并捕获。</p><p>2、explain + 慢SQL分析。</p><p>3、show Profile查询SQL在MySQL数据库中的执行细节和生命周期情况。</p><p>4、MySQL数据库服务器的参数调优。</p><blockquote><p>大表优化</p></blockquote><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，⼀些常见的优化措施如下</p><ol><li>限定范围，如删除一个月之前的记录</li><li>读写分离：主库负责写，从库负责读</li><li>垂直分区：把一张表拆分成多张表，可以简化结构，但是会带来数据冗余，引起Join操作；而且事务更加复杂。</li><li>水平分区：表的数据还是在同⼀台机器上，其实对于提升MySQL并发能⼒没有什么意义，所以<strong>水平拆分最好分库</strong> 。而且会带来逻辑、部署、运维的各种复杂度，如果实在要分片，尽量选择客户端分片架构，这样可以减少⼀次和中间件的网络 IO水平拆分难以解决分片事务，跨节点Join性能差，逻辑复杂。<ul><li><strong>客户端代理：</strong> 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的 <strong>Sharding-JDBC</strong> 、阿⾥的TDDL是两种比较常用的实现。</li><li><strong>中间件代理：</strong> 在应用和数据中间加了⼀个代理层。分片逻辑统⼀维护在中间件服务中。我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul></li></ol><blockquote><p>池化技术</p></blockquote><p>有些对象创建的代价比较大，比如线程、tcp连接、数据库连接等对象。对于这些创建耗时较长，或者资源占用较大(占据操作系统资源，比如说线程，网络连接等)的对象；同时这些资源又是经常使用的，为了避免频繁的创建、销毁这些对象，就使用池化技术，把这些资源放入池中，实现资源的重复使用。</p><p><strong>总结：</strong>获取资源直接从池中获取，实现复用，避免每次都需要重写创建对象。</p><blockquote><p>分库分表之后,id主键如何处理</p></blockquote><p>分成多个表之后，需要⼀个全局唯⼀的id 来⽀持。</p><ul><li>UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。</li><li>数据库自增ID : 两台数据库分别设置不同步长，⽣成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li><li>利用 redis 生成ID：性能高，不依赖数据库，但是加入 redis 组件，系统更复杂，可用性降低。</li><li>Twitter的snowflake（雪花）算法：</li><li>美团的Leaf分布式ID生成系统：</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/19/hello-world/"/>
      <url>/2021/06/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate asfffaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">s</span><br><span class="line">s</span><br><span class="line">s</span><br><span class="line">sss</span><br><span class="line">s</span><br><span class="line"></span><br><span class="line">s</span><br><span class="line">s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
