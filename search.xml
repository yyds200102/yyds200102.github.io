<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java并发(九):Java并发的其他知识</title>
      <link href="/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%B9%9D%20)%20%E6%A1%86%E6%9E%B6%E5%92%8C%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%B9%9D%20)%20%E6%A1%86%E6%9E%B6%E5%92%8C%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1、同步计数：CountDownLatch"><a href="#1、同步计数：CountDownLatch" class="headerlink" title="1、同步计数：CountDownLatch"></a>1、同步计数：CountDownLatch</h2><p><strong>同步计数器：</strong>让一个线程等待（阻塞/等待wait.await(),其他是线程各自执行完毕自己的任务之后，在唤醒等待线程。</p><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch(<span class="keyword">int</span> count);   <span class="comment">// 构造方法,参数必需大于0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span></span>;  <span class="comment">// 获取当前的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span>; <span class="comment">// 值减一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span>;     <span class="comment">// 等待直到值变为0才会被唤醒，可以被中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>; <span class="comment">// 加入超时等待</span></span><br></pre></td></tr></table></figure><p><strong>分析代码：</strong>定义了Sync内部类实现功能，Sync也继承了队列同步器AQS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"><span class="comment">// 关键方法,CAS让值减1</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> nextc = c - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// count的初始值为5</span></span><br><span class="line">        CountDownLatch count = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 每次循环减一</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开启了一次线程&quot;</span>);</span><br><span class="line">                count.countDown();</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里会一直等待，直到计数器值为0，也就是任务完成</span></span><br><span class="line">        count.await();</span><br><span class="line">        count.countDown();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实际应用：</strong>我们要读取处理 6 个⽂件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给⽤户的时候将这⼏个⽂件的处理的结果进⾏统计整理</p><h2 id="2、同步屏障：CyclicBarrier"><a href="#2、同步屏障：CyclicBarrier" class="headerlink" title="2、同步屏障：CyclicBarrier"></a>2、同步屏障：CyclicBarrier</h2><p><strong>原理：</strong>基于可重入锁实现，本质也是基于AQS</p><p><strong>同步屏障：</strong>建立一个屏障，拦截数量自定义，所有线程碰到屏障都会被阻挡等待，等屏障拦截达到一定数量，就会唤醒所有线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier(<span class="keyword">int</span> parties);  <span class="comment">// 一共拦截parties个线程后才打开屏障</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span>;   <span class="comment">// 当前线程触碰到屏障，等待直到屏障打开</span></span><br><span class="line"></span><br><span class="line">CyclicBarrier(<span class="keyword">int</span> parties, Runnable barrierAction); </span><br><span class="line"><span class="comment">// 屏障打开时,会优先执行参数线程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span>  <span class="comment">// 等待的线程数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;           <span class="comment">// 打破屏障,重置参数</span></span><br></pre></td></tr></table></figure><p><strong>构造方法：</strong>定义两个变量实现复用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;   </span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内部结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来记录当前屏障是否已经被打破，当broken=true时说明被打破。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition(); <span class="comment">// 等待队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;                          <span class="comment">// 总阻挡数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;              <span class="comment">// 优先线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录当前屏障是否已经被打破</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;   <span class="comment">// 还需要多少个线程达到屏障点后才能突破屏障</span></span><br></pre></td></tr></table></figure><p><strong>breakBarrier()方法：</strong>打破屏障，唤醒所有线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 所有线程都会执行到if (g.broken) throw new xxxException();</span></span><br><span class="line">    <span class="comment">// 这时候if语句中为true，则会直接抛出异常打破屏障。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nextGeneration()方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 重置count实现复用</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();  <span class="comment">// 说明是新的屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心方法 dowait() :</strong></p><ol><li>上来先进行申请锁操作，没获得锁的进入到AQS的等待队列中进行等待。</li><li>判断broken是否为true，如果为true说明屏障被打破了，直接抛出异常即可，</li><li>判断count是否已经减少到0，表示所有线程已经达到了屏障点，由最后一个线程来执行通过构造函数传递过来的<strong>barrierCommand</strong>任务，调用nextGeneration方法，进行下一轮复用的重置动作。<ul><li>通知条件队列的线程，每个线程依次获取锁，执行，释放锁。</li><li>当执行到 if (g != generation) return index; 此时另外一一个线程已经将generation设置为新的对象，所以会直接返回。</li></ul></li></ol><h2 id="3、限流信号量：Semaphore"><a href="#3、限流信号量：Semaphore" class="headerlink" title="3、限流信号量：Semaphore"></a>3、限流信号量：Semaphore</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Semaphore(<span class="keyword">int</span> permits);      <span class="comment">// 限定进来的线程个数，默认非公平</span></span><br><span class="line">Semaphore(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)  <span class="comment">// </span></span><br></pre></td></tr></table></figure><h2 id="4、线程数据交换：Exchange"><a href="#4、线程数据交换：Exchange" class="headerlink" title="4、线程数据交换：Exchange"></a>4、线程数据交换：Exchange</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           String A = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String B = exchanger.exchange(A);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1&quot;</span>+A);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1&quot;</span>+B);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String B = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String A = exchanger.exchange(B);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2&quot;</span>+A);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2&quot;</span>+B);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、Fork-Join框架"><a href="#5、Fork-Join框架" class="headerlink" title="5、Fork/Join框架"></a>5、Fork/Join框架</h2><p><strong>思想：</strong>把大任务拆分成很多小任务，并行执行任务，再把结果合并起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RecursiveTask 处理任务 有返回值，都实现了ForkjoinTask</span><br><span class="line">RecursiveAction 处理任务没有返回值，都实现了<span class="function">ForkjoinTask</span></span><br><span class="line"><span class="function"><span class="title">fork</span><span class="params">()</span> :提交任务到队列.执行。</span></span><br><span class="line"><span class="function"><span class="title">join</span><span class="params">()</span> ：合并，返回结果集</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//最小拆分数量</span></span><br><span class="line">    <span class="keyword">int</span> min=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo3</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行任务拆分且返回一个 sum</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不拆分 [范围太小] 减掉后的值，小于 3   1,3  3-1=2&lt;=3    ，8，10=2</span></span><br><span class="line">        <span class="keyword">if</span>(end-start&lt;=min)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">            <span class="comment">//拆分</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(end+start)/<span class="number">2</span>;</span><br><span class="line">            Demo3 test1=<span class="keyword">new</span> Demo3(start,mid); <span class="comment">// 0,5</span></span><br><span class="line">            Demo3 test2=<span class="keyword">new</span> Demo3(mid+<span class="number">1</span>,end);<span class="comment">//6,10</span></span><br><span class="line">            <span class="comment">//拆分</span></span><br><span class="line">            test1.fork();</span><br><span class="line">            test2.fork();</span><br><span class="line">            <span class="comment">//拿到小任务结果</span></span><br><span class="line">            Integer join1 = test1.join();</span><br><span class="line">            Integer join2 = test2.join();</span><br><span class="line">            <span class="keyword">int</span> sum= join1+join2;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=====&quot;</span>+sum);</span><br><span class="line">            <span class="comment">//返回总和</span></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Runtime.getRuntime().availableProcessors())类似核心线程</span></span><br><span class="line">        ForkJoinPool pool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; submit = pool.submit(<span class="keyword">new</span> Demo3(<span class="number">1</span>,<span class="number">1000000</span>));</span><br><span class="line">        Integer integer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            integer = submit.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(八):Java线程池</title>
      <link href="/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E5%85%AB%20)%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E5%85%AB%20)%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1、线程池概述"><a href="#1、线程池概述" class="headerlink" title="1、线程池概述"></a>1、线程池概述</h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><p><strong>不建议用： new Thread().start();</strong></p><ul><li><p>浪费服务器的资源，创建和销毁 浪费资源</p></li><li><p>不能立马就销毁对象。大量的对象，GC</p></li><li><p>线程的生命周期比较长，不好管理线程的状态，中断….</p></li><li><p>不支持周期，调度的功能。线程大容易竞争资源</p></li></ul><p><strong>线程池：</strong>维护一批 new thread().start()  放到一个池子或者队列集合里面。提交任务就取出来一条线程直接使用，速度快，结束任务后，把线程返回线程池。或者空闲的线程销毁掉。</p><p><strong>优点：</strong></p><ul><li><p>不用频繁创建和销毁线程。减少浪费资源。</p></li><li><p>便于管理线程的状态。</p></li><li><p>支持周期性，提高相应速度。减少资源竞争，</p></li><li><p>便于控制线程的数量</p></li></ul><p><strong>分类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Executor     <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span>  <span class="comment">// 顶级接口 ，提交任务 </span></span></span><br><span class="line"><span class="function">ExecutorService    <span class="comment">// 扩展了Executor接口，提供了submit，api             </span></span></span><br><span class="line"><span class="function">ForkJoinPool       <span class="comment">// 工作窃取，密集型补充之前的线程池                   </span></span></span><br><span class="line"><span class="function">ThreadPoolExecutor <span class="comment">// 自定义线程池的时候使用                             </span></span></span><br><span class="line"><span class="function">Executors          <span class="comment">// 有静态方法，可以返回线程池对象              </span></span></span><br></pre></td></tr></table></figure><h3 id="1-2、线程池的流程"><a href="#1-2、线程池的流程" class="headerlink" title="1.2、线程池的流程"></a>1.2、线程池的流程</h3><p><img src="img/Thread/5.jpg"></p><p><strong>注意：</strong>当线程池和队列满的情况下，线程池会从默认大小变大到最大大小，再次满的情况下进行拒绝策略（饱和策略）</p><h2 id="2、Executor框架简介"><a href="#2、Executor框架简介" class="headerlink" title="2、Executor框架简介"></a>2、Executor框架简介</h2><h3 id="2-1、简介"><a href="#2-1、简介" class="headerlink" title="2.1、简介"></a>2.1、简介</h3><blockquote><p>Executor框架的结构</p></blockquote><ul><li>任务：即线程，需要实现Runnable或者callable接口</li><li>任务的执行：任务执行的核心接口 Executor 及实现类 ExecutorService（其中ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 实现了该接口）</li><li>异步计算的结果：包括 Future 接口和其实现类 FutureTask </li></ul><blockquote><p>任务执行的过程</p></blockquote><ol><li>创建 ExecutorService 对象，即线程池</li><li>把 Runnable 对象或者 Callable 对象交给 ExecutorService 对象执行</li><li>如果是 Callable 线程，返回一个 Future 对象的结果，当然也可以直接创建 FutureTask 对象 交给 ExecutorService 对象执行。</li><li>通过 Future 或者 FutureTask 对象 获得结果 </li></ol><h3 id="2-2、-Executor-对象的主要成员"><a href="#2-2、-Executor-对象的主要成员" class="headerlink" title="2.2、 Executor 对象的主要成员"></a>2.2、 Executor 对象的主要成员</h3><ul><li><strong>Executor接口：</strong>Executor框架的基础，实现任务的提交和执行分离</li><li><strong>ExecutorService：</strong>一个线程池接口，继承了Executor接口，一般用作 <code>具体的线程池</code> 向上转型成该类对象。</li><li><strong>ThreadPoolExecutor：</strong>线程池的核心实现类，用于创建线程池，通常使用工厂类  Executors 来创建（也可以自定义）。继承了AbstractExecutorService类，AbstractExecutorService 继承了 ExecutorService接口。</li><li><strong>ScheduledThreadPoolExecutor：</strong>线程池的一个实现类，用于创建线程池</li><li><strong>Future接口：</strong>线程池执行Callable 任务后，返回的结果为 Future类型</li></ul><h2 id="3、创建线程池"><a href="#3、创建线程池" class="headerlink" title="3、创建线程池"></a>3、创建线程池</h2><h3 id="3-1、简介"><a href="#3-1、简介" class="headerlink" title="3.1、简介"></a>3.1、简介</h3><ul><li>ThreadPoolExecutor 是 线程池的核心实现类，提供了 3种线程池的实现</li><li>ScheduledThreadPoolExecutor 继承了 ThreadPoolExecutor，主要用于给定延迟之后运行任务或者定期执行任务。</li></ul><h3 id="3-2、JDK四大内置线程池"><a href="#3-2、JDK四大内置线程池" class="headerlink" title="3.2、JDK四大内置线程池"></a>3.2、JDK四大内置线程池</h3><ul><li><strong>SingleThreadExecutor：</strong>单个线程池</li><li><strong>FixedThreadPool：</strong>自己控制线程数量</li><li><strong>CachedThreadPool：</strong>根据需要自动决定容量的线程池</li><li><strong>ScheduledThreadPool：</strong>可以周期性和延迟执行线程</li></ul><p><strong>创建线程：</strong>通过Executors工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService e = Executors.newSingleThreadExecutor(); </span><br><span class="line"><span class="comment">// 单个线程，异常退出的线程，会自动创建。</span></span><br><span class="line">ExecutorService e = Executors.newFixedThreadPool(<span class="number">5</span>);     </span><br><span class="line"><span class="comment">// 线程池可以有多个</span></span><br><span class="line">ExecutorService e = Executors.newCachedThreadPool();     </span><br><span class="line"><span class="comment">// 容量无限,删除60秒的线程</span></span><br><span class="line"></span><br><span class="line">ScheduledExecutorService e = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// ScheduledThreadPool 可以周期性的执行线程</span></span><br><span class="line">ScheduledExecutorService e = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"><span class="comment">// 单个</span></span><br></pre></td></tr></table></figure><p><strong>ScheduledThreadPool：</strong>可以使用**<code>schedule启动</code>**线程周期性运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScheduledThreadPool 可以周期性的执行线程</span></span><br><span class="line"><span class="comment">// 对象.schedule() 执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService e = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 2秒后延迟执行</span></span><br><span class="line">        e.schedule(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;延迟执行&quot;</span>);</span><br><span class="line">        &#125;,<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="comment">// 第一次是4秒之后，然后每隔三秒执行一次</span></span><br><span class="line">        e.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">4</span>,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通用方法：</strong>都可以使用<code>execute和submit启动线程</code>，其中submit支持callable线程</p><ul><li>excute ：无返回值</li><li>submit ：有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 有数量限制的线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放Runnable线程</span></span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 放Runnable线程</span></span><br><span class="line">       executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 放callable线程</span></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、自定义线程池"><a href="#3-3、自定义线程池" class="headerlink" title="3.3、自定义线程池"></a>3.3、自定义线程池</h3><ul><li>上述几个线程池都是参数不同的ThreadPoolExcutor方法，</li><li>该方法有七个参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor();</span><br></pre></td></tr></table></figure><p><strong>七大参数</strong></p><ol><li><strong>初始线程池大小</strong></li><li><strong>线程池最大大小</strong></li><li>等待超时时间大小，超过多少时间没有线程进入就把线程池的大小变为**<code>初始值</code>**</li><li>第3个参数的时间单位   （如TimeUnit.SECONDS）</li><li>阻塞队列<ul><li>线程池满就让线程进入队列，</li><li>队列第一次满(初始线程大小和队列满了)，就把线程池变为最大的大小，</li><li>队列第二次满(线程最大大小和队列都满)，就执行拒绝策略</li></ul></li><li>线程工厂，默认即可</li><li>拒绝策略,</li></ol><p><strong>四大拒绝策略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy();   <span class="comment">// 不处理抛出异常,</span></span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy(); <span class="comment">// 不抛出异常</span></span><br><span class="line">DiscardOldestPolicy();  <span class="comment">// 不抛出异常，队列满尝试和第一个线程竞争，不过仍被扔出</span></span><br><span class="line">CallerRunsPolicy();    <span class="comment">// 只要线程池未关闭，在调用者线程中运行当前的被丢弃的任务</span></span><br></pre></td></tr></table></figure><ul><li><strong>自定义线程</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>),Executors.defaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、FutureTask详解"><a href="#4、FutureTask详解" class="headerlink" title="4、FutureTask详解"></a>4、FutureTask详解</h2><p><strong>概念：</strong>FutureTask继承了 Future类，实现类 Runnable 接口，有多种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;   <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;   <span class="comment">// 运行中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;   <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;   <span class="comment">// 异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;   <span class="comment">// 取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;   <span class="comment">// 中断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;   <span class="comment">// 已中断</span></span><br></pre></td></tr></table></figure><p><strong>作用：</strong></p><ol><li>作为 线程池执行的返回值，通过 get 方法获取结果</li><li>把线程作为参数填入 FutureTask 对象中，这样 ExecutorService 对象 submit 的就不是线程而是 FutureTask 对象，</li><li>通过· cancel 取消任务。</li><li>作为一个线程单独执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 尝试取消执行此任务,若任务已经执行完毕，则无效果</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span>                <span class="comment">// 会尝试获取值，获取不到就一直阻塞到线程执行完成 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span>  <span class="comment">// 此任务是否在完成之前被取消</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span>       <span class="comment">// 这个任务是否完成</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>FutureTask实例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(task);</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>cancel方法详解</p></blockquote><ul><li>参数为true：尝试把通过中断来终止当前线程</li><li>参数为false：尝试把线程状态设置为CANCELLED</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有一个入参，需要说明task是否是可中断的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">        <span class="comment">//尝试修改futuretask的运行状态</span></span><br><span class="line">        <span class="keyword">if</span> (!UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, INTERRUPTING))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//获取当前线程发出中断信号</span></span><br><span class="line">        Thread t = runner;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.interrupt();</span><br><span class="line">        <span class="comment">//修改task状态为已中断的</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED); <span class="comment">// final state</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是不可中断的只修改task的状态为cancelled</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, CANCELLED))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//执行finishCompletion方法</span></span><br><span class="line">    finishCompletion();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、API汇总"><a href="#5、API汇总" class="headerlink" title="5、API汇总"></a>5、API汇总</h2><p><strong>线程池的创建</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService e = Executors.newSingleThreadExecutor(); </span><br><span class="line"><span class="comment">// 单个线程，异常退出的线程，会自动创建。</span></span><br><span class="line">ExecutorService e = Executors.newFixedThreadPool(<span class="number">5</span>);     </span><br><span class="line"><span class="comment">// 线程池可以有多个</span></span><br><span class="line">ExecutorService e = Executors.newCachedThreadPool();     </span><br><span class="line"><span class="comment">// 容量无限,删除60秒的线程</span></span><br><span class="line">ScheduledExecutorService e = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// ScheduledThreadPool 可以周期性的执行线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程池</span></span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor();</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>),Executors.defaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure><p><strong>线程池提交任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">excute</span><span class="params">(Runnable runnable)</span></span>;     <span class="comment">// 无返回值,仅支持Ruuanble线程</span></span><br><span class="line"><span class="function">Object <span class="title">sumbit</span><span class="params">(Callable callable)</span></span>;   <span class="comment">// 支持Callable线程和Ruuanble线程</span></span><br></pre></td></tr></table></figure><p><strong>关闭线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;     <span class="comment">// 遍历线程，中断所有未运行的线程，状态设置为shutdown</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdownNow</span><span class="params">()</span></span>;  <span class="comment">// 遍历线程，中断所有线程，状态设置为stop</span></span><br></pre></td></tr></table></figure><p><strong>线程池的监控</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long getTaskCount(); // 线程池需要执行的任务数量</span><br><span class="line">long getCompletedTaskCount();   // 已完成的</span><br><span class="line">int getActiveCount();</span><br><span class="line">int getLargestPoolSize()</span><br></pre></td></tr></table></figure><p><strong>FutureTask</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> <span class="comment">// 尝试取消执行此任务。</span></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span>                <span class="comment">// 等待计算完成，然后检索其结果。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span>  <span class="comment">// 此任务是否在完成之前被取消</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span>       <span class="comment">// 这个任务是否完成</span></span></span><br></pre></td></tr></table></figure><p><strong>线程的转换</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executors.callable(Runnable task)</span><br><span class="line">Executors.callable(Runnable task,Object result)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(七):Java并发容器</title>
      <link href="/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%B8%83%20)%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%B8%83%20)%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1、JDK1-7、HashMap"><a href="#1、JDK1-7、HashMap" class="headerlink" title="1、JDK1.7、HashMap"></a>1、JDK1.7、HashMap</h2><ul><li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li><li>key 不可重复，所以所在的类要重写：equals()和hashCode()  ，value要重写：equals() </li><li>HashMap 判断<strong>两个key相等</strong>的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。</li><li>HashMap 判断<strong>两个value相等</strong>的标准是：两个 value 通过 equals() 方法返回 true。</li></ul><p><img src="img/Thread/6.jpg"></p><p><strong>结构：</strong> 数组 + 链表 ，每个节点都是一个 Entry 实例对象。</p><ol><li>实例化一个HashMap时，系统会创建一个长度为Capacity（称为容量）的Entry数组，数组存放元素的位置称为 “ 桶 “，每个” 桶 “ 都有自己的索引。</li><li>若添加的数据在一个” 桶 “ 中，则 会形成链表</li></ol><p><strong>添加过程</strong></p><ol><li>添加一个数据时，先封装成 Entry 对象，根据其中 key 的哈希值来判断应该放入哪个桶中</li><li>哈希值可能存在相同的情况，则依次遍历该桶中的链表，依次通过 equals 方法判断是否相等，若相等则把旧的 Entry 对象的 value 替换成新的，若不等则添加到头部。</li></ol><p><strong>扩容：</strong>和JDK1.8相同</p><h2 id="2、JDK1-8：HashMap"><a href="#2、JDK1-8：HashMap" class="headerlink" title="2、JDK1.8：HashMap"></a>2、JDK1.8：HashMap</h2><p><img src="img/Thread/7.jpg"></p><p><strong>结构：</strong> 数组 + 链表 + 红黑树，每个节点都是一个 Node 实例对象（树形化后为 TreeNode）。</p><ol><li>实例化一个HashMap时，会初始化initialCapacity（默认容量）和<code>loadFactor（填充因子）</code></li><li><strong>put数据时，才会</strong>根据默认容量（16）创建Node数组，数组存放数据的地方称为” 桶 “ (bucket),每个bucket都有自己的<code>索引</code>。</li><li>每个bucket存一个Node对象，里面含有指向下一个元素的next引用变量，所以一个bucket可能形成<code>Node链</code>，或者是<code>TreeNode树</code>，而新添加的元素作为链表的last，或树的叶子结点</li></ol><p><strong>哈希函数：</strong></p><ul><li>JDK7：通过<strong>扰动函数处理</strong>过后得到 hash值，然后通过 (n - 1) &amp; hash判断当前元素存放的位置</li><li>JDK8：优化了代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK7</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK8</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line"> <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line"> <span class="comment">// ^ ：按位异或</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;:⽆符号右移，忽略符号位，空位都以0补⻬</span></span><br><span class="line"> <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩容情况</strong>：</p><ol><li><p>HashMap的元素个数大于 initialCapacity（默认容量）*  loadFactor（填充因子）时，就会扩大一倍。</p></li><li><p>扩容时会重新计算每个元素的位置，消耗资源，所以可以预设大小，减少资源消耗</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap(<span class="number">15</span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>树形化</strong>：</p><p>​        若是一个 Node 链 里面的元素超过了8个（容量小于64则会优先先尝试扩大容量减少哈希冲突），就会尝试树形化，然后数节点<code>由Node类型变为TreeNode类型</code>，当然，映射关系移除后，若小于6个，重新变回Node链</p><p>​        <strong>也就是说，桶里的Node链  &gt;  8 ，hashMap 容量 &gt; 64时，实际上才会发生树形化</strong></p><p><strong>填充因子</strong></p><ol><li>负载因子越大，数据密度越大，发生碰撞的几率越高，数组中的链表越容易长，查询或插入时的比较次数多，性能下降</li><li>负载因子越小越容易扩容，容易浪费空间</li><li>最好设置为0.7~0.75</li></ol><blockquote><p>JDK1.8相较于之前的变化：</p></blockquote><ol><li>HashMap map = new HashMap();      //默认情况下，先不创建长度为16的数组，当首次调用map.put()时，再创建长度为16的数组</li><li>JDK 8 数组为Node类型，在jdk7中称为Entry类型</li><li>形成链表结构时，新添加的key-value对在链表的尾部（七上八下）</li><li>当数组指定索引位置的链表长度&gt;8时，且map中的数组的长度&gt; 64时，此索引位置上的所有key-value对使用红黑树进行存储。</li></ol><h2 id="3、JDK1-7：ConcurrentHashMap"><a href="#3、JDK1-7：ConcurrentHashMap" class="headerlink" title="3、JDK1.7：ConcurrentHashMap"></a>3、JDK1.7：ConcurrentHashMap</h2><p><img src="C:\Users\admin\Desktop\Java并发\img\8.jpg"></p><h3 id="3-1、内部结构和属性"><a href="#3-1、内部结构和属性" class="headerlink" title="3.1、内部结构和属性"></a>3.1、内部结构和属性</h3><p><strong>主要结构：</strong> Segment + HashEntry + Unsafe ，Segment继承了 ReentrantLock。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体为一个Segment数组，每个Segment对象里面还有一个HashEntry数组，HashEntry数组的每个节点存储键值对，即我门存的数据</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>属性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 默认加载因子 0.75f （作用域segment内部）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 默认并发级别（和默认初始容量一致） 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 允许的最大容量 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 每段segment最小容量（必须是2的幂，至少是2）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 允许的最大segment数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>; <span class="comment">// slightly conservative</span></span><br><span class="line"><span class="comment">// 锁之前，重试次数（默认自旋次数）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 分段索引的掩码值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</span><br><span class="line"><span class="comment">// 段内索引的移位值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</span><br><span class="line"></span><br><span class="line"><span class="comment">// segment 数组</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br><span class="line">从上面大概可以看出ConcurrentHashMap的结构</span><br></pre></td></tr></table></figure><h3 id="3-2、方法分析"><a href="#3-2、方法分析" class="headerlink" title="3.2、方法分析"></a>3.2、方法分析</h3><blockquote><p>构造方法</p></blockquote><ul><li>构造方法确定了初始容量，加载因子，并发级别等参数。会创建Segment数组并且放入一个数据。</li><li><strong>Segment数组的大小：</strong>sszie，为2的次方，并且不能小于并发级别</li><li><strong>HashEntry初始大小：</strong>cap，且也必须是2的幂，最小为2。cap 乘 sszie 不能小于默认大小。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    <span class="comment">// 默认大16,0.75，并发级别16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 2. 控制最大并发级别不能超过初始容量</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 3. sszie为Segment数组的大小，2^sshift = sszie &gt; 并发级别</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 4. 控制最大初始容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 5. CAP为HashEntry初始大小</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;       <span class="comment">// 默认最小值2，</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 创建第一个Segment元素</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    <span class="comment">// 7. 创建CHM的segments数组，ssize的大小和并发级别有关</span></span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// 把数据放入</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Segment初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化其他Segment(构造方法只初始化了Segments[0]，其他位置第一次插入的时候还是null,需要初始化)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="comment">// 计算原始偏移量</span></span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">// 1. 再次确保是没有初始化过的</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 以第一个segment作为模版原型</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">// 取第一个segment的HashEntry数组长度，加载因子等</span></span><br><span class="line">        <span class="comment">// 因为构造方法时已经算过了，后面的都取第一个的初始化参数</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf); <span class="comment">// 计算阈值</span></span><br><span class="line">        <span class="comment">// 3.初始化segment的HashEntry数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="comment">// 4. 再次检查确保是没有这个过程中没有被其他线程初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            <span class="comment">// 初始化Segment</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// while自旋检测，并将初始化好的segment设置到segments数组对应的索引位置中</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回初始化好的segment by:https://jinglingwang.cn</span></span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>put方法</p></blockquote><ol><li>根据Hash计算出在 segment 数组的位置，若该位置没初始化就先初始化，然后调用HashEntry的put方法。</li><li>尝试获得锁（segment对象），获得锁之后会通过Hash计算在 HashEntry数组的位置（桶），获取后遍历链表并且添加或覆盖节点，记录修改次数，以及扩容检测。完成后会释放锁。</li><li>没有获得锁会调用scanAndLockForPut自旋（最多64次），直到返回一个节点并持有锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="comment">// 1.参数校验，不允许value为null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 2.计算key的hash(32位)</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 3. 默认值时，hash无符号右移28位，保留高4位，然后做位运算 &amp; 15；j的值就是下标</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          </span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) </span><br><span class="line">    <span class="comment">// 4. 构造方法只初始化了Segments[0]，其他位置第一次插入的时候还是null,需要初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 5.往segments中放入值</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  内部类Segment中的实现，真正放segment中添加数据的方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  尝试获得锁，没有获得锁会调用scanAndLockForPut自旋，直到返回一个节点并持有锁</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    <span class="comment">// 旧的值</span></span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前槽Segment中的HashEntry数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 1.计算hash所在的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 定位数组中的HashEntry元素，HashEntry是链表结构，第一个也就是表头</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123; <span class="comment">// 遍历hashEntry链表</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 存在旧值</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">// 1.1 校验key是否一致</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||  (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;  <span class="comment">// 取出覆盖前的旧值</span></span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value; <span class="comment">// 覆盖旧值</span></span><br><span class="line">                        ++modCount; <span class="comment">// 记录修改次数</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next; <span class="comment">// 继续遍历下一个元素</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在旧值</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first); <span class="comment">// 直接设置表头first</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 初始化节点并设置表头first</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>; <span class="comment">// 元素的数量+1</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    <span class="comment">// 触发扩容</span></span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node); <span class="comment">// 将node放到数组tab的index位置，</span></span><br><span class="line">                ++modCount; <span class="comment">// 记录修改次数+1</span></span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>; <span class="comment">// 第一次添加返回null</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue; <span class="comment">// 返回旧值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>自旋获取锁：scanAndLockForPut</p></blockquote><ul><li>会预先创建节点，</li><li>最多自旋64次，超过就是调用 lock方法替代 trylock ，让线程阻塞</li><li>每次自旋会判断调整遍历的 first 节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;      <span class="comment">// 自旋尝试获得锁，直到获得锁退出循环</span></span><br><span class="line">        HashEntry&lt;K,V&gt; f; </span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 预先创建节点</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                e = e.next; <span class="comment">//链表，下一个</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;<span class="comment">// 最大重试次数：单核1，多核64</span></span><br><span class="line">            lock(); <span class="comment">// 阻塞线程，直到获得锁</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            <span class="comment">// first节点所在的位置发生了变化，重新赋值first</span></span><br><span class="line">            e = first = f; </span><br><span class="line">            retries = -<span class="number">1</span>; <span class="comment">// 相当于重新进入scanAndLockForPut方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>扩容：rehash方法</p></blockquote><ul><li>对Segment中的HashEntry数组进行两倍的扩容，并将入参的节点加入到数组列表中。</li><li>只有在put方法时才会触发扩容，调用该方法时已经持有锁。</li><li>对于单节点的直接放到新HashEntry数组中；若形成了链表，其中有些节点的索引会发生改变，需要单独处理。</li><li><strong>注意：</strong>Segment数组是不能进行扩容的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;   <span class="comment">// 旧的容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;  <span class="comment">// 扩容，新的值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">// 计算新的扩容阈值</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历旧的数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i]; <span class="comment">// 旧数组中的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">// 非链表直接将旧值放入到新的数组中</span></span><br><span class="line">                newTable[idx] = e; </span><br><span class="line">            <span class="keyword">else</span> &#123;              <span class="comment">// 说明HashEntry数组中的节点是链表</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;  <span class="comment">// 头结点</span></span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 遍历链表，确定下来一个节点lastRun（重新计算索引后有变化的最后一个节点） </span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="keyword">null</span>;  last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将lastRun节点及它身上所处链表赋值到新的数组中</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// lastRun节点之前的节点，因为重新计算索引有变化，需要赋值到不同的位置</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask; <span class="comment">// 重新计算索引，与lastIdx不一样</span></span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">    <span class="comment">// 重新构造一个新的hashentry节点并赋值到新的数组中，如果不new需要切断链表更麻烦</span></span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新加入的节点，计算索引</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    <span class="comment">// newTable[nodeIndex] 可能已经存在有值，node节点作为头结点设置</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node; <span class="comment">// 重新设置nodeIndex位置</span></span><br><span class="line">    table = newTable; <span class="comment">// 赋值新的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取：get方法</p></blockquote><ol><li>先要确认槽的位置，也就是segment的位置</li><li>然后确定在segment里面的HashEntry数组中的索引位置。</li><li>在链表上找目标key并返回其值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所在的槽</span></span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 计算hash</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="comment">// 1.计算槽的索引位置</span></span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp; (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 计算在HashEntry中的索引位置,遍历链表  </span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile(tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) <span class="comment">// 找到元素，并返回值</span></span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 没有找到，返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>删除：remove</p></blockquote><p>删除和put类似。</p><h3 id="3-3、总结"><a href="#3-3、总结" class="headerlink" title="3.3、总结"></a>3.3、总结</h3><p><strong>结构：</strong> Segment + HashEntry + Unsafe ，Segment继承了 ReentrantLock。</p><ul><li>初始化会根据并发程度来创建 Segment数组（默认大小16），不可以扩容；初始化只会 添加一个Segment节点。</li><li>数组的每个 Segment对象 都封装了 HashEntry 数组，类似 HasMap 的 Entry，默认大小与 并发大小和 ConcurrentHashMap 的默认大小有关</li></ul><p><strong>添加数据</strong></p><ul><li><code>第一次根据 Hashcode 判断</code>去哪个 Segment 节点，若为空则CAS初始化；不为空则 trylcok 获取锁（Segment），获取不到的则自旋。</li><li><code>第二次根据 Hashcode 判断</code>去HashEntry 节点。</li></ul><p><strong>扩容：</strong></p><ul><li>扩容只发生在 put ，所以已获得锁了。</li><li>HashEntry 中链表和单节点的处理方式不同。</li><li>扩容为2倍。</li></ul><p><strong>总结：</strong></p><ul><li>根据分段式锁实现的，不过锁的粒度仍然有些大，引入Segment数组保持并发度也必将耗费资源</li><li>Segment不支持扩容，并发性一定会有所降低。</li></ul><h2 id="4、JDK1-8：ConcurrentHashMap"><a href="#4、JDK1-8：ConcurrentHashMap" class="headerlink" title="4、JDK1.8：ConcurrentHashMap"></a>4、JDK1.8：ConcurrentHashMap</h2><h3 id="4-1、基本结构"><a href="#4-1、基本结构" class="headerlink" title="4.1、基本结构"></a>4.1、基本结构</h3><p><img src="img/Thread/9.jpg"></p><p><strong>结构：</strong>Node + CAS + Synchronized + 红黑树(链表)</p><ul><li>Node节点和TreeNode节点防置我们存的数据 key 和 value</li><li>Node数组放的是Node或者TreeBin，TreeBin 封装了TreeNode的头结点</li><li>ForwardingNode</li></ul><blockquote><p>Node</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node类实现了Map.Entry接口，主要存放key/value键值对，链表结构具有next域。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// volatile 修饰，保证可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TreeNode</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树化后红黑树存储节点，继承于承载数据的Node类。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ForwardingNode</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表特殊节点，hash值为-1（MOVED），在扩容迁移数据时插入到原数组中，表示正在迁移数据。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">        ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="comment">// MOVED: hash值，-1。</span></span><br><span class="line">            <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TreeBin</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeBin通过root属性维护红黑树的根结点，first属性指向TreeNode链表的头结点。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter; <span class="comment">// 当前使用这棵红黑树的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重要属性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;     <span class="comment">// 默认容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能的最大（非 2 的幂）数组大小。 toArray 和相关方法需要。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;    <span class="comment">// 默认并发级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;            <span class="comment">// 默认加载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;     <span class="comment">// 链表转换成树的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;   <span class="comment">// 树退化成链表时的计数值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 链表树化时，最小的链表表容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;<span class="comment">// 最小转移容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;<span class="comment">// sizeCtl 中用于生成标记的位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeCtl 中用于生成标记的位数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeCtl 中记录大小标记的位移位。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">//表示正在转移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">//表示已经转换成树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 装载Node的数组,第一次插入数据时延迟初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 扩容时使用，平时为null，只有在扩容的时候才为非null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本计数器值，主要在没有争用时使用（通过CAS的方式修改）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表初始化和调整大小控制；</span></span><br><span class="line"><span class="comment">// 当 table 为 null 时，保存创建时使用的初始表大小，或默认为 0。</span></span><br><span class="line"><span class="comment">// 负数，则表正在初始化或调整大小，</span></span><br><span class="line"><span class="comment">// 正数，表示容量的大小，或者将要扩容的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整大小时要拆分的下一个表索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br></pre></td></tr></table></figure><h3 id="4-2、初始化方法"><a href="#4-2、初始化方法" class="headerlink" title="4.2、初始化方法"></a>4.2、初始化方法</h3><blockquote><p>构造方法</p></blockquote><ol><li><code>tableSizeFor</code>方法最后会返回一个2的幂的数作为最后的cap。</li><li>构造方法没有初始化数组，具体是在put第一个元素的时候初始化。</li><li>sizeCtl 的计算结果要保证是2的幂（计算方式是1.5*initialCapacity+1的结果向上取第一个2的幂，如果入参initialCapacity为10，sizeCtl就是16，如果入参initialCapacity为17，最后sizeCtl就是32），初始化数组之前表示的是容量的意思。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检验参数的正确性</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 保证并发级别不能大于容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   </span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// 使用默认的并发级别</span></span><br><span class="line">    <span class="comment">// 计算size</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// cap表示容量，为2的倍数</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组初始化：initTable</p></blockquote><ol><li>初始化数组一般是在第一次put数据的时候完成的。</li><li>使用<code>volatile</code>+CAS+自旋+双重检查的方式来控制<code>sizeCtl</code>，<code>sizeCtl</code>小于0表示有线程正在初始化数组。</li><li>未初始化前sizeCtl表示容量，初始化后<code>sizeCtl</code>被表示为下次要扩容的阈值（0.75*n）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123; <span class="comment">// 自旋，判断表是否有初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>) <span class="comment">// 表示正在被其他线程初始化或调整大小。</span></span><br><span class="line">            Thread.yield();     <span class="comment">// 暂停当前正在执行的线程</span></span><br><span class="line">        <span class="comment">// cas 修改为-1，表示当前线程正在初始化table</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123; </span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                 <span class="comment">// 双重检查</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123; </span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;    <span class="comment">// 赋值初始化好的table</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);  <span class="comment">// 计算实际上等同于 0.75 * n</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;   <span class="comment">// sizeCtl 设置为扩容的阈值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab; <span class="comment">// 返回初始化好的table</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、添加获取数据"><a href="#4-3、添加获取数据" class="headerlink" title="4.3、添加获取数据"></a>4.3、添加获取数据</h3><blockquote><p>put方法</p></blockquote><ol><li>ConcurrentHashMap 不允许key/value 为null。在第一次插入数据时才初始化数组<code>table</code>。</li><li>put时如果正在扩容（要插入位置的节点hash值为-1），当前线程会加入到帮组扩容迁移数据（<code>helpTransfer</code>），并返回扩容后的新数组，然后继续执行put逻辑。</li><li>如果put时，目标位置为空时，直接插入，不要锁。</li><li>如果put时，目标位置不为空时，使用<code>synchronized</code>锁住一个桶，然后决定是替换旧值或是加入到链表或树中。替换旧值不会触发扩容，直接返回旧值。</li><li>如果冲突的位置链表长度大于等于8时，会尝试链表树化（<code>treeifyBin</code>：实际还需要数组长度至少为64才会树化 ）。</li><li>添加计数（<code>addCount</code>），检查是否需要扩容，退出。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验，不允许key/value为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 1. 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;       <span class="comment">// 用于记录冲突链表的大小</span></span><br><span class="line">    <span class="comment">// 自旋：第一次put数据时要先初始化数组，</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">// tab 为数组引用</span></span><br><span class="line">        Node&lt;K,V&gt; f;  <span class="comment">// 索引位的节点</span></span><br><span class="line">        <span class="keyword">int</span> n, i, fh; <span class="comment">// n：数组的长度；i:索引（计算方法 (n - 1) &amp; hash）；fh: f节点的hash</span></span><br><span class="line">        <span class="comment">// 数组还没初始化，就初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)  </span><br><span class="line">            tab = initTable(); </span><br><span class="line">         <span class="comment">// 当put进来，计算的目标索引位置没有元素时，直接插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 通过cas的方式修改，直接将put的值放入到指定数组的位置</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>))) </span><br><span class="line">                <span class="comment">// 完成put,退出整个for循环，退出方法</span></span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="comment">// 如果正在扩容，帮助数据迁移，并返回扩容后的新数组</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f); </span><br><span class="line">        <span class="comment">// 已初始化，表明发生了hash冲突</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 同步锁f</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; </span><br><span class="line">                <span class="comment">// 再次检查是否是同一个节点，有没有被修改 </span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// e f 是冲突链表的头结点，这里遍历</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 目标hash，key都一致，满足条件就替换旧值</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 遍历到了尾节点了</span></span><br><span class="line">                                <span class="comment">// new 一个node节点，插入到链表的尾巴上</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,  value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 冲突的位置已经不是链表了，是树</span></span><br><span class="line">                        Node&lt;K,V&gt; p; <span class="comment">// 接收插入树中成功的目标节点</span></span><br><span class="line">                        binCount = <span class="number">2</span>;  <span class="comment">//树，直接设置成2</span></span><br><span class="line">                        <span class="comment">// putTreeVal：查找或添加一个节点兵返回</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value; <span class="comment">// 替换旧值</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 上面put的时候如果已经是树了，binCount会被直接设置成2</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) <span class="comment">// 至少是8，才去尝试转换成为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);  <span class="comment">// 里面还有条件检查，不一定马上转成树</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 退出整个for自旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 元素数量加1，并判断是否达到扩容门槛</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>get方法</p></blockquote><ol><li>先计算hash值，再根据hash值计算索引<ul><li>如果索引位置为null，直接返回null</li><li>如果该位置上的节点hash值、key值都一致，返回找到的节点</li><li>如果该位置节点是链表，则遍历链表查找</li></ul></li><li>如果该位置节点hash值为-1，说明正在扩容，<code>调用find方法</code>查找</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// (n - 1) &amp; h ： 计算hash所在的索引</span></span><br><span class="line">    <span class="comment">// 数组初始化了，并且所在索引有值</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123; <span class="comment">// 目标hash值一致</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))) <span class="comment">// 目标key值一致</span></span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) <span class="comment">// 扩容迁移中by:https://jinglingwang.cn</span></span><br><span class="line">            <span class="comment">// 1.ForwardingNode.find</span></span><br><span class="line">            <span class="comment">// 2.TreeBin.find</span></span><br><span class="line">            <span class="comment">// 3.TreeNode.find</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123; <span class="comment">// 链表，遍历</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>添加计数：addCount</p></blockquote><ol><li>当没有冲突时，直接cas修改<code>basecount</code>完成计数更新。</li><li>自旋，判断是否达到扩容门槛<code>sizeCtl</code>。</li><li>如果达到扩容门槛，调用<code>transfer</code>方法进行扩容和转移数据操作。</li><li>如果发现已经有其他线程在扩容了，则当前线程加入迁移数据中（<code>transfer(tab, nt)</code>）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;<span class="comment">// b:基础计数</span></span><br><span class="line">    <span class="comment">// 两个条件：1.counterCells 不为空   2.cas修改baseCount失败（或的关系）</span></span><br><span class="line">    <span class="comment">// cas修改失败说明存在竞争关系，需要用到counterCells记录</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> || !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<span class="comment">//s:基础加上x后的计数</span></span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>; <span class="comment">//无竞争</span></span><br><span class="line">        <span class="comment">// 1. as == null：说明counterCells数组还没有初始化</span></span><br><span class="line">        <span class="comment">// 2. (m = as.length - 1) &lt; 0：counterCells数组长度为0</span></span><br><span class="line">        <span class="comment">// 3. 当前线程所在的位置段为null</span></span><br><span class="line">        <span class="comment">// 4. cas 修改当前线程段的值失败</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">// 完成了CounterCell数组初始化等工作，计数加入到CounterCell 数组</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>) <span class="comment">// 链表长度小于等与1，不看扩容，直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount(); <span class="comment">// 重新计算元素个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;  <span class="comment">// 主要看这里（counterCells为null,cas修改baseCount成功 ）</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 自旋，判断达到扩容门槛</span></span><br><span class="line">        <span class="comment">// 第一次自旋的时候sizeCtl表示的还是扩容门槛的意思，s表示的再次put一个元素后的值</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;  (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123; <span class="comment">// sc&lt;0 说明正在扩容中</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 扩容完成，退出自旋</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt); <span class="comment">// 其他线程正在扩容，去帮助扩容，nt是已经扩容后的数组了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 正常第一个线程触发扩容时会进入到这里</span></span><br><span class="line">                <span class="comment">// 进入迁移元素</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount(); <span class="comment">// 重新计算元素个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4、扩容"><a href="#4-4、扩容" class="headerlink" title="4.4、扩容"></a>4.4、扩容</h3><blockquote><p>扩容转移：transfer</p></blockquote><ol><li>每次调用transfer方法会按照<code>stride</code> 大小的纬度迁移数组数据（<code>stride:</code>默认16，和数组长度以及CPU数有），按数组索引倒序迁移。</li><li>transfer 方法完成了数组扩容*2的过程，通过<code>volatile</code>修饰的<code>nextTable</code>数组是否能null来验证是否已经有线程扩容了数组。</li><li>将原数组中的节点迁移到新数组后会将原数组中的位置设置成一个特殊的节点<code>ForwardingNode</code>，其hash值为-1，迁移时通过<code>synchronized</code>的方式来锁住迁移的桶。</li><li>当迁移时桶中冲突的链表或树会被拆分成两个新的链表（会被倒序）或树，然后分别放入到低位（原数组的索引位i）和高位（新数组的索引位i+n）。</li><li>第一次迁移完后会做一次对原数组的检查，再次遍历原数组检查数组是否完成迁移（hash为-1）</li><li>最后会将<code>sizeCtl</code>设置为下一次扩容检测阈值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride; <span class="comment">// n:原数组的长度</span></span><br><span class="line">        <span class="comment">// 保证stride 最小16，步长，将n按照stride大小切分成N段  </span></span><br><span class="line">        <span class="comment">// 当原数组n为512，CPU核数为2，stride 会变为32      </span></span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; </span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            </span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="comment">// nextTab 为 null，先进行一次初始化</span></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="comment">// 新的数组大小是原来的2倍   n&lt;&lt;1</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;  <span class="comment">// 防止扩容时内存溢出</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n; <span class="comment">// n是原数组的长度大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length; <span class="comment">// 扩容后数组的大小</span></span><br><span class="line">        <span class="comment">// ForwardingNode 翻译过来就是正在被迁移的 Node   构造方法会把hash设置成-1（MOVED）</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环 ，bound是边界值，i会倒序遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;  <span class="comment">// 自旋</span></span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing) <span class="comment">// 第一次这个if肯定不成立,i每次自减1</span></span><br><span class="line">                    advance = <span class="keyword">false</span>;  <span class="comment">// 退出自旋（这里不是马上退出，下面advance 还有可能被设置成true）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123; <span class="comment">// 第一次while自旋是不会进入到分支里面的,进入到这里说明倒序遍历到0了，已经结束了</span></span><br><span class="line">                    <span class="comment">// transferIndex 在上面被赋值成n,也就是原数组的长度大小</span></span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;  <span class="comment">// 退出自旋</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - **stride** : <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="comment">// 这里cas 修改transferIndex的值成功</span></span><br><span class="line">                    <span class="comment">//  nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0) 是神马意思呢？</span></span><br><span class="line">                    <span class="comment">//  如果原数组长度为512，这里nextBound就是481</span></span><br><span class="line">                    bound = nextBound; <span class="comment">// 遍历完一个stride 单位后，继续下一个边界计算</span></span><br><span class="line">                    i = nextIndex - <span class="number">1</span>; <span class="comment">// i变为原数组长度-1，也就是原数组最后一个元素</span></span><br><span class="line">                    advance = <span class="keyword">false</span>;   <span class="comment">// 退出自旋</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一次自旋进入到下面时，i表示的是原数组的倒序索引（也就是最后一个元素的索引）  </span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;  <span class="comment">// 第一次不会进第一个if分支，先看if后面的分支逻辑，最后走这个分支</span></span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="keyword">null</span>; <span class="comment">// 协助扩容的table置为null</span></span><br><span class="line">                    table = nextTab;  <span class="comment">// 更新扩容后的table</span></span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">// 相当于 n*0.75，作为下次扩容判断的阈值</span></span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 退出</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;  <span class="comment">// 最后面的synchronized 部分全部走完了，会进入到这儿</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>; <span class="comment">// 标记finishing 为true ,下面把i重新设置为原数组大小</span></span><br><span class="line">                    <span class="comment">// i被重新设置成n后，会再次检查原数组是否已经迁移完成；也就是下面的(fh = f.hash) == MOVED；检查完后，再进入到上面finishint = true的逻辑，最后退出</span></span><br><span class="line">                    i = n; <span class="comment">// recheck before commit by:https://jinglingwang.cn</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)  <span class="comment">// tab是原数组，原数组第i个元素是空的？</span></span><br><span class="line">                <span class="comment">// 如果桶中无数据，直接放入ForwardingNode节点标记该位置已经迁移</span></span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// 桶中有数据，但是hash值表示已经迁移过了（节点已经被设置过ForwardingNode）</span></span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 锁原数组的那个桶 table[i]</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">// 再次校验节点是否有变化，防止在锁之前已经被其他线程迁移</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// fh是hash值，只要不是负数（MOVED），就表示还没被迁移</span></span><br><span class="line">                            <span class="comment">// 运行位，和计算索引类似，但是有区别(索引计算是: (n-1) &amp; hash)</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                            <span class="comment">// lastRun 和jdk1.7的类似</span></span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">// 遍历链表</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123; <span class="comment">// 直到找到最后一个不一样的</span></span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 遍历链表，拆分成两个链表（倒序）</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>) <span class="comment">// 放入到低位链表（倒序）</span></span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span> <span class="comment">// 放入到高位链表（倒序）</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 放入到新数组的原位置</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            <span class="comment">// 放入到新数组的新位置</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">// 标记原数组的i位置已迁移</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>; <span class="comment">// 继续自旋处理下一个i--</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;  <span class="comment">//原数组i位置的元素是树节点</span></span><br><span class="line">                            <span class="comment">// 大致过程也是拆分成两棵树</span></span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">// lc  hc 是count数</span></span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="comment">// 遍历整棵树</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123; <span class="comment">// 根据计算，拆分成两棵不同的树</span></span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 分化后的树，节点数小于等于6时，则将树链表化</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln); <span class="comment">// 设置到低位</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn); <span class="comment">// 设置到高位</span></span><br><span class="line">                            setTabAt(tab, i, fwd); <span class="comment">// 标记原数组该位置已迁移</span></span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>helpTransfer</p></blockquote><ol><li>当put时，如果原节点的hash值为-1，说明正在扩容，线程会进入到该方法，确定是否要加入到扩容。</li><li>扩容完成后会返回扩容后的新数组，这样put方法继续执行之后的插入值逻辑。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入该方法，说明是有扩容在发生的</span></span><br><span class="line"><span class="comment">// table是原数组，f是索引位hash为-1的节点</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc; <span class="comment">// nextTab：预扩容的数组（要扩容后的新数组）</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// if 就是检查是否在扩容 </span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;  (sc = sizeCtl) &lt; <span class="number">0</span>) &#123; <span class="comment">// 检查是否正在扩容 </span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// transferIndex &lt;= 0 说明就扩容完成了 </span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);<span class="comment">// 加入到扩容</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// 扩容完成，退出自旋by:https://jinglingwang.cn</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table; <span class="comment">//进入方法发现已经完成扩容了，直接返回新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5、树形化"><a href="#4-5、树形化" class="headerlink" title="4.5、树形化"></a>4.5、树形化</h3><blockquote><p>链表树化：treeifyBin</p></blockquote><ol><li>在put元素的时候，如果冲突链表超过一定长度（至少为<code>8</code>），会触发尝试树化的操作。</li><li>实际还需要数组的长度至少达到了<code>64</code>才会执行树化，如果达不到会尝试扩容。</li><li>需要同时满足 8 + 64的条件才会树化。</li><li>树化的时候会锁住数组中整个冲突的节点（链表）。</li><li>树化会先将原Node链表转换成TreeNode链表，然后再转换成TreeBin节点并构造一颗红黑树设置到原数组的索引位置。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">    Node&lt;K,V&gt; b;  // 数组索引位置的元素</span><br><span class="line">    int n, sc; // n:数组的长度，</span><br><span class="line">    if (tab != null) &#123;</span><br><span class="line">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) // 数组的长度小于64</span><br><span class="line">            tryPresize(n &lt;&lt; 1); // 尝试扩容( &lt;&lt; 1 等效于 *2)，不执行树化</span><br><span class="line">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123; // 需要同时满足 8 + 64的条件</span><br><span class="line">            synchronized (b) &#123; // 锁指定的node节点</span><br><span class="line">                if (tabAt(tab, index) == b) &#123; // 获得锁后再次检查索引位置的节点是否有变</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">                    // 开始遍历链表，转换成树节点链表（还是一个链表关系）</span><br><span class="line">                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;</span><br><span class="line">                        // 构造树节点，这里还不是树形的</span><br><span class="line">                        TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,  null, null);</span><br><span class="line">                        if ((p.prev = tl) == null)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        else</span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 将树链表树化设置到数组中的相应位置，hash值是-2</span><br><span class="line">                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>树化前尝试扩容: tryPresize</p></blockquote><p>有两种情况会进入到该方法：</p><ol><li>直接调用<code>putAll</code>方法。<br>putAll时该方法会先初始化表，和initTable逻辑一致。</li><li>当put元素后，冲突节点的链表长度≥8，&lt;64会进入到该方法。</li></ol><ul><li>最后调用<code>transfer</code>方法开始扩容或者加入到扩容。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private final void tryPresize(int size) &#123;</span><br><span class="line">    // put时这里的size入参已经是原table的长度*2了</span><br><span class="line">    // c: 扩容的值，防止为了超过最大值，保证是2的幂</span><br><span class="line">    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span><br><span class="line">    int sc;</span><br><span class="line">    // sizeCtl：在表初始化好后，存储的值就是扩容的阈值</span><br><span class="line">    while ((sc = sizeCtl) &gt;= 0) &#123; //sizeCtl要么是扩容阈值，要么是初始化容量</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; int n;</span><br><span class="line">        if (tab == null || (n = tab.length) == 0) &#123; // 这里是防止table还没有初始化，putAll方法会直接调这里，和initTable逻辑一致</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (table == tab) &#123; // 初始化表</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) // 没有达到扩容的阈值或者已经达到最大不能再扩容了</span><br><span class="line">            break; // 退出； by:https://jinglingwang.cn</span><br><span class="line">        else if (tab == table) &#123; // 这里再次检查，是否已经被其他线程扩容，表已经发生变化？</span><br><span class="line">            // resizeStamp(n)： return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));</span><br><span class="line">            // Integer.numberOfLeadingZeros(n): 会返回从高位（总32位）数一共有多少个0，直到遇到1，比如numberOfLeadingZeros(n) 返回26</span><br><span class="line">            // 1 &lt;&lt; (RESIZE_STAMP_BITS - 1) ： 1 左位移 15 位，相当于2的15次方</span><br><span class="line">            // |  相当于把两个结果加起来</span><br><span class="line">            int rs = resizeStamp(n); // rs源码没注释，具体什么作用暂时不懂</span><br><span class="line">            if (sc &lt; 0) &#123;// 说明有其他线程已经正在扩容</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                    transferIndex &lt;= 0) // 满足条件退出，这条件啥意思？</span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt); //加入到扩容by:https://jinglingwang.cn</span><br><span class="line">            &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab, null); // 扩容，迁移数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链表树化：treeBin</p></blockquote><p>通过TreeBin的构造方法，将TreeNode链表转换成红黑树；</p><ol><li>初始化TreeBin节点，hash值为-1。by:<a href="https://jinglingwang.cn/">https://jinglingwang.cn</a></li><li>TreeBin节点的first属性指向TreeNode链表的头结点。</li><li>TreeBin节点的root属性记录整颗红黑树根节点。</li><li>加入到右子树后会平衡整棵树。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.first = b; <span class="comment">// treeBin的first节点指向TreeNode链表的头结点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;<span class="comment">// 树化后的根节点root </span></span><br><span class="line">    <span class="comment">// 开始遍历TreeNode链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123; </span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next; <span class="comment">// 遍历当前节点的下一个节点</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>; <span class="comment">// 保证左右节点为null</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123; <span class="comment">// 确定根节点</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 进入到下面，x是从TreeNode链表的第二个节点开始的</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;  <span class="comment">// 当前节点的key和hash值</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 遍历以r为根节点的红黑树</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line"><span class="comment">// 比较确定方向by:https://jinglingwang.cn</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) </span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// comparableClassFor 返回key的class类型（没有实现Comparable接口返回null）</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">// 根据上面确认下来的dir,判断是要加入到树的左子树还是右子树? 并且为null的子树</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp; <span class="comment">// 关联父节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x; <span class="comment">// 加入到左子树</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;  加入到右子树</span><br><span class="line">                    r = balanceInsertion(r, x);  <span class="comment">// 平衡，返回根节点</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 子树非null,继续遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = r;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>; <span class="comment">// 递归检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6、总结"><a href="#4-6、总结" class="headerlink" title="4.6、总结"></a>4.6、总结</h3><p><strong>结构：</strong>Node数组 + CAS + Synchronized。 Node数组存放 Node节点，或者TreeBin节点（封装TreeNode头结点）</p><p><strong>定义一个属性 sizeCtl：</strong>记录表的状态，如正在初始化，正在扩容</p><ol><li>构造对象时：2的次方且刚好大于参数传进来的容量大小，表示容量大小</li><li>初始化时：CAS设置为 -1 ，表示正在初始化</li><li>初始化完成：设置为容量 * 扩充因子，即扩容的阈值</li><li>扩容完成：新的阈值</li></ol><p><strong>初始化：</strong>volatile+CAS+自旋+双重检查的方式创建Node数组</p><p>1、自旋尝试 CAS 把 sizeCtl 设置为 -1，判断是否有其他线程正在初始化</p><p>2、大于则继续双重检查，选择使用 sizeCtl 或 默认容量来创建 Node 数组</p><p>3、成功，把sizeCtl 设置为扩容阈值</p><p><strong>put操作：</strong>不允许key/value 为null，第一次put时候初始化 Node 数组</p><p>1、自旋：先判断是否初始化，然后根据Hashcode找到索引出判断，</p><p>2、索引处没有元素，则CAS的添加元素；成功则退出，失败进行下一步</p><p>3、若在扩容，则先帮助扩容，直到结束；</p><p>4、使用synchronized锁住Node对象，进行操作（添加、替换旧值、树等）。</p><p>5、自旋结束后，使用 addCount计数，当数量大于阈值时，扩容。</p><p><strong>addCount方法：</strong>CAS的方式</p><p><strong>get方法：</strong></p><ol><li>先计算hash值，再根据hash值计算索引<ul><li>如果索引位置为null，直接返回null</li><li>如果该位置上的节点hash值、key值都一致，返回找到的节点</li><li>如果该位置节点是链表，则遍历链表查找</li></ul></li><li>如果该位置节点hash值为-1，说明正在扩容，<code>调用find方法</code>查找</li></ol><p><strong>扩容转移：</strong>CAS的方式转移节点。</p><p><strong>树形化：</strong></p><h2 id="5、CopyOnWriteArrayList"><a href="#5、CopyOnWriteArrayList" class="headerlink" title="5、CopyOnWriteArrayList"></a>5、CopyOnWriteArrayList</h2><p><strong>原理：</strong>每次操作（add ，set，remove等）都是通过复制一个底层的数组副本来实现的，在写操作的时候都会加上锁，有读写分离的意思。</p><p><strong>思想：</strong></p><ul><li>读操作不上锁，多个线程获取的都是同一个资源</li><li>写操作上锁，保证同时只有一个写操作线程。同时 copy 数组，写操作在复制的数组上进行，读操作在原数组上，互不干扰。</li></ul><h3 id="5-1、内部属性"><a href="#5-1、内部属性" class="headerlink" title="5.1、内部属性"></a>5.1、内部属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;   <span class="comment">// 数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类：迭代器，不支持add、set、remove操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot; <span class="comment">// array 快照记录了当时数组状态的引用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;              <span class="comment">// 游标，后续调用 next 将返回的元素索引</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2、方法分析"><a href="#5-2、方法分析" class="headerlink" title="5.2、方法分析"></a>5.2、方法分析</h3><blockquote><p>构造方法</p></blockquote><ol><li>初始化时没有指定数组的初始长度。</li><li>Arrays.copyOf的逻辑就是底层的System.arraycopy数组赋值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化默认无参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化指定集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="comment">// 判断类型</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含给定数组副本的列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将toCopyIn转化为Object[]类型数组，然后设置当前数组</span></span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>add方法</p></blockquote><ol><li>加锁</li><li>拿到原数组引用，并且copy一个长度+1的新数组</li><li>将新增元素加入到新数组的最后，新数组覆盖旧数组</li><li>释放锁，返回结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 0.加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.拿到数组引用</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 2.copy一个长度+1的数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.将新增元素加入到数组的最后</span></span><br><span class="line">        newElements[len] = e; </span><br><span class="line">        <span class="comment">// 4.覆盖旧数组</span></span><br><span class="line">        setArray(newElements); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 5.解锁</span></span><br><span class="line">        lock.unlock();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 覆盖数组</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引的add方法大致相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// addIfAbsent(e)方法：添加的元素不存在，才可以添加成功，避免多线程情况下重复添加元素</span></span><br><span class="line"><span class="comment">// 每次添加前判断数组是否发生了变化，若发生了改变，就判断要加的元素是否已经在数组中</span></span><br></pre></td></tr></table></figure><blockquote><p>remove方法</p></blockquote><ol><li>加锁，找索引，copy删除，覆盖旧数组，解锁返回</li><li>每次删除前判断依次数组是否发生改变，若改变就需要重写检验元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除指定索引位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获得锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 数组引用</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 指定元素的旧值 </span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="comment">// 索引位置后面的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 是最后一个元素，全部复制到一个长度减一的新数组中</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新的长度减一的数组</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 复制两次，相当于删掉了elements[index]</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements); <span class="comment">// 设置新数组的引用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue; <span class="comment">// 返回旧值by:https://jinglingwang.cn</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="comment">// 元素所在位置索引</span></span><br><span class="line">    <span class="keyword">int</span> index = indexOf(o, snapshot, <span class="number">0</span>, snapshot.length);</span><br><span class="line">    <span class="keyword">return</span> (index &lt; <span class="number">0</span>) ? <span class="keyword">false</span> : remove(o, snapshot, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o, Object[] snapshot, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) findIndex: &#123; <span class="comment">// 数组有变化会进入到if分支里面</span></span><br><span class="line">            <span class="keyword">int</span> prefix = Math.min(index, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix; i++) &#123;</span><br><span class="line">                <span class="comment">// 在新的数组中找到了和旧的元素不一致，并且就是要移除的值</span></span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123;</span><br><span class="line">                    index = i; <span class="comment">// 从新数组中重新确认的索引</span></span><br><span class="line">                    <span class="keyword">break</span> findIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上面for循环没找到，有可能元素在新的数组中还是在那个index位置没变化（current[i] != snapshot[i] 条件不满足）</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= len) <span class="comment">// 如果新数组是移除了一个元素，index最多也就等于len,既然新数组移除了元素，上面又没检查出来？直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (current[index] == o) <span class="comment">// 元素在新数组的同一个位置，没变化</span></span><br><span class="line">                <span class="keyword">break</span> findIndex;</span><br><span class="line">            index = indexOf(o, current, index, len); <span class="comment">// 位置有变化，就重新找到新位置</span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)  <span class="comment">// 没找到，已经删掉了，本次删除失败 by:https://jinglingwang.cn</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 后面的逻辑和上面的一直</span></span><br><span class="line">        Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(current, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">        System.arraycopy(current, index + <span class="number">1</span>,</span><br><span class="line">                         newElements, index,</span><br><span class="line">                         len - index - <span class="number">1</span>);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>set方法</p></blockquote><ol><li>加锁</li><li>找到指定索引的值，复制一个长度一样的新数组</li><li>在新数组中指定位置设置新元素，设置为新数组，</li><li>解锁返回</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 旧值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123; <span class="comment">// 两个值不一样</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">// 复制一个长度一样的新数组</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            <span class="comment">// 在新数组中指定位置设置元素</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">// 设置数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">        <span class="comment">// 值一样，设置数组</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue; <span class="comment">// 返回旧值</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3、弱一致性"><a href="#5-3、弱一致性" class="headerlink" title="5.3、弱一致性"></a>5.3、弱一致性</h3><p>只有释放锁的时候，才会把信息强制刷新到主存，所以读操作可能获取到过时的信息，</p><h3 id="5-4、总结"><a href="#5-4、总结" class="headerlink" title="5.4、总结"></a>5.4、总结</h3><ol><li><code>CopyOnWriteArrayList</code> 是一个线程安全的ArrayList，jdk1.8版本是通过<code>ReentrantLock</code>锁实现的，jdk11就已经改成了<code>synchronized</code>锁。</li><li>每次对数据的修改都会copy一份新的数组（哪怕数组的长度没变化），对内存要求比较高。</li><li><code>CopyOnWriteArrayList</code> 是弱一致性，不能保证修改数据后，其他线程马上就能感知。</li><li><code>CopyOnWriteArrayList</code> 不能限制数组的最长长度，使用需要谨慎。</li><li>适合集合大小保持较小，读操作大大超过可变操作的场景</li></ol><h2 id="6、CopyOnWriteArraySet"><a href="#6、CopyOnWriteArraySet" class="headerlink" title="6、CopyOnWriteArraySet"></a>6、CopyOnWriteArraySet</h2><p><strong>概念：</strong>CopyOnWriteArraySet是一个基于CopyOnWriteArrayList实现的线程安全的Set集合，所以该Set和CopyOnWriteArrayList拥有完全相似的特性。</p><h3 id="6-1、结构分析"><a href="#6-1、结构分析" class="headerlink" title="6.1、结构分析"></a>6.1、结构分析</h3><p>CopyOnWriteArraySet继承了AbstractSet，内部持有一个CopyOnWriteArrayList实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5457747651344034263L</span>;</span><br><span class="line">    <span class="comment">// 内部持有CopyOnWriteArrayList实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2、方法"><a href="#6-2、方法" class="headerlink" title="6.2、方法"></a>6.2、方法</h3><blockquote><p>构造方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个CopyOnWriteArrayList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部调用CopyOnWriteArrayList方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过addIfAbsent保证添加的数据不重复</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.addAllAbsent(c) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.contains(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    al.forEach(action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.iterator();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.remove(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>equals方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>) <span class="comment">// 引用相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Set)) <span class="comment">// 比较的对象都不属于Set，没必要比下去了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    Set&lt;?&gt; set = (Set&lt;?&gt;)(o);</span><br><span class="line">    <span class="comment">// 拿到迭代器</span></span><br><span class="line">    Iterator&lt;?&gt; it = set.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Uses O(n^2) algorithm that is only appropriate</span></span><br><span class="line">    <span class="comment">// for small sets, which CopyOnWriteArraySets should be.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Use a single snapshot of underlying array</span></span><br><span class="line">    <span class="comment">// 当前对象的数组，以及数组长度</span></span><br><span class="line">    Object[] elements = al.getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="comment">// Mark matched elements to avoid re-checking</span></span><br><span class="line">    <span class="comment">// 初始化一个长度一样的标识数组，用来记录标识另一个数组是否已经被校验过</span></span><br><span class="line">    <span class="keyword">boolean</span>[] matched = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 一次遍历</span></span><br><span class="line">    outer: <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++k &gt; len) <span class="comment">// 遍历发现两个集合长度都不一致</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Object x = it.next();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="comment">// 遍历，比较，并记录下来标志位</span></span><br><span class="line">            <span class="keyword">if</span> (!matched[i] &amp;&amp; eq(x, elements[i])) &#123;</span><br><span class="line">                matched[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//没匹配到未校验过的目标一致的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k == len; <span class="comment">// 遍历完后只需要校验长度是否一致即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3、总结"><a href="#6-3、总结" class="headerlink" title="6.3、总结"></a>6.3、总结</h3><ol><li><code>CopyOnWriteArraySet</code>主要是基于<code>CopyOnWriteArrayList</code>的<code>addIfAbsent</code>方法实现的。</li><li><code>CopyOnWriteArraySet</code>是线程安全的有序集合。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(六):Java并发队列</title>
      <link href="/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E5%85%AD%20)%20%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/"/>
      <url>/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E5%85%AD%20)%20%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1、并发队列Queue的分类和简介"><a href="#1、并发队列Queue的分类和简介" class="headerlink" title="1、并发队列Queue的分类和简介"></a>1、并发队列Queue的分类和简介</h2><p><strong>分类：</strong></p><ul><li><strong>阻塞队列：</strong>提供不同的方法，添加、移除效果会根据API的不同而不同；每个方法都会使用锁让<code>每次只能有一个线程操作队列</code>。</li><li><strong>非阻塞队列</strong>：队列的容量是无线大的。Integer.MaxValue(); 基于CAS ,没有使用锁，所以并发能力都是强，数据不需要等待。</li></ul><p><strong>堵塞：</strong>调用await让线程堵塞，等队列有空间或者数据了再唤醒。</p><p><strong>特点：</strong></p><ul><li>阻塞队列：ReentrantLock【悲观策略】，可以有两把锁（入队和出队不同的锁）或者一把锁</li><li>非阻塞队列【CAS冲突监测的乐观锁机制】</li></ul><p><strong>注意：</strong>堵塞队列都继承了AQS、BlockingQueue<E></p><blockquote><p>堵塞队列通用API：</p></blockquote><table><thead><tr><th>方法</th><th>抛出异常</th><th>有返回值，不抛异常</th><th>阻塞</th><th>超时等待</th></tr></thead><tbody><tr><td>添加</td><td>add</td><td>offer</td><td>put</td><td>offer</td></tr><tr><td>移除</td><td>remove</td><td>poll</td><td>take</td><td>poll</td></tr><tr><td>监测队首元素</td><td>element</td><td>peek</td><td></td><td></td></tr></tbody></table><h2 id="2、非阻塞队列-ConcurrentLinkedQueue"><a href="#2、非阻塞队列-ConcurrentLinkedQueue" class="headerlink" title="2、非阻塞队列-ConcurrentLinkedQueue"></a>2、非阻塞队列-ConcurrentLinkedQueue</h2><p><img src="C:\Users\admin\Desktop\Java并发\img\4.jpg"></p><p>由 head 节点和 tail 节点组成，每个节点由节点元素 item 和指向下一个节点 next 的引用组成，初始情况情况 head为空，tail 节点等于head节点。</p><p><strong>API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span><span class="comment">// 直接调用offer       </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span>  <span class="comment">// 线程安全的添加元素，不能为null，返回布尔值     </span></span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span>   <span class="comment">// 获取但不删除元素，返回首元素</span></span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span>   <span class="comment">// 获取并删除元素，返回首元素</span></span></span><br></pre></td></tr></table></figure><p><strong>入队列</strong></p><ul><li>利用VarHandle的对象 NEXT TAIL 来指定头结点和尾结点执行CAS操作</li><li>CAS替换尾结点的next 为待添加节点，成功后CAS把待替换节点替换成</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建待添加节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(Objects.requireNonNull(e));</span><br><span class="line"><span class="comment">// 第一次循环时把 p、t 设置为尾节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        <span class="comment">// 让q指向队尾节点的下一个节点</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明p是最后一个节点，于是尝试CAS添加新节点</span></span><br><span class="line">            <span class="comment">// 如果p为null，那么修改成newNode</span></span><br><span class="line">            <span class="keyword">if</span> (NEXT.compareAndSet(p, <span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// 判断p是否是尾结点，如果不是说明其他线程已经设置过，</span></span><br><span class="line">                <span class="keyword">if</span> (p != t)</span><br><span class="line">                    <span class="comment">// 尾结点CAS替换成待添加节点</span></span><br><span class="line">                    TAIL.weakCompareAndSet(<span class="keyword">this</span>, t, newNode);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果p节点等于p的next节点，则说明p节点和q节点都为空，</span></span><br><span class="line">        <span class="comment">// 表示队列刚初始化，所以返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="comment">// p有next节点，表示p的next节点是尾节点，</span></span><br><span class="line">        <span class="comment">// 则需要重新更新p后将它指向next节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>出队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置起始点 </span></span><br><span class="line">    restartFromHead: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// p表示head结点，需要出队的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;; p = q) &#123;</span><br><span class="line">            <span class="keyword">final</span> E item;</span><br><span class="line">            <span class="comment">// item不为空,则CAS设置p节点引用的元素为null</span></span><br><span class="line">            <span class="keyword">if</span> ((item = p.item) != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p != h) </span><br><span class="line">                    <span class="comment">//  把p的下一个节点设置为head节点</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果p节点的下一个节点为null，则说明这个队列为空，更新head</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 结点出队失败，重新跳到restartFromHead来进行出队</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新头结点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// 如果两个结点不相同，尝试用CAS指令原子更新head指向新头节点</span></span><br><span class="line">     <span class="keyword">if</span> (h != p &amp;&amp; HEAD.compareAndSet(<span class="keyword">this</span>, h, p))</span><br><span class="line">         <span class="comment">//将旧的头结点指向自身以实现删除</span></span><br><span class="line">         NEXT.setRelease(h, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、阻塞队列-ArrayBlockingQueue"><a href="#3、阻塞队列-ArrayBlockingQueue" class="headerlink" title="3、阻塞队列-ArrayBlockingQueue"></a>3、阻塞队列-ArrayBlockingQueue</h2><p>继承了BlockingQueue接口，底层是数组结构，按照先进先出的顺序</p><ul><li>默认情况下是非公平的：堵塞的线程会被<code>全部唤醒</code>，会同时竞争，所以不一定先堵塞的先访问队列，可以设置为公平的（参数加true即可）</li><li>创建需要需要指定大小</li></ul><p><strong>内部变量：</strong>两个condition分别等待和唤醒 添加  移除的 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化ID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">817911632652898426L</span>;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">final</span> Object[] items;             <span class="comment">// 内部数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> takeIndex;<span class="comment">// 队首元素序号，移除</span></span><br><span class="line"><span class="keyword">int</span> putIndex;<span class="comment">// 队尾元素序号，移除</span></span><br><span class="line"><span class="keyword">int</span> count;<span class="comment">// 队列中的元素数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;    <span class="comment">// 只有一把锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;  <span class="comment">// 等待condition</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="comment">// 当前活动迭代器的共享状态，如果已知没有迭代器，则为空。允许队列操作更新迭代器状态。</span></span><br><span class="line"><span class="keyword">transient</span> Itrs itrs;</span><br></pre></td></tr></table></figure><p><strong>构造方法：</strong>3种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认false,指定大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自己定义公平还是不公平</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用集合创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, fair);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c)</span><br><span class="line">                items[i++] = Objects.requireNonNull(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        count = i;</span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、阻塞队列-LinkedBlockingQueue"><a href="#4、阻塞队列-LinkedBlockingQueue" class="headerlink" title="4、阻塞队列-LinkedBlockingQueue"></a>4、阻塞队列-LinkedBlockingQueue</h2><p><strong>内部节点：</strong>单向链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内部变量：</strong>双锁机制，锁分离，吞吐量更高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头尾</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双锁机制，分别控制队头的移除和队尾的添加</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p><strong>构造器</strong>：3种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认情况下大小为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用其他集合创建链表阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">            enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、阻塞队列-PriorityBlockingQueue"><a href="#5、阻塞队列-PriorityBlockingQueue" class="headerlink" title="5、阻塞队列-PriorityBlockingQueue"></a>5、阻塞队列-PriorityBlockingQueue</h2><p><strong>结构：</strong>二叉堆+<strong>数组</strong>+CAS,无界队列</p><p><strong>特点：</strong></p><ul><li>默认按照升序排列，需要实现排序接口或者传入排序器。</li><li>默认是11个大小容量，可以自动扩容到无界队列MAX_VALUE</li></ul><p><strong>扩容原理：</strong></p><ol><li>获取锁之后，如果需要扩容就会<code>先释放锁</code>，为了性能：先让其他线程执行操作</li><li>使用CAS控制只有一个线程去扩容，失败的线程调用Thread.yield()让出cpu让出时间片。</li><li>创建新数组，<code>创建之后获取锁</code>，进行复制操作。</li></ol><p><strong>内部变量：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;         <span class="comment">// 大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;   <span class="comment">// 通过数组维护了二叉堆的结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;      <span class="comment">// 排序器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">// 锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();  <span class="comment">// 为空时移除要等待</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容队列时候做cas的，目的是保证只有一个线程可以进行扩容。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line"><span class="keyword">private</span> PriorityQueue&lt;E&gt; q;   <span class="comment">// 搞序列化的</span></span><br></pre></td></tr></table></figure><p><strong>扩容方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">// 出于性能考虑先释放锁</span></span><br><span class="line">    Object[] newArray = <span class="keyword">null</span>;   <span class="comment">//扩容后的数组</span></span><br><span class="line">    <span class="comment">//自旋锁变量，默认为0，需要经过原子cas判断之后才会改值此处控制单线程进入if语句</span></span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ALLOCATIONSPINLOCK.compareAndSet(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//扩容大小，&lt;64, +2, 如果大于64， + 50%， 封顶为int最大值-8</span></span><br><span class="line">            <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                   (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></span><br><span class="line">                                   (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></span><br><span class="line">                <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//扩容出新数组，此处需要queue==array, 原因：已有线程扩容成功不必再扩容</span></span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程不满足allocationSpinLock 自旋锁变量的if判断，表示扩容失败，让出cpu</span></span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) </span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="comment">//数据拷贝，不允许同时出列入列，需要获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">//queue==array 如果已经扩容， 此处扩容放弃</span></span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造器方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定大小，传入构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[Math.max(<span class="number">1</span>, initialCapacity)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、阻塞队列-DelayQueue"><a href="#6、阻塞队列-DelayQueue" class="headerlink" title="6、阻塞队列-DelayQueue"></a>6、阻塞队列-DelayQueue</h2><p><strong>延迟队列：</strong>可以看做特殊优先级队列，只比较剩余时间</p><ul><li>添加元素可以指定有效期；必须过期之后才可以取出来 peek(),poll(),take(),   </li><li><code>元素要实现 Delayed 接口</code> ：long getDelay(TimeUnit unit) 返回剩余时间，如果小于等于0 表示过期。有序，PriorityQueue (数组结构)</li></ul><p><strong>原理：</strong></p><ol><li>内部定义一个优先级队列，使用<code>完全二叉堆</code>实现排序</li><li>取出元素：如果没有达到延时时间，就延时堵塞，到时间会自动醒来。</li><li>设置leader：优化阻塞通知，减少不必要的等待时间。</li></ol><p><strong>注意：</strong>延迟队列take()取出的是Deplay类型的数据</p><p><strong>内部变量：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();   <span class="comment">// 优先级队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Thread leader; <span class="comment">// 用于优化阻塞通知的线程元素leader</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition(); <span class="comment">// 等待condition</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要比较器，因为只能放入实现了Delay接口能比较的对象</span></span><br></pre></td></tr></table></figure><p><strong>构造方法：</strong>2种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 传入集合构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>offer方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e); <span class="comment">// 添加到优先级队列</span></span><br><span class="line">        <span class="comment">// 查看元素是否为队首</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            <span class="comment">// 如果是队首的话，设置leader为空，唤醒所有等待的队列</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>take方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();   <span class="comment">// 执行加锁操作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek(); <span class="comment">// 取出优先级队列元素q的队首</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await(); <span class="comment">// 队首为空,则阻塞</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不为空就判断delay值,到时就poll弹出</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                <span class="comment">// 为空,释放first</span></span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">                <span class="comment">// leader不为空堵塞当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// leader为空就执行当前线程</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 堵塞delay的时间后自动醒来</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 释放leader</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// leader为空并且优先级队列不为空,唤醒一个线程</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();  </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><p><strong>leader：</strong>指向正在取数据的线程</p><ol><li>取数据：先判断有没有数据（等待），再看时间没到到，没到就查看leader，<ul><li>如果不为空：说明已经有线程在取了，自己自然取不出，就await等待</li><li>如果为空：leader指向自己，awaitNanos()延迟等待自动唤醒。</li></ul></li><li>存数据：如果存入的数据优先级最高，就表示没有能取的数据，把leader设置为null，唤醒取一个数据的线程。</li></ol><p><strong>几种情况</strong></p><ul><li>take但没有数据被堵塞：添加数据的时候会被唤醒成功取出数据</li><li>take 但是 leader不为空 被堵塞：leader指向的数据 是awaitNanos()延迟等待，自动醒来后会唤醒当前的线程。</li></ul><p><strong>leader的作用：</strong>减少不必要的等待时间，只要为非nul，说明有线程再取且在等待，就说明自己肯定也取不出，直接堵塞。</p><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">long</span> exprie; <span class="comment">// 过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo4</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">long</span> exprie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.exprie = exprie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Demo4&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> convert = timeUnit.convert(exprie - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(convert);</span><br><span class="line">        <span class="keyword">return</span> convert;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed delayed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS)-delayed.getDelay(TimeUnit.MILLISECONDS)&gt;=<span class="number">0</span>?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DelayQueue&lt;Demo4&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        Long nowTime = System.currentTimeMillis();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> Demo4(<span class="number">1</span>,<span class="string">&quot;周杰伦&quot;</span>,nowTime+<span class="number">1000</span>));</span><br><span class="line">        queue.offer(<span class="keyword">new</span> Demo4(<span class="number">2</span>,<span class="string">&quot;昆凌&quot;</span>,nowTime+<span class="number">5000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、阻塞队列-SynchronousQueue"><a href="#7、阻塞队列-SynchronousQueue" class="headerlink" title="7、阻塞队列-SynchronousQueue"></a>7、阻塞队列-SynchronousQueue</h2><p><strong>特点：</strong></p><ul><li>最多放一个数据，存了就必须去取出来在存，即大小为1的堵塞队列</li><li>线程A put( ) 存东西之后会立即进入堵塞状态。此时只有线程B进行 take( ) 取操作才能让线程A从堵塞状态继续运行。如果A堵塞后，B也是取，那么B也会堵塞</li><li>处于堵塞状态时其他API都不能调用，只能使用take</li><li>默认非公平的，可以设置为公平的</li><li>性能高</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;存数据&quot;</span>);</span><br><span class="line">                queue.put(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、阻塞队列-LinkedTransferQueue"><a href="#8、阻塞队列-LinkedTransferQueue" class="headerlink" title="8、阻塞队列-LinkedTransferQueue"></a>8、阻塞队列-LinkedTransferQueue</h2><p><strong>特点：</strong>无界，多了两个方法</p><h2 id="9、阻塞队列-LinkedBlockingDeque"><a href="#9、阻塞队列-LinkedBlockingDeque" class="headerlink" title="9、阻塞队列-LinkedBlockingDeque"></a>9、阻塞队列-LinkedBlockingDeque</h2><p><strong>特点：</strong>可以双端操作，First、Last方法，无界</p><p><strong>节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node(E x) &#123;</span><br><span class="line">        item = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内部变量：</strong>单锁结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br></pre></td></tr></table></figure><p><strong>构造方法：</strong>3种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(五):锁</title>
      <link href="/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%BA%94%20)%20%E9%94%81/"/>
      <url>/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%BA%94%20)%20%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1、锁介绍"><a href="#1、锁介绍" class="headerlink" title="1、锁介绍"></a>1、锁介绍</h2><h3 id="1-1、各种锁的概念"><a href="#1-1、各种锁的概念" class="headerlink" title="1.1、各种锁的概念"></a>1.1、各种锁的概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">悲观锁：取数据时，认为线程不安全，直接上锁。           //  ReentrantLock</span><br><span class="line">乐观锁：取数据时，不加锁，只是判断信息有没有被修改过。  //  CAS</span><br><span class="line"></span><br><span class="line">共享锁：读锁，多条线程可以持有线程锁。可以认为不加锁</span><br><span class="line">独占锁：互斥锁，一条线程持有锁。</span><br><span class="line"></span><br><span class="line">公平锁：先到先得获取锁，有序获取。降低了性能。</span><br><span class="line">非公平锁：无须，靠运气，提供了性能，</span><br><span class="line"></span><br><span class="line">自旋锁：CAS思想：不短自旋，浪费cpu，不会阻塞。</span><br><span class="line">非自旋锁：容易造成线程等待。</span><br><span class="line"></span><br><span class="line">可中断锁：发送信号，中断获取锁，提高了灵活性。</span><br><span class="line">非可中断锁:不能中断获取锁，会一直等待锁的释放。</span><br><span class="line"></span><br><span class="line">可重入锁：能获取锁多次，一定程度避免死锁</span><br><span class="line">非可重入锁：不可以多次获取锁，只能获取一次。</span><br></pre></td></tr></table></figure><h3 id="1-2、ReentrantLock和Synchronize区别"><a href="#1-2、ReentrantLock和Synchronize区别" class="headerlink" title="1.2、ReentrantLock和Synchronize区别"></a>1.2、ReentrantLock和Synchronize区别</h3><ol><li><p>Synchronized是内置关键字，Lock是类</p></li><li><p>Synchronized无法判断获取锁得状态，Lock可以</p></li><li><p>Synchronized可以自动释放锁(一个线程执行完)，Lock必须手动释放(死锁的可能)</p></li><li><p>Synchronized线程1(获得锁，堵塞)线程2(一直等)，Lock会导入到虚拟的阻塞队列进行自旋等待</p></li><li><p>Synchronized是可重入锁，不能中断，非公平；Lock可重入，可设置公平度</p></li><li><p>Synchronized适合锁少的代码同步，Lock适合锁大量的同步代码</p></li></ol><h2 id="2、队列同步器AQS"><a href="#2、队列同步器AQS" class="headerlink" title="2、队列同步器AQS"></a>2、队列同步器AQS</h2><p><strong>队列同步器AbstractQueuedSynchronizer：</strong><code>用于构建锁或其他同步组件的基础框架，</code>使用了一个int成员变量表示同步状态，内置的 <code>FIFO 队列</code>来完成资源获取线程的排队工作。</p><p>​     同步器的主要实现方式是继承，子类通过继承同步器实现抽象方法管理同步状态。同步器提供的三个方法可以保证状态的改变是线程安全的</p><p>​    同步器是实现锁（其他任意同步组件）的关键，在锁的实现中<code>聚合同步器</code>，从而实现锁的语义。</p><ul><li>锁是面向使用者的，定义了使用者和锁交互的接口，隐藏了细节</li><li>同步器面向的是锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</li></ul><h3 id="2-1、队列同步器的接口与示例"><a href="#2-1、队列同步器的接口与示例" class="headerlink" title="2.1、队列同步器的接口与示例"></a>2.1、队列同步器的接口与示例</h3><p>队列同步器是基于模板方法模式的：使用者可以通过重写指定的方法，同步器会调用这些重写的方法，实现不同的效果。</p><p><strong>同步器提供的方法：</strong>访问或修改同步状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步器提供的方法：访问或修改同步状态</span></span><br><span class="line">getState();              <span class="comment">// 获取当前同步状态</span></span><br><span class="line">setState(<span class="keyword">int</span> newState)   <span class="comment">// 设置当前同步状态</span></span><br><span class="line">compareAndSetSate(<span class="keyword">int</span> except,<span class="keyword">int</span> newState)  <span class="comment">// 原子性设置状态    </span></span><br></pre></td></tr></table></figure><p><strong>同步器可重写的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span>)</span>  <span class="comment">// 独占方式获取同步状态，实现方法需要查询当前状态并判断同步状态是否符合预期，再进行CAS设置状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span>)</span>  <span class="comment">// 独占方式释放同步状态</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span>)</span>    <span class="comment">// 共享方式尝试获取同步状态，负数失败；正数成功，0</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span>)</span><span class="comment">// 共享方式释放同步状态</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span>  <span class="comment">// 当前同步器是否在独占模式下被占用，即是否被当前线程独占</span></span></span><br></pre></td></tr></table></figure><p><strong>同步器的模板方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;  <span class="comment">// 独占式获取同步状态,获取成功由该方法返回，失败调用重写的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;       <span class="comment">// 若失败进入同步队列时,可以被中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg,<span class="keyword">long</span> nanos)</span></span>; <span class="comment">// 中断的基础加入了超时等待</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>; <span class="comment">// 共享式获取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg,<span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;        <span class="comment">// 独占式释放，释放之后会唤醒同步队列的第一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span>  <span class="comment">// 获取等待在同步队列的线程集合</span></span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p><strong>自定义线程的state为1时表示占有了锁，为0表示处于等待</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">// 设置获取到锁的线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置获取到锁的线程</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span>  <span class="comment">// 是否处于占用状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、队列同步器分析：同步队列"><a href="#2-2、队列同步器分析：同步队列" class="headerlink" title="2.2、队列同步器分析：同步队列"></a>2.2、队列同步器分析：同步队列</h3><p>同步器依赖内部的同步队列：一个FIFO双向队列，完成同步状态的管理。</p><ul><li>当前线程获得同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点，并把其加入队列，同时堵塞当前线程，</li><li>同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</li></ul><p><strong>节点的属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread thread   <span class="comment">// 线程</span></span><br><span class="line"><span class="keyword">int</span> waitStatus  <span class="comment">// 等待状态</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 0: 初始状态</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">Node pre Node next <span class="comment">// 前后节点</span></span><br><span class="line">Node nextWaiter    <span class="comment">// 等待队列的后继节点</span></span><br></pre></td></tr></table></figure><ul><li>同步构造器拥有头结点和尾结点，没有成功获取同步状态的线程会变成节点加入队列尾部</li><li>当一个线程获得了同步状态（锁），其他线程就没办法获取到同步状态，所以就没法转换成节点加入同步队列，所以提供了 compareAndSetTail() 设置尾节点。</li><li>同步队列遵循FIFO，头结点是获取同步状态成功的节点，首节点的线程结束后会释放同步状态，唤醒后继节点，成功获得同步状态的节点会把自己设置为头结点，由于只有一个线程能够获取到同步状态，所以设置头结点不需要CAS</li></ul><h3 id="2-3、队列同步器分析：独占式同步状态"><a href="#2-3、队列同步器分析：独占式同步状态" class="headerlink" title="2.3、队列同步器分析：独占式同步状态"></a>2.3、队列同步器分析：独占式同步状态</h3><p>​        调用同步器的<code>模板方法</code> acquire(int arg) 可以获取同步状态(相当于获得锁)，该方法对中断不敏感，也就是说获取同步失败时进入同步队列时，如果进行中断<code>不会移出同步队列</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码分析: 先调用重写的tryAcquire(arg)方法获取同步状态，如果失败就构造节点并添加进同步队列并且不断自旋，如果都失败就中断抛出异常。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();  <span class="comment">// 中断   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addWriter方法：</strong>添加到同步队列尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(mode);  <span class="comment">// 创建当前线程的节点</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        Node oldTail = tail;     <span class="comment">// 尝试在尾部添加</span></span><br><span class="line">        <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) &#123;   </span><br><span class="line">            node.setPrevRelaxed(oldTail);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123; <span class="comment">// CAS在尾部后面添加节点</span></span><br><span class="line">                oldTail.next = node;   <span class="comment">// 尾部指向头部</span></span><br><span class="line">                <span class="keyword">return</span> node;           <span class="comment">// 返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            initializeSyncQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeSyncQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h;</span><br><span class="line">    <span class="keyword">if</span> (HEAD.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, (h = <span class="keyword">new</span> Node())))</span><br><span class="line">        tail = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>acquireQueued方法：</strong>节点进入同步队列之后，会判断是否应该堵塞，若不堵塞就一直自旋。堵塞之后的唤醒依靠前驱节点的的出队或者堵塞线程被中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有头结点能够获取到同步状态，被唤醒后会继续检查前驱节点是不是头结点，若果是则尝试获取同步，获取成功把自己设置为头结点。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();    <span class="comment">// 获得前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  <span class="comment">// 判断前驱节点是不是头结点并获取同步</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过前驱节点判断是否应该被堵塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))</span><br><span class="line">                interrupted |= parkAndCheckInterrupt();  <span class="comment">// 堵塞线程,并重置中断状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>release方法：</strong>释放同步状态，唤醒后面的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);  <span class="comment">// 唤醒后面的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><p>​        获取同步状态时，队列同步器会维护一个队列，获取同步失败的会加入队列进行自旋（自旋会判断是否需要堵塞），当被唤醒（前驱节点释放同步状态或者本线程中断）且前驱节点为头结点时，就会尝试获取同步状态，获取成功后当前线程会设置成队首。</p><h3 id="2-4、队列同步器分析：共享式同步状态"><a href="#2-4、队列同步器分析：共享式同步状态" class="headerlink" title="2.4、队列同步器分析：共享式同步状态"></a>2.4、队列同步器分析：共享式同步状态</h3><p><strong>特点：</strong>同时能够有多个线程获取到同步状态</p><p><strong>acquireShared方法分析</strong>：尝试获取同步状态，失败则执行doAcquireShared</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquireShared自己重写的方法，返回小于0表示未获取到同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)  </span><br><span class="line">        doAcquireShared(arg);  <span class="comment">// 未获取到进入自旋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>doAcquireShared：</strong>先添加到同步队列，然后不断自旋，前驱节点为头结点则尝试获取同步状态，获取到同步状态时会立即唤醒下一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);  <span class="comment">// 添加到同步队列</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();   <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;                     <span class="comment">// 如果前驱节点是头结点</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);   <span class="comment">// 不断尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))  <span class="comment">// 判断是否应该堵塞</span></span><br><span class="line">                interrupted |= parkAndCheckInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>releaseShared：</strong>释放同步状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义重写方法返回真则执行方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();    <span class="comment">// 释放并且唤醒一个线程，释放过程是线程安全的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>doReleaseShared方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!h.compareAndSetWaitStatus(Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果头结点状态为0就重复直到头结点的状态成功设置为Node.PROPAGATE</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !h.compareAndSetWaitStatus(<span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>想要获取同步状态，只有一条路：重写的acquireShared() 方法返回 大于等于0</li><li>与独占式相比：释放的情况下可能有多个线程同时释放，所以通过循环和CAS保证线程安全。</li></ol><blockquote><p>总结</p></blockquote><p>独占：一次只能有一个线程获取到同步状态，获取失败的线程会在自旋中判断堵塞，只有获得同步状态的线程释放后才会唤醒下一节点。</p><p>共享：一次可以有多个线程获取到同步状态，获取失败的线程会在<code>自旋中重复获取</code>和判断堵塞，一旦获取到同步状态或者释放同步状态</p><h3 id="2-5、队列同步器分析：独占式超时"><a href="#2-5、队列同步器分析：独占式超时" class="headerlink" title="2.5、队列同步器分析：独占式超时"></a>2.5、队列同步器分析：独占式超时</h3><p><strong>tryAcquireNanos分析：</strong>如果中断会抛出异常，直接返回。否则尝试获取同步状态，获取失败后进行超时获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())  <span class="comment">// 判断中断状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>doAcquireNanos方法分析：</strong>先添加到同步队列，然后不断自旋：前驱节点为头结点时尝试获取同步，获取失败会判断超时，未超时则等待，超时则抛出异常返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);  <span class="comment">// 添加到同步队列</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();   <span class="comment">// 前驱节点头结点时尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime(); <span class="comment">// 获取失败会判断是否超时</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断线程是否应该等待并执行步骤，小于1000纳秒时不断自旋</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);  <span class="comment">// 堵塞</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();           <span class="comment">// 时间到了就抛出异常退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6、队列同步器分析：堵塞条件判断"><a href="#2-6、队列同步器分析：堵塞条件判断" class="headerlink" title="2.6、队列同步器分析：堵塞条件判断"></a>2.6、队列同步器分析：堵塞条件判断</h3><p><strong>队列的状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> waitStatus  <span class="comment">// 等待状态</span></span><br><span class="line">       </span><br><span class="line"><span class="number">0</span>   INITIAL     <span class="comment">// 初始状态</span></span><br><span class="line"><span class="number">1</span>   CANCELLED   <span class="comment">// 线程取消了</span></span><br><span class="line">-<span class="number">1</span>  SINGAL      <span class="comment">// 线程需要被唤醒</span></span><br><span class="line">-<span class="number">2</span>  CONDITION   <span class="comment">// 节点在等待队列中,节点线程等待在condition上,调用signal方法会转                            移到同步队列中</span></span><br><span class="line">-<span class="number">3</span>  PROPANGATE  <span class="comment">// 状态需要向后传播          </span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><strong>shouldParkAfterFailedAcquire（前驱节点，当前节点）</strong>方法详解</p><ul><li>把node的有效前驱（有效是指node不是CANCELLED的）找到，并且将有效前驱的状态设置为<code>SIGNAL</code>，之后便返回true代表马上可以阻塞了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用该方法的一定是node的线程，也就是lock上锁的线程</span></span><br><span class="line"><span class="comment">// 执行到该方法，已经尝试获取锁失败了，接着就是判断让当前线程堵塞还是继续自自旋</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得前驱节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)  <span class="comment">// 前驱节点等于 -1 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;           <span class="comment">// 如果节点被取消了就把之中的节点踢出队列</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7、总结"><a href="#2-7、总结" class="headerlink" title="2.7、总结"></a>2.7、总结</h3><p>AQS核⼼思想：，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS 是⽤ CLH 队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。</p><p>AQS的应用：</p><ul><li>Semaphore **(**信号量)-允许多个线程同时访问：</li><li>CountDownLatch（倒计时器）：让线程阻塞，倒计时结束才被唤醒</li><li>CyclicBarrier (循环栅栏)：设置屏障</li></ul><h2 id="3、可重入锁"><a href="#3、可重入锁" class="headerlink" title="3、可重入锁"></a>3、可重入锁</h2><h3 id="3-1、ReentrantLock锁：基本概念和特点"><a href="#3-1、ReentrantLock锁：基本概念和特点" class="headerlink" title="3.1、ReentrantLock锁：基本概念和特点"></a>3.1、ReentrantLock锁：基本概念和特点</h3><p><strong>特点</strong></p><ul><li>支持了锁超时</li><li>支持可中断</li><li>支持公平锁、非公平锁</li><li>支持获取自己获得锁的状态</li><li>condition 等待通知</li><li>可重入的锁</li></ul><p><strong>常用API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock                        <span class="comment">// 获取锁           </span></span><br><span class="line">unlock                      <span class="comment">// 释放锁           </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>  <span class="title">trylock</span><span class="params">()</span>          <span class="comment">// 尝试获取锁       </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>  <span class="title">trylock</span><span class="params">(time,unit)</span> <span class="comment">// 限定时间内获取锁 </span></span></span><br><span class="line"><span class="function"><span class="title">lockInterruptibly</span><span class="params">()</span>         <span class="comment">// 响应中断   </span></span></span><br><span class="line"><span class="function"><span class="title">newCondition</span><span class="params">()</span>              <span class="comment">// 等待通知队列     </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="title">isHeldByCurrentThread</span><span class="params">()</span>     <span class="comment">// 当前线程是否持有该锁    </span></span></span><br></pre></td></tr></table></figure><p><strong>简单使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    Lock lock  =<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//同步资源</span></span><br><span class="line">        Demo3 demo3=<span class="keyword">new</span> Demo3();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                demo3.lock.lock();</span><br><span class="line">                i++;</span><br><span class="line">                demo3.lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                demo3.lock.lock();</span><br><span class="line">                i--;</span><br><span class="line">                demo3.lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、ReentrantLock锁：可重入概念"><a href="#3-2、ReentrantLock锁：可重入概念" class="headerlink" title="3.2、ReentrantLock锁：可重入概念"></a>3.2、ReentrantLock锁：可重入概念</h3><ul><li>不可重入：线程只能获取一次锁。如果重复获取锁会容易造成死锁。  sun.lock</li><li> 可重入：线程可以多次获取同一把锁。避免死锁  </li></ul><p><strong>原理：</strong></p><ul><li>AQS内部 维护了一个 变量 state 等于0 表示无锁，**<code>等于1表示获取到锁</code><strong>，</strong><code>大于1 就是可重入锁</code>**。</li><li>通过判断当前线程是否已经持有锁来判定能不能继续获得锁。</li></ul><p><strong>注意：</strong>获得了几次锁，就要释放几次，只有state为0，才表明不再持有该锁，成功释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 初次获得锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// CAS设置状态成功即表示获取到了锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非初次获得锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、ReentrantLock锁：公平锁概念"><a href="#3-3、ReentrantLock锁：公平锁概念" class="headerlink" title="3.3、ReentrantLock锁：公平锁概念"></a>3.3、ReentrantLock锁：公平锁概念</h3><p><strong>原理：</strong></p><ul><li><strong>公平锁：</strong>如果同步队列有等待的节点，新节点就直接加入堵塞队列。符合先进先出</li><li><strong>非公平锁：</strong>先尝试获取锁，获取失败再加入堵塞队列</li></ul><p><strong>使用非公平锁</strong></p><ul><li> Lock lock  =new ReentrantLock(true); 这种方式创建的就是公平锁，默认非公平锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@ReservedStackAccess</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须同步队列里面为空才行</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4、ReentrantLock锁：lockInterruptibly-等待中断"><a href="#3-4、ReentrantLock锁：lockInterruptibly-等待中断" class="headerlink" title="3.4、ReentrantLock锁：lockInterruptibly()等待中断"></a>3.4、ReentrantLock锁：lockInterruptibly()等待中断</h3><p><strong>中断：</strong>类似 sleep 等代码 都需要捕获异常，设置中断后 如果执行到需要捕获异常的代码时，就会被异常捕获，然后跳转到捕获代码之后的代码执行。</p><p><strong>lockInterruptibly()：</strong> 需要捕获异常，所以当设置中断时，就会被捕获抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取锁&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//同步资源</span></span><br><span class="line">        Demo demo = <span class="keyword">new</span>  Demo();</span><br><span class="line">        Runnable runnable = (()-&gt;&#123; </span><br><span class="line">            demo.serviceMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(runnable, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、-读写锁"><a href="#4、-读写锁" class="headerlink" title="4、 读写锁"></a>4、 读写锁</h2><p><strong>ReentrantReadWriteLock作用：</strong>弥补独占锁的不足，公司的场景：读多写少</p><p><strong>特性：</strong></p><ul><li><p> 公平与非公平</p></li><li><p> 支持锁降级：写锁可以降级成读锁</p></li><li><p> 支持可重入     </p></li><li><p> 支持可中断</p></li><li><p> 支持condition</p></li><li><p> API方面</p></li></ul><p><strong>API：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">readLock()                 <span class="comment">// 获取读锁对象 </span></span><br><span class="line">writeLock()                <span class="comment">// 获取写锁对象 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gerReadHoldCount</span><span class="params">()</span>         <span class="comment">// 读锁被获取的总次数    </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getReadLockCount</span><span class="params">()</span>         <span class="comment">// 当前线程获取读锁数量     放在ThreadLocal中 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWriteHoldCount</span><span class="params">()</span>        <span class="comment">//  当前线程获取写锁数量    </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isWriteLocked</span><span class="params">()</span>         </span></span><br></pre></td></tr></table></figure><ul><li>读写互斥</li><li>写写互斥</li><li>读读不互斥</li></ul><p><strong>原理</strong>：state是一个int 变量 ，总共32位，所以拿出前16位 作为读。后16位表示写。</p><p><img src="C:\Users\admin\Desktop\Java并发\img\3.jpg"></p><p><strong>判断读写的状态：</strong>通过位运算</p><ul><li>state  &amp; 0x0000FFFF  把高16位抹去表示写状态</li><li>state  &gt;&gt;&gt; 16               位右移动16位即抹去右边16位表示读状态</li></ul><p><strong>获取释放锁</strong></p><ul><li>存在写锁时，不能继续获得锁（）</li><li>存在读锁时，可以继续获得读锁。</li><li>获取锁的方式：CAS更新标志位  </li><li>释放锁的方式：读锁要保证线程安全，写锁普通释放</li></ul><p><strong>锁降级：</strong>已经持有写锁，先获取读锁，然后释放写锁，</p><p><strong>目的：</strong>保证数据的可见性，若线程A直接释放锁，此时另一个线程B获取锁并修改数据，线程A无法感知到数据的变化。</p><p><strong>读写锁例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取：</span></span><br><span class="line">ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">// 上锁，解锁</span></span><br><span class="line">readWriteLock.writeLock().lock();  <span class="comment">// 读锁</span></span><br><span class="line">readWriteLock.writeLock().unlock();</span><br><span class="line">readWriteLock.readLock().lock();   <span class="comment">// 写锁</span></span><br><span class="line">readWriteLock.readLock().unlock();</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果，两个读操作同时输出，写过了3秒才输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money= <span class="number">500</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readWriteLock.readLock().lock();</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;我有&quot;</span>+money+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().lock();</span><br><span class="line">            money = <span class="number">100</span>;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(money);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo6 demo6 = <span class="keyword">new</span> Demo6();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo6.read();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo6.read();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo6.write();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点：会造成线程饥饿</strong></p><blockquote><p>邮戳锁</p></blockquote><p><strong>线程饥饿</strong>：由于读锁大量占用，导致写锁始终获取不到锁，造成写锁一致等待获取锁</p><p><strong>邮戳：</strong>通过戳校验；判断写锁是否被获取过</p><p><strong>特点：</strong></p><ul><li>不支持可重入</li><li>不支持Condition 等待通知</li><li>读写锁之间互相转化。</li><li>邮戳，提高并发</li></ul><p><strong>API：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">读/写+乐观读</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryOptimisticRead</span><span class="params">()</span>     <span class="comment">// 获取乐观读锁，返回一个 “戳” 版本号</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">long</span> stamp)</span> <span class="comment">// 验戳 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryReadLock</span><span class="params">()</span>           <span class="comment">// 获取读锁 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span>  <span class="title">tryUnlockWrite</span><span class="params">()</span>       <span class="comment">// 获取写锁  </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 注意这里的普通读锁和写锁功能和读写锁一致，不过有一个乐观读，可以随时被写锁打断    </span></span></span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><ul><li>使用 validate 可以根据版本号判断中间是否有读锁请求过</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StampedLock lock=<span class="keyword">new</span> StampedLock();</span><br><span class="line">        <span class="comment">// 获取乐观读锁，返回一个戳版本号</span></span><br><span class="line">        <span class="keyword">long</span> stamped = lock.tryOptimisticRead();</span><br><span class="line">        System.out.println(<span class="string">&quot;乐观邮戳号 &quot;</span>+stamped);</span><br><span class="line">        <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">long</span> r = lock.tryReadLock();</span><br><span class="line">        System.out.println(<span class="string">&quot;读锁版本号 &quot;</span>+r);</span><br><span class="line">        lock.unlockRead(r);</span><br><span class="line">        <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">long</span> w = lock.tryWriteLock();</span><br><span class="line">        System.out.println(<span class="string">&quot;写锁版本号 &quot;</span>+w);</span><br><span class="line">        lock.unlockWrite(w);</span><br><span class="line">        <span class="comment">// 检验戳，判断是否被写过</span></span><br><span class="line">        <span class="keyword">boolean</span> validate = lock.validate(stamped);</span><br><span class="line">        <span class="keyword">if</span>(validate)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有被写锁修改过&quot;</span>+stamped);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;被写锁获取&quot;</span>+stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</span><br><span class="line">    StampedLock lock=<span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//乐观读 获取到版本号</span></span><br><span class="line">        <span class="keyword">long</span> l = lock.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">int</span> a1=a;</span><br><span class="line">        <span class="keyword">int</span> b1=b;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//验戳</span></span><br><span class="line">        <span class="keyword">if</span>(!lock.validate(l))&#123;</span><br><span class="line">            <span class="comment">//悲观读</span></span><br><span class="line">            <span class="keyword">long</span> l1 = lock.readLock();</span><br><span class="line">            System.out.println(<span class="string">&quot;获取到悲观读锁-----》版本号&quot;</span>+l1);</span><br><span class="line">            a1=a;</span><br><span class="line">            b1=b;</span><br><span class="line">            System.out.println(<span class="string">&quot;释放悲观读锁-----》版本号&quot;</span>+l1);</span><br><span class="line">            lock.unlockRead(l1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;a1=&quot;</span>+a1+<span class="string">&quot;b1=&quot;</span>+b1+<span class="string">&quot;计算的总和&quot;</span>+(a1+b1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">udpate</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> w = lock.writeLock();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取到了写锁&quot;</span>+w);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.a=a;</span><br><span class="line">            <span class="keyword">this</span>.b=b;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;释放了写锁&quot;</span>+w);</span><br><span class="line">            lock.unlockWrite(w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo8 demo=<span class="keyword">new</span> Demo8();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;demo.sum()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;demo.udpate(<span class="number">1</span>,<span class="number">2</span>)).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、等待通知队列"><a href="#5、等待通知队列" class="headerlink" title="5、等待通知队列"></a>5、等待通知队列</h2><p><strong>newCondition等待通知队列概念：</strong></p><ul><li>替代object里面的wait和notify() 在多线程场景下更加灵活使用等待通知功能。</li><li>Lock+Condition 替代：synchronized+Object</li><li>通过Lock 的newCondition方法获取</li></ul><p><strong>API：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span>                <span class="comment">// 等待,释放锁资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> <span class="comment">// 对中断不敏感</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> time)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">( )</span>   <span class="comment">// 超时等待</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> signal        <span class="comment">// 随机唤醒</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span>   <span class="comment">// 全部唤醒</span></span></span><br></pre></td></tr></table></figure><p><strong>实现原理</strong></p><p><strong>1、分析如何创建的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到实际是返回一个ConditionObject对象</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、构造</strong>：ConditionObject是队列同步器的一个内部类，每个Condition都包含一个队列（等待队列）。</p><p><strong>3、等待队列</strong>：一个FIFO的队列，每个节点都包含一个线程引用，该线程就是在Condition对象上等待的线程，如果调用了await方法，调用的线程就会释放锁，构造成节点加入等待队列进入等待状态。</p><p><strong>节点引用更新没有使用CAS：</strong>调用await必定获得了锁，不会有线程安全问题。</p><p><strong>注意：</strong>同步队列和静态队列都属于同步器的静态内部类</p><p><strong>4、等待</strong>：调用await() 方法即可让一个线程进入等待，相当于一个处于同步队列的线程移动到等待队列中，等待队列通过中断被异常唤醒，会抛出异常。</p><p><strong>5、唤醒：</strong>唤醒也是先进先出的，唤醒是把等待队列移动的同步队列，并且使用LockSupport唤醒，注意唤醒后没获取到锁，可能短暂自旋后继续休眠，所以唤醒不一定能立即获得锁。若获取到了锁，就会从wait方法返回，继续执行未完成的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 只有对应的Condition对象才能唤醒对应的线程</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toSleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition1.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;被唤醒了&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaken1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;尝试去唤醒线程&quot;</span>);</span><br><span class="line">        condition1.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaken2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;尝试去唤醒线程&quot;</span>);</span><br><span class="line">        condition2.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Demo5 demo5 = <span class="keyword">new</span> Demo5();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo5.toSleep();</span><br><span class="line">        &#125;,<span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo5.awaken2();</span><br><span class="line">        &#125;,<span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo5.awaken1();</span><br><span class="line">        &#125;,<span class="string">&quot;线程3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">线程线程<span class="number">2</span>尝试去唤醒线程</span><br><span class="line">线程线程<span class="number">3</span>尝试去唤醒线程</span><br><span class="line">被唤醒了</span><br></pre></td></tr></table></figure><h2 id="6、阻塞-唤醒工具"><a href="#6、阻塞-唤醒工具" class="headerlink" title="6、阻塞/唤醒工具"></a>6、阻塞/唤醒工具</h2><p><strong>LockSupport 阻塞/唤醒工具特点：</strong></p><p> 1,   不需要加锁，直接阻塞和唤醒。</p><p> 2，唤醒和阻塞的过程可以互换顺序。避免死锁</p><p><strong>API：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span>                <span class="comment">// 阻塞</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> <span class="comment">// 释放，唤醒线程 </span></span></span><br><span class="line"><span class="function"><span class="comment">// 除了unpark之外，如果发生中断，也能够从堵塞中返回</span></span></span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无限等待的线程&quot;</span>);</span><br><span class="line">            <span class="comment">//不需要加锁</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;唤醒线程&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(四):原子类</title>
      <link href="/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E5%9B%9B%20)%20%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"/>
      <url>/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E5%9B%9B%20)%20%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1、CAS和unsafe"><a href="#1、CAS和unsafe" class="headerlink" title="1、CAS和unsafe"></a>1、CAS和unsafe</h2><h3 id="1-1、CAS"><a href="#1-1、CAS" class="headerlink" title="1.1、CAS"></a>1.1、CAS</h3><p><strong>概念：</strong></p><ol><li>CAS 即 compareAndSet </li><li>比较当前**<code>工作内存</code><strong>中的值和</strong><code>主内存</code>**的值，</li><li>如果是期望的，那么执行操作如果不是就一直循环。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="comment">// 先把旧值记录下来,然后计算结果，</span></span><br><span class="line"><span class="comment">// 接着要输出结果前,比较旧值现在与内存的是否还是一样的，一样则输出，不一样则循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> 旧值 = 共享变量;</span><br><span class="line">    <span class="keyword">int</span> 结果 = old + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// compareAndSet的实现依赖unsafe类直接调用底层指令</span></span><br><span class="line">    <span class="keyword">if</span>(compareAndSet(旧值,结果))&#123;</span><br><span class="line">        <span class="comment">// 成功，退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取共享变量时，需要**<code>使用volatile保证可见性</code><strong>，CAS和volatile可以实现</strong><code>无锁并发</code>**，适用于竞争不激烈的情况</p><ul><li>竞争不激烈，效率高</li><li>竞争激烈，循环次数多，反而影响效率</li></ul><p>CAS底层依赖于一个Unsafe类来直接调用系统底层的CAS指令</p><h3 id="1-2、unsafe类"><a href="#1-2、unsafe类" class="headerlink" title="1.2、unsafe类"></a>1.2、unsafe类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">        unsafe.compareAndSwapInt();</span><br><span class="line">        unsafe.compareAndSwapLong();</span><br><span class="line">        unsafe.compareAndSwapObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、原子类概述"><a href="#2、原子类概述" class="headerlink" title="2、原子类概述"></a>2、原子类概述</h2><p><strong>概念：</strong>原⼦类说简单点就是具有原⼦/原⼦操作特征的类。</p><p><strong>介绍</strong></p><ul><li><p>基于 CAS+unsafe+volatile，可以多线程情况下不加锁，仍然保持线程安全 </p></li><li><p>unsafe：操作c,c++库，jni操作，发送指令通过硬件资源，直接操作内存，原子操作，不安全危险</p></li></ul><p><strong>思想：</strong>通过自旋CAS实现的</p><p><strong>缺点：</strong></p><ol><li>循环耗时、</li><li>一次只能保证一个共享变量原子性</li><li>存在ABA等问题</li></ol><p><strong>分类：</strong></p><ul><li><p>基本类型：AtomicInteger，AtomicBoolean，AtomicLong                     </p></li><li><p>数组类型：AtomicLongArray，AtomicIntegerArray，AtomicReferenceArray</p></li><li><p>引用类型：AtomicReference，AtomicStampedReference，AtomicMarkableReference 、</p></li><li><p>字段类型：AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater， </p></li><li><p>累加器：LongAdder，DoubleAdder，LongAccumulator，DoubleAccumulator </p></li></ul><h2 id="3、基本原子类型"><a href="#3、基本原子类型" class="headerlink" title="3、基本原子类型"></a>3、基本原子类型</h2><p><strong>API</strong>：以AtomicInteger为例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span>                      <span class="comment">// 得到最新值                     </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span>    <span class="comment">// 得到旧值，然后设置成新值     </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span>        <span class="comment">// 得到旧值，自增1            </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span>        <span class="comment">// 得到旧值，减去1               </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span>     <span class="comment">// 等到旧址，累加delta       </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span>     <span class="comment">// 得到新值，累加delta </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span><span class="comment">// 有条件的替换    </span></span></span><br></pre></td></tr></table></figure><h2 id="4、原子更新数组"><a href="#4、原子更新数组" class="headerlink" title="4、原子更新数组"></a>4、原子更新数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span>                      <span class="comment">// 得到最新值                 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span>    <span class="comment">// 得到旧值，然后设置成新值     </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span>        <span class="comment">// 得到旧值，自增1            </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span>        <span class="comment">// 得到旧值，减去1               </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span>     <span class="comment">// 等到旧址，累加delta       </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span>     <span class="comment">// 得到新值，累加delta </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span><span class="comment">// 有条件的替换       </span></span></span><br></pre></td></tr></table></figure><h2 id="5、原子更新引用类型"><a href="#5、原子更新引用类型" class="headerlink" title="5、原子更新引用类型"></a>5、原子更新引用类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect,V update)</span>  <span class="comment">// 比较替换</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span>                   <span class="comment">// 返回旧值，设置成新值</span></span></span><br></pre></td></tr></table></figure><ul><li>AtomicReference，</li><li>AtomicStampedReference：解决ABA问题</li><li>AtomicMarkableReference：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        AtomicStampedReference a=<span class="keyword">new</span> AtomicStampedReference(str,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> stamp = a.getStamp();</span><br><span class="line">        a.set(<span class="string">&quot;李四&quot;</span>,a.getStamp()+<span class="number">1</span>);</span><br><span class="line">        a.set(<span class="string">&quot;张三&quot;</span>,a.getStamp()+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a.getStamp()==stamp) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;是原来哪个对象&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象已经被修改&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、原子更新字段类型"><a href="#6、原子更新字段类型" class="headerlink" title="6、原子更新字段类型"></a>6、原子更新字段类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(T obj,<span class="keyword">int</span> expect,<span class="keyword">int</span> update)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(T obj,<span class="keyword">int</span> delta)</span></span></span><br></pre></td></tr></table></figure><p><strong>注意点：</strong>必须volatile修饰，不能是静态和私有的，不能是final</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo10</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Demo10&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo10 demo10 = <span class="keyword">new</span> Demo10(<span class="number">10</span>);</span><br><span class="line">        AtomicIntegerFieldUpdater a = AtomicIntegerFieldUpdater.newUpdater(Demo10.class,<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        a.set(demo10,<span class="number">8</span>);</span><br><span class="line">        System.out.println(demo10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、累加器"><a href="#7、累加器" class="headerlink" title="7、累加器"></a>7、累加器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span>  <span class="comment">// 加一</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span>        <span class="comment">// 求和</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LongAdder l=<span class="keyword">new</span> LongAdder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;<span class="number">97</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;l.increment()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果94 返回自增的次数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;求和&quot;</span>+l.sum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(三):JMM内存模型</title>
      <link href="/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%B8%89%20)%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%B8%89%20)%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Java内存模型基础"><a href="#1、Java内存模型基础" class="headerlink" title="1、Java内存模型基础"></a>1、Java内存模型基础</h2><p>JMM 即 Java Memory Model，它定义了主存（共享内存）、工作内存（线程私有）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p><p>Java内存模型，实际上是不存在的，只是<code>一种约定，一种概念</code></p><h3 id="1-1、并发编程模型的两个问题"><a href="#1-1、并发编程模型的两个问题" class="headerlink" title="1.1、并发编程模型的两个问题"></a>1.1、并发编程模型的两个问题</h3><ul><li>线程间的通信：共享内存（Java的方式）和发生消息</li><li>线程间的同步：控制不同线程间操作发生顺序的机制，<code>共享内存并发模型里面</code>，同步是显示执行的。程序员必须显式的确定某个方法或某段代码需要在线程直接互斥执行。</li></ul><p><strong>同步和异步：</strong>线程同步和异步的区别主要在于发送请求后<code>是否需要等待返回</code>，对于线程同步来说，发送请求后需要等待返回，等待返回后才能继续发送下一个请求，而线程异步是不需要等待返回的，在发送一个请求后随时可发送下一个请求。</p><h3 id="1-2、Java内存模型结构"><a href="#1-2、Java内存模型结构" class="headerlink" title="1.2、Java内存模型结构"></a>1.2、Java内存模型结构</h3><p><strong>共享问题</strong></p><ul><li>共享：Java堆中的实例域，静态域，数组都是共享的</li><li>非共享：局部变量、方法参数、异常处理器参数不会存在线程之间的共享，<code>所以不会有内存可见性问题，也不会受内存模型的影响</code></li></ul><p><strong>如图所示：</strong></p><ul><li>Java线程的通信由Java内存模型JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。抽象的来看，JMM定义了主内存和本地内存之间的关系：<code>线程之间的共享变量存储在主内存，每个线程有自己的本地内存，其中存储了主内存的变量副本</code>。</li><li>线程A想要给线程B发送消息如 x = 1，那么线程A必须把 x 先刷新回主存，然后线程B必须从主存更新数据。即必须通过主存来完成，因为只有主存是共享的。</li></ul><p><img src="C:\Users\admin\Desktop\Java并发\img\1.jpg"></p><h3 id="1-3、指令重排"><a href="#1-3、指令重排" class="headerlink" title="1.3、指令重排"></a>1.3、指令重排</h3><p><strong>概念：</strong>执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。</p><ul><li>编译器优化排序：不改变单线程程序语义</li><li>指令级并行的重排序：指令并行技术，将多条数据进行重叠执行。如果不存在数据依赖，处理器就可能进行重排序</li><li>内存系统的重排序：使用<code>缓存和读写缓冲区</code></li></ul><p><strong>示例：</strong>代码 —-&gt; 1编译器级别—-&gt; 2指令级别 —&gt; 3内存系统级别 —&gt; 最终执行的指令序列</p><p>1属于编译器重排序，2、3属于处理器重排序，重排序可能导致多线程出现内存可见性问题。</p><ul><li>编译器重排序：JMM会禁止特定类型的重排</li><li>处理器重排序：JMM通过插入特定<code>内存屏障</code>禁止某些重排</li></ul><p><strong>总结：</strong>JMM属于语言级别的内存模型确保在不同的编译器和不同的处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，达到一致的内存可见性保证</p><blockquote><p>写缓冲区导致的顺序不一致</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程A    </span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">x = b;</span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">y = a;    <span class="comment">// 初始状态 a = b = 0 </span></span><br></pre></td></tr></table></figure><p><strong>结果可能：</strong>  x = y = 0</p><p><strong>原因：</strong></p><ul><li>处理器层面：线程A、B分别把 a = 1，b = 2 读取并置入写缓存区，接着从主存获取数据，计算 得到 x = 0 ， y = 0，最后把x 、y 刷新回主存</li><li>内存层面：认为先执行了a = 1  和  b = 2 ，结果应该 x = 2， y = 1</li></ul><p>所以造成了执行顺序不一致，因此现代处理器通常都<code>禁止对 写 - 读操作进行重排</code></p><blockquote><p>内存屏障</p></blockquote><p>为了保证内存可见性，Java编译器通过插入内存屏障禁止重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式   数据A 屏障 数据B</span></span><br><span class="line"><span class="comment">// int a = 4 装载指让a等于4，存储是加载到本地内存</span></span><br><span class="line"></span><br><span class="line">StoreStore   <span class="comment">// 数据A的装载优先于数据B的装载</span></span><br><span class="line">StoreLoad    <span class="comment">// 数据A刷新回主存，必须在数据B存储之前</span></span><br><span class="line">LoadLoad     <span class="comment">// 数据A装载，必须在数据B刷新回主存之前</span></span><br><span class="line">LoadStore    <span class="comment">// 数据A刷新回主存，必须在数据B的装载</span></span><br></pre></td></tr></table></figure><h3 id="1-4、happens-before规则"><a href="#1-4、happens-before规则" class="headerlink" title="1.4、happens-before规则"></a>1.4、happens-before规则</h3><p><strong>概念：</strong>JDK5开始，Java使用新的JSR-133内存模型，使用happens-before概念来阐述操作之间的内存可见性，如果一个操作<code>的执行结果对另一个操作可见</code>，那么两个操作必须有happens-before关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主存 a = 3</span></span><br><span class="line">a = <span class="number">5</span>;      <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> b = a;  <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1 对 2 可见,a=5会在b获取a之前被刷新到主存,结果b会等于5</span></span><br><span class="line"><span class="comment">// 1 对 2 不可见,结果b会等于3</span></span><br></pre></td></tr></table></figure><p><strong>目的：</strong>确保了内存可见性</p><p><strong>规则：</strong></p><ul><li>程序顺序规则：一个线程的每个操作，happens-before与该线程的任意后续操作</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后这个锁的加锁</li><li>volatile变量规则：对于一个volatile域的写，happens-before于任意后续对这个域的读</li><li>传递性：A happens-before B，且B happens-before C，则A happens-before C</li><li>start()规则：如果线程A执行启动线程B（调用start方法），那么线程A的启动操作happens-before于线程B的任意操作</li><li>join()规则：如果线程A执行ThreadB.join()方法并成功返回，那么线程B的任意操作happens-before于线程A从Thread.join()操作成功返回。</li></ul><p><strong>总结：</strong>A happens-before B，JMM并不要求A一定要在B之前执行，但是JMM会保证实际的执行结果 一定与 A、B顺序执行的结果一致。</p><h2 id="2、重排序"><a href="#2、重排序" class="headerlink" title="2、重排序"></a>2、重排序</h2><p><strong>概念：</strong>重排序是为了优化程序性能而对指令序列进行重新排序的手段。</p><h3 id="2-1、数据依赖性"><a href="#2-1、数据依赖性" class="headerlink" title="2.1、数据依赖性"></a>2.1、数据依赖性</h3><p><strong>概念：</strong>两个数据访问一个变量，<code>其中一个为写</code>操作，此时这个两个数据就具有数据依赖性。</p><table><thead><tr><th>名称</th><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>写-读</td><td>a = 1;   b = a ;</td><td>写入一个变量，再读该变量</td></tr><tr><td>写-写</td><td>a = 1;   a = 2 ;</td><td>写入一个变量，再写该变量</td></tr><tr><td>读-写</td><td>a = b;   b= 1;</td><td>读取一个变量，再写该变量</td></tr></tbody></table><p>很显然，只要发生重排序，程序的执行结果就会发生改变。</p><p><strong>注意：</strong>编译器和处理器会避免破坏数据依赖性的重排序。</p><h3 id="2-2、as-if-serial"><a href="#2-2、as-if-serial" class="headerlink" title="2.2、as-if-serial"></a>2.2、as-if-serial</h3><p><strong>概念：</strong>无论如何排序，单线程下的执行结果都不能改变</p><p><strong>意义：</strong>编译器，处理器都遵循as-if-serial规则，这使得我们在单线程环境下不需要考虑重排序，不需要考虑内存可见性问题。</p><p>在不改变程序执行结果的前提，提高并发度</p><h3 id="2-3、对多线程的影响"><a href="#2-3、对多线程的影响" class="headerlink" title="2.3、对多线程的影响"></a>2.3、对多线程的影响</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;        <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;               <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> i = a * a;       <span class="comment">// 4</span></span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多线程情况下，重排序可以影响结果</strong>：假设希望依次执行write、reader</p><ul><li>1、2重排序：若执行顺序 2 —&gt; 3 —-&gt;4 —-&gt;1  就与期待的结果相违背</li><li>3、4重排序：由于3和4存在依赖关系，所以步骤4不会真正的执行，而是把计算结果提前计算并且记录下来，当步骤3为真时，才把结果写入变量i</li></ul><h2 id="3、顺序一致性"><a href="#3、顺序一致性" class="headerlink" title="3、顺序一致性"></a>3、顺序一致性</h2><h3 id="3-1、数据竞争与顺序一致性"><a href="#3-1、数据竞争与顺序一致性" class="headerlink" title="3.1、数据竞争与顺序一致性"></a>3.1、数据竞争与顺序一致性</h3><p>JMM保证如果程序正常同步了（同步原语的正确使用），那么程序<strong>将具有顺序一致性</strong>，即程序的执行结果与在顺序一致性内存模型中的执行结果相同。</p><h3 id="3-2、顺序一致性内存模型"><a href="#3-2、顺序一致性内存模型" class="headerlink" title="3.2、顺序一致性内存模型"></a>3.2、顺序一致性内存模型</h3><p>顺序一致性内存模型是一个被<code>理想化的理论</code>（真实不存在）参考模型。提供了极强的内存可见性保证。</p><p><strong>特点：</strong></p><ul><li>一个线程中的所有操作按照程序的顺序来执行</li><li>每个操作都是原子执行并且对所有线程可见。</li></ul><p><strong>结构：</strong>拥有单一的全局内存，同一时刻只有一个线程可以操作内存，多线程并发执行时，开关装置能够让多个线程<code>串行执行</code>，需要注意的是，这只存在理论中，JMM不可能实现这一点。</p><h3 id="3-3、同步程序的顺序一致性效果"><a href="#3-3、同步程序的顺序一致性效果" class="headerlink" title="3.3、同步程序的顺序一致性效果"></a>3.3、同步程序的顺序一致性效果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a;</span><br><span class="line">     <span class="keyword">boolean</span> flag;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123; </span><br><span class="line">         a = <span class="number">1</span>;</span><br><span class="line">         flag = <span class="keyword">true</span>; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123; </span><br><span class="line">         <span class="keyword">if</span> (flag)&#123; </span><br><span class="line">             <span class="keyword">int</span> i = a * a;</span><br><span class="line">             System.out.println(i); </span><br><span class="line">         &#125; </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 假设线程A执行完write方法，线程B执行reader方法，这是一个正确同步的多线程程序，</span></span><br><span class="line"><span class="comment">// 此时线程的执行结果与该程序在顺序一致性内存模型中的结果一致</span></span><br></pre></td></tr></table></figure><p><strong>同步程序也存在指令重排：</strong></p><ul><li>顺序一致性内存模型：所有操作完全按照顺序执行</li><li>JMM：临界区的代码允许指令重排，但是范围只能在临界区之内。（临界区：指<code>线程A获得锁到A释放锁</code>的这一段区域），这样即提高了效率，有没有改变程序的执行结果。</li></ul><p><strong>总结：</strong>JMM的宗旨就是在不改变（正确同步）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门，因为临介区本身就是单线程执行的，而JMM规范已经保证了单线程执行不会有可见性问题。</p><h3 id="3-4、未同步程序的顺序一致性效果"><a href="#3-4、未同步程序的顺序一致性效果" class="headerlink" title="3.4、未同步程序的顺序一致性效果"></a>3.4、未同步程序的顺序一致性效果</h3><p>​        未同步或者未正确同步的多线程程序，JMM只提供最小安全性，JMM保证线程读取到的值不会无中生有，只会是默认值或者之前某个线程写入的值。为了实现最小安全性，JVM在分配内存时，会先对内存空间清零，然后分配内存。</p><p>​        至于顺序一致性，JMM不能保证</p><h2 id="4、volatile的内存语义"><a href="#4、volatile的内存语义" class="headerlink" title="4、volatile的内存语义"></a>4、volatile的内存语义</h2><h3 id="4-1、volatile的特性"><a href="#4-1、volatile的特性" class="headerlink" title="4.1、volatile的特性"></a>4.1、volatile的特性</h3><p>一个volatile变量的操作，效果等于使用锁来同步这个对变量的操作，可以理解为volatile就是给一个变量加锁，所以具有以下特性。</p><ul><li>可见性：对于一个volatile变量的读，总是可以看到其他线程对该变量的写</li><li>原子性：对于<code>单个</code>volatile变量的读、写具有原子性。（volatile++是二次不具有）</li></ul><h3 id="4-2、volatile写-读建立的happens-before规则"><a href="#4-2、volatile写-读建立的happens-before规则" class="headerlink" title="4.2、volatile写-读建立的happens-before规则"></a>4.2、volatile写-读建立的happens-before规则</h3><p>从JSR-133也就是JDK1.5开始，volatile变量的读-写可以实现<strong>线程间的通信</strong>。</p><p>从内存语义来说，volatile的<code>写-读与锁的释放-获取</code>有一样的内存效果，即volatile的<code>写与锁的释放</code>有一样的内存语义，volatile的<code>读 与锁的获取</code>有一样的内存语义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 线程A修改共享变量</span><br><span class="line"><span class="number">2.</span> 线程A写<span class="keyword">volatile</span>变量</span><br><span class="line"><span class="number">3.</span> 线程B读同一个<span class="keyword">volatile</span>变量</span><br><span class="line"><span class="number">4.</span> 线程B读同共享变量</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于volatile写-读建立的happens-before规则，</span></span><br><span class="line"><span class="comment">// 所以步骤1 到2 ,3 到4之间也具有happens-before规则 ，保证了先1后4</span></span><br><span class="line"><span class="comment">// 所以执行顺序为： 1---&gt;2---&gt;3---&gt;4 ，保证了  </span></span><br></pre></td></tr></table></figure><p><strong>原理：</strong>禁止了部分情况下的指令重排</p><h3 id="4-3、volatile写-读的内存语义（原理）"><a href="#4-3、volatile写-读的内存语义（原理）" class="headerlink" title="4.3、volatile写-读的内存语义（原理）"></a>4.3、volatile写-读的内存语义（原理）</h3><p><strong>写：</strong>写一个volatile的变量，JMM会把该线程的本地内存的<code>共享变量</code>值强制刷新回主存。</p><p><strong>读：</strong>读一个volatile的变量，JMM会把该线程的本地内存的<code>共享变量</code>置为无效，从主存获取值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 线程A修改共享变量</span><br><span class="line"><span class="number">2.</span> 线程A写<span class="keyword">volatile</span>变量</span><br><span class="line"><span class="number">3.</span> 线程B读同一个<span class="keyword">volatile</span>变量</span><br><span class="line"><span class="number">4.</span> 线程B读同共享变量</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 若没有volatile，可能结果 2 ---&gt; 3----&gt; 4 ----&gt;1 </span></span><br><span class="line"><span class="comment">// 第4步获取错误的数据，与期望不符合 </span></span><br></pre></td></tr></table></figure><p><strong>组合来看：</strong>第3步线程B读取一个volatile后，之前所有的共享变量都对B可见，即B中的共享变量与主存同步，这样第4步就能获取到正确的数据了。</p><p>为了实现volatile的内存语义，JMM会对编译器和处理器重排序做出限制。</p><h3 id="4-4、volatile内存语义的实现"><a href="#4-4、volatile内存语义的实现" class="headerlink" title="4.4、volatile内存语义的实现"></a>4.4、volatile内存语义的实现</h3><p>JMM为了实现volatile的内存语义，会限制编译器和处理器的重排序</p><table><thead><tr><th>下面第一次，右第二次</th><th>普通读、写</th><th>volatile读</th><th>volatile写</th></tr></thead><tbody><tr><td>普通读、写</td><td></td><td></td><td>NO</td></tr><tr><td>volatile读</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>volatile写</td><td></td><td>NO</td><td>NO</td></tr></tbody></table><ul><li>volatile读操作之后，无论是什么操作，都禁止重排序</li><li>volatile写操作之后，只允许和普通读写操作进行重排序。</li><li>不管前面操作是什么，只要接下来有volatile写，就不能重排序</li></ul><p><strong>做法：</strong>编译器生成字节码的时候，会在<code>指令序列插入内存屏障</code>来静止特定类型的处理器重排序，JMM采用了保守的策略，保证效果在任意平台有效。</p><ul><li>每个volatile写操作的前面插入一个StoreStore字段</li><li>每个volatile写操作的后面插入一个StoreLoad字段</li><li>每个volatile读操作的后面插入一个LoadLoad字段</li><li>每个volatile读操作的后面插入一个LoadStore字段</li></ul><h2 id="5、锁的内存语义"><a href="#5、锁的内存语义" class="headerlink" title="5、锁的内存语义"></a>5、锁的内存语义</h2><h3 id="5-1、锁的释放-获取建立的happens-before规则"><a href="#5-1、锁的释放-获取建立的happens-before规则" class="headerlink" title="5.1、锁的释放-获取建立的happens-before规则"></a>5.1、锁的释放-获取建立的happens-before规则</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;<span class="comment">// 1</span></span><br><span class="line">         a ++;                          <span class="comment">// 2</span></span><br><span class="line">     &#125;                                  <span class="comment">// 3</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123; <span class="comment">// 4</span></span><br><span class="line">         <span class="keyword">int</span> i = a ;                    <span class="comment">// 5</span></span><br><span class="line">     &#125;                                  <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据happens-before 规则，2应该happens-before 在5之前，而A释放之后，B获取了同一个锁，所以<code>线程A释放锁之前所有可见的共享变量，在线程B获取之后，立刻对B可见</code>，符合happens-before 规则。</p><h3 id="5-2、锁的释放和获取的内存语义"><a href="#5-2、锁的释放和获取的内存语义" class="headerlink" title="5.2、锁的释放和获取的内存语义"></a>5.2、锁的释放和获取的内存语义</h3><p>释放锁：JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</p><p>获取锁：JMM会把该线程对应的本地内存置为无效，必须从主存重新读取代码。</p><h3 id="5-3、锁内存语义的实现"><a href="#5-3、锁内存语义的实现" class="headerlink" title="5.3、锁内存语义的实现"></a>5.3、锁内存语义的实现</h3><h2 id="6、final域的内存语义"><a href="#6、final域的内存语义" class="headerlink" title="6、final域的内存语义"></a>6、final域的内存语义</h2><h3 id="6-1、final域的重排规则"><a href="#6-1、final域的重排规则" class="headerlink" title="6.1、final域的重排规则"></a>6.1、final域的重排规则</h3><ol><li>初始化final域之后之后才能被引用                   1 —–&gt; 2</li><li>先读取引用，才能读取数据                               3 —–&gt; 4</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">static</span> Test04 obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;  </span><br><span class="line">        j = <span class="number">2</span>;               <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj = <span class="keyword">new</span> Test04();  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Test04 object = obj;  <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">int</span> a = object.i;</span><br><span class="line">        <span class="keyword">int</span> b = object.j;     <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写final域的重排规则</p></blockquote><p><strong>规则：</strong>JMM会下达指令，让编译器会在final域的写之后，构造函数 return 之前，<code>插入一个StoreStore屏障</code>，禁止处理器<code>把final域的写重排序到构造函数之外</code>。即 obj 引用的对象的final域一定是初始化完成的。</p><p><strong>没有这个规则：</strong>obj就可能是不完整的对象。</p><blockquote><p>读final域的重排规则</p></blockquote><p><strong>规则：</strong>编译器会在读final域前面插入一个LoadLoad屏障，防止值未初始化就被读取。</p><p><strong>如果没有这个规则：</strong>object读取为null</p><h3 id="6-2、final域为引用类型"><a href="#6-2、final域为引用类型" class="headerlink" title="6.2、final域为引用类型"></a>6.2、final域为引用类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">static</span> Test05 obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];    <span class="comment">// 1</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;          <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj = <span class="keyword">new</span> Test05();  <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj.arr[<span class="number">0</span>] = <span class="number">2</span>;      <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 想要reader对writeTwo保持可见性，需要通过lock或者volatile保证</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>)&#123;    <span class="comment">// 5</span></span><br><span class="line">            <span class="keyword">int</span> i = obj.arr[<span class="number">0</span>];  <span class="comment">// 6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新增规则：</strong>在构造函数内对一个final引用类型的初始化，与对该引用类型的赋值之间，不能重排序。即上述 步骤1和步骤2之间不能重排，同时步骤2和步骤3也不能重排。</p><p><strong>即：</strong><code>必须先初始化在赋值，必须赋值之后才能获取到对象</code>。</p><p><strong>如果没有这个规则：</strong></p><ul><li>可能先执行3、在执行2，导致最终值与期望的不符</li><li>也可能先执行2再执行1，导致未初始化就赋值</li></ul><h3 id="6-3、final引用对象溢出问题"><a href="#6-3、final引用对象溢出问题" class="headerlink" title="6.3、final引用对象溢出问题"></a>6.3、final引用对象溢出问题</h3><p><strong>前面的规则：</strong>确保了在final域的引用变量arr被其他线程可见之前，arr已经成功初始化并且赋值了。</p><p><strong>但需要一个前提</strong>：final引用对象不能在构造函数内溢出，即构造函数返回前，被构造的对象不能被其他线程所看见，因为final还没有初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> Test04 obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;           <span class="comment">// 1、写final域</span></span><br><span class="line">        obj = <span class="keyword">this</span>;      <span class="comment">// 2、this引用在此&quot;溢出&quot;</span></span><br><span class="line">        <span class="comment">// 步骤1和2可能重排，导致 2 ---&gt; reader ---&gt; 1 过程的发生</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj = <span class="keyword">new</span> Test04();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = obj.i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JSR-133对final语义的增强</p></blockquote><p>​        旧的内存模型中，线程可能看到final域的值是变化的，JSR-133中确保了：只要对象是正常构建的（被构造对象的引用在构造函数中没有溢出），不需要使用同步机制，任意线程只能看到构造函数构造完之后的final域的变量。</p><h2 id="7、happens-before"><a href="#7、happens-before" class="headerlink" title="7、happens-before"></a>7、happens-before</h2><h3 id="7-1、JMM设计"><a href="#7-1、JMM设计" class="headerlink" title="7.1、JMM设计"></a>7.1、JMM设计</h3><p>JMM把happens-before要求禁止的重排序分为了下面两类</p><ul><li>会改变程序执行结果的重排序，（JMM禁止）</li><li>不会改变程序执行结果的重排序（JMM允许）</li></ul><p>原则：只要不改变程序运行结果，编译器和处理器怎么优化都行。</p><h3 id="7-2、happens-before的定义"><a href="#7-2、happens-before的定义" class="headerlink" title="7.2、happens-before的定义"></a>7.2、happens-before的定义</h3><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序在第二个操作之前。（JMM对程序员的承诺）</li><li>两个操作之间存在happens-before关系，但是并不一定要完全遵循happens-before关系指定的顺序来执行，只要不改变运行结果，JMM就允许。（JMM对编译器和处理器重排序的约束）</li></ul><p>as-if-serial语义保证单线程的执行顺序不会被改变，happens-before关系保证<code>正确同步的多线程程序</code>的执行结果不被改变。</p><p>as-if-serial语义制造了表象：程序按照顺序执行的</p><p>happens-before关系制造了表象：正确同步的多线程程序按照happens-before指定顺序执行</p><h3 id="7-2、happens-before的规则"><a href="#7-2、happens-before的规则" class="headerlink" title="7.2、happens-before的规则"></a>7.2、happens-before的规则</h3><ol><li>程序顺序规则：一个线程的每个操作，happens-before与该线程的任意后续操作</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后这个锁的加锁</li><li>volatile变量规则：对于一个volatile域的写，happens-before于任意后续对这个域的读</li><li>传递性：A happens-before B，且B happens-before C，则A happens-before C</li><li>start()规则：如果线程A执行启动线程B（调用start方法），那么线程A的启动操作happens-before于线程B的任意操作</li><li>join()规则：如果线程A执行ThreadB.join()方法并成功返回，那么线程B的任意操作happens-before于线程A从Thread.join()操作成功返回。</li></ol><h2 id="8、懒汉式单例模式"><a href="#8、懒汉式单例模式" class="headerlink" title="8、懒汉式单例模式"></a>8、懒汉式单例模式</h2><h3 id="8-1、双重检查锁定：double-checked-locking"><a href="#8-1、双重检查锁定：double-checked-locking" class="headerlink" title="8.1、双重检查锁定：double-checked locking"></a>8.1、双重检查锁定：double-checked locking</h3><p><strong>有缺陷的懒汉式单例模式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lazyMan = <span class="keyword">new</span> LazyMan();</span><br><span class="line"><span class="comment">// 1.分配内存空间  2、初始化对象 3.把地址赋值给lazyMan  </span></span><br><span class="line"><span class="comment">// 正常情况1--&gt; 2--&gt;3 ，但是指令重排之后可能 1---&gt;3---&gt;2</span></span><br><span class="line"><span class="comment">// 导致线程A构造对象时还没初始化，这是线程B获取了一个不完整的对象                    </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在单线程中上述的指令重排是被允许的，因为在单线程中不会改变结果，符合as-if-serial规则</p><p>但是多线程情况下就会出现问题。</p><blockquote><p>基于volatile的解决方案</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line">    <span class="comment">// 私有构造器，无法通过该构造器new对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 双重检测模式的懒汉式单例 DCL懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lazyMan = <span class="keyword">new</span> LazyMan();<span class="comment">//不是原子性操作</span></span><br><span class="line"><span class="comment">// 1.分配内存空间  2、初始化对象 3.把地址赋值给lazyMan  </span></span><br><span class="line"><span class="comment">// 正常情况1--&gt; 2--&gt;3 ，但是指令重排之后可能 1---&gt;3---&gt;2</span></span><br><span class="line"><span class="comment">// 导致线程A构造对象时还没初始化，这是线程B获取了一个不完整的对象</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原本 可能的 1—&gt;3—&gt;2，由于声明为volatile，所以指令重排被禁止了，</p><h3 id="8-2、基于类初始化的解决方案"><a href="#8-2、基于类初始化的解决方案" class="headerlink" title="8.2、基于类初始化的解决方案"></a>8.2、基于类初始化的解决方案</h3><ul><li>类的<code>静态属性</code>只会在第一次加载类的时候初始化，可以避免提前被初始化浪费资源</li><li>类的初始化期间，JVM会去获取一个锁（每一个类和接口有一个唯一的初始化锁LC），禁止多个同步线程对一个类的初始化，这里等于是JVM帮助我们保证了线程的安全性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Inner</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">staticInner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Inner instance = <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Inner <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 调用字段导致被初始化</span></span><br><span class="line">        <span class="keyword">return</span> staticInner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本质：</strong>允许指令重排，但是不允许其他线程“看到” 未初始化完成的对象，即其他线程要么获取不到对象，要么只能获取完整的对象。</p><blockquote><p>类初始化分析</p></blockquote><p><strong>类被初始化的几种情况：</strong></p><ul><li>T是一个类，一个T类型的实例被创建</li><li>T是一个类，且T中声明的静态方法被调用</li><li>T声明的静态字段被赋值</li><li>T声明的静态字段被使用，且这个字段不是常量字段</li><li>T是一个顶级类，且一个断言语言嵌套在T内部被执行。</li></ul><p><strong>过程：</strong></p><ol><li>线程A获取到了初始化锁，看到state == noInitialization 表明线程还未初始化，线程A就开始初始化，并设置 state = initializing  ，</li><li>线程B获取到了初始化锁，但是 state = initializing ，于是就释放锁，进入初始化锁的condition开始等待。</li><li>线程A初始化完成，设置 state = initialized ，唤醒所有在condition等待的线程，并且释放锁，到此A的初始化过程完成。</li><li>B获取到初始化锁，发现 state = initialized ，就释放初始化锁，到此B的初始化过程完成。</li><li>C获取到初始化锁，发现 state = initialized ，就释放初始化锁，到此B的初始化过程完成。</li></ol><p><strong>根据JMM的规范：</strong>A释放初始化锁在B的获取之前，二者是同一把锁。所以存在happens-before规则：线程A的初始化的写入操作对线程B可见</p><p>同理，B对C可见，所以A对C也可见。</p><p><strong>注意：</strong>condition和state只要求JVM实现类似的功能。</p><blockquote><p>对比</p></blockquote><ul><li>双重检查：不仅是静态字段，还可以是实例字段</li><li>类初始化：只能是静态字段</li></ul><h2 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h2><h3 id="9-1、处理器的内存模型"><a href="#9-1、处理器的内存模型" class="headerlink" title="9.1、处理器的内存模型"></a>9.1、处理器的内存模型</h3><p>顺序一致性内存模型是一个理论概念，JMM和处理器内存模型设计时以此为参照，但会适当的放松条件，因为完全参照会导致效率很低。</p><ul><li>放松 写 - 读操作的顺序，产生了TSO内存模型（Total Store Ordering）</li><li>继续放松 写 -写顺序，产生了PSO内存模型（Partial  Store Order）</li><li>继续放松读-写 和 读 - 读 顺序，产生了RMO内存模型（Relaxed Memory Order）</li></ul><p>以上都是建立在没有数据依赖的情况下进行的，保证as-if-serial规则</p><p><strong>可以注意到：</strong>都放松了写-读操作顺序，因为都用了写缓存区。这也导致当前处理器可以比其他处理器先看到临时保存在自己缓存区里的写。</p><ul><li>由于JMM的约束性比处理器大，所以JMM会使用内存屏障来禁止某些重排序。</li><li>JMM屏蔽了不同处理器的差异，让程序的运行结果在不同的处理器平台一致</li></ul><p>越追求性能的内存模型，限制会越少。</p><h3 id="9-2、JMM内存可见性保证"><a href="#9-2、JMM内存可见性保证" class="headerlink" title="9.2、JMM内存可见性保证"></a>9.2、JMM内存可见性保证</h3><ul><li>单线程程序：没有内存可见性问题</li><li>正确同步的多线程程序：通过限制处理器和编译器的重排序保证内存可见性。</li><li>未正确同步的多线程程序：JMM提供最小安全性保障，线程不会读到无中生有的值，对象初始化之后，才能被线程使用，但是不能保证值是否是正确的（如线程A初始化一半时就被线程B读取）</li></ul><h3 id="9-3、JSR-133"><a href="#9-3、JSR-133" class="headerlink" title="9.3、JSR-133"></a>9.3、JSR-133</h3><ul><li>对volatile的增强：限制和普通变量的重排序</li><li>对final的增强：保证final引用没有溢出的情况下，具有初始化安全性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(二):多线程基础</title>
      <link href="/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%BA%8C%20)%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%BA%8C%20)%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1、线程简介"><a href="#1、线程简介" class="headerlink" title="1、线程简介"></a>1、线程简介</h2><h3 id="1-1、什么是线程"><a href="#1-1、什么是线程" class="headerlink" title="1.1、什么是线程"></a>1.1、什么是线程</h3><p>​        操作系统运行一个程序时，会为其创建一个进程。<strong>操作系统调度的最小单元是线程</strong>，也叫轻量级进程，一个进程可以创建多个线程，每个线程有自己的计数器、栈、局部变量，能够访问共享的方法区、堆。处理器在线程上高速切换，让使用者感觉线程在同时执行。</p><p>​        一个Java程序就有多个线程，至少有<code>主线程、GC线程，异常处理线程</code>。</p><blockquote><p>程序、进程、线程</p></blockquote><ul><li>程序：指一段静态的代码，静态对象。</li><li>进程：程序的一次执行过程，或是正在运行的一个程序。</li><li>线程：进程可进一步细化为线程，是一个程序内部的一条执行路径。</li></ul><p>进程属于操作系统的范畴，主要是同⼀段时间内，可以同时执行⼀个以上的程序，而线程则是在同⼀程序内几乎同时执行⼀个以上的程序段</p><blockquote><p>并行与并发</p></blockquote><ul><li>并行：多个线程同时执行多个任务。</li><li>并发：多个线程同时执行一个任务。</li></ul><h3 id="1-2、多线程的好处"><a href="#1-2、多线程的好处" class="headerlink" title="1.2、多线程的好处"></a>1.2、多线程的好处</h3><blockquote><p>更多的处理核心</p></blockquote><p>处理器上的核心越来越多，超线程技术运用广泛，现在大多数计算机更加擅长并行计算</p><blockquote><p>更快的响应时间</p></blockquote><p>把数据性不强的操作派发给其他线程处理（也可以使用消息队列）这样响应用户请求的线程能够尽可能地处理完成，缩短了响应时间，提示用户体验。</p><blockquote><p>更好的编程模型</p></blockquote><p>Java提供的多线程编程的良好环境</p><h3 id="1-3、线程优先级"><a href="#1-3、线程优先级" class="headerlink" title="1.3、线程优先级"></a>1.3、线程优先级</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先级高(数字大)的只是权重大，不能保证100%先执行</span></span><br><span class="line"><span class="comment">// 必须先设置优先级，再调用start方法</span></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(t1);</span><br><span class="line">t2.getPriority();     <span class="comment">// 获取优先级</span></span><br><span class="line">t2.setPriority(<span class="number">2</span>);    <span class="comment">// 设置优先级</span></span><br></pre></td></tr></table></figure><h3 id="1-4、线程的状态"><a href="#1-4、线程的状态" class="headerlink" title="1.4、线程的状态"></a>1.4、线程的状态</h3><p><img src="img/Thread/2.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java内部定义状态</span></span><br><span class="line">NEW           <span class="comment">// 未启动状态  </span></span><br><span class="line">RUNNABLE      <span class="comment">// 在Java虚拟机执行的线程状态    </span></span><br><span class="line">BLOACKED      <span class="comment">// 堵塞装态</span></span><br><span class="line">WAITING       <span class="comment">// 等待另一个线程执行</span></span><br><span class="line">TIME_WAITTING <span class="comment">// 超时等待</span></span><br><span class="line">TERMINATED    <span class="comment">// 已退出的线程</span></span><br></pre></td></tr></table></figure><p><strong>获取线程状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下以Thread开头的都是直接调用即可，thread开头的需要通过线程对象调用</span></span><br><span class="line">Thread.currentThread()   <span class="comment">//获取当前线程对象</span></span><br><span class="line">thread.getState();       <span class="comment">//获取线程状态，thread为线程对象</span></span><br><span class="line">thread.getName();        <span class="comment">//获取线程名字，thread为对象</span></span><br><span class="line">thread.isAlive();</span><br><span class="line"></span><br><span class="line">Thread.currentThread().getName();  <span class="comment">// 获取线程的名字</span></span><br></pre></td></tr></table></figure><h3 id="1-5、守护线程"><a href="#1-5、守护线程" class="headerlink" title="1.5、守护线程"></a>1.5、守护线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程分守护线程和用户线程，虚拟机必须保证用户线程执行完毕而守护线程不必</span></span><br><span class="line"><span class="comment">// 守护线程，不会结束运行</span></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(t1);</span><br><span class="line">t2.setDaemon(<span class="keyword">true</span>);   <span class="comment">//设置为守护线程，默认false，需要在启动之前设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 守护线程在虚拟机退出时才会结束，并且不一定运行finally里的程序</span></span><br></pre></td></tr></table></figure><h2 id="2、线程的创建和启动"><a href="#2、线程的创建和启动" class="headerlink" title="2、线程的创建和启动"></a>2、线程的创建和启动</h2><h3 id="2-1、继承Thread类"><a href="#2-1、继承Thread类" class="headerlink" title="2.1、继承Thread类"></a>2.1、继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承类的方式开启</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一个线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test1 thread = <span class="keyword">new</span> Test1();</span><br><span class="line">        thread.setPriority(<span class="number">8</span>);       <span class="comment">// 设置优先级</span></span><br><span class="line">        thread.setName(<span class="string">&quot;线程1&quot;</span>);     <span class="comment">// 设置名字</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Runnable开启</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;一个线程&quot;</span>); </span><br><span class="line">&#125;,<span class="string">&quot;线程2&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ul><li>线程  创建完毕后 ，执行  run 方法开启线程 ，执行完毕后这个线程就结束了</li><li>线程  开启<code>必须通过 start 方法</code>，如果直接调用 run 方法，不是开启线程，而是主线程运行run方法</li></ul><h3 id="2-2、实现Runnable接口"><a href="#2-2、实现Runnable接口" class="headerlink" title="2.2、实现Runnable接口"></a>2.2、实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类对象开启</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一个线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">Demo2 demo2 = <span class="keyword">new</span> Demo2();</span><br><span class="line"><span class="keyword">new</span> Thread(demo2,<span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(demo2,<span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过匿名内部类开启</span></span><br><span class="line">Runnable runnable = (()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;一个线程&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ul><li>Runnable 并没有start方法，不过Thread类实现了Runnable接口，通过Thread开启线程</li><li>避免单继承局限性，同一对象可以被多个线程使用</li></ul><h3 id="2-3、实现Callable接口"><a href="#2-3、实现Callable接口" class="headerlink" title="2.3、实现Callable接口"></a>2.3、实现Callable接口</h3><p><strong>可以有返回值，抛出异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类实现</span></span><br><span class="line"><span class="comment">// 定义线程，重写call方法，返回值为Integer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Demo3 demo = <span class="keyword">new</span> Demo3();</span><br><span class="line">    ExecutorService e = Executors.newFixedThreadPool(<span class="number">1</span>);<span class="comment">// 创建线程池</span></span><br><span class="line">    Future&lt;Integer&gt; r1 = e.submit(demo);                <span class="comment">// 提交执行，返回值，t</span></span><br><span class="line">    System.out.println(r1.get());                       <span class="comment">// 获取结果</span></span><br><span class="line">    e.shutdown();                                       <span class="comment">// 关闭服务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名内部类</span></span><br><span class="line">Callable&lt;Integer&gt; callable = (()-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>重写call()方法并作为线程执行体，并且有返回值，可抛出异常</li><li>Callable也是没有start方法的，所以通过<code>Future类</code>开启线程</li></ul><h2 id="3、线程的终止"><a href="#3、线程的终止" class="headerlink" title="3、线程的终止"></a>3、线程的终止</h2><h3 id="3-1、中断"><a href="#3-1、中断" class="headerlink" title="3.1、中断"></a>3.1、中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread.interrupt();        <span class="comment">// 中断线程，把中断标识位置为true</span></span><br><span class="line">thread.isInterrupted();    <span class="comment">// 检查是否中断,返回中断标识位</span></span><br><span class="line">Thread.interrupted();      <span class="comment">// 把中断标识位置为false</span></span><br></pre></td></tr></table></figure><p><strong>概念：</strong>中断可以理解为线程的一个<code>标识位</code>，标识一个运行中的线程是否被其他线程进行了中断操作。线程内部通过检查自己是否被中断来进行响应。</p><p><strong>作用：</strong>让处于堵塞状态的线程<code>停止一次堵塞</code>（睡眠的抛出异常并停止睡眠，等待的抛出异常并停止等待），对没有处于中断堵塞状态的线程没有效果。</p><ul><li>等待堵塞（wait）、睡眠、IO堵塞、同步堵塞（synchorized）、</li></ul><p><strong>本质：</strong>比如Thread.sleep 需要捕获异常，如果设置中断，就会抛出异常并且被捕获，程序会重捕获的代码之后继续运行，所以 synchorized等待的线程设置中断没有效果。</p><p><strong>注意：</strong>处于堵塞状态的线程中断后，JVM会自动把中断标识位置为false，随后抛出异常。</p><h3 id="3-2、停止"><a href="#3-2、停止" class="headerlink" title="3.2、停止"></a>3.2、停止</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过时的方法</span></span><br><span class="line">supend()   <span class="comment">// 暂停，不会释放资源，容易引发死锁</span></span><br><span class="line">stop()     <span class="comment">// 恢复</span></span><br><span class="line">resume()   <span class="comment">// 停止，不能保证线程资源的正确释放。</span></span><br></pre></td></tr></table></figure><h3 id="3-3、安全的停止线程"><a href="#3-3、安全的停止线程" class="headerlink" title="3.3、安全的停止线程"></a>3.3、安全的停止线程</h3><ol><li>中断线程</li><li>设置标记位</li></ol><h2 id="4、线程间通信"><a href="#4、线程间通信" class="headerlink" title="4、线程间通信"></a>4、线程间通信</h2><p>线程之间通过堆里的共享变量进行通信，栈里的是私有的。</p><h3 id="4-1、volatile和synchorized关键字"><a href="#4-1、volatile和synchorized关键字" class="headerlink" title="4.1、volatile和synchorized关键字"></a>4.1、volatile和synchorized关键字</h3><p><strong>synchorized：</strong>使用再方法或者代码块上</p><p><strong>volatile：</strong>用在变量上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程正在执行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(test2,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(test2,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        test2.shut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">线程<span class="number">1</span>进入</span><br><span class="line">线程正在执行</span><br><span class="line">.......</span><br><span class="line">线程<span class="number">2</span>进入</span><br></pre></td></tr></table></figure><h3 id="4-2、等待通知队列"><a href="#4-2、等待通知队列" class="headerlink" title="4.2、等待通知队列"></a>4.2、等待通知队列</h3><p><strong>注意：</strong>使用wait 和 notify 必须要<code>先获得当前对象的锁</code>，配合synchorized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前线程    Running ---&gt; Waiting</span></span><br><span class="line">wait();       <span class="comment">// 把占用当前对象锁的线程挂起并释放锁，线程进入对象的等待队列</span></span><br><span class="line">wait(<span class="keyword">long</span> time);</span><br><span class="line">wait(<span class="keyword">long</span> time,<span class="keyword">long</span> time)    <span class="comment">// 参数二为微秒    </span></span><br><span class="line"><span class="comment">// 被唤醒的线程 Waiting -----&gt; Blocked</span></span><br><span class="line">notify();     <span class="comment">// 当前线程从等待队列唤醒一个到同步队列</span></span><br><span class="line">  <span class="comment">// 当前线程释放锁之后，同步队列出来一个线程竞争锁，不能保证唤醒的一定获得锁</span></span><br><span class="line">notifyAll()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设线程A、B,锁的对象是obj</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、线程A获取obj对象的锁,线程A执行 obj.wait方法,把当前线程A挂起，线程A释放锁进入等待队列</span><br><span class="line"><span class="number">2</span>、线程B获取obj对象的锁,线程B执行 obj.notify 方法,唤醒线程A进入同步队列</span><br><span class="line"><span class="number">3</span>、线程B wait 释放锁,线程A从同步队列出来竞争锁obj</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 有可能有以下情况,就是A一直未竞争到锁,直到线程B被唤醒且抢占到锁执行完之后，A才获得锁,这样就导致A比B先唤醒,但是A后获取到锁   </span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>JVM不强制规定按顺序唤醒，但是Hotspot是按上面的方式</p><h3 id="4-3、等待通知的经典范式"><a href="#4-3、等待通知的经典范式" class="headerlink" title="4.3、等待通知的经典范式"></a>4.3、等待通知的经典范式</h3><p><strong>等待方</strong></p><ol><li>获得锁</li><li>条件满足执行逻辑</li><li>条件不满足调用 对象的 wait 方法，被通知后仍然检查条件</li></ol><p><strong>通知方</strong></p><ol><li>获得锁</li><li>改变条件</li><li>通知所有等待在对象上的线程</li></ol><h3 id="4-4、管道输入输出流"><a href="#4-4、管道输入输出流" class="headerlink" title="4.4、管道输入输出流"></a>4.4、管道输入输出流</h3><p><strong>用于线程之间的数据传输</strong>：通过connnect把输入输出流连接在一起</p><p>注意：如果write接收了，但是没有对应的read，会报异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PipedReader in;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test4</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">30</span>];</span><br><span class="line">                in.read(ch);</span><br><span class="line">                System.out.println(ch);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        out.connect(in);  <span class="comment">// 通过connnect把输入输出流连接在一起</span></span><br><span class="line"></span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test4(in));</span><br><span class="line">        printThread.start();</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span>[] ch = scanner.nextLine().toCharArray();</span><br><span class="line">                out.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">qwr</span><br><span class="line">qwr                           </span><br><span class="line">张三pc不给钱 应该定什么罪</span><br><span class="line">张三pc不给钱 应该定什么罪                </span><br></pre></td></tr></table></figure><h3 id="4-5、join的使用"><a href="#4-5、join的使用" class="headerlink" title="4.5、join的使用"></a>4.5、join的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread.join()  <span class="comment">// 非静态方法，对象调用</span></span><br><span class="line">thread.join(<span class="keyword">long</span> time)    </span><br><span class="line">thread.join(<span class="keyword">long</span> time,<span class="keyword">long</span> time)  <span class="comment">// 参数二为微秒     </span></span><br></pre></td></tr></table></figure><p><strong>线程A调用thread.join()：</strong>表示线程A开始等待，直到线程thread执行完成后，线程A才继续执行。</p><p><strong>原理：</strong>假设线程A调用 thread.join 这个同步方法，那么线程A就持有了thread对象的锁，所以调用wait 方法让线程A一直等待，等到线程thread 结束之后，JVM会调用 notify 让线程A苏醒。</p><p><strong>总之：</strong>就是通过wait方法让线程等待，JVM负责唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-6、ThreadLocal的使用"><a href="#4-6、ThreadLocal的使用" class="headerlink" title="4.6、ThreadLocal的使用"></a>4.6、ThreadLocal的使用</h3><p><strong>ThreadLocal相当于一个map：</strong>所有线程的线程ID作为map的键，值作为value，不同线程设置的值和获得的值是不同的，互相没有冲突。</p><p><strong>原理：</strong>内部维护了一个ThreadLocalMap（节点Entry），每个线程的ID作为键，存的数据作为value</p><p><strong>内存泄漏问题：</strong>内部map的key 是弱引用，value是强引用，所以可能 key 被回收了，但是value 永远无法回首，ThreadLocal 解决的思路是：调用3个方法的时候，会自动清除键为 null 的 Entry 结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; local = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        Long times = System.currentTimeMillis() - local.get();  <span class="comment">// 获取值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;距离线程创建过去了&quot;</span>+times);</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        <span class="comment">//local.remove();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            local.set(System.currentTimeMillis());              <span class="comment">// 设置值</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                    print();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// local.remove();                                   // 移除</span></span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            local.set(System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                    print();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7、Sleep-和-wait的异同"><a href="#4-7、Sleep-和-wait的异同" class="headerlink" title="4.7、Sleep 和 wait的异同"></a>4.7、Sleep 和 wait的异同</h3><p>同：</p><ul><li>两者都可以暂停线程的执⾏。</li></ul><p>异：</p><ul><li>sleep 不会 释放锁，wait会释放锁</li><li>sleep 会 自动苏醒，wait需要其他线程唤醒或者超时等待自动苏醒</li></ul><h2 id="5、死锁探究"><a href="#5、死锁探究" class="headerlink" title="5、死锁探究"></a>5、死锁探究</h2><p><strong>原因：</strong>两个线程互相占用对方需要的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopping</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置为static保证资源只有一份</span></span><br><span class="line">    <span class="keyword">static</span> Buy buy = <span class="keyword">new</span> Buy();</span><br><span class="line">    <span class="keyword">static</span> Use use = <span class="keyword">new</span> Use();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> choice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shopping</span><span class="params">(<span class="keyword">int</span> choice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.choice = choice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 顾客选择先锁住自己的钱，然后希望先获得试用的机会</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.choice==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (buy)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;我要先试用再给你钱&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (use)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;试用&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 老板锁住试用的机会，然后希望先获得顾客的钱</span></span><br><span class="line">            <span class="keyword">synchronized</span> (use)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;你不付钱就不能试用&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (buy)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收钱&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shopping customer =<span class="keyword">new</span> Shopping(<span class="number">0</span>);</span><br><span class="line">        Shopping boss =<span class="keyword">new</span> Shopping(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(customer,<span class="string">&quot;顾客&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(boss,<span class="string">&quot;老板&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>顾客不先付钱（锁住use），并尝试获取试用（获取锁buy），不然不付钱（释放锁use）</li><li>老板不让试用（锁住buy），并尝试先获得钱（获取锁use），不然不让试用（释放锁buy）</li></ul><p>顾客和老板各自拥有自己的锁，不释放给对方，就这样一致互相等待对方。</p><blockquote><p>避免死锁</p></blockquote><ul><li> <strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li><li><strong>破坏请求与保持条件</strong> ：⼀次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong> ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li> <strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ul><h2 id="6、线程应用案例"><a href="#6、线程应用案例" class="headerlink" title="6、线程应用案例"></a>6、线程应用案例</h2><h3 id="6-1、超时等待模式"><a href="#6-1、超时等待模式" class="headerlink" title="6.1、超时等待模式"></a>6.1、超时等待模式</h3><p>如果不能获得结果，就一直等待直到时间耗尽。</p><p><strong>封装大小为10的连接池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归还连接给连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                <span class="comment">// 添加进了连接，于是唤醒等待的线程去获取连接</span></span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从连接池获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">            <span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">            <span class="keyword">long</span> remain = mills;</span><br><span class="line">            <span class="comment">// 一直等到连接池有连接或者超时</span></span><br><span class="line">            <span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pool.wait(remain);   <span class="comment">// 等待直到被唤醒或超时</span></span><br><span class="line">                remain = future - System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">            Connection result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 不为空就取出一个连接</span></span><br><span class="line">            <span class="keyword">if</span> (!pool.isEmpty()) &#123;</span><br><span class="line">                result = pool.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模拟多线程获取连接池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger got = <span class="keyword">new</span> AtomicInteger();     <span class="comment">// 成功获取次数</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger notGot = <span class="keyword">new</span> AtomicInteger();  <span class="comment">// 失败的次数</span></span><br><span class="line">    <span class="keyword">static</span> ConnectionPool pool = <span class="keyword">new</span> ConnectionPool(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>+got);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接失败&quot;</span>+notGot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getConnectionsTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取线程池，运行等待时间5秒</span></span><br><span class="line">                Connection connection = pool.fetchConnection(<span class="number">500</span>);</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获取connection</span></span><br><span class="line">                    connection.createStatement();</span><br><span class="line">                    connection.commit();</span><br><span class="line">                    <span class="comment">// 释放线程</span></span><br><span class="line">                    pool.releaseConnection(connection);</span><br><span class="line">                    got.incrementAndGet();    <span class="comment">// 计数</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    notGot.incrementAndGet(); <span class="comment">// 计数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 测试1000次获取线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            getConnectionsTest();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2、简单线程池"><a href="#6-2、简单线程池" class="headerlink" title="6.2、简单线程池"></a>6.2、简单线程池</h3><p><strong>接口类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池类</strong></p><ul><li>把工作添加进线程队列</li><li>构造器创建num 个工人去做队列里的工作</li><li>startWork() 方法开启工作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">// 工作集合队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());  <span class="comment">// 工作者线程安全队列</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger id = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workNums = DEFAULT;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init(DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        workNums = num &gt; MAX ? MAX :num &lt; MIN ? MIN : num;</span><br><span class="line">        init(workNums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加一定数量的工人</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加工作到工作队列</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (jobs)&#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 停止工人的线程</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker:workers)&#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加工人，添加的时候不能做工作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num + <span class="keyword">this</span>.workNums &gt; MAX)&#123;</span><br><span class="line">                num = MAX - <span class="keyword">this</span>.workNums;</span><br><span class="line">            &#125;</span><br><span class="line">            init(num);</span><br><span class="line">            <span class="keyword">this</span>.workNums = <span class="keyword">this</span>.workNums + num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除工人，移除的时候不能做工作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="keyword">this</span>.workNums)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;超过数量&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(count &lt; num)&#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker))&#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.workNums = <span class="keyword">this</span>.workNums -count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workNums; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(workers.get(i),<span class="string">&quot;线程&quot;</span>+id.incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running)&#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 获得jobs的锁，并且获取一个job去做</span></span><br><span class="line">                <span class="keyword">synchronized</span> (jobs)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty())&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果工作不为空，那么久执行任务</span></span><br><span class="line">                <span class="keyword">if</span> (job!= <span class="keyword">null</span>)&#123;</span><br><span class="line">                    job.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工作类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TaskDemo implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;工作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DefaultThreadPool&lt;TaskDemo&gt; pool = new DefaultThreadPool&lt;&gt;(5);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            pool.execute(new TaskDemo());</span><br><span class="line">        &#125;</span><br><span class="line">        pool.startWork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(一):简介</title>
      <link href="/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%B8%80%20)%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%B8%80%20)%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1、上下文切换"><a href="#1、上下文切换" class="headerlink" title="1、上下文切换"></a>1、上下文切换</h2><p><strong>多线程原理：</strong>即使是单核处理器也支持多线程执行代码，可以通过CPU给每个线程分配CPU时间片来实现这个机制，由于时间片时间很短，所以感觉是多个线程同时执行的。</p><p><strong>上下文切换：</strong>CPU通过时间片分配执行多线程，当前任务执行一个时间片后湖切换到下一个任务，但是切换前会保存上一个任务的状态，下一次继续执行当前任务时会从保存的状态处继续执行任务。<strong>任务从当前任务保存到下一个任务加载的过程就是上下文的切换。</strong></p><p>注意：单核CPU执行多线程任务一定会触发线程上下文切换，多核CPU执行多线程任务时，若CPU能满足所有线程的需要，就会并行执行任务而没有线程上下文切换(但是一般情况不可能)，当CPU不够所有线程需要时，也会发生线程上下文切换。</p><h3 id="1-1、多线程一定更快么"><a href="#1-1、多线程一定更快么" class="headerlink" title="1.1、多线程一定更快么"></a>1.1、多线程一定更快么</h3><p><strong>不一定，因为上下文切换需要消耗时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> count = <span class="number">100001</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concurrency</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    a = a + <span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        thread.join();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">&quot;多线程方式&quot;</span>+time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            a = a + <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通方式&quot;</span>+time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        serial();</span><br><span class="line">        concurrency();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">普通方式<span class="number">3</span></span><br><span class="line">多线程方式<span class="number">8</span></span><br><span class="line"><span class="comment">// count为1000000001时</span></span><br><span class="line">普通方式<span class="number">1492</span></span><br><span class="line">多线程方式<span class="number">664</span>    </span><br></pre></td></tr></table></figure><p>使用工具测出，1秒中发生1000多次上下文切换。</p><h3 id="1-2、减少上下文切换"><a href="#1-2、减少上下文切换" class="headerlink" title="1.2、减少上下文切换"></a>1.2、减少上下文切换</h3><ul><li>无锁并发编程：多线程竞争时，会引起上下文切换，可以使用一些办法避免使用锁，如不同的线程 按照Hash算法<strong>处理不同的区域</strong>，一个数据只能有一个线程处理。</li><li>CAS算法：</li><li>尽量少的创建线程</li><li>协程，在单线程里面实现多任务的调度</li></ul><h3 id="1-3、死锁"><a href="#1-3、死锁" class="headerlink" title="1.3、死锁"></a>1.3、死锁</h3><p><strong>死锁演示：</strong></p><ol><li>线程t1 执行 占有对象A，线程t2 执行 占有对象B</li><li>线程t1 接着执行需要对象B ，但是无法获取，于是线程 t1 等待</li><li>线程t2 接着执行需要对象A ，但是无法获取，于是线程 t2 等待</li><li>线程 t1 和 t2 将会无限的等待下去。</li></ol><p><strong>实际开发</strong>：实际开发中不会写出这么愚蠢的代码，但是有可能出现以下情形</p><ul><li>t1 拿到资源A（锁）之后，因为异常情况而没有释放</li><li>t1 拿到资源A （锁）之后，释放的时候抛出异常，没有释放成功</li></ul><p><strong>避免死锁：</strong></p><ul><li>避免一个线程获取多个锁</li><li>避免一个线程在锁内占用多个资源</li><li>尝试使用<strong>定时锁</strong>，使用lock.trylock(timeout) 来替代内部锁机制</li><li>对于数据库锁，加锁和释放必须在一个数据库连接中，否则会出现解锁失效的问题。</li></ul><h3 id="1-4、资源限制的挑战"><a href="#1-4、资源限制的挑战" class="headerlink" title="1.4、资源限制的挑战"></a>1.4、资源限制的挑战</h3><p><strong>资源限制：</strong>程序的执行速度受限于软件或者硬件资源，如网站带宽2M/s，即使再多的线程，速度也不会变快。</p><p><strong>问题：</strong>并发编程快的原因：代码串行变成并发执行，但是如果将某段串行的代码并发执行，那么由于资源受限，反而会执行的更慢，因为<strong>增加了上下文切换和资源调度</strong>的时间，</p><p><strong>解决：</strong>考虑集群并行执行程序，单机的资源优先，就让程序在多机上运行，如不同的任务通过算法选择一台机器执行程序</p><p><strong>资源受限的情况下并发：</strong>根据不同的资源限制调整程序的并发度，比如下载文件程序依赖两个资源：带宽和硬盘读写。有数据库操作时，涉及数据库连接数，如果SQL执行的快，而线程的数量比数据库连接数大很多时，某些线程会堵塞，等待数据库连接。</p><h2 id="2、volatile原理"><a href="#2、volatile原理" class="headerlink" title="2、volatile原理"></a>2、volatile原理</h2><p><strong>概念：</strong>用来修饰成员变量和静态成员变量（<strong>放在主存中的变量</strong>），保证所有线程看到某个变量的值都是一致的，保证了共享变量的”可见性”，同时不会引起线程上下文的切换。</p><p><strong>实现原理：</strong>每次操作完数据，JVM会发送一条Lock前缀的指令</p><ol><li>Lock前缀的指令会引起处理器缓存写回到主存</li><li>一个处理器缓存写回到主存，会导致其他处理器的缓存失效。</li></ol><p><strong>效果</strong>：olatile的修饰的变量具有可见性</p><ol><li>写一个volatile的变量，JMM会把该线程的本地内存的<code>共享变量</code>值强制刷新回主存。</li><li>读一个volatile的变量，JMM会把该线程的本地内存的<code>共享变量</code>置为无效，从主存获取值。</li></ol><p><strong>概念2：</strong> volatile 关键字的效果增强：禁止某些情况下的重排序</p><p>原理：加入内存屏障</p><h2 id="3、synchronized"><a href="#3、synchronized" class="headerlink" title="3、synchronized"></a>3、synchronized</h2><p>过去都称为重量级锁，但是在JDK1.6之后优化了（引入轻量级锁和偏向锁），有些情况下并不是那么重了。</p><p><strong>锁的对象：</strong>当一个线程访问同步代码块时必须获得锁，退出或者抛出异常必须释放锁。</p><ul><li>普通同步方法：锁的是实例对象</li><li>静态同步方法：锁的是当前类的Class对象</li><li>同步方法块：锁的是synchorized括号里配置的对象。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：线程A锁 类Demo的普通方法,线程B 锁类Demo的静态方法，二者不会互斥 </span><br></pre></td></tr></table></figure><p><strong>同步代码块实现原理</strong>：基于<code>进入和退出Monitor对象</code></p><ul><li>monitorenter指令：在编译后插入到同步代码块的开始位置</li><li>monitorexit指令：插入到同步代码块的结束处和异常处</li><li>JVM保证每个monitorenter都必须有一个monitorexit与之匹配。</li><li>任何一个对象都有一个monitor与之关联，<code>一个线程执行了monitorenter指令后，就会尝试获取monitor，如果成功获取到，那么当前对象就处于锁定状</code>态，执行了monitorexit就会释放monitor。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitorenter指令：让锁计数器数值变为1</span><br></pre></td></tr></table></figure><p><strong>同步方法实现原理：</strong>使用ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法。</p><p>二者本质都是<strong>对对象监视器</strong> <strong>monitor</strong> <strong>的获取</strong></p><p><strong>Java对象头</strong>：synchorized的锁信息是存在Java对象头里，数组类型3字宽，其他2字宽。Mark Word存储锁信息，来标记是哪个线程获得了该锁，下面是Mark Word存的数据。</p><ul><li>偏向锁：存放线程ID</li><li>轻量级锁：指向栈中锁记录的指针</li><li>重量级锁：指向互斥量的指针</li></ul><p><strong>锁的优化：</strong>Java1.6对synchorized进行了优化</p><p><strong>锁的升级：</strong>JavaSE1.6中，锁有四种状态，级别从低到高依次为 无锁—&gt; 偏向锁 —&gt; 轻量级锁 —&gt; 重量级锁，<code>锁可以升级但是不能降级</code>。</p><blockquote><p>偏向锁</p></blockquote><p><strong>缘由：</strong>HotSpot作者发现，大多数情况下，锁很少存在竞争情况，大多数情况下，锁都是一个线程多次释放和获得，所以为了让线程获得锁的代价更低，引入了偏向锁</p><p><strong>方案：</strong></p><ul><li><strong>无锁情况获取：</strong>直接获得锁，并在对象头和栈帧的锁记录锁偏向的线程ID</li><li><strong>有锁情况获取：</strong>任意线程获取锁时，会比较是否为偏向锁<code>是否有本线程的ID</code>，如果有表示已经占有了锁；如果没有，则看当前<code>是否还是偏向锁</code>，若不是则使用CAS竞争锁；若是则会尝试<code>让偏向锁指向自己的线程ID</code>。</li><li><strong>锁的释放：</strong>当有其他线程竞争锁时，系统会<code>暂停持有锁的线程的执行</code>，然后判断该线程是否存活，若不存活，则把对象头设置为无锁状态；若存活，则该线程的栈会执行去遍历锁记录，选择是否把锁偏向其他的线程、恢复到无锁、或者进行锁的升级。</li></ul><p><strong>关闭锁：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=<span class="number">0</span>  <span class="comment">// 偏向锁生效有延迟，该方法关闭延迟</span></span><br><span class="line">-XX:UseBiasedLocking=<span class="keyword">false</span>       <span class="comment">// 关闭后程序默认进入轻量级锁状态    </span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong>偏向锁就是线程A持有锁，不正常释放，直到线程B来获取锁时，才让线程A释放锁</p><ul><li>加锁：让对象头记录本线程的ID</li><li>释放锁：把持有锁线程ID替换成新的线程的ID</li></ul><blockquote><p>轻量级锁</p></blockquote><ul><li><strong>加锁</strong>：线程执行同步代码块之前，JVM会<code>在当前线程的栈帧中创建用于存储锁记录的空间</code>。并把对象头中的Mark Word复制到锁记录中（称为Diasplaced Mark Word）。然后尝试把对象头的Mark Word替换成指向锁记录的指针，如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程尝试使用自旋获取锁。</li><li><strong>解锁：</strong>使用原子的CAS操作把对象头的Diasplaced Mark Word，替换回原对象头，如果成功，表示没有竞争发生。如果失败，就会膨胀成重量级锁。</li></ul><p>升级为重量级锁后，就可以避免无用的自旋浪费CPU资源。重量级锁情况下：加锁后，所有线程尝试获取锁时都会被堵塞，当锁释放后，线程会唤醒堵塞的线程</p><p><strong>总结：</strong>使用CAS获取锁，如果释放时竞争激烈，就把锁升级成重量级锁。</p><ul><li>加锁：先把对象头的信息备份，然后让对象头的信息更换为当前线程的信息</li><li>解锁：把备份还原</li></ul><blockquote><p>对比</p></blockquote><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁解锁不需额外消耗</td><td>若竞争激烈，会带来额外的锁撤销过程的消耗</td><td>单线程访问同步代码</td></tr><tr><td>轻量级锁</td><td>线程不堵塞，响应快，减少线程上下文切换</td><td>若始终获取不到CPU，会一直自旋，浪费资源</td><td>追求响应时间，同步代码块执行速度快</td></tr><tr><td>重量级锁</td><td>不自旋，不消耗CPU</td><td>线程堵塞，响应时间满，</td><td>追求吞吐量，同步代码块执行时间长</td></tr></tbody></table><p><strong>总结：</strong>竞争越激烈，用越重的锁。</p><h2 id="4、原子操作"><a href="#4、原子操作" class="headerlink" title="4、原子操作"></a>4、原子操作</h2><p><strong>术语定义：</strong></p><ul><li>缓存行（Cache line）：缓存的最小操作单位</li><li>比较与交换（CAS）：每次操作前都把新获得的值与旧值比较，确保中间没有被其他线程修改过</li><li>CPU流水线：CPU中由5<del>6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分解成5</del>6步后，再由这些电路单元分别执行，这样实现在一个CPU时钟周期内完成一条指令。</li><li>内存顺序冲突：多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效。当出现该冲突时，CPU必须情况流水线。</li></ul><p><strong>处理器实现原子操作</strong>：</p><blockquote><p>Java的原子性实现</p></blockquote><p><strong>原子性解决1：</strong>synchronized同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50000</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                    list.add(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50000</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                    list.add(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁不住基本类型的包装类：Integer用synchorized锁不住的原因：Integer每次变化都是用一个新对象</span></span><br></pre></td></tr></table></figure><p><strong>原子性解决2：</strong>CAS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> AtomicInteger atomic = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = atomic.get();</span><br><span class="line">            <span class="keyword">boolean</span> flag = atomic.compareAndSet(i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Test06 test = <span class="keyword">new</span> Test06();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    test.count();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(test.atomic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、CAS操作引起的三大问题"><a href="#5、CAS操作引起的三大问题" class="headerlink" title="5、CAS操作引起的三大问题"></a>5、CAS操作引起的三大问题</h2><blockquote><p>ABA问题</p></blockquote><p><strong>描述：</strong>CAS判断操作，是通过值有没有变化，但是可能出现 A—&gt; B  — &gt;A 的情况，CAS认为没有变化，但是实际上已经发生了改变</p><p><strong>解决：</strong>使用JDK1.5开始提供的AtomicStampedReference原子引用类型，把数据包装到原子引用类型里面，通过原子引用类型操作变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        <span class="comment">// 把str放到原子引用类型AtomicStampedReference里面</span></span><br><span class="line">        AtomicStampedReference a=<span class="keyword">new</span> AtomicStampedReference(str,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> stamp = a.getStamp();</span><br><span class="line">        a.set(<span class="string">&quot;李四&quot;</span>,a.getStamp()+<span class="number">1</span>);</span><br><span class="line">        a.set(<span class="string">&quot;张三&quot;</span>,a.getStamp()+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a.getStamp()==stamp) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;是原来哪个对象&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象已经被修改&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出对象已经被修改</span></span><br></pre></td></tr></table></figure><blockquote><p>循环开销大</p></blockquote><p><strong>描述：</strong>CAS可能会一直自旋，可以CPU带来很大的执行开销。</p><blockquote><p>只能保证一个共享变量的原子操作</p></blockquote><p><strong>描述：</strong>对一个共享变量操作时，可以进行CAS，但是对于多个变量进行处理就不行。</p><p><strong>解决：</strong></p><ul><li>使用锁</li><li>使用JDK1.5中的AtomicReference引用类型类，把多个变量封装到一个引用类型里面</li></ul><h2 id="6、JMM三大特性总结"><a href="#6、JMM三大特性总结" class="headerlink" title="6、JMM三大特性总结"></a>6、JMM三大特性总结</h2><ul><li>原子性：保证指令不会受到线程上下文切换的影响</li><li>可见性 ：保证指令不会受 cpu 缓存的影响</li><li>有序性 ：保证指令不会受 cpu 指令并行优化的影响</li></ul><p><strong>synchronized ：</strong>保证原子性和可见性</p><p><strong>volatile：</strong>保证了可见性，指令重排</p><p>二者都能保证有序性：</p><ul><li>synchronized ：通过同步机制，保证代码块之间的有序进行</li><li>volatile：通过禁止部分指令重排，保证代码执行顺序</li></ul><h2 id="7、CPU⾼速缓存"><a href="#7、CPU⾼速缓存" class="headerlink" title="7、CPU⾼速缓存"></a>7、CPU⾼速缓存</h2><p><strong>目的：</strong>解决CPU处理速度和内存处理速度不对等的问题。</p><p><strong>扩展：</strong>内存缓存的是硬盘数据⽤于解决硬盘访问速度过慢的问题。</p><p><strong>工作流程：</strong>先复制⼀份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 内存缓存不⼀致性的问题！比如执行⼀个 i++操作的话，如果两个线程同时执行的话，假设两个线程从 CPUCache 中读取的 i=1，两个线程做了 1++运算完之后再写回 Main Memory 之后 i=2，⽽正确结果应该是 i=3。</p><p><strong>CPU</strong> <strong>为了解决内存缓存不⼀致性问题可以通过制定缓存⼀致协议或者其他⼿段来解决。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法(十):排序算法</title>
      <link href="/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E5%8D%81%20)%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E5%8D%81%20)%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1、分类："><a href="#1、分类：" class="headerlink" title="1、分类："></a>1、分类：</h2><ol><li>内部排序：在内存中进行排序<ul><li>插入排序：直接插入、希尔</li><li>选择排序：简单选择、堆排序</li><li>交换排序：冒泡、快速排序</li><li>归并排序</li><li>基数排序</li></ul></li><li>外部排序：</li></ol><p><strong>度量程序（算法）执行时间</strong></p><ol><li>事后统计：要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</li><li>事前估算：通过分析某个算法的时间复杂度来判断哪个算法更优.</li></ol><p><strong>时间频度</strong></p><p>一个算法花费的时间与算法中<code>语句的执行次数</code>成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p><h2 id="2、时间复杂度"><a href="#2、时间复杂度" class="headerlink" title="2、时间复杂度"></a>2、时间复杂度</h2><ol><li>一般情况下，算法中的基本操作语句的<code>重复执行次数</code>是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度。</li><li>T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。</li></ol><p><strong>计算时间复杂度的方法：</strong></p><ol><li>用常数1代替运行时间中的所有加法常数  T(n)=n²+7n+6  =&gt; T(n)=n²+7n+1</li><li>修改后的运行次数函数中，<code>只保留最高阶项</code>  T(n)=n²+7n+1 =&gt; T(n) = n²</li><li><strong>去除</strong>最高阶项的<code>系数</code> T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li></ol><p>总结：忽略系数、低次项、常数</p><p><strong>常见的时间复杂度</strong></p><ol><li>常数阶O(1)</li><li>对数阶O(log2n)</li><li>线性阶O(n)</li><li>线性对数阶O(nlog2n)</li><li>平方阶O(n^2)</li><li>立方阶O(n^3)</li><li>k次方阶O(n^k)</li><li>指数阶O(2^n)</li></ol><p>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) </p><p><strong>平均时间复杂度和最坏时间复杂度</strong></p><ol><li>平均时间复杂度是指所有可能的输入实例均以<code>等概率出现的情况下</code>，该算法的运行时间。</li><li>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的<code>界限</code>，这就保证了算法的运行时间不会比最坏情况更长。</li><li>平均时间复杂度和最坏时间复杂度是否一致，和算法有关。</li></ol><h3 id="5-3、空间复杂度"><a href="#5-3、空间复杂度" class="headerlink" title="5.3、空间复杂度"></a>5.3、空间复杂度</h3><ol><li>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。</li><li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况</li><li>在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.</li></ol><h2 id="3、八大内部排序算法"><a href="#3、八大内部排序算法" class="headerlink" title="3、八大内部排序算法"></a>3、八大内部排序算法</h2><h3 id="3-1、冒泡排序"><a href="#3-1、冒泡排序" class="headerlink" title="3.1、冒泡排序"></a>3.1、冒泡排序</h3><ul><li>最好情况，数组已经是正序，没有触发过交换即flag没有发生过改变，则退出，<code>最好情况复杂度为O(n)</code></li><li>平均复杂度和最坏复杂度为O(n^2),        空间复杂度O(1)</li><li>不占用额外内存，很稳定</li></ul><p><strong>思想：</strong></p><ol><li>每次遍历从数组索引0开始，不断与后面一位比较，保证最大的永远在<code>后面</code>，<code>每次比较出最大的一位</code></li><li>第二次比较只需要比较到倒数第二位即可，以此类推，直到第一位和第二位进行以此比较</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSorting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] bubble(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = -<span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    flag = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = flag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == -<span class="number">1024</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> arr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BubbleSorting bubbleSorting = <span class="keyword">new</span> BubbleSorting();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = (<span class="keyword">int</span>) (Math.random()*<span class="number">8000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        bubbleSorting.bubble(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis()-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 耗时：15161毫秒</span></span><br></pre></td></tr></table></figure><h3 id="3-2、选择排序（冒泡排序的优化）"><a href="#3-2、选择排序（冒泡排序的优化）" class="headerlink" title="3.2、选择排序（冒泡排序的优化）"></a>3.2、选择排序（冒泡排序的优化）</h3><ul><li>平均复杂度、最好情况 和最坏复杂度均为O(n^2),        空间复杂度O(1)</li><li>不占用额外内存，很稳定</li></ul><p><strong>思想：</strong></p><ol><li>每次遍历时，选取未排序的第一位不断和后面比较，<code>找出其中最小</code>的一位</li><li>最小的一位和未排序的第一位交换位置，则就把一个位置排好，后面不断继续排序</li><li>交换排序和选择排序基本一致，只不过，选择排序只交换一次</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSorting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] select(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="comment">// 定义最小值为0</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 每次循环先默认arr[min]最小</span></span><br><span class="line">            min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果有比arr[min]还更小的，就把索引记下来</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[min])&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 索引改变就交换</span></span><br><span class="line">            <span class="keyword">if</span> (min!=i) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SelectSorting selectSorting = <span class="keyword">new</span> SelectSorting();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = (<span class="keyword">int</span>) (Math.random()*<span class="number">8000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        selectSorting.select(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis()-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时：4001毫秒</span></span><br></pre></td></tr></table></figure><h3 id="3-3、插入排序"><a href="#3-3、插入排序" class="headerlink" title="3.3、插入排序"></a>3.3、插入排序</h3><ul><li>最好情况的时间复杂度是 O(n)</li><li>平均复杂度、 和最坏复杂度均为O(n^2),        空间复杂度O(1)</li><li>不占用额外内存，很稳定</li></ul><p><strong>思想：</strong>是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的</p><ol><li>默认前面 i -1 位已经排好序，剩下为无序表</li><li>取出第 i  位的值  令temp = arr [ i ]   ,  现在就是让 temp 往前面插入到他应该的位置，这里类似<code>顺序表插入数据</code></li><li>重复直到全部排序完成</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSorting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] insert(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 把要插入的值抽取出来</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="comment">// 定义变量j</span></span><br><span class="line">            <span class="keyword">int</span> j = i ;</span><br><span class="line">            <span class="comment">// 如果j大于0并且temp比arr[j - 1]小</span></span><br><span class="line">            <span class="comment">// 那么久把arr[j-1] 向右移动一位</span></span><br><span class="line">            <span class="keyword">while</span> ( j &gt;= <span class="number">1</span> &amp;&amp; temp &lt; arr[j - <span class="number">1</span>] )&#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果j改变了，那么久说明前面移动过，</span></span><br><span class="line">            <span class="comment">// 因为退出了循环，所以此时j == 0 ，或者arr[j-1] &gt; temp</span></span><br><span class="line">            <span class="comment">// 所以arr[j]就是temp的正确位置</span></span><br><span class="line">            <span class="keyword">if</span> (j!=i)&#123;</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InsertSorting insertSorting = <span class="keyword">new</span> InsertSorting();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = (<span class="keyword">int</span>) (Math.random()*<span class="number">8000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        insertSorting.insert(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis()-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时：827毫秒</span></span><br></pre></td></tr></table></figure><p><strong>插入排序</strong>：可以看到，如果插入的数为最小的数，那么往前插入需要全部判断，会消耗很多资源</p><h3 id="3-4、希尔排序（插入排序优化）"><a href="#3-4、希尔排序（插入排序优化）" class="headerlink" title="3.4、希尔排序（插入排序优化）"></a>3.4、希尔排序（插入排序优化）</h3><ul><li>平均复杂度O(nlogn)、 最坏复杂度为 O(n) ~ O(n^2),        空间复杂度O(1)</li><li>属于内部排序，不稳定</li></ul><p><strong>思想：</strong>把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止默认第一位已经排好序，剩下为无序表</p><ol><li>设置 arr.length/2 为步长，每次步长变为原来的 一半，只要步长大于1，就一直比较</li><li>每次从 i = 步长开始，所以相隔步长的数当做一组，每组直接进行插入排序，</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSorting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shell(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step = arr.length/<span class="number">2</span>; step &gt;=<span class="number">1</span>; step = step/<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                <span class="keyword">int</span> j= i;</span><br><span class="line">                <span class="comment">// 为什么是j&gt;=step， 这么理解： j -step &gt; = 0</span></span><br><span class="line">                <span class="comment">// 如果arr[j-step] 存在切比temp 小</span></span><br><span class="line">                <span class="keyword">while</span> (j&gt;=step &amp;&amp; temp &lt; arr[j-step])&#123;</span><br><span class="line">                    arr[j] = arr[j-step];</span><br><span class="line">                    j = j - step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j!=i)&#123;</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShellSorting shellSorting = <span class="keyword">new</span> ShellSorting();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = (<span class="keyword">int</span>) (Math.random()*<span class="number">800000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        shellSorting.shell(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis()-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时：20毫秒</span></span><br></pre></td></tr></table></figure><p>上面和插入排序都是通过移位，当然也可以通过交换，更容易理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] swap(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step = arr.length; step &gt;=<span class="number">1</span> ; step= step/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= step &amp;&amp; arr[j] &lt; arr[j-step]) &#123;</span><br><span class="line">                <span class="comment">// 交换两个的值</span></span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j-step];</span><br><span class="line">                arr[j-step] = temp;</span><br><span class="line">                j = j - step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 耗时：21毫秒 ，耗时基本没区别</span></span><br></pre></td></tr></table></figure><h3 id="3-5、快速排序（冒泡排序改进）"><a href="#3-5、快速排序（冒泡排序改进）" class="headerlink" title="3.5、快速排序（冒泡排序改进）"></a>3.5、快速排序（冒泡排序改进）</h3><ul><li>平均复杂度和最好情况O(nlogn)、 最坏复杂度为(n^2),        空间复杂度O(logn)</li><li>属于内部排序，不稳定</li></ul><p><strong>思想：</strong>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据有序</p><p><strong>思路：</strong></p><ol><li> 定义方法 getIndex，让其中一个值作为基准值，小于基准值的放在他左边，大于放右边</li><li>递归调用上述方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = getIndex(arr, left, right);</span><br><span class="line">            sort(arr,left,index-<span class="number">1</span>);</span><br><span class="line">            sort(arr,index+<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得arr[left] 和arr[right]之间的基准值索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 表示有0个数比arr[left]小</span></span><br><span class="line">        <span class="comment">// 从left+1到arr[right]比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="comment">// 设置arr[left]为基准值，不能动该值，只要有一个数比基准值值小，索引就加1</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[left])&#123;</span><br><span class="line">                index++; <span class="comment">// 表示小于 arr[left]的数加1</span></span><br><span class="line">                swap(arr, i, left + index); <span class="comment">//把小于基准值的交换到数组前面</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时有index个元素小于基准值</span></span><br><span class="line">        <span class="comment">// 最后把基准值和最后一个比基准值小的交换位置</span></span><br><span class="line">        swap(arr, left, left + index);</span><br><span class="line">        <span class="keyword">return</span> index+left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        QuickSort quickSort = <span class="keyword">new</span> QuickSort();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = (<span class="keyword">int</span>) (Math.random()*<span class="number">800000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        quickSort.sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis()-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 耗时：16毫秒</span></span><br></pre></td></tr></table></figure><h3 id="3-6、归并排序"><a href="#3-6、归并排序" class="headerlink" title="3.6、归并排序"></a>3.6、归并排序</h3><ul><li>平均复杂度和最好情况 最坏复杂度、O(nlogn)   空间复杂度O(n)</li><li>属于外部排序，稳定</li></ul><p><strong>思想：</strong>利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题<code>分成一些小的问题</code>然后递归求解，而<code>治的阶段</code>则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><p><strong>思路</strong></p><ol><li>定义一个方法，按序返回两个数组的合并，</li><li>先把一个数组分成两半，然后以这两个数组做参递归调用，结果传入方法1中，得到结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> middle = (<span class="keyword">int</span>) Math.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span>[] left = Arrays.copyOfRange(arr, <span class="number">0</span>, middle);</span><br><span class="line">        <span class="keyword">int</span>[] right = Arrays.copyOfRange(arr, middle, arr.length);</span><br><span class="line">        <span class="keyword">return</span> compound(mergeSort(left),mergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] compound(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[a.length+b.length];</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index1 == a.length || ( index2 != b.length &amp;&amp; b[index2] &lt; a[index1]))&#123;</span><br><span class="line">                result[i] = b[index2];</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[i] = a[index1];</span><br><span class="line">                index1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MergeSort mergeSort = <span class="keyword">new</span> MergeSort();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = (<span class="keyword">int</span>) (Math.random()*<span class="number">800000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        mergeSort.mergeSort(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis()-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 耗时：29毫秒</span></span><br></pre></td></tr></table></figure><h3 id="3-7、基数排序"><a href="#3-7、基数排序" class="headerlink" title="3.7、基数排序"></a>3.7、基数排序</h3><ul><li>平均复杂度和最好情况 最坏复杂度O(n * k)   空间复杂度O(n + k)</li><li>属于外部排序，稳定</li><li>属于桶排序的扩展</li></ul><p>思想：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><p><strong>思路：</strong></p><ol><li>十位、百位、千位、分别利用桶排序进行排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="comment">// 定义二维数组表示10个痛</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="keyword">int</span> turns = getTop(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; turns; i++ ,n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建数组，每次循环都new，不new就要清空数据</span></span><br><span class="line">            <span class="keyword">int</span>[] bucketNums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="comment">// 一次循环结束代表一次排序结束</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 获取应该在哪个桶里</span></span><br><span class="line">                <span class="keyword">int</span> index = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">// 桶里面放值</span></span><br><span class="line">                bucket[index][bucketNums[index]] = arr[j];</span><br><span class="line">                bucketNums[index]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 排序结束把值从桶里取出来</span></span><br><span class="line">            arr = getArr(bucket,bucketNums,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据桶和桶计数工具举出值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getArr(<span class="keyword">int</span>[][] bucket,<span class="keyword">int</span>[] bucketNums,<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketNums[i]; j++) &#123;</span><br><span class="line">                result[flag++] = bucket[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取最高位的位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTop</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]  &gt; max)&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (max+<span class="string">&quot;&quot;</span>).length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RadixSort radixSort = <span class="keyword">new</span> RadixSort();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = (<span class="keyword">int</span>) (Math.random()*<span class="number">800000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        radixSort.radixSort(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis()-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8、堆排序"><a href="#3-8、堆排序" class="headerlink" title="3.8、堆排序"></a>3.8、堆排序</h3><ul><li>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种<code>选择排序</code>，</li><li>它的最坏，最好，平均时间复杂度均为O(nlogn)，</li><li>它也是不稳定排序。</li></ul><p><strong>性质：</strong></p><ol><li>完全二叉树</li><li>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, </li><li> 没有要求结点的左孩子的值和右孩子的值的大小关系。</li><li>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</li></ol><p><strong>特点：</strong></p><p>​    大顶堆： arr[ i ]  &gt;=  arr[ 2 * i + 1]      arr[ i ]  &gt;=  arr[ 2 * i + 2]   升序使用</p><p>   小顶堆： 相反                                                                                 降序使用</p><p><strong>思想：</strong></p><ol><li>用排序序列构造大堆顶（顺序存储二叉树）</li><li>此时堆顶的根节点最大，将其与末尾元素交换，则末尾最大</li><li>之后调整堆即可，重复步骤，直到全部有序</li></ol><p>arr.length / 2- 1  ：最后一个非叶子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="comment">// 先构建一个堆，只是逻辑上是堆，实际还是数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span>- <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 从叶子节点开始构建堆</span></span><br><span class="line">            buildHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>,i);</span><br><span class="line">            <span class="comment">// 每次调整一次堆即可</span></span><br><span class="line">            buildHeap(arr,<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调整arr[index]在堆中的位置，往下找到一个值比arr[index]小，交换两个值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">        <span class="comment">// 从节点i开始不断往下一层循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index * <span class="number">2</span> + <span class="number">1</span>; i &lt; length; i = i * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果不越界，并且右子节点大于左节点,就指向右子节点</span></span><br><span class="line">            <span class="comment">// 因为找到的节点要换上去，所以必须选比较大的</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; length-<span class="number">1</span> &amp;&amp; arr[i]&lt;arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果父节点大，说明已经是堆了</span></span><br><span class="line">            <span class="comment">// 如果父节点小，就把大的移上去，以小节点为节点继续往下排序</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;temp)&#123;</span><br><span class="line">                arr[index] = arr[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 说明父节点已经最大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最下面的节点赋值</span></span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[index2];</span><br><span class="line">        arr[index2] = arr[index1];</span><br><span class="line">        arr[index1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeapSort heapSort = <span class="keyword">new</span> HeapSort();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = (<span class="keyword">int</span>) (Math.random()*<span class="number">8000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        heapSort.sort(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis()-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、八大内部排序算法总结"><a href="#4、八大内部排序算法总结" class="headerlink" title="4、八大内部排序算法总结"></a>4、八大内部排序算法总结</h2><p><img src="/img/structure/2.jpg"></p><p><strong>关于时间复杂度：</strong></p><ol><li>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</li><li>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序。</li><li>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。希尔排序。</li><li>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</li></ol><p><strong>关于稳定性：</strong></p><p><strong>稳定的排序算法</strong>：冒泡排序、插入排序、归并排序和基数排序。</p><p><strong>不是稳定的排序算法</strong>：选择排序、快速排序、希尔排序、堆排序。</p><p>名词解释：</p><ol><li>n：数据规模</li><li>k：“桶”的个数</li><li>In-place：占用常数内存，不占用额外内存</li><li>Out-place：占用额外内存</li><li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法Java版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法(九):10种常用算法</title>
      <link href="/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E4%B9%9D%20)%2010%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E4%B9%9D%20)%2010%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1、查找算法"><a href="#1、查找算法" class="headerlink" title="1、查找算法"></a>1、查找算法</h2><h3 id="1-1、线性查找"><a href="#1-1、线性查找" class="headerlink" title="1.1、线性查找"></a>1.1、线性查找</h3><p>即顺序查找，逐一比对</p><h3 id="1-2、二分查找法"><a href="#1-2、二分查找法" class="headerlink" title="1.2、二分查找法"></a>1.2、二分查找法</h3><ul><li>递归方法，先取数组中间值，判断查找值和该值的比较，然后继续递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinartSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> middle = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> value = arr[middle];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num &lt; value) &#123;</span><br><span class="line">            <span class="keyword">return</span> getIndex(arr, left, middle - <span class="number">1</span>, num);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; value) &#123;</span><br><span class="line">            <span class="keyword">return</span> getIndex(arr, middle + <span class="number">1</span>, right, num);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(middle);</span><br><span class="line">            <span class="keyword">int</span> temp = middle - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(arr[temp]==value)&#123;</span><br><span class="line">                list.add(temp);</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = middle + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(arr[temp]==value)&#123;</span><br><span class="line">                list.add(temp);</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinartSearch binartSearch = <span class="keyword">new</span> BinartSearch();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">68</span>,<span class="number">99</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(binartSearch.getIndex(a,<span class="number">0</span>,a.length - <span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非递归方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            middle = (left + right )/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[middle]&lt;value)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle]&gt;value)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                list.add(middle);</span><br><span class="line">                <span class="keyword">int</span> temp = middle - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(temp&gt;<span class="number">0</span> &amp;&amp; arr[temp]==value)&#123;</span><br><span class="line">                    list.add(temp);</span><br><span class="line">                    temp--;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = middle + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(temp&lt;arr.length &amp;&amp; arr[temp]==value)&#123;</span><br><span class="line">                    list.add(temp);</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearch binarySearch = <span class="keyword">new</span> BinarySearch();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">68</span>,<span class="number">99</span>&#125;;</span><br><span class="line">        System.out.println(binarySearch.getIndex(a,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3、插值查找（改进二分查找）"><a href="#1-3、插值查找（改进二分查找）" class="headerlink" title="1.3、插值查找（改进二分查找）"></a>1.3、插值查找（改进二分查找）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求middle的公式改变了</span></span><br><span class="line"><span class="keyword">int</span> middle = left + (right-left)*(num-arr[left])/(arr[right]-arr[left]);</span><br></pre></td></tr></table></figure><h3 id="1-4、斐波那契"><a href="#1-4、斐波那契" class="headerlink" title="1.4、斐波那契"></a>1.4、斐波那契</h3><ul><li>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。</li><li>取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。</li><li>斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618</li><li>本质也是修改mid的值</li></ul><h2 id="2、分治算法"><a href="#2、分治算法" class="headerlink" title="2、分治算法"></a>2、分治算法</h2><h3 id="2-1、概念"><a href="#2-1、概念" class="headerlink" title="2.1、概念"></a>2.1、概念</h3><p><strong>分治法在每一层递归上都有三个步骤：</strong></p><ul><li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</li><li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li><li>合并：将各个子问题的解合并为原问题的解</li></ul><p><strong>分治算法可以求解的一些经典问题：</strong></p><p>二分搜索、大整数乘法、棋盘覆盖、合并排序、快速排序</p><p>线性时间选择、最接近点对问题、循环赛日程表、汉诺塔</p><h3 id="2-2、算法设计模式"><a href="#2-2、算法设计模式" class="headerlink" title="2.2、算法设计模式"></a>2.2、算法设计模式</h3><p>if |P|≤n0<br>       then return(ADHOC(P))<br>        //将P分解为较小的子问题 P1 ,P2 ,…,Pk<br>for i←1 to k<br>        do yi ← Divide-and-Conquer(Pi)   递归解决Pi<br>        T ← MERGE(y1,y2,…,yk)   合并子问题<br>        return(T)</p><p>其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p><h3 id="2-3、分治算法解决汉诺塔问题"><a href="#2-3、分治算法解决汉诺塔问题" class="headerlink" title="2.3、分治算法解决汉诺塔问题"></a>2.3、分治算法解决汉诺塔问题</h3><ol><li>把A上面的 n - 1 个全部移动到B</li><li>把A剩下的移动到C</li><li>把B上面的 n  个全部移动到C</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoi</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将n个从s1移动到s2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hannoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> a, <span class="keyword">char</span> b ,<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第1个盘: &quot;</span>+ a + <span class="string">&quot; - &gt; &quot;</span> + c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            hannoi(n - <span class="number">1</span>,a,c,b);</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + n + <span class="string">&quot;个盘: &quot;</span> + a + <span class="string">&quot; - &gt; &quot;</span> + c);</span><br><span class="line">            hannoi(n - <span class="number">1</span>,b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hannoi(<span class="number">3</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、动态规划算法"><a href="#3、动态规划算法" class="headerlink" title="3、动态规划算法"></a>3、动态规划算法</h2><h3 id="3-1、概念"><a href="#3-1、概念" class="headerlink" title="3.1、概念"></a>3.1、概念</h3><ol><li>动态规划(Dynamic Programming)算法的核心思想是：<code>将大问题划分为小问题</code>进行解决，从而一步步获取最优解的处理算法</li><li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li><li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到<code>子问题往往不是互相独立的。</code> ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</li><li>动态规划可以通过填表的方式来逐步推进，得到最优解.</li></ol><h3 id="3-2、背包问题"><a href="#3-2、背包问题" class="headerlink" title="3.2、背包问题"></a>3.2、背包问题</h3><p>一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品使物品的价值大。</p><p><strong>划分：</strong></p><ul><li>01背包和：每个物品最多放一个</li><li>完全背包(完全背包指的是：每种物品都有无限件可用，可以转换成01背包)</li></ul><h3 id="3-3、思路"><a href="#3-3、思路" class="headerlink" title="3.3、思路"></a>3.3、思路</h3><p><strong>利用动态规划来解决。</strong></p><ol><li>对于给定的n个物品，设 v[i] 、w[i]分别为第i个物品的价值和重量，C为背包的容量。</li><li>每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。</li><li>v [i] [j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。</li></ol><p><strong>则我们有下面的结果：</strong></p><ol><li> v [i] [0] =v [0] [j] =0;       //表示 填入表 第一行和第一列是0</li><li>当w[i] &gt; j 时：v[i] [j]=v[i-1] [j]   // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略</li><li>当 j &gt;= w[i] 时： v[i] [j]=max{v[ i- 1 ] [ j ],  v[ i ] + v[ i- 1 ] [j-w[ i ] ] }<br>// 即当 准备加入的新增的商品的容量小于等于当前背包的容量,<br>// 装入的方式:<br>v[i-1] [j]： 就是上一个单元格的装入的最大值<br>v[i] : 表示当前商品的价值<br>v[i-1] [j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值<br>当j&gt;=w[i]时： v[i] [j]=max{v[i-1] [j], v[i]+v[i-1] [j-w[i]]} : </li><li>这样保证 v[i] [j] 一定是i个商品，限制j情况下的最优解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dynamic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bag</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] val,<span class="keyword">int</span> bagSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[weight.length+<span class="number">1</span>][bagSize+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[weight.length+<span class="number">1</span>][bagSize+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; table[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                table[i][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; table[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weight[i-<span class="number">1</span>]&gt; j)&#123;</span><br><span class="line">                    table[i][j] = table[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table[i-<span class="number">1</span>][j] &lt; val[i-<span class="number">1</span>]+table[i-<span class="number">1</span>][j-weight[i-<span class="number">1</span>]])&#123;</span><br><span class="line">                        table[i][j] = val[i-<span class="number">1</span>]+table[i-<span class="number">1</span>][j-weight[i-<span class="number">1</span>]];</span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        table[i][j] = table[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = table.length -<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> j = table[<span class="number">0</span>].length -<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(i+<span class="string">&quot;放入背包&quot;</span>);</span><br><span class="line">                j = j - weight[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] val = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">2000</span>&#125;;</span><br><span class="line">        bag(w,val,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、KMP算法"><a href="#4、KMP算法" class="headerlink" title="4、KMP算法"></a>4、KMP算法</h2><h3 id="4-1、字符串匹配问题"><a href="#4-1、字符串匹配问题" class="headerlink" title="4.1、字符串匹配问题"></a>4.1、字符串匹配问题</h3><p>有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2=”ABCDABD”<br>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</p><h3 id="4-2、暴力算法实现"><a href="#4-2、暴力算法实现" class="headerlink" title="4.2、暴力算法实现"></a>4.2、暴力算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kmp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">baoLi</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length() - str2.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.substring(i,i+str2.length()).equals(str2))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line">        System.out.println(baoLi(str1,str2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、Kmp算法"><a href="#4-3、Kmp算法" class="headerlink" title="4.3、Kmp算法"></a>4.3、Kmp算法</h3><p>KMP方法算法就是利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间</p><p><strong>核心思想</strong>：</p><ol><li><p>为子串制作匹配表，int[] arr ，arr[ i ] ，就表示字符串前 i 个字符中，前arr[ i ]个字符以及后arr[ i ] 个字符相等。</p></li><li><p>比对时，如果str 2 已经被比对了 n 位， 那么就检查 前 n -1 位对应匹配表里面的值，</p><p>下一次开始从str 1 比较 str 2的位置 ，就是     上一次的位置 +  n  - arr[ n - 1]</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kmp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">baoLi</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length() - str2.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.substring(i,i+str2.length()).equals(str2))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = kmpNext(str2);</span><br><span class="line"><span class="comment">//        方法一：更简单        </span></span><br><span class="line"><span class="comment">//        for (int i = 0 , j = 0 ; i &lt; str1.length(); i++) &#123;</span></span><br><span class="line"><span class="comment">//            while (j&gt;0 &amp;&amp; str1.charAt(i)!=str2.charAt(j))&#123;</span></span><br><span class="line"><span class="comment">//                j = next[j-1];</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if(str1.charAt(i) == str2.charAt(j))&#123;</span></span><br><span class="line"><span class="comment">//                j++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if(j==str2.length())&#123;</span></span><br><span class="line"><span class="comment">//                return i - j + 1;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt; str1.length()-str2.length()+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(index==str2.length())&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (str1.charAt(i + index) == str2.charAt(index)) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (index==<span class="number">0</span>)&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(i + <span class="string">&quot; index:&quot;</span> + index);</span><br><span class="line">                        <span class="comment">// 向右移动已经匹配的的字符数减去对应的匹配值</span></span><br><span class="line">                        i = i + index - next[index-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpNext(String dest)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>; i &lt; dest.length() ; i++) &#123;</span><br><span class="line">            </span><br><span class="line"><span class="comment">// j 说明，dest.charAt(i)前面j个数都和dest字符串的前3个数相匹配</span></span><br><span class="line">        <span class="comment">// 所以继续匹配， dest.charAt(j)即dest第j+1个字符和当前字符即可</span></span><br><span class="line">        <span class="comment">// 如果结果对不上，j就可以直接置为0</span></span><br><span class="line">        <span class="comment">// 不过还有一种特殊情况，就是当前字符前一个字符不仅能匹配，第j个字符</span></span><br><span class="line">        <span class="comment">//  还能匹配之前的字符，这时就把j = next[j-1]</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        例如j =3 ，当前字符为ABAB的B，dest前4个字符为ABAC，因为ABAB和ABAC的前面ABC相等，所以当前字符的B的前一个A求匹配值，即next[j-1]，能匹配即不为0，则表示当前也能匹配到该匹配值，所以可以再进行一次比较</span></span><br><span class="line"><span class="comment">        */</span>    </span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; dest.charAt(i)!=dest.charAt(j))&#123;</span><br><span class="line"><span class="comment">//                j = next[j-1];  // 这种方式效率更高一些，但是不利于理解</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i) == dest.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str1 = <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String str2 = <span class="string">&quot; ABCDABC&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(kmp(str1,str2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、贪心算法"><a href="#5、贪心算法" class="headerlink" title="5、贪心算法"></a>5、贪心算法</h2><h3 id="5-1、概念"><a href="#5-1、概念" class="headerlink" title="5.1、概念"></a>5.1、概念</h3><ul><li>求解时，在每一步选择中都采取最好或者最优(即最有利)的选择</li><li>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是一定接近最优解</li></ul><h3 id="5-2、集合覆盖问题"><a href="#5-2、集合覆盖问题" class="headerlink" title="5.2、集合覆盖问题"></a>5.2、集合覆盖问题</h3><p>存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号</p><table><thead><tr><th>广播台</th><th>覆盖地区</th></tr></thead><tbody><tr><td>K1</td><td>“北京”, “上海”, “天津”</td></tr><tr><td>K2</td><td>“广州”, “北京”, “深圳”</td></tr><tr><td>K3</td><td>“成都”, “上海”, “杭州”</td></tr><tr><td>K4</td><td>“上海”, “天津”</td></tr><tr><td>K5</td><td>“杭州”, “大连”</td></tr></tbody></table><h3 id="5-3、思想"><a href="#5-3、思想" class="headerlink" title="5.3、思想"></a>5.3、思想</h3><ol><li>遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） </li><li>将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</li><li>重复第1步直到覆盖了全部的地区</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greedy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">greedy</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; map, HashSet&lt;String&gt; allAreas)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存遍历过程中，每个电台覆盖的地区和当前allAreas的交集</span></span><br><span class="line">        HashSet&lt;String&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 每次循环应该添加的键</span></span><br><span class="line">        String maxKey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!allAreas.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 清空</span></span><br><span class="line">            maxKey = <span class="keyword">null</span>;</span><br><span class="line">            temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// foreaach遍历每个广播台</span></span><br><span class="line">            <span class="keyword">for</span> (String key: map.keySet()) &#123;</span><br><span class="line">                <span class="comment">// 当前广播台能覆盖的地区临时保存到temp</span></span><br><span class="line">                temp = (HashSet&lt;String&gt;) map.get(key);</span><br><span class="line">                <span class="comment">// 获得交集，即广播台在allareas有效的个数</span></span><br><span class="line">                temp.retainAll(allAreas);</span><br><span class="line">                <span class="comment">// 如果数量多，就赋值给maxkey</span></span><br><span class="line">                <span class="keyword">if</span>(temp.size()&gt;max)&#123;</span><br><span class="line">                    maxKey = key;</span><br><span class="line">                    max = temp.size();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果选出来广播站</span></span><br><span class="line">            <span class="keyword">if</span>(maxKey!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 添加到结果集中</span></span><br><span class="line">                selects.add(maxKey);</span><br><span class="line">                <span class="comment">// 把master指向的广播电台地区删除</span></span><br><span class="line">                allAreas.removeAll(map.get(maxKey));</span><br><span class="line">                <span class="comment">// map删除key</span></span><br><span class="line">                map.remove(maxKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> selects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建广播电台</span></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 放入电台信息</span></span><br><span class="line">        HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">        HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet2.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">        HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet3.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet4.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet4.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">        HashSet&lt;String&gt; hashSet5 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet5.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        hashSet5.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;k1&quot;</span>,hashSet1);</span><br><span class="line">        map.put(<span class="string">&quot;k2&quot;</span>,hashSet2);</span><br><span class="line">        map.put(<span class="string">&quot;k3&quot;</span>,hashSet3);</span><br><span class="line">        map.put(<span class="string">&quot;k4&quot;</span>,hashSet4);</span><br><span class="line">        map.put(<span class="string">&quot;k5&quot;</span>,hashSet5);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        allAreas.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(greedy(map,allAreas));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、普利姆算法"><a href="#6、普利姆算法" class="headerlink" title="6、普利姆算法"></a>6、普利姆算法</h2><h3 id="6-1、修路问题"><a href="#6-1、修路问题" class="headerlink" title="6.1、修路问题"></a>6.1、修路问题</h3><p>某城市新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通<br>各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里<br>问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?</p><h3 id="6-2、最小生成树"><a href="#6-2、最小生成树" class="headerlink" title="6.2、最小生成树"></a>6.2、最小生成树</h3><ol><li>给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,</li><li>叫最小生成树 </li><li>N个顶点，一定有N-1条边</li><li>包含全部顶点</li><li>N-1条边都在图中</li></ol><p>求最小生成树的算法主要是<code>普里姆算法和克鲁斯卡尔算法</code></p><h3 id="6-3、普利姆算法"><a href="#6-3、普利姆算法" class="headerlink" title="6.3、普利姆算法"></a>6.3、普利姆算法</h3><p>普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图<br><strong>普利姆的算法如下:</strong></p><ol><li>设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 </li><li>若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1</li><li>若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1</li><li>重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边</li></ol><p><strong>主要思想</strong></p><ol><li>确定一个顶点A，从该顶点开始生成最小生成树</li><li>遍历整个领接矩阵，找到和A最接近的一个顶点B，添加进来</li><li>遍历整个领接矩阵，找到和A或B最接近的一个顶点C，添加进来</li><li>以此类推，直到全部节点添加进来</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建最小生成树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinTree</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(Graph graph,<span class="keyword">int</span> verxs,<span class="keyword">char</span> data[], <span class="keyword">int</span>[][] weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; verxs; i++) &#123;</span><br><span class="line">            graph.data[i] = data[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; verxs; j++) &#123;</span><br><span class="line">                graph.weight[i][j] = weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Graph graph)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] link: graph.weight) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从图graph的第v个顶点生成树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(Graph graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义是否访问过</span></span><br><span class="line">        <span class="keyword">int</span>[] visted = <span class="keyword">new</span> <span class="keyword">int</span>[graph.verxs];</span><br><span class="line">        <span class="comment">// 把当前节点标记为已访问</span></span><br><span class="line">        visted[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// h1.和h2记录两个顶点的下标</span></span><br><span class="line">        <span class="keyword">int</span> h1 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> h2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> minWeight;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; graph.verxs; k++) &#123;</span><br><span class="line">            minWeight = <span class="number">10000</span>;</span><br><span class="line">            <span class="comment">// 确定每一次生成的子图和哪个节点的以及存在的节点距离最近</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.verxs; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.verxs; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(visted[i]==<span class="number">1</span> &amp;&amp; visted[j]==<span class="number">0</span> &amp;&amp; graph.weight[i][j] &lt; minWeight)&#123;</span><br><span class="line">                        <span class="comment">// 替换minWeight</span></span><br><span class="line">                        minWeight =  graph.weight[i][j];</span><br><span class="line">                        h1 = i;</span><br><span class="line">                        h2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时已经找到一条边最小</span></span><br><span class="line">            System.out.println(<span class="string">&quot;边&quot;</span> + graph.data[h1] + <span class="string">&quot; &quot;</span> + graph.data[h2] + <span class="string">&quot; 值&quot;</span> + minWeight);</span><br><span class="line">            <span class="comment">// 将当前找到的节点标记为已经访问</span></span><br><span class="line">            visted[h2] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> verxs;        <span class="comment">// 表示节点个数</span></span><br><span class="line">    <span class="keyword">char</span>[] data;     <span class="comment">// 保存存放节点的数据</span></span><br><span class="line">    <span class="keyword">int</span>[][] weight;  <span class="comment">// 存放边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> verxs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.verxs = verxs;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[verxs];</span><br><span class="line">        weight = <span class="keyword">new</span> <span class="keyword">int</span>[verxs][verxs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prim</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> verxs = data.length;</span><br><span class="line">        <span class="comment">// 领接矩阵使用二维数组表示,10000表示两个点不连通</span></span><br><span class="line">        <span class="keyword">int</span>[][] weight = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10000</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(verxs);</span><br><span class="line">        <span class="comment">// 创建最小生成树对象</span></span><br><span class="line">        MinTree minTree = <span class="keyword">new</span> MinTree();</span><br><span class="line">        minTree.create(graph,verxs,data,weight);</span><br><span class="line">        minTree.show(graph);</span><br><span class="line">        minTree.prim(graph,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、克鲁斯卡尔算法"><a href="#7、克鲁斯卡尔算法" class="headerlink" title="7、克鲁斯卡尔算法"></a>7、克鲁斯卡尔算法</h2><h3 id="7-1、公交站问题"><a href="#7-1、公交站问题" class="headerlink" title="7.1、公交站问题"></a>7.1、公交站问题</h3><p>某城市新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通<br>各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里<br>问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?</p><h3 id="7-2、克鲁斯卡尔算法"><a href="#7-2、克鲁斯卡尔算法" class="headerlink" title="7.2、克鲁斯卡尔算法"></a>7.2、克鲁斯卡尔算法</h3><p>克鲁斯卡尔(Kruskal)算法，同样是用来<strong>求加权连通图的最小生成树</strong>的算法。</p><p><strong>基本思想：</strong>按照权值从小到大的顺序选择n-1条边，<code>并保证这n-1条边不构成回路</code></p><p><strong>具体做法：</strong></p><ol><li>首先构造一个只含n个顶点的森林，</li><li>然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，</li><li>直至森林变成一棵树为止</li></ol><h3 id="7-3、代码实现"><a href="#7-3、代码实现" class="headerlink" title="7.3、代码实现"></a>7.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kruskal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeNums; <span class="comment">// 记录边的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertexs; <span class="comment">//顶点个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix; <span class="comment">// 领接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE; <span class="comment">// 表示两个顶点不能联通</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择排序，根据权值，对所有的边对象进行排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortEdges</span><span class="params">(EData[] eDates)</span></span>&#123;</span><br><span class="line">        EData temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eDates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; eDates.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(eDates[j].weight &lt; eDates[i].weight)&#123;</span><br><span class="line">                    temp = eDates[i];</span><br><span class="line">                    eDates[i] = eDates[j];</span><br><span class="line">                    eDates[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据顶点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPositionIndex</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==vertexs[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取图中的边放到边的对象数组中</span></span><br><span class="line">    <span class="keyword">public</span> EData[] getEdges()&#123;</span><br><span class="line">        EData[] eDates = <span class="keyword">new</span> EData[edgeNums/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]!=INF)&#123;</span><br><span class="line">                    eDates[index++] = <span class="keyword">new</span> EData(vertexs[i], vertexs[j],matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eDates;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">char</span>[] vertexs, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertexs = vertexs;</span><br><span class="line">        <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]!=INF &amp;&amp; matrix[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    edgeNums++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下标为i的顶点的终点,核心算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">(<span class="keyword">int</span>[] ends, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ends[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            i = ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Integer&gt; exist = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[edgeNums/<span class="number">2</span>]; <span class="comment">// 保存每个节点在最小生成树的终点</span></span><br><span class="line">        <span class="comment">// 保存最小生成树</span></span><br><span class="line">        EData[] res = <span class="keyword">new</span> EData[edgeNums/<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 获取数组所有边的集合</span></span><br><span class="line">        EData[] edges = getEdges();</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        sortEdges(edges);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序之后的所有边为&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (EData e:edges )&#123;</span><br><span class="line">            <span class="keyword">if</span> (e!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历数组,不断把最小的边添加到结果数组，保证不产生回路</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = getPositionIndex(edges[i].Point1);</span><br><span class="line">            <span class="keyword">int</span> end = getPositionIndex(edges[i].Point2);</span><br><span class="line">            <span class="comment">// 获取start的终点和end的终点</span></span><br><span class="line">            <span class="keyword">int</span> m = getEnd(ends,start);  <span class="comment">// 如果为0则返回自己也就是start</span></span><br><span class="line">            <span class="keyword">int</span> n = getEnd(ends,end);</span><br><span class="line">            <span class="comment">// 是否构成回路</span></span><br><span class="line">            <span class="keyword">if</span>(m!=n)&#123;</span><br><span class="line">                ends[m] = n; <span class="comment">// 设置m的终点是n</span></span><br><span class="line">                System.out.println(m+<span class="string">&quot; &quot;</span>+n);</span><br><span class="line">                res[index++] = edges[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计并打印最小生成树</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树为&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (EData e:res )&#123;</span><br><span class="line">            <span class="keyword">if</span> (e!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;领接矩阵:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j]==INF)&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;INF&quot;</span>+<span class="string">&quot;   &quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(matrix[i][j] + <span class="string">&quot;    &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 节点</span></span><br><span class="line">        <span class="keyword">char</span>[] vertexs= <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">// 领接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>,<span class="number">12</span>,INF,INF,INF,<span class="number">16</span>,<span class="number">14</span>&#125;,</span><br><span class="line">                &#123;<span class="number">12</span>,<span class="number">0</span>,<span class="number">10</span>,INF,INF,<span class="number">7</span>,INF&#125;,</span><br><span class="line">                &#123;INF,<span class="number">10</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,INF&#125;,</span><br><span class="line">                &#123;INF,INF,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,INF,INF&#125;,</span><br><span class="line">                &#123;INF,INF,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">16</span>,<span class="number">7</span>,<span class="number">6</span>,INF,<span class="number">2</span>,<span class="number">0</span>,<span class="number">9</span>&#125;,</span><br><span class="line">                &#123;<span class="number">14</span>,INF,INF,INF,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        Kruskal kruskal = <span class="keyword">new</span> Kruskal(vertexs,matrix);</span><br><span class="line">        kruskal.kruskal();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EData</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> Point1;   <span class="comment">//起点</span></span><br><span class="line">    <span class="keyword">char</span> Point2;   <span class="comment">//终点</span></span><br><span class="line">    <span class="keyword">int</span> weight; <span class="comment">// 边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EDate&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot; 点1:&quot;</span> +Point1 + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                <span class="string">&quot; 点2:&quot;</span> +Point2 + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                <span class="string">&quot; 权值:&quot;</span> +weight + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EData</span><span class="params">(<span class="keyword">char</span> start, <span class="keyword">char</span> end, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Point1 = start;</span><br><span class="line">        <span class="keyword">this</span>.Point2 = end;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、迪杰斯特拉算法"><a href="#8、迪杰斯特拉算法" class="headerlink" title="8、迪杰斯特拉算法"></a>8、迪杰斯特拉算法</h2><h3 id="8-1、简介"><a href="#8-1、简介" class="headerlink" title="8.1、简介"></a>8.1、简介</h3><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p><h3 id="8-2、最短路径问题"><a href="#8-2、最短路径问题" class="headerlink" title="8.2、最短路径问题"></a>8.2、最短路径问题</h3><p>战争时期，有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里<br><strong>问：</strong></p><ul><li>如何计算出G村庄到 其它各个村庄的最短距离? </li><li>如果从其它点出发到各个点的最短距离又是多少?</li></ul><h3 id="8-3、解决最短路径"><a href="#8-3、解决最短路径" class="headerlink" title="8.3、解决最短路径"></a>8.3、解决最短路径</h3><ol><li>定义 VisitedVertex 类，<ul><li>int[] dis  记录从根节点到每个节点的最短距离</li><li>int[] already;  记录每个节点是否访问过</li></ul></li><li>定义Graph 类 用来创建图，并寻找最短距离<ul><li>char[] vertex;  // 顶点数组</li><li>int[][] matrix;      // 邻接矩阵</li></ul></li><li>初始化 VisitedVertex ，需要传入参数 index ，表示从index 开始 寻找 最短路径</li><li>选择一个节点开始访问（假设为A），选择该节点的<code>其他所有节点</code>（假设为B）<ul><li>计算    <code>A 到B 的值</code> 与 <code>根节点到A</code>的值之和 ，记作value1</li><li>计算   根节点到B的值（根据int[] dis ），记作value2</li><li>如果   value1更小，说明根节点到B的值 找出了更短的，就可以更新数据</li></ul></li><li>重复过程4，注意选择规则，<ul><li>第一次，以根节点为起始节点，</li><li>第二次，以与根节点距离最短的节点为起始节点，</li><li>第三次，以与上次选择的节点距离最短的节点为起始节点，</li><li><strong>注意节点选择过一次就不能再次选择了</strong></li></ul></li></ol><h3 id="8-4、代码"><a href="#8-4、代码" class="headerlink" title="8.4、代码"></a>8.4、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitedVertex</span></span>&#123;</span><br><span class="line">    <span class="comment">// 记录每个节点是否访问过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] already;</span><br><span class="line">    <span class="comment">// 记录出发顶点到其他所有顶点的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dis;</span><br><span class="line">    <span class="comment">// lenght 顶点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VisitedVertex</span><span class="params">(<span class="keyword">int</span> length,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.already = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">this</span>.dis = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">// 初始化数组</span></span><br><span class="line">        Arrays.fill(dis,<span class="number">65535</span>);</span><br><span class="line">        <span class="comment">// 设置为出发顶点已经访问过</span></span><br><span class="line">        <span class="keyword">this</span>.already[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.dis[index] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据索引判断是否访问过</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> already[index]== <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新距离</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDis</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dis[index] = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回距离</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDis</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继续选择并且返回新的访问顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateArr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">65535</span>,index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; already.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (already[i]==<span class="number">0</span> &amp;&amp; dis[i] &lt; min)&#123;</span><br><span class="line">                min = dis[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        already[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;到第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个节点距离：&quot;</span>+dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertex;  <span class="comment">// 顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix; <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> VisitedVertex visitedVertex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">        <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(matrix[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迪杰斯塔拉算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        visitedVertex = <span class="keyword">new</span> VisitedVertex(vertex.length,index);</span><br><span class="line">        <span class="comment">// 更新index下标顶点到周围的距离和前驱顶点</span></span><br><span class="line">        update(index);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            index = visitedVertex.updateArr();</span><br><span class="line">            update(index);</span><br><span class="line">        &#125;</span><br><span class="line">        visitedVertex.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次从index节点开始，选择一个节点，</span></span><br><span class="line">    <span class="comment">// 判断根节点到index节点的最短距离 + index到 A节点的距离 与 已保存的最短距离比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[index].length; i++) &#123;</span><br><span class="line">            <span class="comment">// 出发顶点到index顶点的距离  从index顶点到i顶点的距离和</span></span><br><span class="line">            len = visitedVertex.getDis(index) + matrix[index][i];</span><br><span class="line">            <span class="comment">// 如果j没有被访问过，并且len小于顶点出发到j的距离。就更新距离</span></span><br><span class="line">            <span class="keyword">if</span>(!visitedVertex.in(i) &amp;&amp; len &lt;visitedVertex.getDis(i))&#123;</span><br><span class="line">                visitedVertex.updateDis(i,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">5</span>,<span class="number">7</span>,N,N,N,<span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,N,N,<span class="number">9</span>,N,N,<span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,N,N,N,<span class="number">8</span>,N,N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">9</span>,N,N,N,<span class="number">4</span>,N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,<span class="number">8</span>,N,N,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,N,<span class="number">4</span>,<span class="number">5</span>,N,<span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,N,N,<span class="number">4</span>,<span class="number">6</span>,N&#125;;</span><br><span class="line"></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertex,matrix);</span><br><span class="line">        graph.dijkstra(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、弗洛伊德算法"><a href="#9、弗洛伊德算法" class="headerlink" title="9、弗洛伊德算法"></a>9、弗洛伊德算法</h2><h3 id="9-1、简介"><a href="#9-1、简介" class="headerlink" title="9.1、简介"></a>9.1、简介</h3><p>弗洛伊德算法(Floyd)计算图中<code>各个顶点之间</code>的最短路径</p><p>洛伊德算法中<code>每一个顶点都是出发访问点</code>，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</p><h3 id="9-2、思想"><a href="#9-2、思想" class="headerlink" title="9.2、思想"></a>9.2、思想</h3><ol><li>设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，</li><li>vk的取值为图中所有顶点，则可获得vi到vj的最短路径</li><li>至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Graph &#123;</span><br><span class="line">    private char[] vertex;  // 顶点数组</span><br><span class="line">    private int[][] matrix; // 邻接矩阵</span><br><span class="line">    public Graph(char[] vertex, int[][] matrix) &#123;</span><br><span class="line">        this.vertex = vertex;</span><br><span class="line">        this.matrix = matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void floyd()&#123;</span><br><span class="line">        // 从每个节点遍历</span><br><span class="line">        for (int k = 0; k &lt; vertex.length; k++) &#123;</span><br><span class="line">            // 寻找 其他的节点</span><br><span class="line">            for (int i = 0; i &lt; vertex.length; i++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; vertex.length; j++) &#123;</span><br><span class="line">                    if(i!=k &amp;&amp; j!=k &amp;&amp; i!=j)&#123;</span><br><span class="line">                        matrix[i][j] = Math.min(matrix[i][k]+matrix[k][j],matrix[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        for (int i = 0; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            System.out.println(vertex[0]+&quot;与其他节点的最短距离为&quot;);</span><br><span class="line">            for (int j = 0; j &lt; vertex.length; j++) &#123;</span><br><span class="line">                if(i!=j) &#123;</span><br><span class="line">                    System.out.println(&quot;和&quot; + vertex[j] + &quot;节点的最短距离：&quot; + matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、骑士周游问题"><a href="#10、骑士周游问题" class="headerlink" title="10、骑士周游问题"></a>10、骑士周游问题</h2><p>马踏棋盘算法也被称为骑士周游问题</p><p>将马随机放在国际象棋的8×8棋盘Board[0～7] [0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格</p><p><strong>算法：</strong></p><ol><li>马踏棋盘问题(骑士周游问题)实际上是图的**深度优先搜索(DFS)**的应用。</li><li>如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了53个点，如图：走到了第53个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… ，思路分析+代码实现</li><li>分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题.</li></ol><p><strong>步骤：</strong></p><ol><li>定义二维数组 board 表示棋盘</li><li>把当前位置设置已访问，并且计算马还能走哪些地方，放入集合中，</li><li>每走一步，step + 1</li><li>遍历集合的位置，看看哪些地方可以走通，走不通就回溯</li><li>判断马是不是完成任务，使用step和应该走的步骤比较</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Horse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> X;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> Y;</span><br><span class="line">    <span class="comment">// 标记是否访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> finished;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">horse</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        board[row][column] = step;</span><br><span class="line">        visited[row][column] = <span class="keyword">true</span>;</span><br><span class="line">        ArrayList&lt;Point&gt; list = next(<span class="keyword">new</span> Point(column,row));</span><br><span class="line">        Collections.sort(list,(p1,p2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> count1 = next(p1).size();</span><br><span class="line">            <span class="keyword">int</span> count2 = next(p2).size();</span><br><span class="line">            <span class="keyword">if</span>(count1 &lt; count2) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count1 == count2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty())&#123;</span><br><span class="line">            Point p = list.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(!visited[p.y][p.x])&#123;</span><br><span class="line">                horse(board,p.y,p.x,step + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回退</span></span><br><span class="line">        <span class="keyword">if</span>(step &lt; X * Y &amp;&amp; !finished)&#123;</span><br><span class="line">            board[row][column] = <span class="number">0</span>;</span><br><span class="line">            visited[row][column] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            finished = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给一个点，表示马的位置，把马能够走的位置放入集合</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title">next</span><span class="params">(Point curPoint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newX;</span><br><span class="line">        <span class="keyword">int</span> newY;</span><br><span class="line">        ArrayList&lt;Point&gt; list = <span class="keyword">new</span> ArrayList&lt;Point&gt;();</span><br><span class="line">        <span class="keyword">if</span>((newX = curPoint.x - <span class="number">2</span> )&gt;=<span class="number">0</span> &amp;&amp;( newY = curPoint.y - <span class="number">1</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Point(newX,newY));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((newX = curPoint.x - <span class="number">2</span> )&gt;=<span class="number">0</span> &amp;&amp;( newY = curPoint.y + <span class="number">1</span>)&lt;Y)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Point(newX,newY));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((newX = curPoint.x + <span class="number">2</span> )&lt;X &amp;&amp;( newY = curPoint.y - <span class="number">1</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Point(newX,newY));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((newX = curPoint.x + <span class="number">2</span> )&lt;X &amp;&amp;( newY = curPoint.y + <span class="number">1</span>)&lt;Y)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Point(newX,newY));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((newX = curPoint.x + <span class="number">1</span> )&lt;X &amp;&amp;( newY = curPoint.y + <span class="number">2</span>)&lt;Y)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Point(newX,newY));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((newX = curPoint.x + <span class="number">1</span> )&lt;X &amp;&amp;( newY = curPoint.y - <span class="number">2</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Point(newX,newY));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((newX = curPoint.x - <span class="number">1</span> )&gt;=<span class="number">0</span> &amp;&amp;( newY = curPoint.y + <span class="number">2</span>)&lt;Y)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Point(newX,newY));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((newX = curPoint.x - <span class="number">1</span> )&gt;=<span class="number">0</span> &amp;&amp;( newY = curPoint.y - <span class="number">2</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Point(newX,newY));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        X = <span class="number">8</span>;</span><br><span class="line">        Y = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] board = <span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[X][Y];</span><br><span class="line">        horse(board,row,column,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] arr:board) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a:arr)&#123;</span><br><span class="line">                System.out.print(a+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法Java版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法(八):图</title>
      <link href="/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E5%85%AB%20)%20%E5%9B%BE/"/>
      <url>/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E5%85%AB%20)%20%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="1、图的概念"><a href="#1、图的概念" class="headerlink" title="1、图的概念"></a>1、图的概念</h2><p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 </p><p><strong>表示方法：</strong></p><ol><li>二维数组（邻接矩阵）：能直接相连的节点标位1，不能标位0</li><li>链表（邻接表）：每个节点都创建一条链表，链表上有能<code>直接到</code>的节点，数组+链表</li></ol><p><strong>分类</strong></p><ul><li>有向图、无向图</li><li>简单图（不存在重复边。不存在顶点到自己的边）、多重图</li><li>完全图：任意两个点之间都存在边</li><li>子图</li><li>连通图、非连通图</li></ul><p><strong>概念</strong></p><ul><li>度：与点有几条线相连（入度、出度）</li></ul><h2 id="2、图的创建"><a href="#2、图的创建" class="headerlink" title="2、图的创建"></a>2、图的创建</h2><h3 id="2-1、领接矩阵"><a href="#2-1、领接矩阵" class="headerlink" title="2.1、领接矩阵"></a>2.1、领接矩阵</h3><ol><li>list集合存放节点名称</li><li>二维数据存放图对应的领接矩阵</li><li>整形存放边的数目</li><li>二维数组大小对应节点的数量，添加边就把二维数组对应的节点设置为1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList; <span class="comment">// 顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> nums; <span class="comment">// 边的数目</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        nums = <span class="number">0</span>;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span></span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据节点和权重加入边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdges</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2 ,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        nums++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 图中常用方法</span></span><br><span class="line">    <span class="comment">// 1、返回节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVertexNums</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、返回边的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gerNums</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、根据索引返回节点i的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、返回v1和v2的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeightByPionts</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、显示邻接矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] a:edges) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b:a)&#123;</span><br><span class="line">                System.out.print(b+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 创建图</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">// 添加节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            graph.insertVertex(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加边  a-b a-c b-c b-d b-e</span></span><br><span class="line">        graph.insertEdges(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdges(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdges(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdges(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdges(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、邻接表"><a href="#2-2、邻接表" class="headerlink" title="2.2、邻接表"></a>2.2、邻接表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList; <span class="comment">// 顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> Node[] table; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            String name = list.get(i);</span><br><span class="line">            vertexList.add(name);</span><br><span class="line">            table[i] = <span class="keyword">new</span> Node(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertPoints</span><span class="params">(String name,Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node temp:table) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.getName()==name)&#123;</span><br><span class="line">                temp.insert(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delPoint</span><span class="params">(String name,Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node temp:table) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.getName()==name)&#123;</span><br><span class="line">                temp.del(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&quot;</span> + name +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.getName()==temp.getName())&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.getName()==temp.getName())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            temp.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (node.next.getName()==temp.next.getName())&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、深度优先遍历算法（DFS）"><a href="#3、深度优先遍历算法（DFS）" class="headerlink" title="3、深度优先遍历算法（DFS）"></a>3、深度优先遍历算法（DFS）</h2><p><strong>思想：</strong></p><p>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， </p><p><strong>特点：</strong></p><ul><li>每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</li><li>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</li><li>显然，深度优先搜索是一个<code>递归的过程</code></li></ul><p><strong>步骤：</strong></p><ol><li>访问初始结点v，并标记结点v为已访问。</li><li>依次访问v的第一个邻接节点，第二个。。。。。（这里实现了回溯）</li><li>其中的每次访问成功之后以访问的那个节点为初始节点进行递归。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第index个节点的第一个相邻节点</span></span><br><span class="line"><span class="comment">// 获取edges[index]里的第一个节点下标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(edges[index][i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edges[v1][v2]为第v1个节点的相邻节点，找下一个</span></span><br><span class="line"><span class="comment">// 根据前一个临接节点的下标获取下一个领结节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextIndex</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = v2+<span class="number">1</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(edges[v1][i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DFS深度度优先，扫描与第i+1个节点相连的其他节点，即扫描edges[i][从0到length-1]是否有值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsShow</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;=vertexList.size())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取第i的节点的第一个临接节点</span></span><br><span class="line">    <span class="keyword">int</span> result = getFirstIndex(i);</span><br><span class="line">    <span class="keyword">while</span> (result!=-<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该临接节点为访问过且两个节点之间能够访问</span></span><br><span class="line">        <span class="keyword">if</span>(isVisited[result]==<span class="keyword">false</span> &amp;&amp; edges[i][result]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            isVisited[result] = <span class="keyword">true</span>;</span><br><span class="line">            System.out.print(<span class="string">&quot; =&gt; &quot;</span>+vertexList.get(result));</span><br><span class="line">            <span class="comment">// 以下一个节点为起点访问</span></span><br><span class="line">            dfsShow(result);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该节点已经访问，寻找下一个节点</span></span><br><span class="line">            result = getNextIndex(i,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsShow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 输出第一个节点，设置为已访问</span></span><br><span class="line">    System.out.print(vertexList.get(<span class="number">0</span>));</span><br><span class="line">    isVisited[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 防止非连通图的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isVisited.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isVisited[i]==<span class="keyword">false</span>)&#123;</span><br><span class="line">           dfsShow(<span class="number">0</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 便于下次访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isVisited.length; i++) &#123;</span><br><span class="line">        isVisited[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：深度优先遍历也可以不通过递归，通过栈来实现，道理和BFS使用队列差不多。</p><h2 id="4、广度度优先遍历算法（BFS）"><a href="#4、广度度优先遍历算法（BFS）" class="headerlink" title="4、广度度优先遍历算法（BFS）"></a>4、广度度优先遍历算法（BFS）</h2><p>思想：</p><p>​        首先访问第一个邻接结点，把该节点的所有邻接节点访问完之后，再一次以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， </p><p><strong>步骤：</strong></p><ol><li>选取第一个节点开始，不断访问临接节点并且<code>放入队列</code>中直到结束。</li><li>从队列取出一个节点，开始访问该节点的临接节点，把每次得到的节点<code>放入队列</code>中，直到访问结束，不断重复此步骤。</li><li>队列为空则表示遍历结束。</li><li>linkedlist为空时遍历结束</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6、BFS广度优先</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfsShow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index; <span class="comment">// 队列头结点对应下标</span></span><br><span class="line">    <span class="keyword">int</span> result; <span class="comment">// 邻接节点w</span></span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    System.out.print(vertexList.get(<span class="number">0</span>));</span><br><span class="line">    isVisited[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    list.addLast(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!list.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 每次取出一个节点，判断其是否还可以在遍历</span></span><br><span class="line">        index = list.removeFirst();</span><br><span class="line">        <span class="comment">// 获取第一个节点</span></span><br><span class="line">        result = getFirstIndex(index);</span><br><span class="line">        <span class="keyword">while</span> (result!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[result])&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; =&gt; &quot;</span> +vertexList.get(result));</span><br><span class="line">                isVisited[result] = <span class="keyword">true</span>;</span><br><span class="line">                list.addLast(result);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                result = getNextIndex(index,result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 便于下次访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isVisited.length; i++) &#123;</span><br><span class="line">        isVisited[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法Java版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法(七):赫夫曼树</title>
      <link href="/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E4%B8%83%20)%20%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E4%B8%83%20)%20%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为<code>最优二叉树</code>，也称为<code>哈夫曼树(Huffman Tree)</code>, 还有的书翻译为<code>霍夫曼树</code>。</p><p>赫夫曼树是<code>带权路径长度最短</code>的树，权值较大的结点离根较近</p><p><strong>路径和路径长度：</strong>若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</p><p><strong>结点的权及带权路径长度：</strong>所有叶子节点的路径长度之和</p><h2 id="2、列表构建赫夫曼树"><a href="#2、列表构建赫夫曼树" class="headerlink" title="2、列表构建赫夫曼树"></a>2、列表构建赫夫曼树</h2><ol><li>将节点放入list集合中，调用Collections类的方法进行排序</li><li>取出最小的两个节点，新建一个节点作为他们的父节点，父节点值为他们值的和</li><li>把父节点放入list集合，继续重复步骤2</li><li>一直到list集合只剩一个节点，该节点就是<strong>根节点</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index : arr)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Node(index));</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 取出权值最小的节点</span></span><br><span class="line">            Node leftNode = list.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 取出权值第二小的节点</span></span><br><span class="line">            Node rightNode = list.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 构建新二叉树</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">// ArrayList中删除处理过的二叉树,新的加入</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">            list.add(parent);</span><br><span class="line">            <span class="comment">// 最后重新排序</span></span><br><span class="line">            System.out.print(<span class="string">&quot;处理后:&quot;</span>);</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入根节点，前序遍历测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        System.out.println(node);</span><br><span class="line">        <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>)</span><br><span class="line">            preOrder(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>)</span><br><span class="line">            preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HuffmanTree huffmanTree = <span class="keyword">new</span> HuffmanTree();</span><br><span class="line">        <span class="keyword">int</span>[] a =<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        huffmanTree.preOrder(huffmanTree.createHuffmanTree(a));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - node.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、赫夫曼编码"><a href="#3、赫夫曼编码" class="headerlink" title="3、赫夫曼编码"></a>3、赫夫曼编码</h2><p><strong>概念</strong></p><ol><li>赫夫曼编码是一种编码方式, <code>属于一种程序算法</code></li><li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li><li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间</li><li>赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</li></ol><p><strong>分析</strong>：</p><ul><li><p><strong>通信领域中信息的处理方式1-定长编码</strong></p><p>i like like like java do you like a java       // 共40个字符(包括空格，空格ASCII编码是32)  </p><p>105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121</p><p>111 117 32 108 105 107 101 32 97 32 106 97 118 97  //对应Ascii码</p><p>如果按照二进制来传递信息，总的长度是  359   (包括空格)</p></li><li><p><strong>通信领域中信息的处理方式2-变长编码</strong></p><p>给各个字符规定的编码，如上述定义规则</p><p>​            0=  ,  1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d</p><p>​            原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推</p><p>这样传输的时候，编码就是：</p><p>​            10010110100…  </p><p>字符的编码都不能是其他字符编码的前缀，不然有<code>多义性</code>，符合此要求的编码叫做<code>前缀编码</code></p></li><li><p><strong>通信领域中信息的处理方式3-赫夫曼编码</strong></p><ol><li><p>i like like like java do you like a java       // 共40个字符(包括空格)</p></li><li><p>d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  // 各个字符对应的个数</p></li><li><p>按照上面字符出现的次数构建一颗赫夫曼树, <code>次数作为权值</code>，</p></li><li><p>根据赫夫曼树，向左的定义为0，向右的为1，<code>路径作为编码</code>，最终结果作为根</p></li><li><p>“i like like like java do you like a java”   字符串对应的编码只有133位：</p><p>1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</p><p>原来长度是  359 , 压缩了  (359-133) / 359 = 62.9%</p></li></ol></li></ul><p><strong>优点：</strong></p><ul><li>赫夫曼编码任何一个编码都不是其他编码的前缀，因为都为<code>叶子节点</code></li><li>最终结果作为根，所以权越大，离根越近，次数越少，越节约资源</li></ul><h2 id="4、赫夫曼编码压缩字符串"><a href="#4、赫夫曼编码压缩字符串" class="headerlink" title="4、赫夫曼编码压缩字符串"></a>4、赫夫曼编码压缩字符串</h2><h3 id="4-1、压缩"><a href="#4-1、压缩" class="headerlink" title="4.1、压缩"></a>4.1、压缩</h3><p><strong>生成节点，每个节点对应一个编码</strong></p><ol><li>创建TreeNode节点，节点内含有对应的哈夫曼编码，权重，值</li><li>字符串一个一个字符的遍历，把出现的字符放在map的key里，次数放在value里面</li><li>根据key和value就能创建节点了，把这些节点放进List集合里面</li></ol><p><strong>根据节点，求出编码</strong></p><ol><li>按照前面方法构造哈夫曼树</li><li>从根节点开始，左子节点等于自己节点的编码值加上 0 ，右子节点则为1，不断递归，这样最终叶子节点就会由对应的编码</li><li>根据编码把字符串转换成<code>编码化的字符串</code></li></ol><p><strong>编码压缩</strong></p><ol><li>定义 str ，str每次等于<code>编码化的字符串</code>的8个字符</li><li>Integer.parseInt(str,2);  调用此方法就可以获得二进制转成的字节</li><li>依次进行获得字节数组</li><li>此时，压缩已经完成</li></ol><h3 id="4-2、解压缩"><a href="#4-2、解压缩" class="headerlink" title="4.2、解压缩"></a>4.2、解压缩</h3><ol><li><p>把字节数组转换成二进制，然后变换成字符串</p><ul><li><p>如何字节的值小于0，就需要截取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = (Integer.toBinaryString(bytes[i] | 256)).substring(1);</span><br></pre></td></tr></table></figure></li><li><p>如果字符串的值大于0，就需要补位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = (Integer.toBinaryString(bytes[i] | <span class="number">256</span>)).substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是最后一位，就不需要补</span></span><br><span class="line">str = Integer.toBinaryString(bytes[i]);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>把字符串拼接起来，对准哈夫曼表变成原字符串</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Compress</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字符，哈夫曼编码对照表，抽出来便于使用</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入字符串，返回对象数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">statistics</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这个map存储了字符出现的次数</span></span><br><span class="line">        Map&lt;String,Integer&gt; numsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 一个一个字符的遍历，如果key存在,那么久让对应的值加1，不存就就存进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            s = str.substring(i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (numsMap.containsKey(s))&#123;</span><br><span class="line">                numsMap.put(s, numsMap.get(s)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                numsMap.put(s, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据map的数据，创建对应的TreeNode节点，便于之后的生成哈夫曼树</span></span><br><span class="line">        numsMap.keySet().forEach((m) -&gt; &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> TreeNode(m,numsMap.get(m)));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成哈夫曼树，返回哈夫曼树的头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">toHuffmanTree</span><span class="params">(List&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 先排序</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            <span class="comment">// 创建节点</span></span><br><span class="line">            TreeNode leftNode = list.get(<span class="number">0</span>);</span><br><span class="line">            TreeNode rightNode = list.get(<span class="number">1</span>);</span><br><span class="line">            TreeNode parent = <span class="keyword">new</span> TreeNode(leftNode.value+rightNode.value);</span><br><span class="line">            <span class="comment">// 处理关系</span></span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">// 移除集合的，因为已经通过左右子树关联了</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">            list.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);   <span class="comment">// 获得根节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据头结点遍历，为最后的叶子节点设置编码，并且叶子节点会存入list</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCode</span><span class="params">(TreeNode node,List&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            node.left.code = node.code + <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            getCode(node.left,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            node.right.code = node.code + <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            getCode(node.right,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="keyword">null</span> &amp;&amp; node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list集合内有所有的叶子节点，根据数据生成哈夫曼编码表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createHuffmanTable</span><span class="params">(List&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; huffmanMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        list.forEach((l)-&gt;&#123;</span><br><span class="line">            huffmanMap.put(l.ch, l.code);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.map = huffmanMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把正常的字符串，通过哈夫曼表来压缩，转换成字符数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] zip(String str)&#123;</span><br><span class="line">        <span class="comment">// result为二进制字符串</span></span><br><span class="line">        StringBuffer result= <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            result.append(map.get(str.substring(i,i+<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = (result.length() + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// 创建一个bytes数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] by = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 记录是第几个byte</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length(); i += <span class="number">8</span>) &#123; <span class="comment">// 每8位</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; result.length()) &#123;</span><br><span class="line">                strByte = result.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = result.substring(i,i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将strByte转换成一个byte,参数2表示字符串是以是2进制存储的</span></span><br><span class="line">            by[index] = (<span class="keyword">byte</span>) Integer.parseInt(strByte,<span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> by;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把压缩的步骤封装成方法：实现输入字符串，转成字符数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] seal(String str)&#123;</span><br><span class="line">        <span class="comment">// 获得存有字符和出现次数的数组对象</span></span><br><span class="line">        List&lt;TreeNode&gt; list = statistics(str);</span><br><span class="line">        <span class="comment">// 用于存放转换后的结果</span></span><br><span class="line">        List&lt;TreeNode&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 转成哈夫曼树，返回的是头结点</span></span><br><span class="line">        TreeNode treeNode = toHuffmanTree(list);</span><br><span class="line">        <span class="comment">// 根据头结点遍历哈夫曼树获得所有字符的编码</span></span><br><span class="line">        getCode(treeNode,result);</span><br><span class="line">        <span class="comment">// 获得字符和哈弗曼编码的一一对应表</span></span><br><span class="line">        createHuffmanTable(result);</span><br><span class="line">        <span class="comment">// 转换后的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = zip(str);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩，返回二进制字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toBinaryStr</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果大于0就需要补位</span></span><br><span class="line">            <span class="keyword">if</span> (bytes[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 最后一位不需要补位</span></span><br><span class="line">                <span class="keyword">if</span> (i==bytes.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 如果是最后一位，无序补高位</span></span><br><span class="line">                    str = Integer.toBinaryString(bytes[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    str = (Integer.toBinaryString(bytes[i] | <span class="number">256</span>)).substring(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 如果小于0，就要截取，同时不需要补位</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                str = Integer.toBinaryString(bytes[i]);</span><br><span class="line">                str = str.substring(str.length()-<span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不断添加数据</span></span><br><span class="line">            stringBuffer.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(stringBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据二进制字符串和 哈夫曼map表转换成原字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        String result= <span class="string">&quot;&quot;</span>; <span class="comment">// 存储结果</span></span><br><span class="line">        String temp = <span class="string">&quot;&quot;</span>;  <span class="comment">// 存储中间遍历</span></span><br><span class="line">        Map&lt;String,String&gt; reverseMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 反转map的值和value</span></span><br><span class="line">        map.entrySet().forEach((m)-&gt;&#123;</span><br><span class="line">            String key = m.getKey();</span><br><span class="line">            String value = m.getValue();</span><br><span class="line">            reverseMap.remove(key);</span><br><span class="line">            reverseMap.put(value,key);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">while</span> (str.length()!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 每次取出前i个数遍历，如果符合就把result加上并把str删去</span></span><br><span class="line">                temp = str.substring(<span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">if</span> ( reverseMap.containsKey(str.substring(<span class="number">0</span>, i))) &#123;</span><br><span class="line">                    result = result +  reverseMap.get(temp);</span><br><span class="line">                    str = str.substring(i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 封装成解压缩方法：输入字符数组，转换成正常字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uZip</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(toBinaryStr(bytes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Compress compress = <span class="keyword">new</span> Compress();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = compress.seal(<span class="string">&quot;i like like like java do you like a java&quot;</span>);</span><br><span class="line">        System.out.println(compress.uZip(bytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">TreeNode</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String ch;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="keyword">public</span> String code=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(String ch, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ch = ch;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;TreeNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;ch=&#x27;&quot;</span> + ch + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&quot;, code=&#x27;&quot;</span> + code + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法Java版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法(六):二叉树</title>
      <link href="/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E5%85%AD%20)%20%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E5%85%AD%20)%20%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="1、二叉树"><a href="#1、二叉树" class="headerlink" title="1、二叉树"></a>1、二叉树</h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><p><strong>树的名词</strong></p><p>节点、根节点（最上面的节点）、父节点、子节点、叶子节点 (没有子节点的节点)、节点的权(节点值)<br>路径(从root根节点找到该节点的路线)、层（同一层）<br>子树、树的高度(最大层数)、森林 :多颗子树构成森林</p><p><strong>二叉树特点：</strong></p><ul><li><p>最多只能有两个子节点，左右子树颠倒就是不同的二叉树</p></li><li><p>叶子结点的数等于度为2的节点数加1</p></li><li><p>非空二叉树第k层至多有2^(k-1)个节点</p></li></ul><p><strong>分类：</strong></p><ul><li>满二叉树：完全二叉树把底部补满就是满二叉树</li><li>完全二叉树：注意必须先有左子节点，再有右子节点</li><li>二叉排序树</li><li>平衡二叉树</li></ul><h3 id="1-2、前、中、后遍历"><a href="#1-2、前、中、后遍历" class="headerlink" title="1.2、前、中、后遍历"></a>1.2、前、中、后遍历</h3><ol><li>前序遍历: 先输出父节点，再遍历左子树和右子树</li><li>中序遍历: 先遍历左子树，再输出父节点，再遍历右子树</li><li>后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点</li></ol><p><strong>小结: 看输出父节点的顺序，就确定是前序，中序还是后序</strong></p><p>代码中表现形式，输出父节点就用输出自己</p><ul><li>节点定义以及遍历方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>树定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  下面有三个方法直接调用节点里的方法，这里省略</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><ul><li>测试代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个二叉树</span></span><br><span class="line">    BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">    Node root = <span class="keyword">new</span> Node(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">    Node node1 = <span class="keyword">new</span> Node(<span class="number">2</span>,<span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">    Node node2 = <span class="keyword">new</span> Node(<span class="number">3</span>,<span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">    Node node3 = <span class="keyword">new</span> Node(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先手动创建二叉树，后面递归创建</span></span><br><span class="line">    root.left = node1;</span><br><span class="line">    root.right = node2;</span><br><span class="line">    node2.right = node3;</span><br><span class="line">    binaryTree.setRoot(root);</span><br><span class="line">    binaryTree.preOrder();  <span class="comment">// 前序遍历，1、2、3、4</span></span><br><span class="line">    binaryTree.infixOrder(); <span class="comment">// 中序遍历 2、 1 、3 、4</span></span><br><span class="line">    binaryTree.postOrder(); <span class="comment">//  后序遍历 2 、 4、 1、 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3、前、中、后序查找"><a href="#1-3、前、中、后序查找" class="headerlink" title="1.3、前、中、后序查找"></a>1.3、前、中、后序查找</h3><ul><li>其他查找变换3块代码的位置即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">preSearch</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.id==id)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断左子节点</span></span><br><span class="line">    Node resNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        resNode = left.preSearch(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 值不为null就说明已经找到了</span></span><br><span class="line">    <span class="keyword">if</span> (resNode!= <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断右子节点</span></span><br><span class="line">    <span class="keyword">if</span> (right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        resNode = right.preSearch(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resNode!= <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序查找,可以直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">infixSearch</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> left.infixSearch(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.id == id)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断右子节点</span></span><br><span class="line">    <span class="keyword">if</span> (right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> right.infixSearch(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除节点</strong></p><p><strong>规则：</strong></p><ul><li>如果删除的节点是叶子节点，则删除该节点</li><li>如果删除的节点是非叶子节点，则删除该子树</li></ul><p><strong>思路：</strong></p><ol><li>因为是单向的，所以节点不能自我删除，所以<code>必须通过父节点</code>来删除子节点，</li><li>先依次判断左右子树是否符合表，符合就把左右子树设置为null，否则递归左右子树</li></ol><ul><li><strong>节点</strong>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为null是必须的</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.id == id )&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.id == id )&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.delNode(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.delNode(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历到最后如果为空，不满足上面条件就会退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>树方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 根节点的情况要特殊讨论</span></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空树无法删除&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (root.id==id)&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        root.delNode(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4、顺序存储二叉树及层次遍历"><a href="#1-4、顺序存储二叉树及层次遍历" class="headerlink" title="1.4、顺序存储二叉树及层次遍历"></a>1.4、顺序存储二叉树及层次遍历</h3><p><strong>概念</strong></p><ol><li>数组存储方式和树的存储方式可以相互转换，数组可以转换成树，树也可以转换成数组</li><li>顺序存储就是把二叉树从根节点按照每一次从左往右的方式存储</li></ol><p><strong>特点</strong></p><ul><li>顺序二叉树通常<code>只考虑完全二叉树</code>（不要求满二叉树）</li><li>第n个元素的左子节点为  2 * n + 1               </li><li>第n个元素的右子节点为  2 * n + 2</li><li>第n个元素的父节点为  (n-1) / 2</li><li>n : 表示二叉树中的第几个元素(<code>按0开始</code>编号)</li></ul><p><strong>步骤：</strong></p><ol><li>从根节点也就是0开始arr[0]作为树的根节点</li><li>递归的创建左子节点和右子节点</li></ol><p><strong>层次遍历（可以获得把二叉树变成数组，这里只是遍历）</strong></p><ul><li>使用linkedlist代替队列使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkedList&lt;Node&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!list.isEmpty())&#123;</span><br><span class="line">        list = getNextFloor(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> LinkedList&lt;Node&gt; <span class="title">getNextFloor</span><span class="params">(LinkedList&lt;Node&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 输出当前层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Node&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!list.isEmpty())&#123;</span><br><span class="line">        Node temp = list.removeFirst();</span><br><span class="line">        <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            result.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            result.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>根据数组前序构建二叉树</strong></p><ul><li>节点方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据数组还原出二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTree</span><span class="params">(Node node,<span class="keyword">int</span> arr[],<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    Node leftNode = <span class="keyword">new</span> Node(arr[index],<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    Node rightNode = <span class="keyword">new</span> Node(arr[index + <span class="number">1</span>],<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    node.left = leftNode;</span><br><span class="line">    node.right = rightNode;</span><br><span class="line">    <span class="keyword">if</span>((index *<span class="number">2</span> + <span class="number">1</span>)&lt;arr.length) &#123;</span><br><span class="line">        leftNode.createTree(leftNode,arr,index *<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((index *<span class="number">2</span> + <span class="number">3</span>)&lt;arr.length) &#123;</span><br><span class="line">        rightNode.createTree(rightNode,arr,index *<span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>树方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">creatTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    Node root = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;根节点&quot;</span>);</span><br><span class="line">    root.createTree(root,arr,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>根据数组遍历二叉树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出当前的数</span></span><br><span class="line">        System.out.println(arr[index]);</span><br><span class="line">        <span class="comment">// 向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (( index * <span class="number">2</span> + <span class="number">1</span>)&lt; arr.length) &#123;</span><br><span class="line">            preOrder(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (( index * <span class="number">2</span> + <span class="number">2</span>)&lt; arr.length) &#123;</span><br><span class="line">            preOrder(index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5、线索化二叉树"><a href="#1-5、线索化二叉树" class="headerlink" title="1.5、线索化二叉树"></a>1.5、线索化二叉树</h3><blockquote><p>中序线索化二叉树</p></blockquote><p>​    二叉树的叶子结点总会有 左右指针，并没有完全的利用上.</p><p><strong>解决</strong></p><ul><li>给左右指针为空的，左指针指向前一个，右指针指向后一个结点</li></ul><p><strong>步骤：</strong></p><ul><li>记录一个pre表示每个节点的前一个节点，初始为空</li><li>若符合条件  <strong>本结点左指针指向pre，pre的右指针指向本节点</strong></li><li>对本节点操作完后，<code>必须把 pre 指向本节点</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> Node pre = <span class="keyword">null</span>; <span class="comment">// 辅助，指向前驱节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadedNodes(root);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 线索化的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线索化左子树</span></span><br><span class="line">        threadedNodes(node.left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 线索化本节点</span></span><br><span class="line">        <span class="comment">// 把左边的指向前一个节点，并标识为线索</span></span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            node.left = pre;</span><br><span class="line">            node.leftType = <span class="number">1</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 把前一个节点指向该节点，并标识为线索化</span></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            pre.right = node;</span><br><span class="line">            pre.rightType = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每处理一个节点后，让该节点成为下一个节点的前驱节点</span></span><br><span class="line">        pre = node;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//线索化右子树</span></span><br><span class="line">        threadedNodes(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadBinaryTree threadBinaryTree = <span class="keyword">new</span> ThreadBinaryTree();</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">3</span>,<span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">6</span>,<span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">8</span>,<span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">        Node node5 = <span class="keyword">new</span> Node(<span class="number">10</span>,<span class="string">&quot;李逵&quot;</span>);</span><br><span class="line">        Node node6 = <span class="keyword">new</span> Node(<span class="number">14</span>,<span class="string">&quot;关胜&quot;</span>);</span><br><span class="line">        <span class="comment">// 先手动创建二叉树，后面递归创建</span></span><br><span class="line">        root.left = node2;</span><br><span class="line">        root.right = node3;</span><br><span class="line">        node2.left = node4;</span><br><span class="line">        node2.right = node5;</span><br><span class="line">        node3.left = node6;</span><br><span class="line">        threadBinaryTree.setRoot(root);</span><br><span class="line">        threadBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">        System.out.println(node5.left);</span><br><span class="line">        System.out.println(node5.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node节点和上述一样，不过新增两个字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标识节点是线索化的还是子树，1表示线索化了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> leftType;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> rightType;</span><br></pre></td></tr></table></figure><p><strong>遍历</strong></p><ol><li>先直到最左下角的结点，即左子树为空，然后输出</li><li>接着若右子树为空就一直输出线索化右子树</li><li>直到右子树存在，转到右子树重新循环</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node temp = root;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 找到leftType为1的节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.leftType==<span class="number">0</span>)&#123;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出循环之后</span></span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        <span class="comment">// 如果右指针指向后继节点就一直输出</span></span><br><span class="line">        <span class="keyword">while</span> (temp.rightType==<span class="number">1</span>)&#123;</span><br><span class="line">            temp = temp.right;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换temp</span></span><br><span class="line">        temp = temp.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前序线索化二叉树及遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索化前序二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadPreOrderTree</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  线索化当前结点</span></span><br><span class="line">    <span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>)&#123;</span><br><span class="line">        node.setLeft(pre);</span><br><span class="line">        node.setLeftType(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>)&#123;</span><br><span class="line">        pre.setRight(node);</span><br><span class="line">        pre.setRightType(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//!!!!!</span></span><br><span class="line">    pre = node;</span><br><span class="line">    <span class="comment">//线索化左子树，多了判断</span></span><br><span class="line">    <span class="keyword">if</span>(node.getLeftType() == <span class="number">0</span>)&#123;</span><br><span class="line">        threadPreOrderTree(node.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线索化右子树</span></span><br><span class="line">    <span class="keyword">if</span>(node.getRightType() == <span class="number">0</span>)&#123;</span><br><span class="line">        threadPreOrderTree(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从根节点开始输出</li><li>一值输出左子节点，直到遇到线索化的节点</li><li>转到右子树继续循环</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历前序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadPreOrderList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node node = root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 只要有左子节点，就一直往左子节点输出</span></span><br><span class="line">        <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            node = node.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把没有左子节点的那个节点输出</span></span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        <span class="comment">// 找到右子树</span></span><br><span class="line">        node = node.getRight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索化后序二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadPostOrderTree</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线索化左子树</span></span><br><span class="line">    threadPostOrderTree(node.getLeft());</span><br><span class="line">    <span class="comment">//线索化右子树</span></span><br><span class="line">    threadPostOrderTree(node.getRight());</span><br><span class="line">    <span class="comment">//线索化当前结点</span></span><br><span class="line">    <span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>)&#123;</span><br><span class="line">        node.setLeft(pre);</span><br><span class="line">        node.setLeftType(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>)&#123;</span><br><span class="line">        pre.setRight(node);</span><br><span class="line">        pre.setRightType(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//!!!</span></span><br><span class="line">    pre = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历后序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadPostOrderList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node node = root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> &amp;&amp; node.getLeftType() == <span class="number">0</span>)&#123;</span><br><span class="line">        node = node.getLeft();<span class="comment">//从最左结点开始遍历</span></span><br><span class="line">    &#125;    </span><br><span class="line"><span class="comment">//退出循环，得到最左结点</span></span><br><span class="line">    <span class="comment">//从最左结点，开始遍历</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//输出全部 后缀结点</span></span><br><span class="line">        <span class="keyword">if</span>(node.getRightType() == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            pre = node;</span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;<span class="comment">//上一次的后缀结点输出完毕，在此开始判断是否输出 前驱</span></span><br><span class="line">            <span class="keyword">if</span>(node.getRight() == pre)&#123;</span><br><span class="line">                <span class="comment">//上个处理的节点是当前结点的右节点,即当前结点是 父结点</span></span><br><span class="line">                System.out.println(node);</span><br><span class="line">                <span class="keyword">if</span>(node == root)&#123;<span class="comment">//如果父结点是根节点，则遍历结束</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = node;</span><br><span class="line">                node = node.getParent();</span><br><span class="line">                <span class="comment">// 此时本父结点的左右子树已经遍历完毕，回到上一层(可参考根节点进行思考)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//相当于回到了root节点，开始遍历右子树,从右子树的最左结点开始往上</span></span><br><span class="line">                node = node.getRight();</span><br><span class="line">                <span class="keyword">while</span> (node != <span class="keyword">null</span> &amp;&amp; node.getLeftType() == <span class="number">0</span>)&#123;</span><br><span class="line">                    node = node.getLeft();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="2、二叉排序树"><a href="#2、二叉排序树" class="headerlink" title="2、二叉排序树"></a>2、二叉排序树</h2><h3 id="2-1、概念"><a href="#2-1、概念" class="headerlink" title="2.1、概念"></a>2.1、概念</h3><ul><li>二叉排序树的任何一个<code>非叶子节点</code>，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</li><li>如果有相同的值，可以将该节点放在左子节点或右子节点</li><li>对二叉排序树进行<code>中序遍历</code>，即可获得从小到大的顺序的值</li></ul><h3 id="2-2、创建和添加节点"><a href="#2-2、创建和添加节点" class="headerlink" title="2.2、创建和添加节点"></a>2.2、创建和添加节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">// 添加节点，注意添加后为叶子节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">7</span> ,<span class="number">3</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="comment">// 添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要添加的值更小就往左添加</span></span><br><span class="line">        <span class="keyword">if</span> (node.value&gt;<span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 要添加的值更大就往左添加</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、删除节点"><a href="#2-3、删除节点" class="headerlink" title="2.3、删除节点"></a>2.3、删除节点</h3><p><strong>情况：</strong></p><ol><li>删除叶子节点 </li><li>删除只有一颗子树的节点</li><li>删除有两颗子树的节点</li></ol><p><strong>节点内增加方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找要删除节点的父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果子节点为node，那么返回当前节点</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value==value) || (<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp;<span class="keyword">this</span>.right.value==value))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 如果当前节点值更小，说明值位于当前节点的右子节点，向右递归</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.value &lt; value )&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);</span><br><span class="line">        <span class="comment">// 反之向左递归</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据值来查找要删除的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchSelf</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.value==value)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value&lt;<span class="keyword">this</span>.value )&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.left.searchSelf(value);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.right.searchSelf(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>树类方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    Node target = node;</span><br><span class="line">    <span class="comment">// 循环查找左节点，找到最小值</span></span><br><span class="line">    <span class="keyword">while</span> (target.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        target = target.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有左子节点的话，就是把自己替换</span></span><br><span class="line">    <span class="comment">// 此时 target就删除了最小节点</span></span><br><span class="line">    del(target.value);</span><br><span class="line">    <span class="keyword">return</span> target.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        Node node = searchSelf(value);</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到父节点</span></span><br><span class="line">        Node parent = searchParent(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点不为null，</span></span><br><span class="line">        <span class="comment">// 第一种情况，为叶子节点,父节点指向子节点置为空即可</span></span><br><span class="line">        <span class="keyword">if</span> (node.right==<span class="keyword">null</span> &amp;&amp; node.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right == node) &#123;</span><br><span class="line">                parent.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 第2种情况，有两个子树，</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node.right!=<span class="keyword">null</span> &amp;&amp; node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = delRightTreeMin(node.right);</span><br><span class="line">            node.value = min;</span><br><span class="line">        <span class="comment">// 第3种情况，只有一个子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3.1 删除的节点只有右子节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(parent!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent.right == node) &#123;</span><br><span class="line">                        parent.right = node.left;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        parent.left = node.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    root = node.left;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 3.2 删除的节点只有左子节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(parent!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent.right == node) &#123;</span><br><span class="line">                        parent.right = node.right;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        parent.left = node.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    root = node.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、二叉平衡树（前提是排序树）"><a href="#3、二叉平衡树（前提是排序树）" class="headerlink" title="3、二叉平衡树（前提是排序树）"></a>3、二叉平衡树（前提是排序树）</h2><h3 id="3-1、概念"><a href="#3-1、概念" class="headerlink" title="3.1、概念"></a>3.1、概念</h3><ul><li>平衡二叉树也叫平衡二叉搜索树又被称为AVL树， 可以保证查询效率较高。</li><li>它是一 棵<code>空树</code>或它的<code>左右两个子树的高度差的绝对值不超过1</code>，并且左右两个子树都是一棵平衡二叉树。</li><li>平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</li></ul><h3 id="3-2、创建"><a href="#3-2、创建" class="headerlink" title="3.2、创建"></a>3.2、创建</h3><p><strong>思路：</strong></p><ol><li>按照前面创建二叉排序树的方式创建</li><li>如果二叉树不平衡了，就需要通过旋转来调整</li></ol><p><strong>分类：</strong>AVL树的旋转类型有4种， 分别是LL(left-left)旋转、LR(left-right)旋转、RR(right-right)旋转和RL(right-left)旋转。</p><blockquote><p>LL旋转</p></blockquote><p><img src="/img/structure/4.jpg"></p><blockquote><p>LR旋转</p></blockquote><p><img src="/img/structure/5.jpg"></p><blockquote><p>RR旋转</p></blockquote><p><img src="/img/structure/6.jpg"></p><blockquote><p>RL旋转</p></blockquote><p><img src="/img/structure/7.jpg"></p><h3 id="3-3、红黑树"><a href="#3-3、红黑树" class="headerlink" title="3.3、红黑树"></a>3.3、红黑树</h3><p>红黑树是一种自平衡的二叉查找树，它不是严格控制左、右子树高度或节点数之差小于等于1。</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong>即如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li></ul><p>性质4导致一条路至少有一般是黑的，所以，根到叶子的最长的可能路径不多于最短的可能路径的两倍长，即。但红黑树高度依然是平均log(n),且最坏情况高度不会超过2log(n),。</p><blockquote><p>红黑树能自平衡，它靠的是什么</p></blockquote><p><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。</p><p><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。</p><p><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</p><h2 id="4、多叉树"><a href="#4、多叉树" class="headerlink" title="4、多叉树"></a>4、多叉树</h2><h3 id="4-1、概念"><a href="#4-1、概念" class="headerlink" title="4.1、概念"></a>4.1、概念</h3><ul><li>如果允许每个节点可以有2个以上的数据项和更多的子节点，就是多叉树（multiway tree）</li><li>多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。</li></ul><h3 id="4-2、B树"><a href="#4-2、B树" class="headerlink" title="4.2、B树"></a>4.2、B树</h3><blockquote><p>设计B树的理由</p></blockquote><ol><li>文件系统及数据库系统的设计者利用了磁盘预读原理，<code>将一个节点的大小设为等于一个页</code>(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入将树的度M设置为1024（节点最多含有1024个子节点）</li><li>在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中</li></ol><p><strong>概念：</strong>B树也称B-树,它是一颗多路平衡查找树。B树的设计就是为了增加每个节点存储的数据，降低高度从而减少 IO 次数。</p><ul><li>用m表示 B 树的阶数，则B的一个节点最多有 m 个子节点</li><li>每个节点最多有m-1个<strong>关键字</strong>（可以存有的键值对）。</li><li>根节点最少可以只有1个<strong>关键字</strong>，非根节点至少有m/2个<strong>关键字</strong>。</li><li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li><li>每个节点都存有索引和数据，也就是对应的key和value</li></ul><p>所以，根节点的<strong>关键字</strong>数量范围：<code>1 &lt;= k &lt;= m-1</code>，非根节点的<strong>关键字</strong>数量范围：<code>m/2 &lt;= k &lt;= m-1</code>。</p><h3 id="4-3、B-树"><a href="#4-3、B-树" class="headerlink" title="4.3、B+ 树"></a>4.3、B+ 树</h3><p>B+树其实和B树是非常相似的，我们首先看看<strong>相同点</strong>。</p><ul><li>根节点至少一个元素： 1 &lt;= k &lt;= m-1</li><li>非根节点元素范围：m/2 &lt;= k &lt;= m-1</li></ul><p><strong>不同点</strong>。</p><ul><li><p>B+树只有叶子节点存储数据，叶子节点之间通过链表连接；内部节点只存索引，父节点存有右孩子的第一个元素的索引。</p></li><li><p>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</p></li></ul><p><img src="/img/structure/8.jpg"></p><blockquote><p>总结</p></blockquote><p><strong>B树：</strong>B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速</p><p><strong>B+ 树：</strong>所有的叶子结点使用链表相连，<strong>便于区间查找和遍历</strong>。B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。b+树的中间节点不保存数据，能容纳更多节点元素。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法Java版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法(五):哈希表</title>
      <link href="/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E4%BA%94%20)%20%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E4%BA%94%20)%20%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><ul><li><strong>散列表（Hash table，也叫哈希表）</strong>，是根据关键码值(Key value)而直接进行访问的数据结构。</li><li>也就是说，它通过把<strong>关键码值映射到表中一个位置</strong>来访问记录，以加快查找的速度。</li><li>这个映射函数叫做<code>散列函数</code>，存放记录的<code>数组叫做散列表</code>。</li></ul><p><strong>散列函数几种情况</strong></p><ul><li>直接地址法：  H(key) = a * key + b</li><li>除留余数法      H(key) = key % b</li><li>平方取中法     </li><li>数字分析法</li></ul><p><strong>哈希冲突解决办法：多个字段通过哈希函数映射的结果一致</strong></p><ul><li>链表法：  </li><li>开放地址法：<ul><li>线性探测法： Hi = ( H(key) + d ) % m</li><li>平方探测法：即d = 平方</li><li>再散列法：</li></ul></li></ul><h2 id="2、分析"><a href="#2、分析" class="headerlink" title="2、分析"></a>2、分析</h2><p>有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的id时,要求查找到该员工的 所有信息.<br>要求: 不使用数据库,尽量节省内存,速度越快越好=&gt;哈希表(散列)</p><ol><li>把员工信息放在一个类中，该类同时作为链表的一个节点</li><li>定义哈希表，用数组存储上述描述的链表，自定义哈希函数，实现id对数组位置的映射。</li><li>通过控制台测试功能</li></ol><h2 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h2><ul><li>Emp实体类（链表结点）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Emp next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Emp&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&quot;</span> + name +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>链表结构</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头指针</span></span><br><span class="line">    <span class="keyword">private</span> Emp head;</span><br><span class="line">    <span class="comment">// 添加雇员到链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Emp temp = head;</span><br><span class="line">            <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.next = emp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过删除员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有查询到该员工信息,可能已经删除!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.getId()==id)&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">                System.out.println(<span class="string">&quot;删除成功!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Emp temp = head;</span><br><span class="line">                <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(temp.next.getId()==id)&#123;</span><br><span class="line">                        temp.next = temp.next.next;</span><br><span class="line">                        System.out.println(<span class="string">&quot;删除成功!&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有查询到该员工信息,可能已经删除!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Emp emp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有查询到该员工信息,无法更新!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.getId()==emp.getId())&#123;</span><br><span class="line">                emp.next = head.next;</span><br><span class="line">                head = emp;</span><br><span class="line">                System.out.println(<span class="string">&quot;修改成功!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Emp temp = head;</span><br><span class="line">                <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(temp.next.getId()==emp.getId())&#123;</span><br><span class="line">                        emp.next = temp.next.next;</span><br><span class="line">                        temp.next = emp;</span><br><span class="line">                        System.out.println(<span class="string">&quot;没有查询到该员工信息,无法更新!&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有查询到该员工信息,无法更新!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;条数据无信息&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;条:&quot;</span>);</span><br><span class="line">            Emp temp = head;</span><br><span class="line">            <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.print(temp);</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据id显示员工信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不存在该员工信息&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Emp temp = head;</span><br><span class="line">            <span class="keyword">while</span> (temp.getId()!=id)&#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">                <span class="keyword">if</span> (temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;不存在该员工信息&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>哈希表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理多条链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedLists;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashTable</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.empLinkedLists = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line">        <span class="comment">// 不要忘了初始化每一条链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedLists[i] = <span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 根据员工id，判断应该加入哪一条链表</span></span><br><span class="line">        empLinkedLists[hashFun(emp.getId())].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过id查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = hashFun(id);</span><br><span class="line">        empLinkedLists[num].findEmpById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过id删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = hashFun(id);</span><br><span class="line">        empLinkedLists[num].delById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateById</span><span class="params">(Emp emp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = hashFun(emp.getId());</span><br><span class="line">        empLinkedLists[num].update(emp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历哈希变</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedLists[i].show(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义哈希函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>   <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyHashTable myHashTable = <span class="keyword">new</span> MyHashTable(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;========员 工 管 理 系 统========&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;           a:添加雇员           &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;           s:显示雇员           &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;           f:查找雇员           &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;           d:删除雇员           &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;           u:修改雇员           &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;           e:退出系统           &quot;</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入id&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入名字&quot;</span>);</span><br><span class="line">                    String name = scanner.next();</span><br><span class="line">                    Emp emp = <span class="keyword">new</span> Emp(id,name);</span><br><span class="line">                    myHashTable.add(emp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;d&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入id&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> empId1 = scanner.nextInt();</span><br><span class="line">                    myHashTable.delById(empId1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;f&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入id&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> empId2 = scanner.nextInt();</span><br><span class="line">                    myHashTable.findById(empId2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;u&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入id&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> empId3 = scanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入名字&quot;</span>);</span><br><span class="line">                    String empName = scanner.next();</span><br><span class="line">                    Emp emp2 = <span class="keyword">new</span> Emp(empId3,empName);</span><br><span class="line">                    myHashTable.updateById(emp2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;s&quot;</span>:</span><br><span class="line">                    myHashTable.show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;e&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法Java版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法(四):递归</title>
      <link href="/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E5%9B%9B%20)%20%E9%80%92%E5%BD%92%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E5%9B%9B%20)%20%E9%80%92%E5%BD%92%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><strong>基本概念：</strong></p><p>递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁</p><p><strong>递归调用规则：</strong></p><ol><li><p>当程序执行到一个方法时，就会开辟一个独立的空间(栈)</p></li><li><p>每个空间的数据(局部变量)，是独立的.</p></li></ol><h2 id="2、小案例"><a href="#2、小案例" class="headerlink" title="2、小案例"></a>2、小案例</h2><ul><li>循环打印直到2</li><li>阶乘</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环打印直到2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            test(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;n=&quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶乘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        System.out.println(factorial(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、递归规则"><a href="#3、递归规则" class="headerlink" title="3、递归规则"></a>3、递归规则</h2><ol><li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li><li>方法的局部变量是独立的，不会相互影响, 比如n变量</li><li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</li><li>递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)</li><li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li></ol><h2 id="4、迷宫问题"><a href="#4、迷宫问题" class="headerlink" title="4、迷宫问题"></a>4、迷宫问题</h2><ol><li>小球得到的路径，和程序员设置的找路策略有关即：找路的上下左右的顺序相关</li><li>再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化</li><li>测试回溯现象</li></ol><p><strong>思路：</strong></p><ol><li>小球在每一个点都按照<code>下右上左</code>的顺序走，走过的点设置为2，且走过的路不再走</li><li>如果过程中map[6] [5] 为2，那么表示该路到达了终点，返回true；</li><li>如果走到某一点上、下、左、右全部都走不通，或已经走过，那么表示找不到路</li><li>所以走的顺序就是，<code>一直往下走，走不了先往右，还是走不了就往上，还是不行再往左</code>，直到成功</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">// 使用1表示墙</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j]+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(setWay(map,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j]+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map指地图，i、j指开始的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                map[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 向下走</span></span><br><span class="line">                <span class="keyword">if</span> (setWay(map, i + <span class="number">1</span>, j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 向右走</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map,i, j+<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 向上走</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i - <span class="number">1</span>,j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 向左</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、八皇后问题"><a href="#5、八皇后问题" class="headerlink" title="5、八皇后问题"></a>5、八皇后问题</h2><p><strong>思路：</strong></p><ol><li>用数组表示棋盘，数组索引表示每一列，值表示皇后在该列的位置</li><li>把每次往数组中添加值当做放皇后，arr[0] 就是第一个皇后，值就是第一个皇后位置<ul><li>每次放皇后若成功，即arr[i] = value 且不与前面的冲突，则往后一列 arr[i+1] =0 并且往该列的下一个位置 arr[i] = value + 1 尝试；若失败，只往该列下一行尝试 arr[i] = value + 1</li><li>一直放到最后一行，可以依次判断最后一行的每个位置是否能放，如果能放就返回1，否则返回0</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightQueens</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断第j列的棋子能不能放下</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">success</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i == j || arr[i] == arr[j] || Math.abs(j - i) == Math.abs(arr[j] - arr[i]))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">allPos</span><span class="params">(<span class="keyword">int</span>[] queens,<span class="keyword">int</span> j, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; queens.length)&#123;</span><br><span class="line">            <span class="comment">// 先把当前位置放上皇后，然后判断</span></span><br><span class="line">            queens[j] = value;</span><br><span class="line">            <span class="keyword">if</span>(value &lt; queens.length - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果值小于7，成功了，继续下一列和该列的下一行</span></span><br><span class="line">                <span class="keyword">if</span>(success(queens,j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> allPos(queens, j + <span class="number">1</span>, <span class="number">0</span>)+ allPos(queens,j,value+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 如果值小于7，失败了，继续该列的下一行</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> allPos(queens,j,value+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value == queens.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果值等于7，说明已经是该列的最后一个位置，成功了，继续下一列</span></span><br><span class="line">                <span class="keyword">if</span> (success(queens, j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> allPos(queens, j + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j== queens.length )&#123; <span class="comment">// 等于8说明已经放完了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 不符合要求返回0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        System.out.println(allPos(arr,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis()-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简化思路：</strong></p><ol><li>用数组表示棋盘，数组索引表示每一列，值表示皇后在该列的位置</li><li>每次判断防止第n个皇后，在第n列的8行能不能放下，如果可以，就去下一列继续判断</li><li>相比于上面，少了每列中的递归，抽成for循环了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue8</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义max表示一共有多少个皇后</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span>[] queues = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将皇后的位置打印</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queues.length; i++) &#123;</span><br><span class="line">            System.out.println(queues[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否冲突</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queues[i] == queues[n] || Math.abs(n-i) == Math.abs(queues[n] - queues[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == max)&#123;</span><br><span class="line">            <span class="comment">//print();</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前皇后</span></span><br><span class="line">            queues[n] = i;</span><br><span class="line">            <span class="comment">// 判断是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> (judge(n))&#123;</span><br><span class="line">                check(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue8 queue8 = <span class="keyword">new</span> Queue8();</span><br><span class="line">        queue8.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(queue8.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法Java版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法(三):稀疏矩阵</title>
      <link href="/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E4%B8%89%20)%20%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E4%B8%89%20)%20%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="1、基本介绍："><a href="#1、基本介绍：" class="headerlink" title="1、基本介绍："></a>1、基本介绍：</h2><p>当一个数组中大部分元素为<code>０</code>，或者为<code>同一个值</code>的数组时，可以使用稀疏数组来保存该数组</p><p><strong>处理方法:</strong></p><ol><li>记录数组一共有几行几列，有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而<code>缩小程序的规模</code></li></ol><img src="C:\Users\admin\Desktop\Java数据结构和算法\img\1.jpg" style="zoom:90%;" /><p><strong>二维数组转稀疏数组：</strong></p><ol><li>遍历二维数组，获取有效数据的个数sum</li><li>创建稀疏数组 sparseArr int[sum+1] [3] ,把有效数据存入</li></ol><p><strong>稀疏数组转二维数组</strong></p><ol><li>读取<code>第一行</code>（包括数组信息和），根据其创建二维数组，</li><li>读取后几行的数据，赋给原始的二维数组</li></ol><h2 id="2、代码实现："><a href="#2、代码实现：" class="headerlink" title="2、代码实现："></a>2、代码实现：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArr</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二维数组转稀疏矩阵，稀疏矩阵也是二维数组</span></span><br><span class="line">    <span class="comment">// 参数arr，传入的二维数组，sum不为0的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] toSparseArr(<span class="keyword">int</span>[][] arr,<span class="keyword">int</span> sum)&#123;</span><br><span class="line">        <span class="comment">// 创建稀疏矩阵，sum+1行，3列</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 稀疏矩阵第一行，存数组的信息</span></span><br><span class="line">        sparseArr[<span class="number">0</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;arr.length,arr[<span class="number">0</span>].length,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> flag= <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 稀疏数组把依次存数据的行，列和值</span></span><br><span class="line">                    <span class="comment">// 先flag 在++，arr[i][j]就是不为0的数</span></span><br><span class="line">                    sparseArr[flag++]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j,arr[i][j]&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sparseArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 稀疏矩阵转回二维数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] toArr(<span class="keyword">int</span>[][] sparseArr)&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 从第二行读取信息获得数的位置存入数组</span></span><br><span class="line">            arr[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建二维数组</span></span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = SparseArr.toSparseArr(arr,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row: sparseArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data: row) &#123;</span><br><span class="line">                System.out.print(data+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        arr = SparseArr.toArr(sparseArr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row: arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data: row) &#123;</span><br><span class="line">                System.out.print(data+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法Java版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法(二):栈</title>
      <link href="/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E4%BA%8C%20)%20%E6%A0%88%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E4%BA%8C%20)%20%E6%A0%88%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><strong>概念：</strong></p><ol><li>栈的英文为(stack)，栈是一个<code>先进后出(FILO-First In Last Out)</code>的有序列表。</li><li>栈(stack)是限制线性表中元素的插入和删除只能在线性表的<code>同一端进行</code>的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<code>栈顶(Top)</code>，另一端为固定的一端，称为栈底(Bottom)。</li><li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</li></ol><p><strong>应用场景</strong></p><ol><li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。     </li><li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li><li>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</li><li>二叉树的遍历。</li><li>图形的深度优先(depth一first)搜索法。</li></ol><h2 id="2、数组实现栈"><a href="#2、数组实现栈" class="headerlink" title="2、数组实现栈"></a>2、数组实现栈</h2><p><strong>实现思路：</strong></p><ol><li><p>使用数组来模拟栈</p></li><li><p>定义一个 <code>top  来表示栈顶</code>，初始化 为  -1</p></li><li><p> 入栈的操作，当有数据加入到栈时， top++;  stack[top] = data;</p></li><li><p>出栈的操作， int value = stack[top]; top–, return value</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;  <span class="comment">// 表示栈顶，栈只在栈顶操作数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经满了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.top--;</span><br><span class="line">        <span class="keyword">return</span> stack[top+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经空了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> flag = <span class="number">1</span>, i = top; i &gt;= <span class="number">0</span>; i-- ,flag++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+flag+<span class="string">&quot;个数：&quot;</span>+stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayStack arrayStack = <span class="keyword">new</span> ArrayStack(<span class="number">5</span>);</span><br><span class="line">        arrayStack.push(<span class="number">1</span>);</span><br><span class="line">        arrayStack.push(<span class="number">2</span>);</span><br><span class="line">        arrayStack.push(<span class="number">3</span>);</span><br><span class="line">        arrayStack.push(<span class="number">4</span>);</span><br><span class="line">        arrayStack.push(<span class="number">5</span>);</span><br><span class="line">        arrayStack.push(<span class="number">6</span>);</span><br><span class="line">        arrayStack.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(arrayStack.pop());</span><br><span class="line">            System.out.println(arrayStack.pop());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        arrayStack.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(arrayStack.pop());</span><br><span class="line">            System.out.println(arrayStack.pop());</span><br><span class="line">            System.out.println(arrayStack.pop());</span><br><span class="line">            System.out.println(arrayStack.pop());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        arrayStack.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="number">100</span>);</span><br><span class="line">        arrayStack.push(<span class="number">55</span>);</span><br><span class="line">        arrayStack.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、链表实现栈"><a href="#3、链表实现栈" class="headerlink" title="3、链表实现栈"></a>3、链表实现栈</h2><ul><li>链表的<code>头结点当做栈顶</code>，每次插入数据就是<code>头插法</code></li><li>缺点是查找节点数据更慢 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> Node top = <span class="keyword">new</span> Node(<span class="number">0</span>); <span class="comment">// 定义头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top.next==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        Node temp = top;</span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            flag++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag==maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 入栈，头插法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经满了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="keyword">if</span> (top.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            top.next =node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = top.next;</span><br><span class="line">            top.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = top.next.getNum();</span><br><span class="line">        top.next = top.next.next;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经空了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = top.next;</span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedListStack linkedListStack = <span class="keyword">new</span> LinkedListStack(<span class="number">5</span>);</span><br><span class="line">        linkedListStack.push(<span class="number">1</span>);</span><br><span class="line">        linkedListStack.push(<span class="number">2</span>);</span><br><span class="line">        linkedListStack.push(<span class="number">3</span>);</span><br><span class="line">        linkedListStack.push(<span class="number">4</span>);</span><br><span class="line">        linkedListStack.push(<span class="number">5</span>);</span><br><span class="line">        linkedListStack.push(<span class="number">6</span>);</span><br><span class="line">        linkedListStack.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        System.out.println(linkedListStack.pop());</span><br><span class="line">        System.out.println(linkedListStack.pop());</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        linkedListStack.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(linkedListStack.pop());</span><br><span class="line">            System.out.println(linkedListStack.pop());</span><br><span class="line">            System.out.println(linkedListStack.pop());</span><br><span class="line">            System.out.println(linkedListStack.pop());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;num=&quot;</span> + num +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、栈实现计算器（中缀表达式）"><a href="#4、栈实现计算器（中缀表达式）" class="headerlink" title="4、栈实现计算器（中缀表达式）"></a>4、栈实现计算器（中缀表达式）</h2><p><strong>思路：</strong></p><ol><li>通过一个 index  值（索引），来遍历我们的表达式</li><li>如果我们发现是一个数字, 就直接入数栈</li><li>如果发现扫描到是一个符号,  就分如下情况<ul><li>如果发现当前的符号栈为 空，就直接入栈</li><li>如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</li><li> 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符， 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，<code>将得到结果，入数栈，然后将当前的操作符入符号栈，</code></li></ul></li><li>当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</li><li>最后在数栈只有一个数字，就是表达式的结果</li></ol><p><strong>举例：</strong></p><ul><li> 3 + 2 * 6 - 2</li></ul><ol><li>3先入数栈，然后 + 入符号栈，接着 2 入数栈，因为 * 优先级大于 + ，所以 * 入符号栈，接着 6入数栈</li><li>此时数栈 6 2 3       符号栈  *  + </li><li>接着到 - 号，由于 - 号的优先级小于 * 所以，取出 6、 2 进行 * 运算，结果12放入数栈</li><li>此时数栈 12 3         符号栈 +   ，然后再把 - 入符号栈 ，此时数栈 12    3  ， 符号栈   -   +</li><li>接着把2 入栈 ，此时数栈    2 12    3  ， 符号栈   -   +</li><li>表达式扫描完成，取出数和符号运算，先计算 12 -2  得到 10 ，然后 3 + 10 等于 13， 把13放入数栈</li><li>得到结果13</li></ol><p>总结</p><ol><li>数字放数栈，字符放字符栈</li><li>保证放入的字符比栈顶的优先级大，否则就弹出两个数字和栈顶运算符运算后放回数栈，</li><li>继续比较字符和栈顶的优先级，要放入的更大就放入，不然重复步骤2</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经满了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.top--;</span><br><span class="line">        <span class="keyword">return</span> stack[top+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经空了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> flag = <span class="number">1</span>, i = top; i &gt;= <span class="number">0</span>; i-- ,flag++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+flag+<span class="string">&quot;个数：&quot;</span>+stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回栈顶的值，但不取出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回运算符的优先级</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oper == <span class="string">&#x27;+&#x27;</span> || oper == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//设置只有加减乘除</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否为运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val == <span class="string">&#x27;+&#x27;</span> ||val == <span class="string">&#x27;-&#x27;</span>|| val ==<span class="string">&#x27;*&#x27;</span>|| val == <span class="string">&#x27;/&#x27;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1 + num2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1 - num2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1 * num2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1 / num2;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//calculator1为数栈，calculator2为符号栈</span></span><br><span class="line">        Calculator calculator1 = <span class="keyword">new</span> Calculator(<span class="number">10</span>);</span><br><span class="line">        Calculator calculator2 = <span class="keyword">new</span> Calculator(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        String experssion = <span class="string">&quot;7+2*6-4&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="comment">// 不断遍历</span></span><br><span class="line">        <span class="keyword">while</span> (index!=experssion.length())&#123;</span><br><span class="line">            <span class="comment">// 得到每一个字符</span></span><br><span class="line">            ch = experssion.substring(index,index+<span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 如果是字符的话</span></span><br><span class="line">            <span class="keyword">if</span>(isOper(ch))&#123;</span><br><span class="line">                <span class="keyword">if</span> (calculator2.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">// 如果为空，直接push进制</span></span><br><span class="line">                    calculator2.push(ch);</span><br><span class="line">                    <span class="comment">// 如果当前字符优先级更低</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (priority(ch) &lt;= priority(calculator2.peek()))&#123;</span><br><span class="line">                    <span class="comment">// 依次取出2个数和操作符</span></span><br><span class="line">                    num1 = calculator1.pop();</span><br><span class="line">                    num2 = calculator1.pop();</span><br><span class="line">                    oper = calculator2.pop();</span><br><span class="line">                    <span class="comment">// 这里注意顺序应该是后取出的放在前面</span></span><br><span class="line">                    result = cal(num2,num1,oper); </span><br><span class="line">                    <span class="comment">// 结果放入数栈中</span></span><br><span class="line">                    calculator1.push(result);</span><br><span class="line">                    <span class="comment">// 当前操作符放入符号栈</span></span><br><span class="line">                    calculator2.push(ch);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    calculator2.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是数字就放入数栈中注意需要变成int类型</span></span><br><span class="line">                calculator1.push(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一直到字符栈为空</span></span><br><span class="line">        <span class="keyword">while</span> (!calculator2.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 取出两个数和一个运算符来比较</span></span><br><span class="line">            num1 = calculator1.pop();</span><br><span class="line">            num2 = calculator1.pop();</span><br><span class="line">            oper = calculator2.pop();</span><br><span class="line">            result = cal(num2,num1,oper);  <span class="comment">// 这里注意顺序</span></span><br><span class="line">            <span class="comment">// 放入结果</span></span><br><span class="line">            calculator1.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;表达式&quot;</span>+experssion+<span class="string">&quot;=&quot;</span>+calculator1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺陷：</p><ol><li>用一个字符来表示，如果数字时多位比如30，那么会认为是两个字符，出错</li></ol><p><strong>优化1：</strong>支持多位数运算</p><p>更改如果是数字之后的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 先加入到nums中</span></span><br><span class="line">    nums = nums + ch;</span><br><span class="line">    <span class="keyword">if</span> (index == experssion.length()-<span class="number">1</span>)&#123;</span><br><span class="line">        calculator1.push(Integer.parseInt(nums));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果下一位是运算符，就转换成int放入</span></span><br><span class="line">        <span class="keyword">if</span> (isOper(experssion.substring(index+<span class="number">1</span>, index + <span class="number">2</span>).charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">            calculator1.push(Integer.parseInt(nums));</span><br><span class="line">            nums = <span class="string">&quot;&quot;</span>;  <span class="comment">// 清空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化2</strong>：增加括号的处理</p><p><strong>思路：</strong></p><ol><li>把上面的步骤封装成方法</li><li>不断把括号里的内容计算出来，用结果替代原来的括号及内容，最终变成没有括号的表达式</li></ol><p><strong>把上面的步骤封装成方法</strong>：输入字符串，返回运算结果（不能含有括号）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal2</span><span class="params">(String experssion)</span></span>&#123;</span><br><span class="line">    <span class="comment">//calculator1为数栈，calculator2为符号栈</span></span><br><span class="line">    Calculator calculator1 = <span class="keyword">new</span> Calculator(<span class="number">10</span>);</span><br><span class="line">    Calculator calculator2 = <span class="keyword">new</span> Calculator(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> oper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    String nums = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 不断遍历</span></span><br><span class="line">    <span class="keyword">while</span> (index!=experssion.length())&#123;</span><br><span class="line">        <span class="comment">// 得到每一个字符</span></span><br><span class="line">        ch = experssion.substring(index,index+<span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果是字符的话</span></span><br><span class="line">        <span class="keyword">if</span>(isOper(ch))&#123;</span><br><span class="line">            <span class="keyword">if</span> (calculator2.isEmpty())&#123;</span><br><span class="line">                <span class="comment">// 如果为空，直接push进制</span></span><br><span class="line">                calculator2.push(ch);</span><br><span class="line">                <span class="comment">// 如果当前字符优先级更低</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (priority(ch) &lt;= priority(calculator2.peek()))&#123;</span><br><span class="line">                <span class="comment">// 依次取出2个数和操作符</span></span><br><span class="line">                num1 = calculator1.pop();</span><br><span class="line">                num2 = calculator1.pop();</span><br><span class="line">                oper = calculator2.pop();</span><br><span class="line">                <span class="comment">// 这里注意顺序应该是后取出的放在前面</span></span><br><span class="line">                result = cal(num2,num1,oper);</span><br><span class="line">                <span class="comment">// 结果放入数栈中</span></span><br><span class="line">                calculator1.push(result);</span><br><span class="line">                <span class="comment">// 当前操作符放入符号栈</span></span><br><span class="line">                calculator2.push(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                calculator2.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先加入到nums中</span></span><br><span class="line">            nums = nums + ch;</span><br><span class="line">            <span class="keyword">if</span> (index == experssion.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                calculator1.push(Integer.parseInt(nums));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果下一位是运算符，就转换成int放入</span></span><br><span class="line">                <span class="keyword">if</span> (isOper(experssion.substring(index+<span class="number">1</span>, index + <span class="number">2</span>).charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">                    calculator1.push(Integer.parseInt(nums));</span><br><span class="line">                    nums = <span class="string">&quot;&quot;</span>;  <span class="comment">// 清空</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一直到字符栈为空</span></span><br><span class="line">    <span class="keyword">while</span> (!calculator2.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 取出两个数和一个运算符来比较</span></span><br><span class="line">        num1 = calculator1.pop();</span><br><span class="line">        num2 = calculator1.pop();</span><br><span class="line">        oper = calculator2.pop();</span><br><span class="line">        result = cal(num2,num1,oper);  <span class="comment">// 这里注意顺序</span></span><br><span class="line">        <span class="comment">// 放入结果</span></span><br><span class="line">        calculator1.push(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> calculator1.pop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>去括号</strong>，运用递归的方式，每次去除一对括号（保证这里的括号内部没有括号）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">noBrackets</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">        <span class="comment">//  匹配最后一个 （ 和最后一个 ），保证中间没有括号</span></span><br><span class="line">        <span class="keyword">if</span> (ch==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            left = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            right = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果没发现括号，就退出递归</span></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把括号里的内容计算出来</span></span><br><span class="line">    String str2 = str.substring(left+<span class="number">1</span>,right);</span><br><span class="line">    <span class="keyword">int</span> result = cal2(str2);</span><br><span class="line">    <span class="comment">// 递归的方式，让他们不断的去去括号，每次递归去除一个括号</span></span><br><span class="line">    <span class="keyword">return</span> noBrackets(str.substring(<span class="number">0</span>,left)+String.valueOf(result)+str.substring(right+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;7*(2+(3-3))-(4+2)*5&quot;</span>;</span><br><span class="line">    System.out.println(noBrackets(str));</span><br><span class="line">    System.out.println(cal2(noBrackets(str)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果,可以看到括号被剔除了</span></span><br><span class="line"><span class="number">7</span>*<span class="number">2</span>-<span class="number">6</span>*<span class="number">5</span></span><br><span class="line">-<span class="number">16</span></span><br></pre></td></tr></table></figure><h2 id="5、前缀、后缀、中缀表达式"><a href="#5、前缀、后缀、中缀表达式" class="headerlink" title="5、前缀、后缀、中缀表达式"></a>5、前缀、后缀、中缀表达式</h2><p><strong>1、前缀表达式（波兰表达式）求值</strong></p><ul><li>从右至左扫描表达式，遇到数字时，将数字压入堆栈，</li><li>遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），结果入栈；</li><li>重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</li></ul><p>(3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 </p><ol><li>从右至左扫描，将6、5、4、3压入堆栈</li><li>遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈</li><li>接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈</li><li>最后是-运算符，计算出35-6的值，即29，由此得出最终结果</li></ol><p><strong>2、后缀表达式（逆波兰）求值</strong></p><ul><li>从左至右扫描表达式，遇到数字时，将数字压入堆栈，</li><li>遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），结果入栈；</li><li>重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</li></ul><p>(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - </p><ol><li>从左至右扫描，将3和4压入堆栈；</li><li>遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；<br>将5入栈；</li><li>接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；将6入栈；</li><li>最后是-运算符，计算出35-6的值，即29，由此得出最终结果</li></ol><h2 id="6、逆波兰表达式计算器"><a href="#6、逆波兰表达式计算器" class="headerlink" title="6、逆波兰表达式计算器"></a>6、逆波兰表达式计算器</h2><ul><li>输入逆波兰表达式，计算结果，使用Java提供的栈，</li><li>支持小括号和多位整数，支持整数的计算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toList</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] split = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s: split) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否为运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.equals(<span class="string">&quot;+&quot;</span>)  || str.equals(<span class="string">&quot;-&quot;</span>) || str.equals(<span class="string">&quot;*&quot;</span>) || str.equals(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,String oper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1 + num2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1 - num2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1 * num2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1 / num2;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;运算符错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为了方便数字和符号使用空格隔开,这样就不用判断是数字有几位了</span></span><br><span class="line">        <span class="comment">// 4 * 5 - 8 + 60 + 8 / 2 =&gt; 4 5 8 - 6 + 8 2 / +</span></span><br><span class="line">        <span class="comment">// String suffixExperssion = &quot;3 4 + 5 * 6 -&quot;;</span></span><br><span class="line">        String suffixExperssion = <span class="string">&quot;4 5 * 8 - 60 + 8 2 / +&quot;</span>;</span><br><span class="line">        List&lt;String&gt; list = toList(suffixExperssion);</span><br><span class="line"></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.forEach((str)-&gt; &#123;</span><br><span class="line">            <span class="comment">// 是数字直接入栈</span></span><br><span class="line">            <span class="keyword">if</span> (!isOper(str))&#123;</span><br><span class="line">                stack.push(str);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是字符,就出栈二个，和字符做运算，结果入栈</span></span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> result = cal(num2,num1,str);</span><br><span class="line">                stack.push(String.valueOf(result));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、中缀表达式转逆波兰表达式"><a href="#7、中缀表达式转逆波兰表达式" class="headerlink" title="7、中缀表达式转逆波兰表达式"></a>7、中缀表达式转逆波兰表达式</h2><ol><li><p>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</p></li><li><p>从左至右扫描中缀表达式；遇到操作数时，将其压s2；</p></li><li><p>遇到运算符时，比较其<code>与s1栈顶运算符</code>的优先级：</p><ul><li><p>如果s1为空，或栈顶运算符为左括号“(”，将运算符入栈s1；</p></li><li><p>否则，若优先级比栈顶运算符的高，也将运算符压入s1；</p></li><li><p>否则，将s1栈顶的运算符弹出并压入到s2中，重新比较该字符串</p></li></ul></li><li><p>遇到括号时：</p><ul><li> 如果是左括号“(”，则直接压入s1</li><li>如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这括号丢弃</li></ul></li><li><p>重复步骤直到表达式的最右边</p></li><li><p>将s1中剩余的运算符依次弹出并压入s2，依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</p></li></ol><p>总结：</p><p>1、数字入数栈</p><p>2、<code>保证进入字符栈的优先级比栈顶更大</code>，否则就把字符栈的放入数栈，直到要入字符栈的优先级最大</p><p>3、左括号直接如字符栈，左括号后面字符随意（不考虑优先级），</p><p>4、遇到右括号，把字符栈的不断弹出放到数栈，直到左右括号相碰，然后删去一对括号</p><p>5、最后把字符栈依次弹出放到数栈里面</p><p><strong>思路：</strong></p><p>将处理每个字符串的步骤封装成方法，因为步骤三需要重新比较该字符串，需要递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toList</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] split = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s: split) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否为运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.equals(<span class="string">&quot;+&quot;</span>)  || str.equals(<span class="string">&quot;-&quot;</span>) || str.equals(<span class="string">&quot;*&quot;</span>) || str.equals(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回运算符的优先级</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(String oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper.equals(<span class="string">&quot;*&quot;</span>) || oper.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oper.equals(<span class="string">&quot;+&quot;</span>) || oper.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//设置只有加减乘除</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,String oper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1 + num2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1 - num2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1 * num2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1 / num2;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;运算符错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆波兰转换中处理一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toPolandNotationForOne</span><span class="params">(String str,Stack&lt;String&gt; s1,Stack&lt;String&gt; s2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断是不是括号</span></span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">            s1.push(str);</span><br><span class="line">            <span class="comment">// 如果匹配右括号则，s1出栈放到s2，直到s1取出的为左括2</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">&quot;)&quot;</span>))&#123;</span><br><span class="line">            String brackets = s1.pop();</span><br><span class="line">            <span class="keyword">while</span> (!brackets.equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                s2.push(brackets);</span><br><span class="line">                brackets = s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isOper(str))&#123;</span><br><span class="line">            <span class="comment">// 如果s1为空，或栈顶运算符为左括号“(”，将运算符入栈s1；</span></span><br><span class="line">            <span class="keyword">if</span>(s1.empty() || s1.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                s1.push(str);</span><br><span class="line">            <span class="comment">// 如果运算符的优先级大于栈1顶部的，将运算符入栈s1；</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(priority(str)&gt;priority(s1.peek()))&#123;</span><br><span class="line">                s1.push(str);</span><br><span class="line">            <span class="comment">// 把栈s1抛出 到 s2 ，然后继续处理该字符串</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">                toPolandNotationForOne(str,s1,s2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是数组，直接放入s2</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            s2.push(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换成逆波兰格式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toPolandNotation</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;String&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list = toList(str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        list.forEach((s)-&gt;&#123;</span><br><span class="line">            toPolandNotationForOne(s,s1,s2);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s1.empty())&#123;</span><br><span class="line">            s2.push(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        result = s2.pop();</span><br><span class="line">        <span class="keyword">while</span> (!s2.empty())&#123;</span><br><span class="line">            result = s2.pop() + <span class="string">&quot; &quot;</span> + result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入一个中缀表达式，调用其他方法，返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(String suffixExperssion)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = toList(toPolandNotation(suffixExperssion));</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.forEach((str)-&gt; &#123;</span><br><span class="line">            <span class="comment">// 是数字直接入栈</span></span><br><span class="line">            <span class="keyword">if</span> (!isOper(str))&#123;</span><br><span class="line">                stack.push(str);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是字符,就出栈二个，和字符做运算，结果入栈</span></span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> result = cal(num2,num1,str);</span><br><span class="line">                stack.push(String.valueOf(result));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> str = cal(<span class="string">&quot;( 3 + 5 ) * 5 - 6&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法Java版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法(一):队列</title>
      <link href="/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E4%B8%80%20)%20%E9%98%9F%E5%88%97(%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8)/"/>
      <url>/2021/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/(%20%E4%B8%80%20)%20%E9%98%9F%E5%88%97(%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8)/</url>
      
        <content type="html"><![CDATA[<h2 id="1、顺序表"><a href="#1、顺序表" class="headerlink" title="1、顺序表"></a>1、顺序表</h2><ul><li>使用数组存储数据，默认长度为5，如果长度不够，会自动扩展容量</li><li>顺序表默认  <code>添加  删除</code>  操作最后的数据</li><li>顺序表可以 指定索引  在索引出 添加和 删除数据</li><li>顺序表可以根据 值 返回索引</li><li>顺序表可以根据 索引 返回 值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sequence;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sequence = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sequence[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入到最后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        isFull();</span><br><span class="line">        sequence[index] = value;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据索引添加值，先把数据往后移动一位，在把值赋给传入的索引位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        isFull();</span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="keyword">this</span>.index || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入数据不合格&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.index; i &gt; index; i--) &#123;</span><br><span class="line">            sequence[i] = sequence[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        sequence[index] = value;</span><br><span class="line">        <span class="keyword">this</span>.index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span>&#123;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据索引删除值，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delByIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="keyword">this</span>.index - <span class="number">1</span> || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入数据不合格&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; <span class="keyword">this</span>.index - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            sequence[i] = sequence[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.index--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搜索值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]==value)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            System.out.print(sequence[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 判断数组是不是满了，如果满了长度就扩大2倍</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = sequence.length;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= length) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[length * <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                newArr[i] = sequence[i];</span><br><span class="line">            &#125;</span><br><span class="line">            sequence = newArr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、单链表"><a href="#2、单链表" class="headerlink" title="2、单链表"></a>2、单链表</h2><ul><li>头插法 和尾插法</li><li>根据 值 或者 直接查找第 i 个节点</li><li>对 第 i 个节点 进行增删改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从头节点的下一个节点开始展示所有的链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp.getNext()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp.getNext());</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.setNext(head.getNext());</span><br><span class="line">        head.setNext(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尾插法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTail</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp.getNext()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        temp.setNext(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp.getNext()!=<span class="keyword">null</span> )&#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照序号查找节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchByIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照值查找节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchByValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp.getNext()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.getNext().getData()==value)&#123;</span><br><span class="line">                <span class="keyword">return</span> temp.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照索引插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertByIndex</span><span class="params">(<span class="keyword">int</span> index,Node node)</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">int</span> length = getLength();</span><br><span class="line">        <span class="keyword">if</span>(index &gt; length + <span class="number">1</span> || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == length + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (temp.getNext()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp = temp.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            temp.setNext(node);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩下的情况能够插入</span></span><br><span class="line">        <span class="comment">// 循环index - 1 次，即找到索引节点的前一个节点的前一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">            <span class="keyword">if</span> (temp.getNext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.setNext(temp.getNext());</span><br><span class="line">        temp.setNext(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点第index个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delByIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">int</span> length = getLength();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; length || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩下的情况能够删除</span></span><br><span class="line">        <span class="comment">// 循环index - 1 次，即找到索引节点的前一个节点的前一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">            <span class="keyword">if</span> (temp.getNext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.setNext(temp.getNext().getNext());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照索引修改节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateByIndex</span><span class="params">(<span class="keyword">int</span> index,Node node)</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">int</span> length = getLength();</span><br><span class="line">        <span class="keyword">if</span>(index &gt; length  || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩下的情况能够插入</span></span><br><span class="line">        <span class="comment">// 循环index - 1 次，即找到索引节点的前一个节点的前一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">            <span class="keyword">if</span> (temp.getNext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.setNext(temp.getNext().getNext());</span><br><span class="line">        temp.setNext(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展 可以增加一个tail指向尾部</span></span><br><span class="line"><span class="comment">// private Node tail;</span></span><br></pre></td></tr></table></figure><h2 id="3、队列（数组）"><a href="#3、队列（数组）" class="headerlink" title="3、队列（数组）"></a>3、队列（数组）</h2><h3 id="3-1、介绍"><a href="#3-1、介绍" class="headerlink" title="3.1、介绍"></a>3.1、介绍</h3><ol><li>队列是一个有序列表，可以用<code>数组</code>或是<code>链表</code>来实现。</li><li>遵循<strong>先入先出</strong>的原则，进入都是在队尾，出去都是在队首</li></ol><h3 id="3-2、数组实现"><a href="#3-2、数组实现" class="headerlink" title="3.2、数组实现"></a>3.2、数组实现</h3><ol><li>因此需要两个变量 front及 rear分别记录队列前后端的下标，<strong>arr[ 0 ]作为队首</strong></li><li>front 会随着数据输出而改变，初始为 - 1 ，每次操作时先自增，然后 返回 arr[ front ]</li><li>rear则是随着数据输入而改变，初始为 - 1 ，每次操作时先 自增，然后操作 arr[ rear ]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组模拟队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;  <span class="comment">// 表示数据头指针,想象成排队，从这里出去</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;   <span class="comment">// 表示尾指针,想象配排队，从这里进来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建队列的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.front = -<span class="number">1</span>; <span class="comment">// 指向队列头部前一个,实际队首应该是arr[0]</span></span><br><span class="line">        <span class="keyword">this</span>.rear = -<span class="number">1</span>;  <span class="comment">// 指向队列尾部,实际就是arr[-1],如果加入,就指向了arr[0]</span></span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span> [maxSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断队列是不是满的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize-<span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断队列是不是空的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已经满了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.rear++;        <span class="comment">// rear后移</span></span><br><span class="line">            arr[rear] = value;  <span class="comment">// 添加数据，注意如果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;加入成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已经空了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.front++;       <span class="comment">//注意逻辑上已经删除了数据</span></span><br><span class="line">            <span class="keyword">return</span> arr[front];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已经空了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; rear; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">2</span>)+<span class="string">&quot;个数据:&quot;</span>+arr[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取头部信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已经空了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[front + <span class="number">1</span>]; <span class="comment">// 默认arr[0],每取出一个数front+1,往后移动一位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayQueue arrayQueue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">&#x27; &#x27;</span>; <span class="comment">//接收用户输入数据</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s:显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e:退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a:添加数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g:取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h:查看队首&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        arrayQueue.showQueue();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入一个整数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    arrayQueue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(arrayQueue.getQueue());</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(arrayQueue.headQueue());</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>出队列逻辑上删除，实际并没有删除，通过模拟指针右移，这样指针左边的空间会浪费掉</li><li>如上述，添加3次数据后，即使把数据全删了，也无法继续添加数据</li></ul><p><strong>解决：环形数组</strong></p><h3 id="3-3、环形数组"><a href="#3-3、环形数组" class="headerlink" title="3.3、环形数组"></a>3.3、环形数组</h3><p><strong>思路：</strong></p><ul><li>若rear指针已经到了数组尽头，且数组没满，则让rear重新指向数组的第一位</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组模拟队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建队列的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue2</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.front = <span class="number">0</span>;  <span class="comment">// 指向队列头部</span></span><br><span class="line">        <span class="keyword">this</span>.rear = <span class="number">0</span>;   <span class="comment">// 指向队列尾部后一个位置，插入后就指向了arr[1]</span></span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span> [maxSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断队列是不是满的，默认数组最多有maxSize -1 空间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front; </span><br><span class="line">        <span class="comment">// 若maxSize-1个数据，则实际队尾是arr[maxSize-2]，离满还差一个，但指向arr[maxSize]</span></span><br><span class="line">        <span class="comment">// 若让满数据,则条件为 rear % maxSize == front; 开始即满足,无法判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断队列是不是空的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已经满了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            arr[rear] = value;</span><br><span class="line">            <span class="keyword">this</span>.rear++;             <span class="comment">// rear后移</span></span><br><span class="line">            <span class="keyword">if</span>(rear == maxSize)&#123;     <span class="comment">// arr[maxSize]为最大,在大就变到第一个</span></span><br><span class="line">                rear = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;加入成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已经空了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = arr[front]; <span class="comment">// 因为指针指向当前，所以必须先获取值，在自增</span></span><br><span class="line">            <span class="keyword">this</span>.front++;</span><br><span class="line">            <span class="keyword">if</span>(front == maxSize)&#123;   <span class="comment">// arr[maxSize]为最大,在大就变到第一个</span></span><br><span class="line">                front = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = front ;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已经空了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 队伍长度 (rear + maxSize - front) % maxSize</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (rear + maxSize - front) % maxSize ; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个数:&quot;</span>+arr[flag++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取头部信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已经空了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[front];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayQueue2 arrayQueue = <span class="keyword">new</span> ArrayQueue2(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">&#x27; &#x27;</span>; <span class="comment">//接收用户输入数据</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s:显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e:退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a:添加数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g:取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h:查看队首&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        arrayQueue.showQueue();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入一个整数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    arrayQueue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(arrayQueue.getQueue());</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(arrayQueue.headQueue());</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><p>此时输入3，只能存入2个数据，为什么？如果能存入3个数据，那么<code>满和空的条件一致</code>。</p></li><li><p>所以是判断存了2个数据，就满了，所以只要判断，rear的<code>下一个地址和front相等即可</code></p><p>(rear + 1 - front) % maxSize == front 分析：</p><ul><li>情况一： rear + 1 = front，这种情况就是说 rear 下一个地址，就是front</li><li>情况二：rear + 1 - maxSize = front ，当rear为数组末尾时，下一个地址循环，减去maxSize</li></ul></li><li><p>有效个数等于 front - rear ，如果 rear已经循环了一次在front前面，则加上maxSize</p><p><code>(rear + maxSize - front) % maxSize</code></p></li></ol><h2 id="2、队列（链表）"><a href="#2、队列（链表）" class="headerlink" title="2、队列（链表）"></a>2、队列（链表）</h2><h3 id="4-1、单链表介绍"><a href="#4-1、单链表介绍" class="headerlink" title="4.1、单链表介绍"></a>4.1、单链表介绍</h3><ol><li>链表是以节点的方式来存储,是链式存储，每个节点包含 data 域， next 域：</li><li>链表的各个节点不一定是连续存储.</li><li>链表分<code>带头节点的链表和没有头节点</code>的链表，根据实际的需求来确定</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个头结点，头结点不要动,不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 返回头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加结点，添加到最后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp = head; <span class="comment">// 把head的地址给temp</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据Id大小添加结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addById</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp = head; <span class="comment">// 把head的地址给temp</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.id&lt; node.id &amp;&amp; temp.next.id &gt; node.id)&#123;</span><br><span class="line">                node.next = temp.next;</span><br><span class="line">                temp.next = node;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时temp.next = null，处于最后一个</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改结点,根据节点的编号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateById</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node temp = head;           <span class="comment">// 把head的地址给temp</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;    </span><br><span class="line">            <span class="keyword">if</span> (temp.next.id == node.id)&#123;</span><br><span class="line">                node.next = temp.next.next;</span><br><span class="line">                temp.next = node;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据Id删除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head; <span class="comment">// 把head的地址给temp</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.id == id)&#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显示链表，遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为头结点不能动，所以需要一个辅助变量遍历</span></span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并两个链表，变成有序的</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">mergeLinkedList</span><span class="params">(Node node1,Node node2)</span></span>&#123;</span><br><span class="line">        Node newLinkedList  = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);  <span class="comment">// 创建头结点</span></span><br><span class="line">        Node temp = newLinkedList;</span><br><span class="line">        <span class="comment">// 只有两个都是null才会停止</span></span><br><span class="line">        <span class="keyword">while</span> (node1!=<span class="keyword">null</span> || node2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果node2空了，后者node1的id更小，就添加node1</span></span><br><span class="line">            <span class="keyword">if</span>( node2==<span class="keyword">null</span> || node1.id&lt;=node2.id)&#123;</span><br><span class="line">                temp.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newLinkedList;  <span class="comment">// 返回头结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>,<span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>,<span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        Node node5 = <span class="keyword">new</span> Node(<span class="number">4</span>,<span class="string">&quot;柴进&quot;</span>,<span class="string">&quot;小旋风&quot;</span>);</span><br><span class="line">        Node node6 = <span class="keyword">new</span> Node(<span class="number">6</span>,<span class="string">&quot;秦明&quot;</span>,<span class="string">&quot;霹雳火&quot;</span>);</span><br><span class="line">        Node node7 = <span class="keyword">new</span> Node(<span class="number">7</span>,<span class="string">&quot;关胜&quot;</span>,<span class="string">&quot;大刀&quot;</span>);</span><br><span class="line">        node6.next = node7;</span><br><span class="line"></span><br><span class="line">        singleLinkedList.add(node1);</span><br><span class="line">        singleLinkedList.add(node2);</span><br><span class="line">        singleLinkedList.add(node4);</span><br><span class="line">        singleLinkedList.addById(node3);</span><br><span class="line">        singleLinkedList.delById(<span class="number">2</span>);</span><br><span class="line">        singleLinkedList.updateById(node5);</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        singleLinkedList.insert(node6);</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        singleLinkedList.reverse();</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        singleLinkedList.reversePrint();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickName;</span><br><span class="line">    <span class="keyword">public</span> Node next; <span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> id, String name, String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickName=&#x27;&quot;</span> + nickName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2、单链表题"><a href="#4-2、单链表题" class="headerlink" title="4.2、单链表题"></a>4.2、单链表题</h3><p><strong>1、单链表的反转</strong></p><ul><li>很容易想到存放在数组里然后重新构建链表，但是效率很低</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    <span class="comment">// 不断把节点添加到list集合里面去</span></span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    list.forEach((l)-&gt;l.next=<span class="keyword">null</span>);     <span class="comment">// 确保节点不含next信息</span></span><br><span class="line">    Node reverse = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);   <span class="comment">// 创建头结点</span></span><br><span class="line">    head = reverse;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        add(list.get(i));              <span class="comment">// 调用方法添加节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头插法，效率更高</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转链表，把旧链表依次遍历，每次取出一个插入新链表头结点和第一个节点之间</span></span><br><span class="line"><span class="comment">// 最后得到反转的新链表，把新旧链表的头结点的next互换即可得到反转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp = head.next;  <span class="comment">// temp指向需要反转的有值的节点</span></span><br><span class="line">    Node next = <span class="keyword">null</span>;       <span class="comment">// 临时保存,temp的下一个节点</span></span><br><span class="line"></span><br><span class="line">    Node reverseHead = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = temp.next;  <span class="comment">// 临时保存,temp的下一个节点</span></span><br><span class="line">        temp.next = reverseHead.next;  <span class="comment">// 这第一次循环时为null</span></span><br><span class="line">        reverseHead.next = temp;       <span class="comment">// reverseHead指向temp</span></span><br><span class="line">        temp = next;       <span class="comment">// temp变回原来</span></span><br><span class="line">    &#125;</span><br><span class="line">    head.next = reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、从尾到头打印单链表</strong></p><p><strong>方法：</strong></p><ol><li>先反转，然后打印，会改变链表的结构，不可取</li><li>利用栈的特点，先进后出打印</li><li>存到数组、list集合里，然后输出，效率低</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(temp);  <span class="comment">// 因为只是输出，所以不需要管里面的next</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、合并两个有序的单链表，合并之后的链表依然有序</strong></p><ul><li>可以把一个单链表分割成许多节点，依次插入另一个单链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        next = node.next;</span><br><span class="line">        node.next = <span class="keyword">null</span>;       <span class="comment">// 注意每次插入前，要把next设为null，不然指向会乱</span></span><br><span class="line">        addById(node, node.id); <span class="comment">// 利用前面写好的按id插入方法</span></span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新建链表，每次插入前比较两个链表谁的更小，小就插入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为两个链表的头结点的下一节点（有值的）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">mergeLinkedList</span><span class="params">(Node node1,Node node2)</span></span>&#123;</span><br><span class="line">    Node newLinkedList  = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    Node temp = newLinkedList;</span><br><span class="line">    <span class="comment">// 一直循环到两个都空了</span></span><br><span class="line">    <span class="keyword">while</span> (node1!=<span class="keyword">null</span> || node2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果链表2为空，或者1更小，就加入1。</span></span><br><span class="line">        <span class="keyword">if</span>( node2==<span class="keyword">null</span> || node1.id&lt;=node2.id)&#123;</span><br><span class="line">            temp.next = node1;</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newLinkedList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、双向链表"><a href="#4-3、双向链表" class="headerlink" title="4.3、双向链表"></a>4.3、双向链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个头结点，头结点不要动,不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> Node2 head = <span class="keyword">new</span> Node2(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 返回头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node2 <span class="title">getHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加结点,添加到最后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node2 node)</span></span>&#123;</span><br><span class="line">        Node2 temp = head; <span class="comment">// 把head的地址给temp</span></span><br><span class="line">        <span class="comment">// 找到最后一个temp</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = node;</span><br><span class="line">        node.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据ID添加结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addById</span><span class="params">(Node2 node)</span></span>&#123;</span><br><span class="line">        Node2 temp = head; <span class="comment">// 把head的地址给temp</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.id&lt; node.id &amp;&amp; temp.next.id &gt; node.id)&#123;</span><br><span class="line">                node.next = temp.next;</span><br><span class="line">                temp.next.pre = node;</span><br><span class="line">                temp.next = node;</span><br><span class="line">                node.pre = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = node;</span><br><span class="line">        node.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据Id修改结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateById</span><span class="params">(Node2 node)</span></span>&#123;</span><br><span class="line">        Node2 temp = head.next; <span class="comment">// 把head的地址给temp</span></span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.id == node.id)&#123;</span><br><span class="line">                temp.next.pre = node;</span><br><span class="line">                temp.pre.next = node;</span><br><span class="line">                node.next = temp.next;</span><br><span class="line">                node.pre = temp.pre;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据Id删除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node2 temp = head.next; <span class="comment">// 把head的地址给temp</span></span><br><span class="line">        <span class="comment">// 判断每个节点，然后自我删除即可</span></span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.id == id)&#123;</span><br><span class="line">                <span class="comment">// 把前面的指向后面</span></span><br><span class="line">                temp.pre.next = temp.next;</span><br><span class="line">                <span class="comment">// 把后面的指向前面,注意若为null会有空指针异常</span></span><br><span class="line">                <span class="keyword">if</span> (temp.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    temp.next.pre = temp.pre;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 顺序显示链表，遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为头结点不能动，所以需要一个辅助变量遍历</span></span><br><span class="line">        Node2 temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反序显示链表，遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseShow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node2 temp = head.next;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为头结点不能动，所以需要一个辅助变量遍历</span></span><br><span class="line">        <span class="keyword">while</span> (temp.pre!=head)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        Node2 node1 = <span class="keyword">new</span> Node2(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        Node2 node2 = <span class="keyword">new</span> Node2(<span class="number">2</span>,<span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        Node2 node3 = <span class="keyword">new</span> Node2(<span class="number">3</span>,<span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        Node2 node4 = <span class="keyword">new</span> Node2(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        Node2 node5 = <span class="keyword">new</span> Node2(<span class="number">5</span>,<span class="string">&quot;柴进&quot;</span>,<span class="string">&quot;小旋风&quot;</span>);</span><br><span class="line">        Node2 node6 = <span class="keyword">new</span> Node2(<span class="number">4</span>,<span class="string">&quot;秦明&quot;</span>,<span class="string">&quot;霹雳火&quot;</span>);</span><br><span class="line">        Node2 node7 = <span class="keyword">new</span> Node2(<span class="number">7</span>,<span class="string">&quot;关胜&quot;</span>,<span class="string">&quot;大刀&quot;</span>);</span><br><span class="line">        doubleLinkedList.add(node1);</span><br><span class="line">        doubleLinkedList.add(node2);</span><br><span class="line">        doubleLinkedList.add(node4);</span><br><span class="line">        doubleLinkedList.add(node5);</span><br><span class="line">        doubleLinkedList.add(node7);</span><br><span class="line">        doubleLinkedList.addById(node3);</span><br><span class="line">        doubleLinkedList.show();</span><br><span class="line">        doubleLinkedList.delById(<span class="number">3</span>);</span><br><span class="line">        doubleLinkedList.updateById(node6);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        doubleLinkedList.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        Node2 temp = doubleLinkedList.head.next.next.next.next.next;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        System.out.println(temp.pre);</span><br><span class="line">        System.out.println(temp.pre.pre);</span><br><span class="line">        System.out.println(temp.pre.pre.pre);</span><br><span class="line">        System.out.println(temp.pre.pre.pre.pre);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        doubleLinkedList.reverseShow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickName;</span><br><span class="line">    <span class="keyword">public</span> Node2 pre;  <span class="comment">// 指向前一个节点</span></span><br><span class="line">    <span class="keyword">public</span> Node2 next; <span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node2</span><span class="params">(<span class="keyword">int</span> id, String name, String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickName=&#x27;&quot;</span> + nickName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4、单向环形链表"><a href="#4-4、单向环形链表" class="headerlink" title="4.4、单向环形链表"></a>4.4、单向环形链表</h3><p><strong>约瑟夫问题（约瑟夫环）</strong></p><p>设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p><p><strong>思路：</strong></p><ol><li>需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点.</li><li>编号为k，则helper和first（指向链头）右移 k - 1 次，然后移动m - 1 次</li><li>需要出列时， helper  =  first.next 即可</li><li>重复直到所有人出列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造长度为nums的环形链表，注意队尾指向队首</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;值不符合标准&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy temp = <span class="keyword">null</span>; <span class="comment">// temp指向队伍尾部</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">            <span class="keyword">if</span> ( i == <span class="number">1</span>)&#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.next = first;</span><br><span class="line">                temp = first;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = boy;</span><br><span class="line">                boy.next = first;</span><br><span class="line">                temp = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy temp = first;</span><br><span class="line">        <span class="keyword">while</span> (temp.next!=first)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除，k 和 m对应题目里的k和m</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 检验数据</span></span><br><span class="line">        <span class="keyword">if</span>(first==<span class="keyword">null</span> || k &lt; <span class="number">1</span> )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入数据违法&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy helper = first;  </span><br><span class="line">        <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把helper指向链首的前一位,这样便于操作，因为单链表要删除节点，不能自我删除</span></span><br><span class="line">        <span class="comment">// 必须通过前一个节点.next = 要删除节点.next 才能删除</span></span><br><span class="line">        <span class="keyword">while</span> (helper.next!=first)&#123;</span><br><span class="line">            helper = helper.next;</span><br><span class="line">            nums++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; k)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入数据违法&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// helper右移动 k - 1 次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k -<span class="number">1</span>; i++) &#123;</span><br><span class="line">            helper = helper.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first.next!=first)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) &#123;</span><br><span class="line">                helper = helper.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 由于first和helper位置固定，所以只要使用first前指向helper的下一即可</span></span><br><span class="line">            first = helper.next;</span><br><span class="line">            System.out.println(first+<span class="string">&quot;出列&quot;</span>);</span><br><span class="line">            first = first.next;</span><br><span class="line">            helper.next = first;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(first+<span class="string">&quot;最后留在队里&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CircleLinkedList circleLinkedList = <span class="keyword">new</span> CircleLinkedList();</span><br><span class="line">        circleLinkedList.add(<span class="number">125</span>);</span><br><span class="line">        circleLinkedList.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        circleLinkedList.del(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> Boy next; <span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Boy&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4、队列（链表实现）"><a href="#4-4、队列（链表实现）" class="headerlink" title="4.4、队列（链表实现）"></a>4.4、队列（链表实现）</h3><p><strong>思路：</strong></p><ul><li>链表的头结点当做队尾，插入节点使用头插法</li><li>链表的尾部当做队首，出队列在链表的尾部进行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> Node3 front = <span class="keyword">new</span> Node3(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Node3 rear = front.next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear==front.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node3 node= front;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node.next!=rear)&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  flag==maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQueue</span><span class="params">(Node3 node)</span></span>&#123;</span><br><span class="line">        Node3 temp = front;</span><br><span class="line">        <span class="keyword">while</span> (temp.next!=rear)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = node;</span><br><span class="line">        rear = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node3 <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node3 node = front.next;</span><br><span class="line">        Node3 temp = front.next.next;</span><br><span class="line">        front.next = temp;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//展示队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node3 temp = front.next;</span><br><span class="line">        <span class="keyword">while</span> (temp!=rear)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedListQueue linkedListQueue = <span class="keyword">new</span> LinkedListQueue();</span><br><span class="line">        Node3 node1 = <span class="keyword">new</span> Node3(<span class="number">1</span>);</span><br><span class="line">        Node3 node2 = <span class="keyword">new</span> Node3(<span class="number">2</span>);</span><br><span class="line">        Node3 node3 = <span class="keyword">new</span> Node3(<span class="number">3</span>);</span><br><span class="line">        Node3 node4 = <span class="keyword">new</span> Node3(<span class="number">4</span>);</span><br><span class="line">        linkedListQueue.setQueue(node1);</span><br><span class="line">        linkedListQueue.setQueue(node2);</span><br><span class="line">        linkedListQueue.setQueue(node4);</span><br><span class="line">        linkedListQueue.setQueue(node3);</span><br><span class="line">        linkedListQueue.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        System.out.println(linkedListQueue.getQueue());</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        linkedListQueue.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node3</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> Node3 next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node3</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node3&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法Java版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb(五):SSM框架整合</title>
      <link href="/2021/07/01/Web/JavaWeb%20(%20%E4%BA%94%20)%20SSM%E6%95%B4%E5%90%88/"/>
      <url>/2021/07/01/Web/JavaWeb%20(%20%E4%BA%94%20)%20SSM%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="1、依赖配置"><a href="#1、依赖配置" class="headerlink" title="1、依赖配置"></a>1、依赖配置</h1><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wzh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Book<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring 核心jar --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring 测试jar --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--   spring jdbc  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring事物 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring  aop --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- mysql 驱动包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis分页插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis 第三方缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 添加mybatis与Spring整合的核心包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        </span><br><span class="line">        <span class="comment">&lt;!-- 日志打印相关的jar --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- spring web --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring webmvc --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- servlet --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jsp --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jstl --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- json --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- fastjson --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.75<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--文件上传--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  build里面： --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h1><h3 id="db-properties"><a href="#db-properties" class="headerlink" title="db.properties"></a>db.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><h3 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global logging configuration</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG, stdout</span></span><br><span class="line"><span class="comment"># Consoleoutput...</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p [%t] - %m%n</span></span><br></pre></td></tr></table></figure><h1 id="3、SSM配置文件"><a href="#3、SSM配置文件" class="headerlink" title="3、SSM配置文件"></a>3、SSM配置文件</h1><h3 id="mybatis-xml"><a href="#mybatis-xml" class="headerlink" title="mybatis.xml"></a>mybatis.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- setting 设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--  设置日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  开启缓存 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--别名的配置 每个人必须会 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.wzh.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 分页插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- com.github.pagehelper 为 PageHelper 类所在包名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该参数默认为 false --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置为 true 时，会将 RowBounds 第一个参数 offset 当成 pageNum 页码使用 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 和 startPage 中的 pageNum 效果一样 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;offsetAsPageNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该参数默认为 false --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置为 true 时，使用 RowBounds 分页会进行 count 查询 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rowBoundsWithCount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全 部的结果 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- （相当于没有执行分页查询，但是返回结果仍然是 Page 类型） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pageSizeZero&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 3.3.0 版本可用 - 分页参数合理化，默认 false 禁用 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 启用合理化时，如果 pageNum&lt;1 会查询第一页，如果 pageNum&gt;pages 会查询 最后一页 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 禁用合理化时，如果 pageNum&lt;1 或 pageNum&gt;pages 会返回空数据 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;reasonable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 3.5.0 版本可用 - 为了支持 startPage(Object params)方法 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 增加了一个`params`参数来配置参数映射，用于从 Map 或 ServletRequest 中取值 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射 的用默认值 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;params&quot;</span> <span class="attr">value</span>=<span class="string">&quot;pageNum=start;pageSize=limit;pageSizeZero=zero;reasonable=heli;count=countsql&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="spring-xml"><a href="#spring-xml" class="headerlink" title="spring.xml"></a>spring.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载数据库资源文件db.properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描包 过滤conroller层 交给springMvc去做 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzh&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置aop 代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开始事务 标注@Transactional的类和方法将具有事务性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库连接池</span></span><br><span class="line"><span class="comment">       dbcp 半自动化操作 不能自动连接</span></span><br><span class="line"><span class="comment">       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置连接池属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关闭连接后不自动commit --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommitOnClose&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 获取连接超时时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireRetryAttempts&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 整合 框架（Spring与Mybatis） --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 sqlSessionFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 框架的配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 映射文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/wzh/dao/*.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置扫描器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperScanner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 扫描com.wzh.dao这个包以及它的子包下的所有映射接口类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.wzh.dao&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="servlet-xml"><a href="#servlet-xml" class="headerlink" title="servlet.xml"></a>servlet.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描 com.xxx.controller 下包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzh.controller&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- mvc 请求映射处理器与适配器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 消息转换器  处理json字符串解决乱码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span> <span class="attr">value</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器 默认的视图解析器- --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--文件上传配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40960&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  拦截器拦截的两种方式  - --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置方式一（拦截所有请求配置方式）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;mvc:interceptors&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &amp;lt;!&amp;ndash; 自己定义的拦截器位置 &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;bean class=&quot;com.xxx.interceptors.MyInterceptor&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/mvc:interceptors&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置方式二（拦截指定请求配置方式）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;mvc:interceptors&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mvc:interceptor&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &amp;lt;!&amp;ndash;/** 包括路径及其子路径&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &amp;lt;!&amp;ndash;/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &amp;lt;!&amp;ndash;/admin/** 拦截的是/admin/下的所有&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;mvc:mapping path=&quot;/**&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &amp;lt;!&amp;ndash;bean配置的就是拦截器&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;bean class=&quot;com.wzh.interceptor.MyInterceptor&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/mvc:interceptor&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/mvc:interceptors&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4、web-xml配置"><a href="#4、web-xml配置" class="headerlink" title="4、web.xml配置"></a>4、web.xml配置</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 可以不加 表示容器启动时 加载上下文配置 这里指定 spring 相关配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 可以不加 启用 spring 容器环境上下文监听 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--DispatcherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--所有请求都会被springmvc拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC 官方过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Session过期时间--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="5、mapper-xml"><a href="#5、mapper-xml" class="headerlink" title="5、mapper.xml"></a>5、mapper.xml</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.wzh.mapper.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启第三方 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="6、案例（图书）"><a href="#6、案例（图书）" class="headerlink" title="6、案例（图书）"></a>6、案例（图书）</h1><h2 id="1、整体结构"><a href="#1、整体结构" class="headerlink" title="1、整体结构"></a>1、整体结构</h2><p><img src="/img/web/%E5%9B%BE%E7%89%8750.jpg"></p><h2 id="2、前台页面"><a href="#2、前台页面" class="headerlink" title="2、前台页面"></a>2、前台页面</h2><h3 id="index-jsp"><a href="#index-jsp" class="headerlink" title="index.jsp"></a>index.jsp</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">  &lt;style type=<span class="string">&quot;text/css&quot;</span>&gt;</span><br><span class="line">    a &#123;</span><br><span class="line">      text-decoration: none;</span><br><span class="line">      color: black;</span><br><span class="line">      font-size: 18px;</span><br><span class="line">    &#125;</span><br><span class="line">    h3 &#123;</span><br><span class="line">      width: 180px;</span><br><span class="line">      height: 38px;</span><br><span class="line">      margin: 100px auto;</span><br><span class="line">      text-align: center;</span><br><span class="line">      line-height: 38px;</span><br><span class="line">      background: deepskyblue;</span><br><span class="line">      border-radius: 4px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;</span><br><span class="line">  &lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;</span>&gt;点击进入列表页&lt;/a&gt;</span><br><span class="line">&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="addBook-jsp"><a href="#addBook-jsp" class="headerlink" title="addBook.jsp"></a>addBook.jsp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;新增书籍&lt;/title&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;row clearfix&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;col-md-12 column&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;page-header&quot;&gt;</span><br><span class="line">                &lt;h1&gt;</span><br><span class="line">                    &lt;small&gt;新增书籍&lt;/small&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/addBook&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">        书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">        书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="allBook-jsp"><a href="#allBook-jsp" class="headerlink" title="allBook.jsp"></a>allBook.jsp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;书籍列表&lt;/title&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;row clearfix&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;col-md-12 column&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;page-header&quot;&gt;</span><br><span class="line">                &lt;h1&gt;</span><br><span class="line">                    &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;col-md-4 column&quot;&gt;</span><br><span class="line">            &lt;a class=&quot;btn btn-primary&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;&gt;新增&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;row clearfix&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;col-md-12 column&quot;&gt;</span><br><span class="line">            &lt;table class=&quot;table table-hover table-striped&quot;&gt;</span><br><span class="line">                &lt;thead&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;th&gt;书籍编号&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;书籍名字&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;书籍数量&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;书籍详情&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">                &lt;/thead&gt;</span><br><span class="line"></span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                &lt;c:forEach var=&quot;book&quot; items=&quot;$&#123;requestScope.get(&#x27;list&#x27;)&#125;&quot;&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.getBookID()&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.getBookName()&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.getDetail()&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;</span><br><span class="line">                            &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;/a&gt; |</span><br><span class="line">                            &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;/a&gt;</span><br><span class="line">                        &lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                &lt;/c:forEach&gt;</span><br><span class="line">                &lt;/tbody&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="updateBook-jsp"><a href="#updateBook-jsp" class="headerlink" title="updateBook.jsp"></a>updateBook.jsp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;修改信息&lt;/title&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;row clearfix&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;col-md-12 column&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;page-header&quot;&gt;</span><br><span class="line">                &lt;h1&gt;</span><br><span class="line">                    &lt;small&gt;修改信息&lt;/small&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/updateBook&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;hidden&quot; name=&quot;bookID&quot; value=&quot;$&#123;book.getBookID()&#125;&quot;/&gt;</span><br><span class="line">        书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot; value=&quot;$&#123;book.getBookName()&#125;&quot;/&gt;</span><br><span class="line">        书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot; value=&quot;$&#123;book.getBookCounts()&#125;&quot;/&gt;</span><br><span class="line">        书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot; value=&quot;$&#123;book.getDetail() &#125;&quot;/&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、实体类"><a href="#3、实体类" class="headerlink" title="3、实体类"></a>3、实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Books</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bookID;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bookCounts;</span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、dao层"><a href="#4、dao层" class="headerlink" title="4、dao层"></a>4、dao层</h2><h3 id="BookMapper"><a href="#BookMapper" class="headerlink" title="BookMapper"></a>BookMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.wzh.pojo.Books;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个Book</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addBook</span><span class="params">(Books book)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id删除一个Book</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteBookById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Book</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateBook</span><span class="params">(Books books)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id查询,返回一个Book</span></span><br><span class="line">    <span class="function">Books <span class="title">queryBookById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询全部Book,返回list集合</span></span><br><span class="line">    <span class="function">List&lt;Books&gt; <span class="title">queryAllBook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BookMapper-xml"><a href="#BookMapper-xml" class="headerlink" title="BookMapper.xml"></a>BookMapper.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.wzh.dao.BookMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--增加一个Book--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        insert into ssmbuild.books(bookName,bookCounts,detail)</span><br><span class="line">        values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据id删除一个Book--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteBookById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete from ssmbuild.books where bookID=#&#123;bookID&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--更新Book--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        update ssmbuild.books</span><br><span class="line">        set bookName = #&#123;bookName&#125;,bookCounts = #&#123;bookCounts&#125;,detail = #&#123;detail&#125;</span><br><span class="line">        where bookID = #&#123;bookID&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据id查询,返回一个Book--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBookById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        select * from ssmbuild.books</span><br><span class="line">        where bookID = #&#123;bookID&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--查询全部Book--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAllBook&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        SELECT * from ssmbuild.books</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5、service层"><a href="#5、service层" class="headerlink" title="5、service层"></a>5、service层</h2><h3 id="BookService"><a href="#BookService" class="headerlink" title="BookService"></a>BookService</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import com.wzh.pojo.Books;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">//BookService:底下需要去实现,调用dao层</span><br><span class="line">public interface BookService &#123;</span><br><span class="line">    //增加一个Book</span><br><span class="line">    int addBook(Books book);</span><br><span class="line">    //根据id删除一个Book</span><br><span class="line">    int deleteBookById(int id);</span><br><span class="line">    //更新Book</span><br><span class="line">    int updateBook(Books books);</span><br><span class="line">    //根据id查询,返回一个Book</span><br><span class="line">    Books queryBookById(int id);</span><br><span class="line">    //查询全部Book,返回list集合</span><br><span class="line">    List&lt;Books&gt; queryAllBook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BookServiceImpl"><a href="#BookServiceImpl" class="headerlink" title="BookServiceImpl"></a>BookServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.wzh.dao.BookMapper;</span><br><span class="line"><span class="keyword">import</span> com.wzh.pojo.Books;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用dao层的操作，设置一个set接口，方便Spring管理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookMapper</span><span class="params">(BookMapper bookMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookMapper = bookMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addBook</span><span class="params">(Books book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.addBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteBookById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.deleteBookById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateBook</span><span class="params">(Books books)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.updateBook(books);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Books <span class="title">queryBookById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.queryBookById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Books&gt; <span class="title">queryAllBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.queryAllBook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6、controller层"><a href="#6、controller层" class="headerlink" title="6、controller层"></a>6、controller层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.wzh.pojo.Books;</span><br><span class="line"><span class="keyword">import</span> com.wzh.service.BookService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/allBook&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Books&gt; list = bookService.queryAllBook();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;allBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toAddBook&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toAddPaper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;addBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addBook&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addPaper</span><span class="params">(Books books)</span> </span>&#123;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        bookService.addBook(books);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/book/allBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toUpdateBook&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toUpdateBook</span><span class="params">(Model model, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Books books = bookService.queryBookById(id);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;book&quot;</span>,books );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;updateBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/updateBook&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateBook</span><span class="params">(Model model, Books book)</span> </span>&#123;</span><br><span class="line">        System.out.println(book);</span><br><span class="line">        bookService.updateBook(book);</span><br><span class="line">        Books books = bookService.queryBookById(book.getBookID());</span><br><span class="line">        model.addAttribute(<span class="string">&quot;books&quot;</span>, books);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/book/allBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/del/&#123;bookId&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteBook</span><span class="params">(<span class="meta">@PathVariable(&quot;bookId&quot;)</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        bookService.deleteBookById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/book/allBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb(四):Mybatis框架</title>
      <link href="/2021/07/01/Web/JavaWeb%20(%20%E5%9B%9B%20)%20Mybatis/"/>
      <url>/2021/07/01/Web/JavaWeb%20(%20%E5%9B%9B%20)%20Mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Mybatis简介"><a href="#1、Mybatis简介" class="headerlink" title="1、Mybatis简介"></a>1、Mybatis简介</h1><h2 id="1-1、什么是Mybatis"><a href="#1-1、什么是Mybatis" class="headerlink" title="1.1、什么是Mybatis"></a>1.1、什么是Mybatis</h2><ul><li>MyBatis 是基于Java的优秀持久层框架，支持定制化SQL查询，存储过程和高级映射</li><li>MyBatis 避免了几乎所有的JDBC代码和手动设置参数以及获取结果集</li><li>使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO映射成数据库中的记录</li><li>MyBatis 本是apache的一个开源项目iBatis, 2010年迁移到了google code，改名MyBatis 。2013年11月迁移到Github</li></ul><blockquote><p>持久层</p></blockquote><p><strong>Dao层、Service层、Controller层</strong></p><ul><li>完成持久化工作的代码</li><li>层界限十分明显</li></ul><h2 id="1-2、为什么需要MyBatis"><a href="#1-2、为什么需要MyBatis" class="headerlink" title="1.2、为什么需要MyBatis"></a>1.2、为什么需要MyBatis</h2><ul><li>JDBC 和 Java 代码之间直接使用SQL，不易维护</li><li>Hibernate 和 JPA 内部自动生产的SQL，不容易做特殊优化。基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。导致数据库性能下降。 </li><li>MyBatis是一个半自动化的持久化层框架，有自己的优点。如SQL和代码分离，提高可维护性、提供映射标签，支持对象与数据库orm字段关系映射、提供对象关系映射标签，支持对象关系组建维护、提供XML标签，支持<strong>动态</strong>编写SQL</li></ul><h2 id="1-3、Mybatis的结构"><a href="#1-3、Mybatis的结构" class="headerlink" title="1.3、Mybatis的结构"></a>1.3、Mybatis的结构</h2><blockquote><p>功能架构</p></blockquote><p><img src="/img/web/%E5%9B%BE%E7%89%8745.jpg"></p><ul><li><strong>API接口层：</strong>提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li><strong>数据处理层：</strong>负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li><strong>基础支撑层：</strong>负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑</li></ul><h2 id="1-4、Mybatis执行SQL的流程"><a href="#1-4、Mybatis执行SQL的流程" class="headerlink" title="1.4、Mybatis执行SQL的流程"></a>1.4、Mybatis执行SQL的流程</h2><img src="/img/web/图片46.jpg" style="zoom:80%;" /> <blockquote><p>Mapped Statement：</p></blockquote><p><strong>概念：</strong>Mapped Statement对象就是<code>对SQL语句的封装</code>。</p><p>Executor 会利用MappedStatement对象，创建StatementHandler对象，StatementHandler对象会进行参数输入映射，然后和JDBC交互获取结果，最后把结果映射。</p><blockquote><p>SqlSession</p></blockquote><p><strong>一个SqlSession 对象代表和数据库的一次会话</strong>，产生流程如下</p><p><strong>流程：</strong>SqlSessionFactoryBuilder  ——&gt;    SqlSessionFactory  ———&gt; SqlSession</p><p><strong>SqlSessionFactoryBuilder：</strong>一旦创建了，就不再需要他了，可以设置为局部变量</p><p><strong>SqlSessionFactory：</strong>负责生产SqlSession，单例模式或者静态单例模式比较适合</p><p><strong>SqlSession：</strong></p><ul><li>SqlSession 的实例<code>不是线程安全的</code>，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域</li><li>用完之后需要赶紧关闭</li><li>SqlSession可以直接调用方法的id进行数据库操作，但是我们一般还是推荐使用SqlSession获取到Dao接口的代理类，执行代理对象的方法，可以更安全的进行类型检查操作</li></ul><h2 id="1-5、Mybatis四大核心组件"><a href="#1-5、Mybatis四大核心组件" class="headerlink" title="1.5、Mybatis四大核心组件"></a>1.5、Mybatis四大核心组件</h2><blockquote><p>Executor</p></blockquote><p>Executor像一个管理员，协调其他三个组件完成工作。</p><ul><li>基本功能：改、查。</li><li>缓存维护：这里的缓存主要是为一级缓存服务，功能包括创建缓存Key、清理缓存、判断缓存是否存在。</li><li>事务管理：提交、回滚、关闭、批处理刷新。（一般我们都交由spring管理，不会使用mybatis的）</li><li>Executor:可包含多个statement</li></ul><p><strong>三种 Executor 解析器</strong></p><ul><li><strong>SimpleExecutor:</strong> 每执行⼀次 update 或 select，就开启⼀个 Statement 处理器对象，用完立刻刻关闭Statement 对象。</li><li><strong>ReuseExecutor:</strong> 执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使⽤，不存在就创建，⽤完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下⼀次使用。简⾔之，就是重复使用 Statement 对象</li><li><strong>BatchExecutor:</strong> 执行 update（没有 select，JDBC 批处理不⽀持 select），将所有 sql 都添加到批处理中（addBatch()），等待统⼀执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch ()批处理。与JDBC 批处理相同。</li></ul><p><strong>作用范围：</strong>Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p><p><strong>指定执行器：</strong>在 Mybatis 配置⽂件中，可以指定默认的 ExecutorType 执行器类型，也可以⼿动给DefaultSqlSessionFactory 的创建 SqlSession 的⽅法传递 ExecutorType 类型参数</p><blockquote><p>StatementHandler：</p></blockquote><p><strong>作用：</strong>JDBC处理器，基于JDBC构建并且<code>管理JDBC Statement</code>,并设置参数，然后执行Sql。每调用会话当中一次sql，都会有与之相对应的且唯一的Statement实例(命中缓存除外)。</p><ul><li>SimpleStatementHandler：对应JDBC中的Statement</li><li>PreparedStatementHandler：对应JDBC中的PreparedStatement</li><li>CallableStatementHandler：对应JDBC中的CallableStatement</li></ul><blockquote><p>ParameterHandler：</p></blockquote><p>参数映射</p><blockquote><p>ResultSetHandler：</p></blockquote><p>结果映射</p><h1 id="2、第一个MyBatis程序"><a href="#2、第一个MyBatis程序" class="headerlink" title="2、第一个MyBatis程序"></a>2、第一个MyBatis程序</h1><h2 id="2-1、创建maven项目"><a href="#2-1、创建maven项目" class="headerlink" title="2.1、创建maven项目"></a>2.1、创建maven项目</h2><p>多模块可能出现的问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Demo2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="comment">&lt;!--抄父模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wzh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Servlet-02<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>      <span class="comment">&lt;!--子模块属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>pom.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- junit测试  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis jar 包依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- log4j日志打印 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2、配置Mybatis通用配置"><a href="#2-2、配置Mybatis通用配置" class="headerlink" title="2.2、配置Mybatis通用配置"></a>2.2、配置Mybatis通用配置</h2><p>mybatis-config.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis头文件声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加数据库连接相关配置信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 加入事务控制 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;jdbc&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置数据库连接信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;pooled&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span> <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mapper 配置文件指定，配置路径为下面的映射文件xml，文件数量可配置多个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/wzh/mapper/UserMapper.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>日志文件log4j.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global logging configuration</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG, stdout</span></span><br><span class="line"><span class="comment"># Consoleoutput...</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p [%t] - %m%n</span></span><br></pre></td></tr></table></figure><h2 id="2-3、mapper文件以及解释"><a href="#2-3、mapper文件以及解释" class="headerlink" title="2.3、mapper文件以及解释"></a>2.3、mapper文件以及解释</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">namespace：命名空间配置,全局唯一</span></span><br><span class="line"><span class="comment">id：方法名</span></span><br><span class="line"><span class="comment">    parameterType：输入类型       </span></span><br><span class="line"><span class="comment">resultType：输出结果类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.wzh.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">&quot;com.wzh.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT id,name &#x27;userName&#x27;,pwd &#x27;userPwd&#x27; FROM user WHERE id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-4、业务代码实现"><a href="#2-4、业务代码实现" class="headerlink" title="2.4、业务代码实现"></a>2.4、业务代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPwd;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//工具类返回SqlSession对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">             <span class="comment">// 加载配置到内存</span></span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">             <span class="comment">// 获取SqlSessionFactory 实例化对象</span></span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getsqlsession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取session以便操作数据库，这种方式少用，应该通过接口</span></span><br><span class="line">        SqlSession session = Demo.getsqlsession();</span><br><span class="line">        User customer = session.selectOne</span><br><span class="line">                (<span class="string">&quot;com.wzh.mapper.UserMapper.queryUserById&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(customer);</span><br><span class="line">        <span class="comment">// 关闭session</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3、mybatis-config-xml文件解释"><a href="#3、mybatis-config-xml文件解释" class="headerlink" title="3、mybatis-config.xml文件解释"></a>3、mybatis-config.xml文件解释</h1><h3 id="3-1、properties配置文件"><a href="#3-1、properties配置文件" class="headerlink" title="3.1、properties配置文件"></a>3.1、properties配置文件</h3><p>1、mybatis-config.xml直接配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;url=jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>2、引用外部的properties文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--   原来几个标签修改成 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--   加入新标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>db.properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><h3 id="3-2、配置多环境"><a href="#3-2、配置多环境" class="headerlink" title="3.2、配置多环境"></a>3.2、配置多环境</h3><p>1、db.properties多加一条属性</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## development </span></span><br><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>2、mybatis-config.xml里面与之对应</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  default表示用途，这里指用于开发  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--  id对应上面的  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3、数据源解释"><a href="#3-3、数据源解释" class="headerlink" title="3.3、数据源解释"></a>3.3、数据源解释</h3><p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p><p>数据源类型有三种</p><ul><li>UNPOOLED：每次被请求时打开和关闭连接</li><li>POOLED：利用“池”的概念将 JDBC 连接对象组织起来，能快速响应请求</li><li>JNDI：能在如 EJB 或应用服务器这类容器中使用</li><li>自定义：实现DataSourceFactory接口，定义数据源的获取方式。</li></ul><p><strong>实际开发中我们使用Spring管理数据源，并进行事务控制的配置来覆盖上述配置</strong></p><h3 id="3-4、事务管理器"><a href="#3-4、事务管理器" class="headerlink" title="3.4、事务管理器"></a>3.4、事务管理器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  type指的就是事务管理器的类型  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure><ul><li>JDBC：这个配置就是直接使用了 JDBC 的提交和回滚设置</li><li>MANAGED ： 从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认情况下MANAGED会关闭连接，设置不关闭连接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;MANAGED&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;closeConnection&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：集成到Spring就不必配置，因为spring会使用覆盖Mybatis</p><h3 id="3-5、typeAliases取别名"><a href="#3-5、typeAliases取别名" class="headerlink" title="3.5、typeAliases取别名"></a>3.5、typeAliases取别名</h3><p>1、扫描方式（常用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml配置，扫描该路径下的实体类，别名为实体类名字首字母小写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.wzh.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类上使用</span></span><br><span class="line"><span class="meta">@Alias(&quot;user&quot;)</span></span><br></pre></td></tr></table></figure><p>3、手动配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.wzh.pojo.User&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、基本类型自动取别名</p><p>基本上都为小写</p><h3 id="3-6、mappers映射器"><a href="#3-6、mappers映射器" class="headerlink" title="3.6、mappers映射器"></a>3.6、mappers映射器</h3><p><strong>1、直接映射mapper文件路径</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 相对路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/wzh/mapper/UserMapper.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 绝对路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2、映射接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line">Public <span class="class"><span class="keyword">interface</span> <span class="title">CustomerDao</span></span>&#123;</span><br><span class="line"><span class="function">Customer <span class="title">queryCustomerByName</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mapper文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.wzh.dao.CustomerDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryCustomerByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">&quot;com.wzh.pojo.Customer&quot;</span>&gt;</span></span><br><span class="line">SELECT id,name &#x27;userName&#x27;,balance &#x27;userBalance&#x27; FROM information WHERE id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 映射包下所有接口（常用） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.wzh.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>两种方式对比：</strong></p><ul><li><p>接口形式：</p><ul><li><p>mybatis.xml文件映射接口的位置</p></li><li><p>mapper.xml文件里面的namesapces指定接口位置,测试代码里面获取接口位位</p><p>CustomerDao customerDao = sqlSession.getMapper(CustomerDao.class);</p><p>Customer customer = customerDao.queryCustomerByName(“name”);</p></li></ul></li><li><p>普通形式：</p><ul><li><p>mybatis.xml文件映射mapper.xml文件位置</p></li><li><p>mapper.xml文件里面的namesapces的值随意指定,测试代码要与之对应</p><p>SqlSession session=factory.openSession();</p><p>Customer c1 = session.selectOne(“com.xxx.mapper.CustomerMapper.query”, 1);</p></li></ul></li></ul><p><strong>注意点：</strong></p><ul><li>调用方法的参数需要与SQL语句里的参数一致</li><li>接口名与映射文件名称一致（非集成环境）</li><li>映射文件与接口处于同一个包中(集成环境)</li></ul><h3 id="3-7、-对象工厂（objectFactory）"><a href="#3-7、-对象工厂（objectFactory）" class="headerlink" title="3.7、 对象工厂（objectFactory）"></a>3.7、 对象工厂（objectFactory）</h3><ul><li>MyBatis 每次创建<strong>结果对象</strong>的新实例时，它都会使用一个对象工厂实例来完成。</li><li>默认的对象工厂做的仅仅是<code>实例化目标类</code>，通过默认构造方法，或通过参数构造方法。</li><li>总之主要作用就是根据一个类的类型得到该类的一个实体对象类似spring的 工厂实例化bean</li></ul><h3 id="3-8、日志工厂"><a href="#3-8、日志工厂" class="headerlink" title="3.8、日志工厂"></a>3.8、日志工厂</h3><p><img src="/img/web/%E5%9B%BE%E7%89%879.jpg"></p><p>SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</p><p>在mybatis-config.xml配置，具体使用哪个依照情况：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用log4j需要配置log4j.properties和导入依赖</p><h3 id="3-9、typeHandlers-类型处理器"><a href="#3-9、typeHandlers-类型处理器" class="headerlink" title="3.9、typeHandlers 类型处理器"></a>3.9、typeHandlers 类型处理器</h3><p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。</p><p><strong>自定义处理器：</strong>重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler，然后可以选择性地将它映射到一个 JDBC 类型。当然最后需要在在mybatis全局配置文件中注册</p><h3 id="3-10、plugins插件"><a href="#3-10、plugins插件" class="headerlink" title="3.10、plugins插件"></a>3.10、plugins插件</h3><p>插件是MyBatis提供的一个非常强大的机制，我们可以通过插件来修改MyBatis的一些核心行为。插件通过动态代理机制，可以介入<code>四大对象</code>的任何一个方法的执行。</p><p><strong>Executor</strong> (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</p><p><strong>ParameterHandler</strong> (getParameterObject, setParameters) </p><p><strong>ResultSetHandler</strong> (handleResultSets, handleOutputParameters) </p><p><strong>StatementHandler</strong> (prepare, parameterize, batch, update, query) </p><h3 id="3-11、setting设置"><a href="#3-11、setting设置" class="headerlink" title="3.11、setting设置"></a>3.11、setting设置</h3><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p><p><img src="C:\Users\admin\Desktop\Java学习笔记\Web\img\web\图片7.jpg"></p><h1 id="4、CRUD（mapper基本讲解）"><a href="#4、CRUD（mapper基本讲解）" class="headerlink" title="4、CRUD（mapper基本讲解）"></a>4、CRUD（mapper基本讲解）</h1><blockquote><p>输入类型（parameterType）</p></blockquote><p>基本数据类如int、字符串类型string、Map类型、JavaBean类型</p><ul><li>为map(JavaBean)类型时:map里面存的键的名字要与id=#{id}里面{}里的名称一致</li><li>当有多个如id=#{id}和name=#{name}时，只需要含id和name的键即可</li></ul><blockquote><p>输出类型（resultType）</p></blockquote><p>基本数据类如int、字符串类型string、Map类型、JavaBean类型</p><p>Map类型与JavaBean一致，select多个数据即可</p><p>输出的数据的字段名与SQL语句中的字段名或者别名一致</p><blockquote><p>输出类型（resultMap：解决属性名和字段名不一致的问题）</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;user_map&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span>     <span class="comment">&lt;!-- 主键 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userPwd&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;user_map&quot;</span>&gt;</span></span><br><span class="line">select id,name,pwd information where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>resultMap=”user_map”对应上面的id=”user_map”</p></li><li><p>resultMap中type=”User”表示要映射的实体类属性</p></li><li><p>id、name、balancefrom等映射成实体类中的id、userName、userBalance属性</p></li><li><p>等价于取别名：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id &#x27;id&#x27;,name &#x27;userName&#x27;,pwd &#x27;userPwd&#x27; information where id=#&#123;id&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SQL复用</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义sql语句--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;User_columns&quot;</span>&gt;</span>id,name,pwd<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span><span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用sql语句--&gt;</span></span><br><span class="line">SELECT <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;User_columns&quot;</span>/&gt;</span> FROM user WHERE id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>insert、update、delete元素</p></blockquote><p><img src="C:\Users\admin\Desktop\Java学习笔记\Web\img\web\图片8.jpg"></p><p><strong>支持自增的数据库：</strong></p><p>useGeneratedKeys=”true” <strong>keyProperty</strong>= “id” ；设置自动生成主键，主键为id</p><p><strong>不支持的：</strong>通过<strong>selectKey</strong> 子元素，查询的结果会被设置为主键。</p><p>&lt; selectKey &gt; select xxx from xxxx &lt;/ selectKey &gt; </p><p><img src="/img/web/%E5%9B%BE%E7%89%8747.jpg" alt="image-20210703115142515"></p><blockquote><p>select</p></blockquote><p><img src="/img/web/%E5%9B%BE%E7%89%8748.jpg"></p><h2 id="4-1、Select语句"><a href="#4-1、Select语句" class="headerlink" title="4.1、Select语句"></a>4.1、Select语句</h2><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出结果list</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">queryUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//输出结果为user</span></span><br><span class="line">    <span class="function">User <span class="title">queryUserByIdAndName</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.wzh.mapper.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 虽然输出结果为List&lt;User&gt;，但是只要设置为user即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span><span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        SELECT id,name &#x27;userName&#x27;,pwd &#x27;userPwd&#x27; FROM user WHERE id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置输入参数为map --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        SELECT id,name &#x27;userName&#x27;,pwd &#x27;userPwd&#x27; FROM user WHERE id=#&#123;id&#125; And name =#&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取session以便操作数据库</span></span><br><span class="line">        SqlSession session = Demo.getsqlsession();</span><br><span class="line">        UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line">        <span class="comment">//queryUserById方法</span></span><br><span class="line">        List&lt;User&gt;  list = userDao.queryUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//queryUserByIdAndName方法</span></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;wzh&quot;</span>);</span><br><span class="line">        User user = userDao.queryUserByIdAndName(map);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">// 关闭session</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用到的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">             <span class="comment">// 加载配置到内存</span></span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">             <span class="comment">// 获取SqlSessionFactory 实例化对象</span></span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getsqlsession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2、Insert语句"><a href="#4-2、Insert语句" class="headerlink" title="4.2、Insert语句"></a>4.2、Insert语句</h2><p>接口文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入一条语句，返回影响行数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUserNoKey</span><span class="params">(User user)</span></span>;</span><br><span class="line"><span class="comment">//插入一条语句，返回影响行数，同时插入的user对象自动更新id（主键）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUserHasKey</span><span class="params">(User user)</span></span>;</span><br><span class="line"><span class="comment">//插入多条语句，返回影响行数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(List&lt;User&gt; list)</span></span>;</span><br></pre></td></tr></table></figure><p>mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUserNoKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">insert into user(name,pwd) values(#&#123;userName&#125;,#&#123;userPwd&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUserHasKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>  <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">insert into user(name,pwd) values(#&#123;userName&#125;,#&#123;userPwd&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> &gt;</span></span><br><span class="line">insert into user(name,pwd) values</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">(#&#123;item.userName&#125;,#&#123;item.userPwd&#125;)</span><br><span class="line"><span class="comment">&lt;!--  循环遍历，separator是添加逗号分隔--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addUserNoKey方法</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUserPwd(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">user.setUserName(<span class="string">&quot;zk&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> number = userDao.addUserNoKey(user);</span><br><span class="line">System.out.println(number);</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">session.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//addUserHasKey方法</span></span><br><span class="line">user.setUserPwd(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">user.setUserName(<span class="string">&quot;lyx&quot;</span>);</span><br><span class="line">userDao.addUserHasKey(user);</span><br><span class="line">System.out.println(user.getId());</span><br><span class="line">session.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//addUser方法</span></span><br><span class="line">List&lt;User&gt;  list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">User user1 = <span class="keyword">new</span> User();</span><br><span class="line">user1.setUserPwd(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">user1.setUserName(<span class="string">&quot;wfk&quot;</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User();</span><br><span class="line">user2.setUserPwd(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">user2.setUserName(<span class="string">&quot;yrz&quot;</span>);</span><br><span class="line">list1.add(user1);</span><br><span class="line">list1.add(user2);</span><br><span class="line">number = userDao.addUser(list1);</span><br><span class="line">System.out.println(number);</span><br><span class="line">session.commit();</span><br></pre></td></tr></table></figure><h2 id="4-3、Update语句"><a href="#4-3、Update语句" class="headerlink" title="4.3、Update语句"></a>4.3、Update语句</h2><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新一条数据，返回更新的行数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateOneUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"><span class="comment">//更新多条数据，返回更新的行数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure><p>mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateOneUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">update user set name=#&#123;userName&#125; ,pwd=#&#123;userPwd&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">update user set name=#&#123;userName&#125; where id in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span>&gt;</span>#&#123;item&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>业务实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//updateOneUser方法</span></span><br><span class="line"><span class="comment">//user对象里面要有id属性对应mapper里面的where id=#&#123;id&#125;</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setId(<span class="number">7</span>);</span><br><span class="line">user.setUserName(<span class="string">&quot;老八&quot;</span>);</span><br><span class="line">user.setUserPwd(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(userDao.updateOneUser(user));</span><br><span class="line"><span class="comment">//updateUser方法</span></span><br><span class="line"><span class="comment">//该方法传入参数为map，里面要放入2个数据，</span></span><br><span class="line"><span class="comment">//数据1的key对应#&#123;userName&#125;，数据2的key对应collection=&quot;ids&quot;</span></span><br><span class="line">Map&lt;String,Object&gt; map =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;老八&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;ids&quot;</span>,list);</span><br><span class="line">System.out.println(userDao.updateUser(map));</span><br><span class="line">session.commit();</span><br></pre></td></tr></table></figure><h2 id="4-4、Delete语句"><a href="#4-4、Delete语句" class="headerlink" title="4.4、Delete语句"></a>4.4、Delete语句</h2><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除一条数据，返回更新的行数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"><span class="comment">//删除多条数据，返回更新的行数，参数为map</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteUserByList</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br><span class="line"><span class="comment">//删除多条数据，返回更新的行数，参数为数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteUserByArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>;</span><br></pre></td></tr></table></figure><p>mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">delete from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUserByList&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">delete from user where id in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span>&gt;</span>#&#123;item&#125;<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUserByArray&quot;</span>&gt;</span></span><br><span class="line">delete from user where id in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span>#&#123;item&#125;<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>业务代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//deleteUserById方法</span></span><br><span class="line"><span class="keyword">int</span> number = userDao.deleteUserById(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//deleteUserByList方法，参数为map</span></span><br><span class="line"><span class="comment">//map里面的key名对应mapper.xml里面collection=&quot;ids&quot;</span></span><br><span class="line"><span class="comment">//也可以传数组不传list</span></span><br><span class="line">Map&lt;String,Object&gt; map =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">&quot;ids&quot;</span>,list);</span><br><span class="line">System.out.println(userDao.deleteUserByList(map));</span><br><span class="line"><span class="comment">//deleteUserByArray方法，参数为数据</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">7</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">System.out.println(userDao.deleteUserByArray(arr));</span><br><span class="line">session.commit();</span><br></pre></td></tr></table></figure><h1 id="5、级联映射（-resultMap-association）"><a href="#5、级联映射（-resultMap-association）" class="headerlink" title="5、级联映射（ resultMap+ association）"></a>5、级联映射（ resultMap+ association）</h1><h3 id="5-1、一对一"><a href="#5-1、一对一" class="headerlink" title="5.1、一对一"></a>5.1、一对一</h3><p>resultType实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryTwoTable1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select u.id ,u.name,u.pwd,a.pwd &#x27;Pwd&#x27;</span><br><span class="line">from user u Left JOIN admin a on u.id=a.id</span><br><span class="line">where u.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>resultMap实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryTwoTable1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;baseUser&quot;</span>&gt;</span></span><br><span class="line">select u.id ,u.name,u.pwd,a.pwd &#x27;Pwd&#x27;</span><br><span class="line">from user u Left JOIN admin a on u.id=a.id</span><br><span class="line">where u.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4个字段对应Select查询的四个属性 </span></span><br><span class="line"><span class="comment"> 注意两个pwd字段一样，必须取别名，否则就会输出错误</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseUser&quot;</span> <span class="attr">type</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 主键 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 普通 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user_pwd&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;Pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;admin_pwd&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p> resultMap+ association实现</p><p>可以开启延迟加载和属性按需加载，需要设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">association里面：</span></span><br><span class="line"><span class="comment">property：结果的名字map=[&#123;admin_id=1, admin_pwd=123456&#125;]&#125;</span></span><br><span class="line"><span class="comment">column：利用哪个属性当参数，与column属性对应，不能用property属性</span></span><br><span class="line"><span class="comment">select：调用哪个Select方法</span></span><br><span class="line"><span class="comment">javaType：结果封装给哪个类的对象</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;user_Map&quot;</span> <span class="attr">type</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userPwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;map&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">select</span>=<span class="string">&quot;query2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;admin_Map&quot;</span> <span class="attr">type</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;admin_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;admin_pwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;query1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;user_Map&quot;</span>&gt;</span></span><br><span class="line">select id,name,pwd from user where id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;query2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;admin_Map&quot;</span>&gt;</span></span><br><span class="line">SELECT id,pwd  FROM admin WHERE  id=#&#123;cid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">调用query1()方法的输出结果：</span></span><br><span class="line"><span class="comment">&#123;user_id=1, userPwd=123456, userName=yrz, map=[&#123;admin_id=1, admin_pwd=123456&#125;]&#125;</span></span><br><span class="line"><span class="comment">解释： 前3个为resultMap的属性</span></span><br><span class="line"><span class="comment">  最后一个表示，利用resultMap的id属性作为参数调用query2方法查询的结果</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-2、一对多"><a href="#5-2、一对多" class="headerlink" title="5.2、一对多"></a>5.2、一对多</h3><p>只能使用resultMap实现：</p><ul><li>类似上面不过association变成了collection</li><li>javaType=”list”，因为输出多个数据</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;user_Map&quot;</span> <span class="attr">type</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userPwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;map&quot;</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">select</span>=<span class="string">&quot;query2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;admin_Map&quot;</span> <span class="attr">type</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;admin_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;admin_pwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;query1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;user_Map&quot;</span>&gt;</span></span><br><span class="line">select id,name,pwd from user where id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;query2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;admin_Map&quot;</span>&gt;</span></span><br><span class="line">SELECT id,pwd  FROM admin WHERE  pwd=#&#123;pwd&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="6、动态SQL语句"><a href="#6、动态SQL语句" class="headerlink" title="6、动态SQL语句"></a>6、动态SQL语句</h1><blockquote><p>Ognl表达式</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Ognl@isEmpty(userName)空判断</span><br><span class="line">@Ognl@isNotEmpty(userName)不为空</span><br><span class="line">@Ognl@isBlank(userName)空字符串</span><br><span class="line">@Ognl@isNotBlank(userName)不为空字符串</span><br></pre></td></tr></table></figure><p><img src="/img/web/%E5%9B%BE%E7%89%8749.jpg"></p><h3 id="6-1、if条件判断"><a href="#6-1、if条件判断" class="headerlink" title="6.1、if条件判断"></a>6.1、if条件判断</h3><p>test属性作为判断，多个条件组合判断用and，or连接</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模糊匹配 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByUserName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span> </span><br><span class="line">select id,userName,userPwd from user where 1=1 </span><br><span class="line">    <span class="comment">&lt;!-- 如果userName没值就进行模糊查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null and userName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and userName like &#x27;%$&#123;userName&#125;%&#x27; </span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-2、choose-when-otherwise"><a href="#6-2、choose-when-otherwise" class="headerlink" title="6.2、choose, when, otherwise"></a>6.2、choose, when, otherwise</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 若nation不为空就查userName的值, 否则是realName的值 --&gt;</span></span><br><span class="line">select id,userPwd </span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;nation!=null and nation!=&#x27;&#x27;&quot;</span>&gt;</span>,userName <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>,realName<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-3、trim-where-set"><a href="#6-3、trim-where-set" class="headerlink" title="6.3、trim, where, set"></a>6.3、trim, where, set</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByUserName&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;RM_User&quot;</span> &gt;</span> </span><br><span class="line">    select</span><br><span class="line">    userId, userName, password </span><br><span class="line">    from</span><br><span class="line">    user </span><br><span class="line">    where</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null and userName != &#x27;&#x27;&quot;</span> &gt;</span> </span><br><span class="line">        userName like &#x27;%$&#123;userName&#125;%&#x27; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;phone != null and phone != &#x27;&#x27;&quot;</span> &gt;</span> </span><br><span class="line">        and phone like &#x27;%$&#123;phone&#125;%&#x27; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">若userName为空且phone不为空</span></span><br><span class="line"><span class="comment">则语句为：</span></span><br><span class="line"><span class="comment">select userId, userName, password  from user where and phone like &#x27;%$&#123;phone&#125;%&#x27;</span></span><br><span class="line"><span class="comment">显然不正确</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>解决办法1：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- where会自动判断and和or是否添加或去除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;&quot;</span>&gt;</span> userName like &#x27;%$&#123;userName&#125;%&#x27; <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;&quot;</span>&gt;</span> and phone like &#x27;%$&#123;phone&#125;%&#x27; <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果是update语句，where换成set,内容为userName=#&#123;userName&#125;,有逗号 --&gt;</span></span><br></pre></td></tr></table></figure><p>解决办法2：自定义 trim 元素来定制功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">prefixOverrides会忽略通过管道分隔的文本序列(此例中的空格也是必要的)</span></span><br><span class="line"><span class="comment">prefixOverrides中指定的内容被移除，prefix 属性中指定的内容被插入</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and |or&quot;</span> &gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName !=null and userName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">userName like &#x27;%$&#123;userName&#125;%&#x27; </span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;phone!=null and phone!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and phone like &#x27;%$&#123;phone&#125;%&#x27; </span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">若是update语句</span></span><br><span class="line"><span class="comment">则：prefix=&quot;set&quot; suffixOverrides=&quot;,&quot; 内容为userName=#&#123;userName&#125;,有逗号</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-4、foreach"><a href="#6-4、foreach" class="headerlink" title="6.4、foreach"></a>6.4、foreach</h3><p>对一个集合进行遍历，比如构建 IN 条件语句或者是批量插入</p><ul><li><p>collection属性:</p><ul><li>单参数：list集合和array数组时值为list和array</li><li>多参数：Map，map的key名就是collection的属性值</li></ul></li><li><p>item：表示集合中每一个元素进行迭代时的别名，</p></li><li><p>index：指定一个名字，用于表示在迭代过程中，每次迭代到的位置，</p></li><li><p>open：表示该语句以什么开始，close：表示以什么结束</p></li><li><p>separator：表示在每次进行迭代之间以什么符号作为分隔符</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryCustomerById2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">select id,name,balance from information</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span> id in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">collection</span>=<span class="string">&quot;customerId&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">#&#123;item&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="function">List&lt;Customer&gt; <span class="title">queryCustomerById2</span><span class="params">(Map&lt;String,List&lt;Integer&gt;&gt; map)</span></span>;</span><br><span class="line"><span class="comment">//业务代码实现</span></span><br><span class="line">List&lt;Integer&gt; listId = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">listId.add(<span class="number">1</span>);</span><br><span class="line">listId.add(<span class="number">2</span>);</span><br><span class="line">Map&lt;String,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//map加入的键的属性与collection相同，value为list集合</span></span><br><span class="line">map.put(<span class="string">&quot;customerId&quot;</span>,listId);</span><br><span class="line">List&lt;Customer&gt; customer = customerDao.queryCustomerById2(map);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">[Customer&#123;id=1, userName=&#x27;wzh&#x27;, userBalance=9999.222&#125;, </span></span><br><span class="line"><span class="comment">Customer&#123;id=2, userName=&#x27;wfk&#x27;, userBalance=33333.3&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>输入参数为map类型，key的值为customerId要与foreach中collection的值相等</li><li>value的值为list<code>&lt;Integer&gt;</code>类型</li><li>foreach循环的是该list类型的值，查询id等于1和2的值</li><li>返回类型为list<code>&lt;Customer&gt;</code>类型</li></ul><h2 id="6-5、bind"><a href="#6-5、bind" class="headerlink" title="6.5、bind"></a>6.5、bind</h2><h1 id="7、注解开发"><a href="#7、注解开发" class="headerlink" title="7、注解开发"></a>7、注解开发</h1><h2 id="7-1、注解形式动态sql"><a href="#7-1、注解形式动态sql" class="headerlink" title="7.1、注解形式动态sql"></a>7.1、注解形式动态sql</h2><p>方式一、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口定义</span></span><br><span class="line"><span class="meta">@Delete(&quot;Delete from information where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteCustomerById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">userDao.deleteAdminById(<span class="number">1</span>);</span><br><span class="line">session.commit();</span><br></pre></td></tr></table></figure><p>方式二、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口定义</span></span><br><span class="line"><span class="meta">@SelectProvider(method = &quot;queryUserById&quot;,type = UserProvider.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryUser</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserProvider类定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUserById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()&#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>);</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line">String name = userDao.queryUser(<span class="number">1</span>);</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure><h2 id="7-2、-Param-详解（最好使用）"><a href="#7-2、-Param-详解（最好使用）" class="headerlink" title="7.2、@Param()详解（最好使用）"></a>7.2、@Param()详解（最好使用）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">query</span><span class="params">(<span class="meta">@Param(&quot;id1&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;query&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">select id,name &#x27;userName&#x27;,pwd &#x27;userPwd&#x27;from user where id=#&#123;id1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>@Param(“id1”)     和    id=#{id1}     要对应</li></ul><h1 id="8、缓存"><a href="#8、缓存" class="headerlink" title="8、缓存"></a>8、缓存</h1><blockquote><p>缓存：</p></blockquote><ul><li>存在内存中的临时数据</li><li>将用户经常查询的数据放在缓存中，用户去查询数据就不用从数据库查，节约资源</li></ul><p>为什么使用：</p><ul><li>减少和数据库交互次数，提高效率</li></ul><p>什么样的数据能当缓存：</p><ul><li>经常查询但是不经常改变的数据</li></ul><blockquote><p>Mybatis缓存</p></blockquote><ul><li>MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。</li><li>缓存可以极大的提高查询效率</li><li>MyBatis 自定义了两种缓存：一级缓存和二级缓存<ul><li>默认情况下，只有一级缓存开启（SqlSession级别）</li><li>二级缓存需要手动开启和配置（namespace级别）</li><li>可以通过实现Cache缓存接口自定义二级缓存</li></ul></li></ul><h2 id="8-1、一级缓存"><a href="#8-1、一级缓存" class="headerlink" title="8.1、一级缓存"></a>8.1、一级缓存</h2><ul><li><p>一级缓存也叫本地缓存，Mybatis默认开启一级缓存。</p><ul><li>与数据库<strong>一次会话期间</strong>查询到的数据会放在本地缓存中</li><li>以后再次查询时，直接从缓存哪，没必要再去查询数据库</li></ul></li><li><p>注意必须时<code>同一个SqlSession</code>执行相同的查询SQL，才能使用缓存</p></li><li><p>当发生了clearCache()、提交、或者增删改的操作，MyBatis会把SqlSession的缓存清空。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">一级缓存的范围有SESSION和STATEMENT两种，默认是SESSION，</span></span><br><span class="line"><span class="comment">如果不想使用一级缓存，可以把一级缓存的范围指定为STATEMENT，</span></span><br><span class="line"><span class="comment">这样每次执行完一个Mapper中的语句后都会将一级缓存清除</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 修改方法 mybatis-config.xml修改 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STATEMENT&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">//java代码里操作</span><br><span class="line">session.clearCache();//手动清除缓存</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>当Mybatis整合Spring后，每个Mapper的每次查询操作都对应一个全新的SqlSession实例，这个时候就不会有一级缓存的命中，但是在同一个事务中时共用的是同一个SqlSession。</p></li><li><p>只有当同一个线程开启事务时同一个sql查询多次会走一级缓存，而不开启事务时，每一查询都是不同的sqlsession，即缓存为“失效”状态</p></li></ul><h2 id="8-2、二级缓存"><a href="#8-2、二级缓存" class="headerlink" title="8.2、二级缓存"></a>8.2、二级缓存</h2><ul><li>Mybatis需要手动设置启动二级缓存<ul><li>一个会话查询一条数据，这个数据就会先放在当前会话的一级缓存中</li><li>当前会话<strong>关闭或者提交</strong>一级缓存就失效了，但是会保存到二级缓存中</li><li>新的会话查询信息就可以从二级缓存中读取内容</li></ul></li><li>同一个namespace（<code>一个mapper文件</code>）的多个sqlsession可以使用二级缓存</li><li>增删改SQL语句的时候，会<strong>强制刷新</strong>二级缓存。</li></ul><p>1、mybatis-config.xml里面开启全局缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、在需要使用的mapper.xml中使用二级缓存</p><p><strong>注意：</strong>：POJO需要实现Serializable接口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span>          </span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">eviction：策略</span></span><br><span class="line"><span class="comment">flushInterval：刷新时间</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">也可以直接<span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次查询并更新二级缓存</span></span><br><span class="line">SqlSession session1 = factory.openSession();</span><br><span class="line">UserDao userDao1 = session1.getMapper(UserDao.class);</span><br><span class="line">User user1 = userDao1.findById(<span class="number">45</span>);</span><br><span class="line"><span class="comment">//第二次查找命中二级缓存</span></span><br><span class="line">SqlSession session2 = factory.openSession();</span><br><span class="line">UserDao userDao2 = session2.getMapper(UserDao.class);</span><br><span class="line">User user2 = userDao2.findById(<span class="number">45</span>);</span><br></pre></td></tr></table></figure><blockquote><p>缓存有关设置总结</p></blockquote><p>1、全局setting的cacheEnable： – 配置二级缓存的开关。一级缓存一直是打开的。 </p><p>2、select标签的useCache属性：– 配置这个select是否使用二级缓存。一级缓存一直是使用的 </p><p>3、sql标签的flushCache属性：– 增删改默认flushCache=true。sql执行以后，会同时清空一级和二级缓存。查询默认flushCache=false。 </p><p>4、sqlSession.clearCache()：  只是用来清除一级缓存。 </p><p>5、当在某一个作用域 (一级缓存Session/二级缓存Namespaces) 进行了 C/U/D 操作后，默认该作用域下<strong>所有 select 中的缓存将被clear</strong>。</p><h2 id="8-3、查询顺序"><a href="#8-3、查询顺序" class="headerlink" title="8.3、查询顺序"></a>8.3、查询顺序</h2><p>如果二缓存开启，首先从二级缓存查询数据，如果二级缓存有则从二级缓存中获取数据， 如果二级缓存没有，从一级缓存找是否有缓存数据，如果一级缓存没有，查询数据库。</p><h2 id="8-4、自定义缓存"><a href="#8-4、自定义缓存" class="headerlink" title="8.4、自定义缓存"></a>8.4、自定义缓存</h2><p>1、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第三方缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.mapper.xml中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span> = <span class="string">“org.acme.FooMapper”</span> &gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、ehcache.xml</p><p>编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">updateCheck</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：</span></span><br><span class="line"><span class="comment">      user.home – 用户主目录</span></span><br><span class="line"><span class="comment">      user.dir – 用户当前工作目录</span></span><br><span class="line"><span class="comment">      java.io.tmpdir – 默认临时文件路径</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;./tmpdir/Tmp_EhCache&quot;</span>/&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;1800&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;259200&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">           <span class="attr">name</span>=<span class="string">&quot;cloud_user&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;5000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;1800&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;1800&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     name:缓存名称。</span></span><br><span class="line"><span class="comment">     maxElementsInMemory:缓存最大数目</span></span><br><span class="line"><span class="comment">     maxElementsOnDisk：硬盘最大缓存个数。</span></span><br><span class="line"><span class="comment">     eternal:对象是否永久有效，一但设置了，timeout将不起作用。</span></span><br><span class="line"><span class="comment">     overflowToDisk:是否保存到磁盘，当系统当机时</span></span><br><span class="line"><span class="comment">     timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</span></span><br><span class="line"><span class="comment">     timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</span></span><br><span class="line"><span class="comment">     diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.</span></span><br><span class="line"><span class="comment">     diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</span></span><br><span class="line"><span class="comment">     diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</span></span><br><span class="line"><span class="comment">     memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</span></span><br><span class="line"><span class="comment">     clearOnFlush：内存数量最大时是否清除。</span></span><br><span class="line"><span class="comment">     memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。</span></span><br><span class="line"><span class="comment">     FIFO，first in first out，这个是大家最熟的，先进先出。</span></span><br><span class="line"><span class="comment">     LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。</span></span><br><span class="line"><span class="comment">     LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="9、Mybatis分页"><a href="#9、Mybatis分页" class="headerlink" title="9、Mybatis分页"></a>9、Mybatis分页</h1><h2 id="9-1、通过SQL语句实现"><a href="#9-1、通过SQL语句实现" class="headerlink" title="9.1、通过SQL语句实现"></a>9.1、通过SQL语句实现</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 从第3行数据开始显示，显示3个数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAdmin&quot;</span>  <span class="attr">resultType</span>=<span class="string">&quot;admin&quot;</span>&gt;</span></span><br><span class="line">    SELECT id &#x27;admin_id&#x27;,pwd &#x27;admin_pwd&#x27;  FROM admin LIMIT 3,3</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9-2、分页插件实现"><a href="#9-2、分页插件实现" class="headerlink" title="9.2、分页插件实现"></a>9.2、分页插件实现</h2><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、mybatis.xml添加插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- com.github.pagehelper 为 PageHelper 类所在包名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该参数默认为 false --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置为 true 时，会将 RowBounds 第一个参数 offset 当成 pageNum 页码使用 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 和 startPage 中的 pageNum 效果一样 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;offsetAsPageNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该参数默认为 false --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置为 true 时，使用 RowBounds 分页会进行 count 查询 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rowBoundsWithCount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全 部的结果 --&gt;</span> <span class="comment">&lt;!-- （相当于没有执行分页查询，但是返回结果仍然是 Page 类型） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pageSizeZero&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 3.3.0 版本可用 - 分页参数合理化，默认 false 禁用 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 启用合理化时，如果 pageNum&lt;1 会查询第一页，如果 pageNum&gt;pages 会查询 最后一页 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 禁用合理化时，如果 pageNum&lt;1 或 pageNum&gt;pages 会返回空数据 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;reasonable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 3.5.0 版本可用 - 为了支持 startPage(Object params)方法 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 增加了一个`params`参数来配置参数映射，用于从 Map 或 ServletRequest 中取值 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射 的用默认值 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;params&quot;</span> <span class="attr">value</span>=<span class="string">&quot;pageNum=start;pageSize=limit;pageSizeZero=zero;reasonable=heli;count=countsql&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置页面的大小和现实第几页</span></span><br><span class="line">PageHelper.startPage(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//查询结果为userlist</span></span><br><span class="line">List&lt;User&gt; userlist = userDao.queryUserById();</span><br><span class="line"><span class="comment">//把查询结果用插件处理</span></span><br><span class="line">PageInfo&lt;User&gt; userPageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(userList);</span><br><span class="line"><span class="comment">//插件处理的结果转换</span></span><br><span class="line">List&lt;User&gt; list = userPageInfo.getList();</span><br><span class="line"><span class="keyword">for</span>(User users:list) &#123;</span><br><span class="line">System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用方法在官网：<a href="https://pagehelper.github.io/">https://pagehelper.github.io/</a></p><h1 id="10、完整项目配置"><a href="#10、完整项目配置" class="headerlink" title="10、完整项目配置"></a>10、完整项目配置</h1><h2 id="1、pom-xml"><a href="#1、pom-xml" class="headerlink" title="1、pom.xml"></a>1、pom.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- junit测试  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis jar 包依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- log4j日志打印 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 分页插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第三方缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、log4j-properties"><a href="#2、log4j-properties" class="headerlink" title="2、log4j.properties"></a>2、log4j.properties</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global logging configuration</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG, stdout</span></span><br><span class="line"><span class="comment"># Consoleoutput...</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p [%t] - %m%n</span></span><br></pre></td></tr></table></figure><h2 id="3、db-properties"><a href="#3、db-properties" class="headerlink" title="3、db.properties"></a>3、db.properties</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><h2 id="4、mybatis-config-xml"><a href="#4、mybatis-config-xml" class="headerlink" title="4、mybatis-config.xml"></a>4、mybatis-config.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis头文件声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加数据库连接相关配置信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  设置日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  开启缓存 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  取别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.wzh.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 加入事务控制 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;Jdbc&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置数据库连接信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;pooled&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mapper 配置文件指定，配置路径为下面的映射文件xml，文件数量可配置多个--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 映射mapper文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.wzh.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5、mapper-xml"><a href="#5、mapper-xml" class="headerlink" title="5、mapper.xml"></a>5、mapper.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.wzh.mapper.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启第三方 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6、工具类"><a href="#6、工具类" class="headerlink" title="6、工具类"></a>6、工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getsqlsession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = Demo.getsqlsession();</span><br><span class="line"><span class="comment">//userDao为接口</span></span><br><span class="line">UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line">String name = userDao.queryUser(<span class="number">1</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="comment">// 关闭session</span></span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><h1 id="11、MyBatis常见面试题"><a href="#11、MyBatis常见面试题" class="headerlink" title="11、MyBatis常见面试题"></a>11、MyBatis常见面试题</h1><blockquote><p>#{}   和  ${} 的区别</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> #&#123;name&#125;;<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> $&#123;name&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="operator">!</span><span class="comment">-- 解析之后的结果均为 --&gt;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zhangsan&#x27;</span>;</span><br></pre></td></tr></table></figure><p>但是 #{} 和 ${} 在预编译中的处理是不一样的。</p><p><strong>#{} 在预处理时，会把参数部分用一个占位符 ? 代替，变成如下的 sql 语句：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure><p><strong>而 ${} 则只是简单的字符串替换，在动态解析阶段，该 sql 语句会被解析成</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zhangsan&#x27;</span>;</span><br></pre></td></tr></table></figure><p>以上，#{} 的参数替换是发生在 DBMS 中，而 ${} 则发生在动态解析过程中。</p><p><strong>总结：</strong></p><ul><li>优先使用 #{}。因为 ${} 会导致 sql 注入的问题。</li><li>mybatis #{}相当于prepareStatement, ${}相当于Statement</li></ul><blockquote><p>Xml 映射文件中，除了常见的增删改查标签外还有哪些标签</p></blockquote><ul><li>&lt; resultMap &gt; 、 &lt; parameterMap &gt; 、 &lt; sql &gt; 、 &lt; include &gt; 、 &lt; selectKey &gt; ，</li><li>加上动态 sql 的 9个标签，trim | where | set | foreach | if | choose | when | otherwise | bind 。 </li></ul><p>其中为 sql 片段标签，通过&lt; include &gt; 标签引⼊ sql 片段， &lt; selectKey &gt; 为不支持自增的主键生成策略标签</p><blockquote><p>通过接口与XML配合，原理？Dao接口里的能重载吗？</p></blockquote><p><strong>无法重载：</strong>每一个增删改查标签的SQL语句都会被解析成为一个MappedStatement 对象，每个该对象的确定是由<code>接口全限名 + 方法名</code>确定的，不能依靠参数区分，所以<code>无法重载</code>。</p><p><strong>原理：</strong>Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 MappedStatement 所代表的 sql，然后将 sql 执行结果返回。</p><blockquote><p>Mybatis 执行，能返回数据库主键列表吗？</p></blockquote><p>能，因为JDBC可以，而Mybatis只是对JDBC的封装。</p><blockquote><p>动态SQL的作用和原理</p></blockquote><p>Mybatis 动态 sql 可以让我们在 Xml 映射⽂件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，Mybatis 提供了 9 种动态 sql 标签trim | where | set | foreach | if | choose | when | otherwise | bind 。</p><p><strong>原理：</strong>使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p><blockquote><p>SQL语句执行的结果，MyBatis是如何封装成Java对象的？</p></blockquote><p>首先需要保证字段名称一致性，可以通过 1、ResultMap  2、取别名</p><p>然后ResultSetHandler会把查询的结果封装成Java的类型，接着是Mybatis的对象工厂会使用反射帮助我们创建对象，最后对象会被赋值，那些找不到映射关系的属性，是无法完成赋值的。</p><blockquote><p>Mybatis的一对一，一对多查询方式？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非接口方式</span></span><br><span class="line">User customer = session.selectOne(<span class="string">&quot;xxxxx.query&quot;</span>, <span class="number">1</span>); <span class="comment">// 一对一、多对一</span></span><br><span class="line">List&lt;User&gt; c = session.selectList(<span class="string">&quot;xxxxx.query&quot;</span>, <span class="number">1</span>); <span class="comment">// 多对一、多对多</span></span><br><span class="line"><span class="comment">// List也可以改成Map</span></span><br><span class="line">Map&lt;Integer, User&gt; map = session.selectMap(<span class="string">&quot;cn.bjsxt.mapper.UserMapper.selAll&quot;</span>, <span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口方式</span></span><br></pre></td></tr></table></figure><p><strong>关联对象查询的两种方式：</strong></p><ol><li>SQL语句中使用 join 进行连接。</li><li>使用 ResultMap + Association 的方式组合两条SQL，第一条SQL查询的结果作为第二条SQL查询的条件。第二条的查询结果会作为第一条的一个字段；最终返回的条数是第一条SQL的结果条数。</li></ol><blockquote><p>Mybatis的延迟加载？</p></blockquote><p><strong>部分支持：</strong>仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是⼀对⼀，collection 指的就是⼀对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false</p><p><strong>原理：</strong>使用Cglib 创建目标对象的代理对象。</p><blockquote><p>不同XMl文件的id是否可以重复？</p></blockquote><ul><li>如果配置了 namespace，那么 id 可以重复；</li><li>如果没有配置namespace，那么 id 不能重复；</li></ul><p><strong>原因：</strong>通过 namespace + id 共同确定的 sql。</p><blockquote><p>是否可以映射枚举类</p></blockquote><p>可以，Mybatis 可以映射任何对象到表的⼀列上。</p><p><strong>原因：</strong>可以自定义 TypeHandler 处理器完成映射。</p><p>映射方式为自定义⼀个 TypeHandler ，实现 TypeHandler 的 setParameter() 和 getResult()接口方法。 TypeHandler 有两个作⽤，⼀是完成从 javaType ⾄ jdbcType 的转换，⼆是完成jdbcType 至 javaType 的转换，体现为 setParameter() 和 getResult() 两个⽅法，分别代表设置sql 问号占位符参数和获取列查询结果。</p><blockquote><p>A 标签通过 include引⽤了 B标签的内容，请问，B 标签能否定义在 A 标签的后面</p></blockquote><p>可以，A 标签解析的时候如果没有 还没有解析 B，就会设置为未解析状态，等全部解析完成，会继续把未解析的解析完成。</p><blockquote><p>Mybatis为什么为半自动的Orm框架</p></blockquote><p>原因：需要自己写SQL，全自动的是把数据库转换成 实体类</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb(三):SpringMvc框架</title>
      <link href="/2021/07/01/Web/JavaWeb%20(%20%E4%B8%89%20)%20SpringMVC/"/>
      <url>/2021/07/01/Web/JavaWeb%20(%20%E4%B8%89%20)%20SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="1、MVC三层架构"><a href="#1、MVC三层架构" class="headerlink" title="1、MVC三层架构"></a>1、MVC三层架构</h1><p>什么是MVC：Model、view、Controller            模型、视图、控制器</p><ul><li><p>Model：处理业务（Service）、数据持久化（Dao）</p></li><li><p>View：展示数据、提供链接发起Servlet请求</p></li><li><p>Controller：接收用户请求（request）、交给业务层处理对应的代码、控制视图的跳转</p><p>登录——&gt;接收用户请求—–&gt;处理用户请求（获取参数）——&gt;给业务层处理（判断密码是否正确）——&gt;Dao层查询用户名和密码是否正确</p></li></ul><p>实体类：20个数据           User类20字段</p><p>前端：用户名、密码       UserVo类2字段</p><blockquote><p>MVC架构之前</p></blockquote><p>Mode1时代：整个 Web 应用几乎全部用 JSP页面组成，只⽤少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层又是表现层。显而易见，这种模式存在很多问题。比如①将控制逻辑和表现逻辑混杂在⼀起，导致代码重用率极低；②前端和后端相互依赖，难以进行测试并且开发效率极低；</p><p>Model2时代：Java Bean(Model)+ JSP（View）+Servlet（Controller）</p><h1 id="2、Servlet-JSP回顾"><a href="#2、Servlet-JSP回顾" class="headerlink" title="2、Servlet+JSP回顾"></a>2、Servlet+JSP回顾</h1><p>创建子项目，然后右键子项目”点击”添加框架支持”，添加”Web应用程序”</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 前端 --&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;/SpringMVC_Demo_01_war_exploded/hello&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;method&quot;</span>/&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Servlet</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、获取前端参数</span></span><br><span class="line">        String method = req.getParameter(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(method.equals(<span class="string">&quot;add&quot;</span>))&#123;</span><br><span class="line">            req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;执行了add方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(method.equals(<span class="string">&quot;delete&quot;</span>))&#123;</span><br><span class="line">            req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;执行了delete方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调用业务层方法</span></span><br><span class="line">        <span class="comment">//3.视图转发或者重定向</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/jsp/test.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 重定向页面 --&gt;</span><br><span class="line">$&#123;msg&#125;</span><br></pre></td></tr></table></figure><h1 id="3、SpringMVC流程与简单实现"><a href="#3、SpringMVC流程与简单实现" class="headerlink" title="3、SpringMVC流程与简单实现"></a>3、SpringMVC流程与简单实现</h1><p>对于MVC三层架构的扩展。一种基于 Java 的实现了 Web MVC 设计思想的请求驱动类型的轻量级 Web 框架，即<strong>使用了</strong> <strong>MVC</strong> <strong>架构</strong>模式的思想，将 web 层进行职责解耦<strong>，</strong>基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring MVC 也是要简化我们日常 Web 开发的。</p><ul><li>轻量级，简单易学</li><li>高效，基于请求响应的MVC框架</li><li>与Spring无缝结合</li><li>约定大于配置</li><li>功能强大：Restful、数据验证、格式化、本地化、主题等</li></ul><h2 id="3-1、工作流程"><a href="#3-1、工作流程" class="headerlink" title="3.1、工作流程"></a>3.1、工作流程</h2><p>前端控制器DispatcherServlet：</p><ul><li>本质上是一个servlet对所有的servlet进行管理</li><li>使用了 适配器模式适配 Controller</li></ul><p><strong>DispatcherServlet的核心方法，所有请求都经过该方法</strong></p><p><img src="/img/web/%E5%9B%BE%E7%89%8712.jpg"></p><p><img src="/img/web/%E5%9B%BE%E7%89%8713.jpg"></p><ol><li><p>用户发送请求,请求被<strong>前端控制器</strong>捕获</p></li><li><p><strong>前端控制器</strong>对请求的URL进行解析，获得URI，再根据URI调用<strong>处理器映射器</strong></p></li><li><p><strong>前端控制器</strong>获得返回的HandlerExecutionChain(包括Handler对象及其对应的拦截器）</p></li><li><p><strong>前端控制器</strong>根据获得的HandlerExecutionChain，选择一个合适的<strong>处理器适配器</strong></p><ul><li>如果成功获得 HandlerAdapter 后，此时将开始 执行拦截器的 preHandler(…)方法</li></ul></li><li><p><strong>处理器适配器</strong>提取Request中的模型数据,填充Handler入参并执行<strong>处理器（即自己写的类方法）</strong></p><p>填充 Handler的入参过程中，根据配置Spring将做一些额外的工作：</p><ul><li>HttpMessageConveter：将请求消息如Json转换成一个对象，再转为响应信息。</li><li>数据转换：对请求消息进行数据转换。</li><li>数据格式化：对请求消息进行数据格式化。 </li><li>数据验证： 验证数据的有效性如长度、格式等，结果存储到BindingResult或Error </li></ul></li><li><p><strong>处理器（即自己写的类方法）</strong>执行完毕，返回一个 ModelAndView给<strong>处理器适配器</strong></p></li><li><p><strong>处理器适配器</strong>将执行结果 ModelAndView 返回给<strong>前端控制器</strong></p></li><li><p><strong>前端控制器</strong>接收到 ModelAndView 后，请求对应的<strong>视图解析器</strong>。</p></li><li><p><strong>视图解析器</strong>解析 ModelAndView后返回对应<strong>视图</strong></p></li><li><p><strong>渲染视图</strong>并返回渲染后的视图给<strong>前端控制器</strong>。</p></li><li><p><strong>前端控制器</strong>将渲染后的页面响应给用户或客户端</p></li></ol><blockquote><p>总结</p></blockquote><ol><li><code>前端控制器</code>捕获请求，解析URI之后，选择并传递请求给<code>处理器映射器</code>，获取<code>处理器执行链</code>（包括处理器和处理器对应的拦截器）</li><li>前端控制器把 <code>处理器执行链</code> 交给<code>处理器适配器</code>处理，这里先进行拦截器的拦截，然后处理器适配器会负责提取参数 给<code>处理器</code>执行，处理器最后返回 ModelAndView  。</li><li>前端控制器接收 ModelAndView  给<code>视图解析器</code>解析之后，再给<code>视图</code>进行渲染，然后把页面传会给服务端。</li></ol><h2 id="3-2、Hello-SpringMVC实现"><a href="#3-2、Hello-SpringMVC实现" class="headerlink" title="3.2、Hello SpringMVC实现"></a>3.2、Hello SpringMVC实现</h2><p>1、创建父项目，添加依赖后，不用模板创建子模块（需要右键项目，添加框架中添加web支持）</p><p>2、配置web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注册前端控制器 springmvc架构的核心 框架的入口 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet 请求分发器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关联配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示启动容器时初始化该 Servlet --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这是拦截请求, /代表拦截所有请求,不包括jsp /* 会拦截jsp--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、配置servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加处理映射器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加处理器适配器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加视图解析器  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器 默认的视图解析器- --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;defaultViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 前缀  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后缀  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置的controller --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wzh.controller.HelloController&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、新建类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//ModelAndView 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">//封装对象，放在里面</span></span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;HelloSpringMvc&quot;</span>);</span><br><span class="line">        <span class="comment">//封装要跳转的视图</span></span><br><span class="line">        mv.setViewName(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// /WEB_INF/jsp/hello.jsp</span></span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、jsp文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;msg&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3、Hello-SpringMVC注解实现"><a href="#3-3、Hello-SpringMVC注解实现" class="headerlink" title="3.3、Hello SpringMVC注解实现"></a>3.3、Hello SpringMVC注解实现</h2><p>1、pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖   --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- junit 测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring webmvc --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- servlet --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jsp --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jstl --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  加载资源   --&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzh.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    支持mvc注解驱动</span></span><br><span class="line"><span class="comment">        在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">        要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">        必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">        和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">        这两个实例分别在类级别和方法级别处理。</span></span><br><span class="line"><span class="comment">        而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、HelloController.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/HelloController&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//真实访问地址 : 项目名/HelloController/hello</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//向模型中添加属性msg与值，可以在JSP页面中取出并渲染</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello,SpringMVC&quot;</span>);</span><br><span class="line">        <span class="comment">//跳转到web-inf/jsp/hello.jsp</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、后台</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;msg&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4、404问题（重要）"><a href="#3-4、404问题（重要）" class="headerlink" title="3.4、404问题（重要）"></a>3.4、404问题（重要）</h2><p>注意：有时候会报错404，</p><p>原因：tomacat里面没有环境</p><p>解决办法：lib目录下添加项目的jar包，记得变更依赖后重新配置</p><p><img src="/img/web/%E5%9B%BE%E7%89%8714.jpg"></p><h1 id="4、SpringMVC注解特性"><a href="#4、SpringMVC注解特性" class="headerlink" title="4、SpringMVC注解特性"></a>4、SpringMVC注解特性</h1><h2 id="4-1、-Controller注解"><a href="#4-1、-Controller注解" class="headerlink" title="4.1、@Controller注解"></a>4.1、@Controller注解</h2><ul><li>注解在类上表示控制器，代表被Spring接管</li><li>负责将请求转换成 一个模型（ModelAndView）。</li></ul><h3 id="1、注解使用-Controller（接口也能实现）"><a href="#1、注解使用-Controller（接口也能实现）" class="headerlink" title="1、注解使用@Controller（接口也能实现）"></a>1、注解使用@Controller（接口也能实现）</h3><p>新建类添加@Controller，@RequestMapping(“/t2”)，xml配置，表示访问路径为t2</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzh.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>使用之后再加上@RsponseBody注解，则返回 JSON 数据。</p><h3 id="2、-RestController"><a href="#2、-RestController" class="headerlink" title="2、@RestController"></a>2、@RestController</h3><p>在类上直接使用 <strong>@RestController</strong> ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！</p><h2 id="4-2、-RequestMapping"><a href="#4-2、-RequestMapping" class="headerlink" title="4.2、@RequestMapping"></a>4.2、@RequestMapping</h2><ul><li><p><strong>注解在类或者方法上面</strong></p></li><li><p>用于映射url到控制器类或一个特定的处理程序方法</p></li><li><p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p></li><li><p>可以配置多个</p></li></ul><p><strong>参数详解：</strong></p><ul><li><strong>value：</strong>指定请求的 URL。（和 path 属性的作用一样）</li><li><strong>method：</strong>用于指定请求的方式。</li><li><strong>params：</strong>用于指定限制请求参数的条件。支持简单的表达式。<ul><li>params = {“accountName”}，表示请求参数必须有 accountName</li><li>params = {“moeny!100”}，表示请求参数中 money 不能是 100</li></ul></li><li><strong>headers：</strong>指定限制请求消息头的条件。</li><li><strong>consumes：</strong>筛选指定Content-Type值</li><li><strong>produces：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;test01&quot;,method = RequestMethod.get)</span></span><br></pre></td></tr></table></figure><h2 id="4-3、-RequestParam注解"><a href="#4-3、-RequestParam注解" class="headerlink" title="4.3、@RequestParam注解"></a>4.3、@RequestParam注解</h2><blockquote><p>作用概述</p></blockquote><ul><li><p><strong>注解在方法的形参前</strong></p></li><li><p>用于接收基本数据类型及其包装类</p></li><li><p>把请求中指定名称的参数给控制器中的形参赋值</p></li></ul><blockquote><p>参数详解：</p></blockquote><ul><li><p>value：请求参数中的名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getArrayParams(<span class="meta">@RequestParam(value=&quot;id&quot;)</span><span class="keyword">int</span> ids)</span><br><span class="line"><span class="comment">//传的参数名字为id，不用为ids</span></span><br></pre></td></tr></table></figure></li><li><p>required：请求参数中是否必须提供此参数。默认值：true，表示必须提供。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getArrayParams(@RequestParam(required=&quot;flase&quot;)int id)</span><br></pre></td></tr></table></figure></li><li><p>defaultValue：为参数设置默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getArrayParams(<span class="meta">@RequestParam(defaultValue=&quot;1&quot;)</span><span class="keyword">int</span> id)</span><br><span class="line"><span class="comment">//不传参数时，id默认为1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-4、-PathVaribale"><a href="#4-4、-PathVaribale" class="headerlink" title="4.4、@PathVaribale"></a>4.4、@PathVaribale</h3><ul><li>用于Restful风格</li><li>也可以设置required属性</li></ul><h2 id="4-5、-ResponseBody和-RequestBody"><a href="#4-5、-ResponseBody和-RequestBody" class="headerlink" title="4.5、@ResponseBody和@RequestBody"></a>4.5、@ResponseBody和@RequestBody</h2><h3 id="1、-ResponseBody"><a href="#1、-ResponseBody" class="headerlink" title="1、@ResponseBody"></a>1、@ResponseBody</h3><ul><li><strong>注解在方法上</strong></li><li>返回的结果直接写入HTTP响应正文，一般在异步获取数据时使用。</li><li>使用@RequestMapping 后，返回值通常解析为跳转路径，加上@Responsebody 后返回结果就不会被解析为跳转路径，而是直接写入HTTP 响应正文中。 </li></ul><blockquote><p>使用时机 </p></blockquote><ul><li>将方法的返回值以 <code>json/xml</code> 的数据格式返回给客户端</li><li>如果是map或者javabean类型，就会转换成 <code>json/xml</code> </li><li>如果是String类型，会变成在正常的Json串前后加上双引号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/findById&quot;)</span></span><br><span class="line"><span class="comment">//注解在方法头上，返回 json/xml</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">findById</span><span class="params">(<span class="meta">@RequestParam</span> Long id)</span> </span>&#123;</span><br><span class="line">    User user = userService.findById(id);</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.success(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、-RequestBody"><a href="#2、-RequestBody" class="headerlink" title="2、@RequestBody"></a>2、@RequestBody</h3><ul><li><p><strong>注解在方法的形参前</strong></p></li><li><p>把前台发送过来固定格式的数据（XML/JSON）封装为对应的 JavaBean 对象</p></li><li><p>封装时使用系统默认配置的 HttpMessageConverter进行解析（get 请求方式不适用）</p></li><li><p>如果是前端页面传参时，需要手动设置 <code>contentType: &quot;application/json&quot;</code>,默认的为 ``application/x-www-form-urlencoded`。</p></li><li><p>required：是否必须有请求体。默认值是true。</p><ul><li>当取值为 true 时，数据不对时，会报错。</li><li>如果取值为 false，得到是 null。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/findById&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">// 注解在形参前，用于接收 json/xml</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">findById</span><span class="params">(<span class="meta">@RequestBody(required = true)</span> User testUser)</span> </span>&#123;</span><br><span class="line">    User user = userService.findById(testUser.getId());</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.success(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6、SessionAttributes和SessionAttribute"><a href="#4-6、SessionAttributes和SessionAttribute" class="headerlink" title="4.6、SessionAttributes和SessionAttribute"></a>4.6、SessionAttributes和SessionAttribute</h2><h3 id="1、-SessionAttributes"><a href="#1、-SessionAttributes" class="headerlink" title="1、@SessionAttributes"></a>1、@SessionAttributes</h3><ul><li><strong>注解在类上</strong>，把ModeAndView 指定的参数 的作用域 级别提升到Session。</li><li>value：指定存入的属性名称</li><li>type：指定存入的数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该注解放在类控制器上</span></span><br><span class="line"><span class="meta">@SessionAttributes(value = &#123;&quot;name&quot;&#125;)</span> <span class="comment">//把name=极多人小红存入session域中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">annotationController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;testSessionAttribute&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testSessionAttribute</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//底层会存入request域对象中</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;极多人小红&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从session域中获取值</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;testGetSessionAttribute&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testGetSessionAttribute</span><span class="params">(ModelMap modelMap)</span></span>&#123;</span><br><span class="line">        String name = (String)modelMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除session域中的值  </span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;testDelSessionAttribute&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testDelSessionAttribute</span><span class="params">(SessionStatus session)</span></span>&#123;</span><br><span class="line">        session.setComplete();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//jsp页面取值</span></span><br><span class="line">$&#123;requestScope.name&#125;  &lt;!-- request域 --&gt;</span><br><span class="line">$&#123;sessionScope&#125;&lt;!-- session域 --&gt;</span><br></pre></td></tr></table></figure><h3 id="2、-SessionAttribute"><a href="#2、-SessionAttribute" class="headerlink" title="2、@SessionAttribute"></a>2、@SessionAttribute</h3><ul><li>获取存储在session中的属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/info&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">userInfo</span><span class="params">(<span class="meta">@SessionAttribute(&quot;user&quot;)</span> User user)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Email: &quot;</span> + user.getEmail());</span><br><span class="line">      System.out.println(<span class="string">&quot;First Name: &quot;</span> + user.getFname());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="4-7、-ModelAttribute注解"><a href="#4-7、-ModelAttribute注解" class="headerlink" title="4.7、@ModelAttribute注解"></a>4.7、@ModelAttribute注解</h2><ul><li><strong>注解在方法上</strong>，该类的任何方法调用前都会调用注解的方法，</li><li>value：用于获取数据的key，可以是 POJO属性名或map结构的 key。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span>     <span class="comment">//可以把方法设置返回值为Map，这样参数不用设置map</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUsers</span><span class="params">(String name, Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(name!=<span class="keyword">null</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;调用ModelAttribute&quot;</span>);</span><br><span class="line">List&lt;Phone&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">phone1.setNum(<span class="string">&quot;131&quot;</span>);</span><br><span class="line">list.add(phone1);</span><br><span class="line"><span class="comment">//模拟从数据库中获取的对象。</span></span><br><span class="line">    <span class="comment">//new一个user对象，并赋值</span></span><br><span class="line">User users = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;123&quot;</span>,<span class="number">20</span>,<span class="number">32.3</span>,list);</span><br><span class="line">System.out.println(<span class="string">&quot;从数据库中获取一个对象&quot;</span>+users);</span><br><span class="line">    <span class="comment">//把user对象放到map里，设置为user键的值</span></span><br><span class="line">map.put(<span class="string">&quot;user&quot;</span>,users);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;getObject&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getObject</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">http:<span class="comment">//localhost:8080/getObject?id=1&amp;name=wzh&amp;age=20</span></span><br><span class="line">输出：</span><br><span class="line">调用ModelAttribute从数据库中获取一个对象</span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">&#x27;123&#x27;</span>, age=<span class="number">20</span>, balance=<span class="number">32.3</span>, phones=[Phone&#123;num=<span class="string">&#x27;131&#x27;</span>&#125;]&#125;</span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">&#x27;wzh&#x27;</span>, age=<span class="number">20</span>, balance=<span class="number">32.3</span>, phones=[Phone&#123;num=<span class="string">&#x27;131&#x27;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><p>执行流程</p><ul><li>调用getObject方法时传的user里必须含name属性（getUsers的参数一），否则报错</li><li>先执行getUsers方法，name作为参数创建user对象并赋值，并存入map集合中，</li><li>map集合里键的名字为user，与getObject方法里的对应，值当做传入的user对象默认值</li><li>传入的值，id=1&amp;name=wzh&amp;age=20对默认值进行覆盖</li></ul><h2 id="4-8、-RequestHeader"><a href="#4-8、-RequestHeader" class="headerlink" title="4.8、@RequestHeader"></a>4.8、@RequestHeader</h2><ul><li><strong>注解在方法的形参前</strong></li><li>将请求头中的属性值绑定到处理方法的入参中，用于获取消息信息头</li><li>value：提供消息头名称</li><li>defaultValue：默认值</li><li>required：是否必须有此消息头</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="meta">@RequestHeader(value = &quot;Accept&quot;)</span> String header)</span></span>&#123;</span><br><span class="line">    System.out.println(header);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-9、CookieValue"><a href="#4-9、CookieValue" class="headerlink" title="4.9、CookieValue"></a>4.9、CookieValue</h2><ul><li><p><strong>作用在方法的形参前</strong></p></li><li><p>把指定 cookie 名称的值传入控制器方法参数</p></li><li><p>value：指定 cookie 的名称。</p></li><li><p>required：是否必须有此 cookie</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="meta">@CookieValue(value = &quot;JSESSIONID&quot;)</span> String cookieValue)</span></span>&#123;</span><br><span class="line">System.out.println(cookieValue);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、ModelAndView-模型视图类"><a href="#5、ModelAndView-模型视图类" class="headerlink" title="5、ModelAndView 模型视图类"></a>5、ModelAndView 模型视图类</h1><ul><li>ModelAndView 中的Model代表模型，View代表视图。</li><li>显示的数据存储到了Model属性中，要跳转的视图信息存储到view 属性，作用域为Request。</li></ul><h3 id="1、配置视图解析器"><a href="#1、配置视图解析器" class="headerlink" title="1、配置视图解析器"></a>1、配置视图解析器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 前缀跳转的视图页面前缀 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 后缀跳转的是jsp页面 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">indexTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">ModelAndView modelAndViewnew = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"><span class="comment">//设置跳转的页面</span></span><br><span class="line">modelAndViewnew.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line"><span class="comment">//设置元素和值</span></span><br><span class="line">modelAndViewnew.addObject(<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;SpringMvc&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> modelAndViewnew;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、数据接受和处理"><a href="#6、数据接受和处理" class="headerlink" title="6、数据接受和处理"></a>6、数据接受和处理</h1><h2 id="6-1、接收参数"><a href="#6-1、接收参数" class="headerlink" title="6.1、接收参数"></a>6.1、接收参数</h2><h3 id="1、提交的域名称和处理方法的参数名一致"><a href="#1、提交的域名称和处理方法的参数名一致" class="headerlink" title="1、提交的域名称和处理方法的参数名一致"></a>1、提交的域名称和处理方法的参数名一致</h3><p>提交数据 : <a href="http://localhost:8080/hello?name=wzh">http://localhost:8080/hello?name=wzh</a></p><p>处理方法 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出 : wzh</p><h3 id="2、提交的域名称和处理方法的参数名不一致"><a href="#2、提交的域名称和处理方法的参数名不一致" class="headerlink" title="2、提交的域名称和处理方法的参数名不一致"></a>2、提交的域名称和处理方法的参数名不一致</h3><p>提交数据 : <a href="http://localhost:8080/hello?username=wzh">http://localhost:8080/hello?username=wzh</a></p><p>处理方法 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RequestParam(&quot;username&quot;) : username提交的域的名称 .</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出 : wzh</p><h3 id="3、提交的是一个对象"><a href="#3、提交的是一个对象" class="headerlink" title="3、提交的是一个对象"></a>3、提交的是一个对象</h3><p>要求提交的表单域和对象的属性名一致  , 参数使用对象即可</p><p>1、实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="comment">//构造</span></span><br><span class="line">   <span class="comment">//get/set</span></span><br><span class="line">   <span class="comment">//tostring()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、提交数据 : <a href="http://localhost:8080/mvc04/getUser?name=wzh&amp;id=1&amp;age=15">http://localhost:8080/mvc04/getUser?name=wzh&amp;id=1&amp;age=15</a></p><p>3、处理方法 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">   System.out.println(user);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出 : User { id=1, name=’wzh, age=15 }</p><p><strong>注意：</strong>如果使用对象的话，前端传递的参数名和对象字段名必须一致，否则就是null。</p><h3 id="4、其他情况"><a href="#4、其他情况" class="headerlink" title="4、其他情况"></a>4、其他情况</h3><ul><li><p>数组：(@RequestParam(value=”ids”)int[] ids 所有的ids 会放进数组中)</p></li><li><p>list集合：必须绑定到对象里，不能直接传</p></li><li><p>set集合：必须绑定到对象里，不能直接传</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定 Set 数据时，必须先在 Set 对象中 add 相应的数量的模型对象。</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Phone&gt; phones=<span class="keyword">new</span> HashSet&lt;Phone&gt;(); </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    phones.add(<span class="keyword">new</span> Phone()); </span><br><span class="line">    phones.add(<span class="keyword">new</span> Phone()); </span><br><span class="line">    phones.add(<span class="keyword">new</span> Phone()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>map集合：必须绑定到对象里，不能直接传</p></li></ul><h2 id="6-2、数据显示到前端"><a href="#6-2、数据显示到前端" class="headerlink" title="6.2、数据显示到前端"></a>6.2、数据显示到前端</h2><h3 id="1、通过ModelAndView"><a href="#1、通过ModelAndView" class="headerlink" title="1、通过ModelAndView"></a>1、通过ModelAndView</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;ControllerTest1&quot;</span>);</span><br><span class="line">       mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、通过ModelMap"><a href="#2、通过ModelMap" class="headerlink" title="2、通过ModelMap"></a>2、通过ModelMap</h3><p>ModelMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, ModelMap model)</span></span>&#123;</span><br><span class="line">   <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">   <span class="comment">//相当于req.setAttribute(&quot;name&quot;,name);</span></span><br><span class="line">   model.addAttribute(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、通过Model"><a href="#3、通过Model" class="headerlink" title="3、通过Model"></a>3、通过Model</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ct2/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, Model model)</span></span>&#123;</span><br><span class="line">   <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">   <span class="comment">//相当于req.setAttribute(&quot;name&quot;,name);</span></span><br><span class="line">   model.addAttribute(<span class="string">&quot;msg&quot;</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、使用servlet方法（不推荐使用）"><a href="#4、使用servlet方法（不推荐使用）" class="headerlink" title="4、使用servlet方法（不推荐使用）"></a>4、使用servlet方法（不推荐使用）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/result/t1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">rsp.getWriter().println(<span class="string">&quot;Hello,Spring BY servlet API&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><ul><li><p>Model 只有几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解</p></li><li><p>ModelMap 继承了 LinkedMap ，继承 LinkedMap 的方法和特性；</p></li><li><p>ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</p></li></ul><h1 id="7、重定向和转发"><a href="#7、重定向和转发" class="headerlink" title="7、重定向和转发"></a>7、重定向和转发</h1><h2 id="7-1、通过servlet实现"><a href="#7-1、通过servlet实现" class="headerlink" title="7.1、通过servlet实现"></a>7.1、通过servlet实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定向</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/result/t2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">rsp.sendRedirect(<span class="string">&quot;/Demo_03_war_exploded/index.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转发</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/result/t3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">req.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;1221&quot;</span>);</span><br><span class="line">req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/test.jsp&quot;</span>).forward(req,rsp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2、通过SpringMVC实现"><a href="#7-2、通过SpringMVC实现" class="headerlink" title="7.2、通过SpringMVC实现"></a>7.2、通过SpringMVC实现</h2><h3 id="1、不使用视图解析器"><a href="#1、不使用视图解析器" class="headerlink" title="1、不使用视图解析器"></a>1、不使用视图解析器</h3><ul><li>直接跳转到web路径下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSpringMVC</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转发到页面index.jsp（web目录下）</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/rsm/t1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;     </span><br><span class="line">        <span class="comment">//转发到其他请求  </span></span><br><span class="line">        <span class="comment">//return &quot;/result/t1&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转发方式二</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/rsm/t3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/index.jsp&quot;</span>;</span><br><span class="line">        <span class="comment">//转发到其他请求  </span></span><br><span class="line">        <span class="comment">//return &quot;forward:/result/t1&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 重定向到页面（注意不要加入项目名了,默认在本项目下）</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/rsm/t5&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">        <span class="comment">//重定向到其他请求 </span></span><br><span class="line">        <span class="comment">//return &quot;redirect:/result/t1&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、使用视图解析器"><a href="#2、使用视图解析器" class="headerlink" title="2、使用视图解析器"></a>2、使用视图解析器</h3><ul><li>跳转到视图解析器自定义的路径下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转发，跳转到视图解析器自定义的路径下</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSpringMVC2</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/rsm2/t1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//转发</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//也可以</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置了摄图解析器之后，想转发到其他请求只能    </span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/result/t1&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//重定向，跳转到项目路径下,和上面一样，不能跳转到WEB-INF目录下</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/rsm2/t2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line"><span class="comment">//重定向到其他请求</span></span><br><span class="line"><span class="comment">//return &quot;redirect:/result/t1&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p><strong>转发</strong></p><blockquote><p>未配置视图解析器，</p></blockquote><p>return “/index.jsp”;   或者 return “/result/t1”;   </p><p>跳转到  <a href="http://localhost:8080/Demo_03_war_exploded/index.jsp">http://localhost:8080/Demo_03_war_exploded/index.jsp</a></p><p>​                         <a href="http://localhost:8080/Demo_03_war_exploded/result/t1">http://localhost:8080/Demo_03_war_exploded/result/t1</a></p><blockquote><p>配置了视图解析器</p></blockquote><p>return “hello”;            </p><p>跳转  <a href="http://localhost:8080/Demo_03_war_exploded/WEB-INF/jsp/hello.jsp">http://localhost:8080/Demo_03_war_exploded/WEB-INF/jsp/hello.jsp</a></p><blockquote><p>配不配置，都可以用的情况</p></blockquote><p>return “forward:/index.jsp”;   return “forward:/result/t1”;   </p><p>跳转 <a href="http://localhost:8080/Demo_03_war_exploded/index.jsp">http://localhost:8080/Demo_03_war_exploded/index.jsp</a></p><p>​                   <a href="http://localhost:8080/Demo_03_war_exploded/result/t1">http://localhost:8080/Demo_03_war_exploded/result/t1</a></p><p><strong>重定向</strong></p><p>return “redirect:/index.jsp”;        设不设置都只能这样</p><p>跳转<a href="http://localhost:8080/Demo_03_war_exploded/index.jsp">http://localhost:8080/Demo_03_war_exploded/index.jsp</a></p><p><strong>注意：</strong>重定向不能跳转到WEB-INF目录下</p><h1 id="8、获取Web对象"><a href="#8、获取Web对象" class="headerlink" title="8、获取Web对象"></a>8、获取Web对象</h1><h2 id="8-1、获取request-response对象"><a href="#8-1、获取request-response对象" class="headerlink" title="8.1、获取request,response对象"></a>8.1、获取request,response对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;getReqAndRes&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryUser</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">String userName = request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> userName;</span><br><span class="line">&#125;</span><br><span class="line">表单&lt;input name=<span class="string">&quot;userName&quot;</span> value=<span class="string">&quot;123456&quot;</span> /&gt; 使用request对象可以获取到</span><br></pre></td></tr></table></figure><h2 id="8-2、获取Session对象"><a href="#8-2、获取Session对象" class="headerlink" title="8.2、获取Session对象"></a>8.2、获取Session对象</h2><ul><li>参数填 HttpSession session</li></ul><h1 id="9、过滤器乱码解决"><a href="#9、过滤器乱码解决" class="headerlink" title="9、过滤器乱码解决"></a>9、过滤器乱码解决</h1><h2 id="9-1、SpringMVC自带过滤器"><a href="#9-1、SpringMVC自带过滤器" class="headerlink" title="9.1、SpringMVC自带过滤器"></a>9.1、SpringMVC自带过滤器</h2><p>web.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9-2、自定义过滤器（更强大）"><a href="#9-2、自定义过滤器（更强大）" class="headerlink" title="9.2、自定义过滤器（更强大）"></a>9.2、自定义过滤器（更强大）</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- tomacat的conf文件夹下server文件修改 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">URIEncoding</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编码过滤 utf-8 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span><span class="comment">&lt;!-- 给服务器看的 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置资源路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.wzh.filter.GenericEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span><span class="comment">&lt;!-- 给服务器看的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/s1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!-- 设置要拦截的路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义过滤器</span></span><br><span class="line"><span class="keyword">package</span> com.wzh.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决get和post请求 全部乱码的过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//处理response的字符编码</span></span><br><span class="line">        HttpServletResponse myResponse=(HttpServletResponse) response;</span><br><span class="line">        myResponse.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 转型为与协议相关对象</span></span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// 对request包装增强</span></span><br><span class="line">        HttpServletRequest myrequest = <span class="keyword">new</span> MyRequest(httpServletRequest);</span><br><span class="line">        chain.doFilter(myrequest, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义request对象，HttpServletRequest的包装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">    <span class="comment">//是否编码的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasEncode;</span><br><span class="line">    <span class="comment">//定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);<span class="comment">// super必须写</span></span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对需要增强方法 进行覆盖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getParameterMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先获得请求方式</span></span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;post&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// post请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理post乱码</span></span><br><span class="line">                request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> request.getParameterMap();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// get请求</span></span><br><span class="line">            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">            <span class="keyword">if</span> (!hasEncode) &#123; <span class="comment">// 确保get手动编码逻辑只运行一次</span></span><br><span class="line">                <span class="keyword">for</span> (String parameterName : parameterMap.keySet()) &#123;</span><br><span class="line">                    String[] values = parameterMap.get(parameterName);</span><br><span class="line">                    <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 处理get乱码</span></span><br><span class="line">                                values[i] = <span class="keyword">new</span> String(values[i]</span><br><span class="line">                                        .getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                hasEncode = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parameterMap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getParameterMap();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取一个值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values[<span class="number">0</span>]; <span class="comment">// 取回参数的第一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取所有值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10、拦截器"><a href="#10、拦截器" class="headerlink" title="10、拦截器"></a>10、拦截器</h1><h2 id="10-1、基本概念"><a href="#10-1、基本概念" class="headerlink" title="10.1、基本概念"></a>10.1、基本概念</h2><p><strong>过滤器</strong></p><ul><li>servlet规范中的一部分，任何java web工程都可以使用</li><li>在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截</li></ul><p><strong>拦截器</strong> </p><ul><li>拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li><li>拦截器<code>只会拦截访问的控制器方法</code>， 如果访问的是jsp/html/css/image/js是不会进行拦截的</li></ul><p><strong>实现：</strong></p><ul><li><p>实现接口：org.springframework.web.servlet.HandlerInterceptor</p></li><li><p>继承适配器 org.springframework.web.servlet.handler.HandlerInterceptorAdapter</p></li></ul><h2 id="10-2、自定义拦截器："><a href="#10-2、自定义拦截器：" class="headerlink" title="10.2、自定义拦截器："></a>10.2、自定义拦截器：</h2><h3 id="1、编写拦截器"><a href="#1、编写拦截器" class="headerlink" title="1、编写拦截器"></a>1、编写拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">   <span class="comment">//在请求处理的方法之前执行</span></span><br><span class="line">   <span class="comment">//如果返回true执行下一个拦截器</span></span><br><span class="line">   <span class="comment">//如果返回false就不执行下一个拦截器</span></span><br><span class="line">   <span class="comment">//第三个参数为响应的处理器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;------------处理前------------&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//在请求处理方法执行之后执行</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;------------处理后------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//在dispatcherServlet处理后执行,做清理工作.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;------------清理------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、配置拦截器"><a href="#2、配置拦截器" class="headerlink" title="2、配置拦截器"></a>2、配置拦截器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--关于拦截器的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--/** 包括路径及其子路径--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--/admin/** 拦截的是/admin/下的所有--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--bean配置的就是拦截器--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.wzh.interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 该方式拦截所有请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.interceptors.MyInterceptor&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试拦截器的控制器</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/interceptor&quot;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">testFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;控制器中的方法执行了&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/interceptor&quot;</span>&gt;拦截器测试&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="10-3、自定义注解实现登陆拦截"><a href="#10-3、自定义注解实现登陆拦截" class="headerlink" title="10.3、自定义注解实现登陆拦截"></a>10.3、自定义注解实现登陆拦截</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CheckType</span> </span>&#123;</span><br><span class="line">   LOGIN,NONE</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Permission &#123;</span><br><span class="line">    <span class="function">CheckType <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> CheckType.NONE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wzh.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.HandlerMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionHandler</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> HandlerMethod)&#123;</span><br><span class="line">            <span class="comment">//获得类对象</span></span><br><span class="line">            HandlerMethod handlerMethod = (HandlerMethod) o;</span><br><span class="line">            <span class="comment">//反射获得方法</span></span><br><span class="line">            Method method = handlerMethod.getMethod();</span><br><span class="line">            <span class="comment">//获取获得的方法获得上的注解类Permission</span></span><br><span class="line">            Permission permission = method.getAnnotation(Permission.class);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=permission)&#123;</span><br><span class="line">                CheckType type =permission.value();</span><br><span class="line">                <span class="keyword">if</span>(type==CheckType.LOGIN) &#123;<span class="comment">//登录校验</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;开始拦截&quot;</span>);</span><br><span class="line">                    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                    <span class="keyword">int</span> i= random.nextInt(<span class="number">10</span>);</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;用户已经完成登录校验&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;用户未完成登录校验&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11、文件上传下载"><a href="#11、文件上传下载" class="headerlink" title="11、文件上传下载"></a>11、文件上传下载</h1><h2 id="11-1、准备工作"><a href="#11-1、准备工作" class="headerlink" title="11.1、准备工作"></a>11.1、准备工作</h2><ul><li><p>文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。</p></li><li><p>前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">   &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span>/&gt;</span><br><span class="line">   &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><ul><li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li><li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li><li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件</li></ul><p>在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。</p><ul><li><p>Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。</p></li><li><p>而Spring MVC则提供了更简单的封装。</p></li><li><p>Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。</p></li><li><p>Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类：</p><p>CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。</p></li></ul><h2 id="11-2、文件上传"><a href="#11-2、文件上传" class="headerlink" title="11.2、文件上传"></a>11.2、文件上传</h2><p>1、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--文件上传--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--文件上传配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40960&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、前端页面</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/upload&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span>/&gt;选择文件</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;upload&quot;</span>&gt;上传</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>4、<strong>Controller</strong></p><p>CommonsMultipartFile 的 常用方法：</p><ul><li>String getOriginalFilename()：获取上传文件的原名</li><li>InputStream getInputStream()：获取文件流</li><li>void transferTo(File dest)：将上传文件保存到一个目录文件中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line">   <span class="comment">//@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象</span></span><br><span class="line">   <span class="comment">//批量上传CommonsMultipartFile则为数组即可</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">fileUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> CommonsMultipartFile file , HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取文件名 : file.getOriginalFilename();</span></span><br><span class="line">       String uploadFileName = file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果文件名为空，直接回到首页！</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(uploadFileName))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;上传文件名 : &quot;</span>+uploadFileName);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//上传路径保存设置</span></span><br><span class="line">       String path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">       <span class="comment">//如果路径不存在，创建一个</span></span><br><span class="line">       File realPath = <span class="keyword">new</span> File(path);</span><br><span class="line">       <span class="keyword">if</span> (!realPath.exists())&#123;</span><br><span class="line">           realPath.mkdir();</span><br><span class="line">      &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;上传文件保存地址：&quot;</span>+realPath);</span><br><span class="line"></span><br><span class="line">       InputStream is = file.getInputStream(); <span class="comment">//文件输入流</span></span><br><span class="line">       OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(realPath,uploadFileName)); <span class="comment">//文件输出流</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//读取写出</span></span><br><span class="line">       <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">       <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">           os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">           os.flush();</span><br><span class="line">      &#125;</span><br><span class="line">       os.close();</span><br><span class="line">       is.close();</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 采用file.Transto 来保存上传的文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/upload2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">fileUpload2</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> CommonsMultipartFile file, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//上传路径保存设置</span></span><br><span class="line">        String path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">        File realPath = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (!realPath.exists())&#123;</span><br><span class="line">            realPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上传文件地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;上传文件保存地址：&quot;</span>+realPath);</span><br><span class="line">        <span class="comment">//通过CommonsMultipartFile的方法直接写文件（注意这个时候）</span></span><br><span class="line">        file.transferTo(<span class="keyword">new</span> File(realPath +<span class="string">&quot;/&quot;</span>+ file.getOriginalFilename()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-3、文件下载"><a href="#11-3、文件下载" class="headerlink" title="11.3、文件下载"></a>11.3、文件下载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/download&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Downloads</span><span class="params">(HttpServletResponse response ,HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">   <span class="comment">//要下载的图片地址，为web文件夹upload目录下的文件</span></span><br><span class="line">   String  path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">   String  fileName = <span class="string">&quot;1.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1、设置response 响应头</span></span><br><span class="line">   response.reset(); <span class="comment">//设置页面不缓存,清空buffer</span></span><br><span class="line">   response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">//字符编码</span></span><br><span class="line">   response.setContentType(<span class="string">&quot;multipart/form-data&quot;</span>); <span class="comment">//二进制传输数据</span></span><br><span class="line">   <span class="comment">//设置响应头</span></span><br><span class="line">   response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,</span><br><span class="line">           <span class="string">&quot;attachment;fileName=&quot;</span>+URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">   File file = <span class="keyword">new</span> File(path,fileName);</span><br><span class="line">   <span class="comment">//2、 读取文件--输入流</span></span><br><span class="line">   InputStream input=<span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">   <span class="comment">//3、 写出文件--输出流</span></span><br><span class="line">   OutputStream out = response.getOutputStream();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">byte</span>[] buff =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">   <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">   <span class="comment">//4、执行 写出操作</span></span><br><span class="line">   <span class="keyword">while</span>((index= input.read(buff))!= -<span class="number">1</span>)&#123;</span><br><span class="line">       out.write(buff, <span class="number">0</span>, index);</span><br><span class="line">       out.flush();</span><br><span class="line">  &#125;</span><br><span class="line">   out.close();</span><br><span class="line">   input.close();</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/download&quot;</span>&gt;点击下载&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 或者直接跳转到再加上响应头 --&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/upload/1.txt&quot;</span>&gt;点击下载&lt;/a&gt;</span><br></pre></td></tr></table></figure><h1 id="12、使用JSON"><a href="#12、使用JSON" class="headerlink" title="12、使用JSON"></a>12、使用JSON</h1><p>前后端分离时代：通过JSON</p><h2 id="12-1、JSON概念"><a href="#12-1、JSON概念" class="headerlink" title="12.1、JSON概念"></a>12.1、JSON概念</h2><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><ul><li>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。</li><li>采用完全独立于编程语言的<strong>文本格式</strong>来存储和表示数据。</li><li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。</li><li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li><li>在 JavaScript 语言中，一切都是对象。</li><li>因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。</li></ul><h3 id="2、要求和语法格式："><a href="#2、要求和语法格式：" class="headerlink" title="2、要求和语法格式："></a>2、要求和语法格式：</h3><ul><li>对象表示为键值对，数据由逗号分隔，和 JavaScript 对象的写法也大同小异</li><li>花括号保存对象</li><li>方括号保存数组</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;QinJiang&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;age&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;sex&quot;</span>: <span class="string">&quot;男&quot;</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>JSON 是 JavaScript 对象的字符串表示法，</li><li>它使用文本表示一个 JS 对象的信息，<strong>本质是一个字符串。</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">&#x27;Hello&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;World&#x27;</span>&#125;; <span class="comment">//这是一个对象，键名可以使用引号包裹的</span></span><br><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span>; <span class="comment">//这是一个JSON字符串，本质是字符串</span></span><br></pre></td></tr></table></figure><h3 id="3、JSON-和-JavaScript-对象互转（JS里操作）"><a href="#3、JSON-和-JavaScript-对象互转（JS里操作）" class="headerlink" title="3、JSON 和 JavaScript 对象互转（JS里操作）"></a>3、JSON 和 JavaScript 对象互转（JS里操作）</h3><ul><li>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span>);</span><br><span class="line"><span class="comment">//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>: <span class="string">&#x27;Hello&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;World&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="12-2、JackSon使用"><a href="#12-2、JackSon使用" class="headerlink" title="12.2、JackSon使用"></a>12.2、JackSon使用</h2><h4 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、实体类"><a href="#2、实体类" class="headerlink" title="2、实体类"></a>2、实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要导入lombok</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lombok依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.18</span><span class="number">.18</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把对象变成字符串，然后返回，自动解析成JSON</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/json1&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">json1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个jackson的对象映射器，用来解析数据</span></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">//创建一个对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;1号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="comment">//将我们的对象解析成为json格式</span></span><br><span class="line">        String str = mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">//由于@ResponseBody注解，这里会将str转成json格式返回；十分方便</span></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：</p><ul><li><p>乱码解决1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//produces:指定响应体返回类型和编码</span></span><br><span class="line"><span class="meta">@RequestMapping(value =&quot;&quot;,produces =&quot;application/json;charset=utf-8&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p>乱码解决2：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 消息转换器 处理json字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;failOnEmptyBeans&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>返回json字符串统一解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、输出时间对象"><a href="#4、输出时间对象" class="headerlink" title="4、输出时间对象"></a>4、输出时间对象</h3><blockquote><p>默认情况</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/json3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json3</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">   ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">   <span class="comment">//创建时间一个对象，java.util.Date</span></span><br><span class="line">   Date date = <span class="keyword">new</span> Date();</span><br><span class="line">   <span class="comment">//将我们的对象解析成为json格式</span></span><br><span class="line">   String str = mapper.writeValueAsString(date);</span><br><span class="line">   <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果本应该是一个字符串，但输出一串数字</li><li>默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！</li><li>Jackson 默认是会把时间转成timestamps形式</li></ul><blockquote><p>自定义形式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消timestamps形式 ， 自定义时间格式**，</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/json3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json4</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">   ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">   <span class="comment">//不使用时间戳的方式</span></span><br><span class="line">   mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">   <span class="comment">//自定义日期格式对象</span></span><br><span class="line">   SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">   <span class="comment">//指定日期格式</span></span><br><span class="line">   mapper.setDateFormat(sdf);</span><br><span class="line">   Date date = <span class="keyword">new</span> Date();</span><br><span class="line">   String str = mapper.writeValueAsString(date);</span><br><span class="line">   <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传统Java方式</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/json3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json4</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">   ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">   Date date = <span class="keyword">new</span> Date();</span><br><span class="line">   <span class="comment">//自定义日期格式对象</span></span><br><span class="line">   SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> mapper.writeValueAsString(sdf.format(date));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽取为工具类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getJson</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getJson(object,<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getJson</span><span class="params">(Object object,String dateFormat)</span> </span>&#123;</span><br><span class="line">       ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       <span class="comment">//不使用时间差的方式</span></span><br><span class="line">       mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">       <span class="comment">//自定义日期格式对象</span></span><br><span class="line">       SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(dateFormat);</span><br><span class="line">       <span class="comment">//指定日期格式</span></span><br><span class="line">       mapper.setDateFormat(sdf);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> mapper.writeValueAsString(object);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//Java方式实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getJson1</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">//自定义日期格式对象</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsString(sdf.format(date));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接调用工具类，简洁代码</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/json4&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json5</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">   Date date = <span class="keyword">new</span> Date();</span><br><span class="line">   String json = JsonUtils.getJson(date);</span><br><span class="line">   <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12-3、FastJson使用"><a href="#12-3、FastJson使用" class="headerlink" title="12.3、FastJson使用"></a>12.3、FastJson使用</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的</p><h3 id="2、类详解"><a href="#2、类详解" class="headerlink" title="2、类详解"></a>2、类详解</h3><blockquote><p>JSONObject  代表 json 对象 </p></blockquote><ul><li>JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。</li><li>JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</li></ul><blockquote><p>JSONArray  代表 json 对象数组</p></blockquote><ul><li>内部是有List接口中的方法来完成操作的。</li></ul><blockquote><p>JSON代表 JSONObject和JSONArray的转化</p></blockquote><ul><li>JSON类源码分析与使用</li><li>仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。</li></ul><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个对象</span></span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="string">&quot;1号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="string">&quot;2号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">        User user3 = <span class="keyword">new</span> User(<span class="string">&quot;3号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">        User user4 = <span class="keyword">new</span> User(<span class="string">&quot;4号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">        list.add(user1);</span><br><span class="line">        list.add(user2);</span><br><span class="line">        list.add(user3);</span><br><span class="line">        list.add(user4);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******Java对象 转 JSON字符串*******&quot;</span>);</span><br><span class="line">        String str1 = JSON.toJSONString(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;JSON.toJSONString(list)==&gt;&quot;</span>+str1);</span><br><span class="line">        String str2 = JSON.toJSONString(user1);</span><br><span class="line">        System.out.println(<span class="string">&quot;JSON.toJSONString(user1)==&gt;&quot;</span>+str2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n****** JSON字符串 转 Java对象*******&quot;</span>);</span><br><span class="line">        User jp_user1=JSON.parseObject(str2,User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;JSON.parseObject(str2,User.class)==&gt;&quot;</span>+jp_user1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n****** Java对象 转 JSON对象 ******&quot;</span>);</span><br><span class="line">        JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);</span><br><span class="line">        System.out.println(<span class="string">&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;</span>+jsonObject1.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n****** JSON对象 转 Java对象 ******&quot;</span>);</span><br><span class="line">        User to_java_user = JSON.toJavaObject(jsonObject1, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;</span>+to_java_user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13、Ajax使用"><a href="#13、Ajax使用" class="headerlink" title="13、Ajax使用"></a>13、Ajax使用</h1><h2 id="13-1、简介"><a href="#13-1、简介" class="headerlink" title="13.1、简介"></a>13.1、简介</h2><ul><li><p><strong>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</strong></p></li><li><p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p></li><li><p><strong>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</strong></p></li><li><p>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。</p></li><li><p>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</p></li><li><p>就和国内百度的搜索框一样!</p></li></ul><h2 id="13-2、Ajax的Demo"><a href="#13-2、Ajax的Demo" class="headerlink" title="13.2、Ajax的Demo"></a>13.2、Ajax的Demo</h2><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;test&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Demo1: servlet方式实现</span></span><br><span class="line">    <span class="comment">//输入之后，若离开输入框，则进行判断</span></span><br><span class="line">    <span class="comment">//名字为admin弹出显示true，否则flase</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/a1&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ajax1</span><span class="params">(String name , HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name))&#123;</span><br><span class="line">            response.getWriter().print(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            response.getWriter().print(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Demo2: SpringMvc实现</span></span><br><span class="line">    <span class="comment">//点击按钮后，加载数据</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/a2&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">ajax2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="string">&quot;秦疆1号&quot;</span>,<span class="number">3</span>,<span class="string">&quot;男&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="string">&quot;秦疆2号&quot;</span>,<span class="number">3</span>,<span class="string">&quot;男&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="string">&quot;秦疆3号&quot;</span>,<span class="number">3</span>,<span class="string">&quot;男&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> list; <span class="comment">//由于@RestController注解，将list转成json格式返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Demo3: SPringMVC</span></span><br><span class="line">    <span class="comment">//动态判断输入的结果是否正确</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/a3&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ajax3</span><span class="params">(String name,String pwd)</span></span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//模拟数据库中存在数据</span></span><br><span class="line">        <span class="keyword">if</span> (name!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name))&#123;</span><br><span class="line">                msg = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                msg = <span class="string">&quot;用户名输入错误&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pwd!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;123456&quot;</span>.equals(pwd))&#123;</span><br><span class="line">                msg = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                msg = <span class="string">&quot;密码输入有误&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> msg; <span class="comment">//由于@RestController注解，将msg转成json格式返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo1的前端</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">    &lt;%--&lt;script src=<span class="string">&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;</span>&gt;&lt;/script&gt;--%&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function">function <span class="title">a1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            $.post(&#123;</span><br><span class="line">                &lt;%-- url指要访问的地方</span><br><span class="line">     data指要传过去的数据</span><br><span class="line">      name与后台参数对应</span><br><span class="line">                          txtName与本页面的对应</span><br><span class="line">     success指访问回来进行的函数</span><br><span class="line">    --%&gt;</span><br><span class="line">                url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;</span>,</span><br><span class="line">                data:&#123;<span class="string">&#x27;name&#x27;</span>:$(<span class="string">&quot;#txtName&quot;</span>).val()&#125;,</span><br><span class="line">                success:function (data,status) &#123;</span><br><span class="line">                    alert(data);</span><br><span class="line">                    alert(status);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--onblur：失去焦点触发事件--%&gt;</span><br><span class="line">用户名:&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;txtName&quot;</span> onblur=<span class="string">&quot;a1()&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>Demo2的前端</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span> value=<span class="string">&quot;获取数据&quot;</span>/&gt;</span><br><span class="line">&lt;table width=<span class="string">&quot;80%&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;年龄&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;性别&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tbody id=<span class="string">&quot;content&quot;</span>&gt;</span><br><span class="line">  &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">  $(function () &#123;</span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).click(function () &#123;</span><br><span class="line">      $.post(<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;</span>,function (data) &#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">        <span class="keyword">var</span> html=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;data.length ; i++) &#123;</span><br><span class="line">          html+= <span class="string">&quot;&lt;tr&gt;&quot;</span> +</span><br><span class="line">                  <span class="string">&quot;&lt;td&gt;&quot;</span> + data[i].name + <span class="string">&quot;&lt;/td&gt;&quot;</span> +</span><br><span class="line">                  <span class="string">&quot;&lt;td&gt;&quot;</span> + data[i].age + <span class="string">&quot;&lt;/td&gt;&quot;</span> +</span><br><span class="line">                  <span class="string">&quot;&lt;td&gt;&quot;</span> + data[i].sex + <span class="string">&quot;&lt;/td&gt;&quot;</span> +</span><br><span class="line">                  <span class="string">&quot;&lt;/tr&gt;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        $(<span class="string">&quot;#content&quot;</span>).html(html);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>Demo3的前端</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;ajax&lt;/title&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">        <span class="function">function <span class="title">a1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            $.post(&#123;</span><br><span class="line">                url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;</span>,</span><br><span class="line">                data:&#123;<span class="string">&#x27;name&#x27;</span>:$(<span class="string">&quot;#name&quot;</span>).val()&#125;,</span><br><span class="line">                success:function (data) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (data.toString()==<span class="string">&#x27;OK&#x27;</span>)&#123;</span><br><span class="line">                        $(<span class="string">&quot;#userInfo&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;green&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        $(<span class="string">&quot;#userInfo&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    $(<span class="string">&quot;#userInfo&quot;</span>).html(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">function <span class="title">a2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            $.post(&#123;</span><br><span class="line">                url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;</span>,</span><br><span class="line">                data:&#123;<span class="string">&#x27;pwd&#x27;</span>:$(<span class="string">&quot;#pwd&quot;</span>).val()&#125;,</span><br><span class="line">                success:function (data) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (data.toString()==<span class="string">&#x27;OK&#x27;</span>)&#123;</span><br><span class="line">                        $(<span class="string">&quot;#pwdInfo&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;green&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        $(<span class="string">&quot;#pwdInfo&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    $(<span class="string">&quot;#pwdInfo&quot;</span>).html(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    用户名:&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;name&quot;</span> onblur=<span class="string">&quot;a1()&quot;</span>/&gt;</span><br><span class="line">    &lt;span id=<span class="string">&quot;userInfo&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    密码:&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;pwd&quot;</span> onblur=<span class="string">&quot;a2()&quot;</span>/&gt;</span><br><span class="line">    &lt;span id=<span class="string">&quot;pwdInfo&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="13-3、获取百度接口Demo"><a href="#13-3、获取百度接口Demo" class="headerlink" title="13.3、获取百度接口Demo"></a>13.3、获取百度接口Demo</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSONP百度搜索<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#q</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">14px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#ul</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">520px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-top</span>: -<span class="number">1px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#ul</span> <span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#f60</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2.步骤二</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 定义demo函数 (分析接口、数据)</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> Ul = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ul&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> html = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 如果搜索数据存在 把内容添加进去</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (data.s.length) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 隐藏掉的ul显示出来</span></span></span><br><span class="line"><span class="javascript">                Ul.style.display = <span class="string">&#x27;block&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 搜索到的数据循环追加到li里</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;data.s.length;i++)&#123;</span></span><br><span class="line"><span class="javascript">                    html += <span class="string">&#x27;&lt;li&gt;&#x27;</span>+data.s[i]+<span class="string">&#x27;&lt;/li&gt;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 循环的li写入ul</span></span></span><br><span class="line"><span class="javascript">                Ul.innerHTML = html;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1.步骤一</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 获取输入框和ul</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> Q = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;q&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> Ul = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ul&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 事件鼠标抬起时候</span></span></span><br><span class="line"><span class="javascript">            Q.onkeyup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 如果输入框不等于空</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (<span class="built_in">this</span>.value != <span class="string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 创建标签</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//给定要跨域的地址 赋值给src</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//这里是要请求的跨域的地址 我写的是百度搜索的跨域地址</span></span></span><br><span class="line"><span class="javascript">                    script.src = <span class="string">&#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#x27;</span>+<span class="built_in">this</span>.value+<span class="string">&#x27;&amp;cb=demo&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 将组合好的带src的script标签追加到body里</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.body.appendChild(script);</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;q&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="14、Restful风格"><a href="#14、Restful风格" class="headerlink" title="14、Restful风格"></a>14、Restful风格</h1><h2 id="14-1、概念"><a href="#14-1、概念" class="headerlink" title="14.1、概念"></a>14.1、概念</h2><ul><li>Restful就是一个资源定位及资源操作的风格。</li><li>不是标准也不是协议，只是一种风格。</li><li>基于此风格的软件可以更简洁，更有层次，更易于实现缓存等机制。</li></ul><h2 id="14-2、功能"><a href="#14-2、功能" class="headerlink" title="14.2、功能"></a>14.2、功能</h2><ul><li>资源：互联网所有的事物都可以被抽象为资源</li><li>资源操作：使用POST、DELETE、PUT、GET、PATCH，不同方法操作资源</li><li>分别对应 添加、 删除、修改、查询。</li><li>PATCH也对应修改（update）</li></ul><h2 id="14-3、传统方式与Restful风格对比"><a href="#14-3、传统方式与Restful风格对比" class="headerlink" title="14.3、传统方式与Restful风格对比"></a>14.3、传统方式与Restful风格对比</h2><h3 id="1、传统方式操作资源-："><a href="#1、传统方式操作资源-：" class="headerlink" title="1、传统方式操作资源  ："></a>1、传统方式操作资源  ：</h3><ul><li>通过不同的<strong>参数</strong>来实现不同的效果！方法单一，</li></ul><h3 id="2、使用Restful操作资源-："><a href="#2、使用Restful操作资源-：" class="headerlink" title="2、使用Restful操作资源 ："></a>2、使用Restful操作资源 ：</h3><ul><li>可以通过不同的<strong>请求方式</strong>来实现不同的效果</li><li>请求地址一样，但是功能可以不同！<ul><li><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</li><li><a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</li><li><a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</li><li><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</li></ul></li></ul><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射访问路径</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/add/&#123;p1&#125;/&#123;p2&#125;&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index1</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> p1, <span class="meta">@PathVariable</span> <span class="keyword">int</span> p2, Model model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = p1 + p2;</span><br><span class="line"><span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果1：&quot;</span> + result);</span><br><span class="line"><span class="comment">//返回视图位置</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping</span> (<span class="string">&quot;/add/&#123;p1&#125;/&#123;p2&#125;&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index2</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> p1, <span class="meta">@PathVariable</span> <span class="keyword">int</span> p2, Model model)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = p1 + p2;</span><br><span class="line"><span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果2：&quot;</span> + result);</span><br><span class="line"><span class="comment">//返回视图位置</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受参数方式：</p><ul><li>@PathVariable注解</li></ul><p>指定接受的请求方式：</p><ul><li><p>method = RequestMethod.POST</p></li><li><p>@GetMapping @PostMapping@PutMapping@DeleteMapping</p><p>@PatchMapping</p></li></ul><p>输入<a href="http://localhost:8080/Demo_03_war_exploded/add/1/2">http://localhost:8080/Demo_03_war_exploded/add/1/2</a></p><ul><li>若为post方式，则执行index1方法</li><li>若为get方式，则执行index2方法</li></ul><h1 id="15、SpringMVC配置文件总结"><a href="#15、SpringMVC配置文件总结" class="headerlink" title="15、SpringMVC配置文件总结"></a>15、SpringMVC配置文件总结</h1><h3 id="1、pom-xml依赖"><a href="#1、pom-xml依赖" class="headerlink" title="1、pom.xml依赖"></a>1、pom.xml依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- junit 测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jsp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jstl --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- json --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- fastjson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--文件上传--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、servlet-xml文件"><a href="#2、servlet-xml文件" class="headerlink" title="2、servlet.xml文件"></a>2、servlet.xml文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzh.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    支持mvc注解驱动</span></span><br><span class="line"><span class="comment">        在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">        要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">        必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">        和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">        这两个实例分别在类级别和方法级别处理。</span></span><br><span class="line"><span class="comment">        而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 消息转换器 处理json字符串 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;failOnEmptyBeans&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--文件上传配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40960&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--关于拦截器的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--/** 包括路径及其子路径--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--/admin/** 拦截的是/admin/下的所有--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--bean配置的就是拦截器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.wzh.interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 该方式拦截所有请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.interceptors.MyInterceptor&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、web-xml"><a href="#3、web-xml" class="headerlink" title="3、web.xml"></a>3、web.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以不加 表示容器启动时 加载上下文配置 这里指定 spring 相关配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 可以不加 启用 spring 容器环境上下文监听 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自定义过滤器 编码过滤 utf-8 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span><span class="comment">&lt;!-- 给服务器看的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.wzh.filter.GenericEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span><span class="comment">&lt;!-- 给服务器看的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!-- 设置要拦截的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC 官方过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1.注册servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--所有请求都会被springmvc拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb(二):Spring框架</title>
      <link href="/2021/07/01/Web/JavaWeb%20(%20%E4%BA%8C%20)%20Spring/"/>
      <url>/2021/07/01/Web/JavaWeb%20(%20%E4%BA%8C%20)%20Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Spring"><a href="#1、Spring" class="headerlink" title="1、Spring"></a>1、Spring</h1><h2 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h2><ul><li>2002年，首次推出了spring框架的雏形：interface 21</li><li>2004年3月24日，spring框架正式发布</li><li>Rod Johnson：Spring Framework的创始人</li><li>spring理念：<strong>使现有的技术更加容易使用</strong>，本身是一个大杂烩</li><li>SSH：Struct2 + Spring +Hibernate</li><li>SSM：SpringMvc + Spring + Mybatis</li><li>文档：<a href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference">https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference</a></li></ul><blockquote><p>官方特性</p></blockquote><ul><li><strong>核心技术</strong> ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</li><li><strong>测试</strong> ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</li><li><strong>数据访问</strong> ：事务，DAO⽀持，JDBC，ORM，编组XML。</li><li><strong>Web支持</strong> : Spring MVC和Spring WebFlux Web框架。</li><li><strong>集成</strong> ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</li><li><strong>语言</strong> ：Kotlin，Groovy，动态语言。</li></ul><h2 id="1-2、优点"><a href="#1-2、优点" class="headerlink" title="1.2、优点"></a>1.2、优点</h2><ul><li>Spring是一个开源的免费的框架（容器）</li><li>Spring是一个轻量级的、非入侵的框架</li><li><strong>控制反转（IOC）、面向切面编程（AOP）</strong></li><li>支持事务的处理，对框架的整合</li></ul><h2 id="1-3、组成"><a href="#1-3、组成" class="headerlink" title="1.3、组成"></a>1.3、组成</h2><p><img src="/img/web/%E5%9B%BE%E7%89%8710.jpg"></p><p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p><ul><li><strong>Spring Core：</strong>Spring 框架的核心。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li><li><strong>Spring Aspects</strong> ： 该模块为与AspectJ的集成提供支持。</li><li><strong>Spring AOP</strong> ：提供了面向切面的编程实现。</li><li><strong>Spring JDBC</strong> : Java数据库连接。</li><li><strong>Spring JMS</strong> ：Java消息服务。</li><li><strong>Spring ORM</strong> : ⽤于⽀持ORM⼯具，包括 JDO、Hibernate 和 iBatis SQL Map等。</li><li><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</li><li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li></ul><h2 id="1-4、拓展"><a href="#1-4、拓展" class="headerlink" title="1.4、拓展"></a>1.4、拓展</h2><p><img src="/img/web/%E5%9B%BE%E7%89%8711.jpg"></p><ul><li>Spring Boot：<ul><li>构建一切，一个快速开发的脚手架</li><li>基于SpringBoot可以快速开发单个微服务</li><li><strong>约定大于配置</strong></li></ul></li><li>SPring Cloud：协调一切<ul><li>基于SpringBoot实现</li></ul></li><li>Spring Cloud Data Flow：连接一切</li></ul><p>大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要掌握Spring和SpringMVC！</p><p>弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，人称：”配置地狱”</p><h1 id="2、IOC"><a href="#2、IOC" class="headerlink" title="2、IOC"></a>2、IOC</h1><h2 id="2-1、IOC的理解"><a href="#2-1、IOC的理解" class="headerlink" title="2.1、IOC的理解"></a>2.1、IOC的理解</h2><p>**控制反转IOC(Inversion of Control)**，不是什么技术，而是一种<code>设计思想</code>。在Java开发中，Ioc意味着将你设计好的对象交给Spring容器（一个Map，其中的value存放容器创建的对象）来控制，而不是传统的在你的对象内部直接控制。</p><p>实际开发中，我们写的一个类，有可能依赖成败上千的相关的类作他的底层结构，我们创建这个类时的对象时，就要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。现在使用Ioc，只需要配置好（XML或者注解），然后在需要的地方引用就行了，这等待增加了项目的可维护性且降低了开发难度。</p><blockquote><p>IOC的初始化过程</p></blockquote><p>xml  —-读取—–&gt;   Resource  —解析—- &gt;  BeanDefinition —–注册—&gt; BeanFactory</p><blockquote><p>谁控制谁，控制什么</p></blockquote><p>传统Java SE程序设计，直接在对象内部通过new对象，即程序主动去创建依赖对象在IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；</p><ul><li>谁控制谁？当然是IoC 容器控制了对象；</li><li>控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</li></ul><blockquote><p>为何是反转，哪些方面反转了：</p></blockquote><p>传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；反转则是由容器来帮忙创建及注入依赖对象</p><ul><li>为何是反转？因为由容器查找及注入依赖对象，对象只是被动的接受依赖对象，</li><li>哪些方面反转了？依赖对象的获取被反转了。</li></ul><h2 id="2-2、IOC容器源码分析"><a href="#2-2、IOC容器源码分析" class="headerlink" title="2.2、IOC容器源码分析"></a>2.2、IOC容器源码分析</h2><h3 id="1、BeanFactory-简介"><a href="#1、BeanFactory-简介" class="headerlink" title="1、BeanFactory 简介"></a>1、BeanFactory 简介</h3><p>BeanFactory使用的是工厂模式，前面的 ApplicationContext 就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：</p><p><img src="C:\Users\admin\Desktop\Java学习笔记\Web和SSM\img\web\图片40.jpg"></p><ol><li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。</li><li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li><li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li><li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。</li></ol><h3 id="2、启动Spring容器"><a href="#2、启动Spring容器" class="headerlink" title="2、启动Spring容器"></a>2、启动Spring容器</h3><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 需要配置pom.xml文件 引入依赖</span><br><span class="line">// spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span> <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wzh.MessageServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在 ClassPath 中寻找 xml 配置文件，来构建 ApplicationContext。</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:application.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 从 context 中取出我们的 Bean，而非通过new</span></span><br><span class="line">        Message message = context.getBean(Message.class);</span><br><span class="line">        <span class="comment">// 这句将输出: hello world</span></span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ApplicationContext的层次结构：</p></blockquote><p>可以看到除了ClassPathXmlApplicationContext我们还可以选择绿色的两个加载信息，一个是文件、一个是注解。</p><p><img src="/img/web/%E5%9B%BE%E7%89%8739.jpg"></p><blockquote><p>ClassPathXmlApplicationContext的构造方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line">  <span class="comment">// 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh(); <span class="comment">// 核心方法，</span></span><br><span class="line">      <span class="comment">// 调用的是父类AbstractApplicationContext的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ApplicationContext 建立起来以后，<code>可以通过 refresh() 重建</code>，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p><blockquote><p>refresh方法</p></blockquote><p>refresh方法是继承父类 AbstractApplicationContext得到的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="comment">// 来个锁，防止refresh()还没结束，又来个启动或销毁容器的操作</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">         initMessageSource();</span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、Refresh：创建-Bean前的准备"><a href="#3、Refresh：创建-Bean前的准备" class="headerlink" title="3、Refresh：创建 Bean前的准备"></a>3、Refresh：创建 Bean前的准备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 记录启动时间，</span></span><br><span class="line">   <span class="comment">// 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span></span><br><span class="line">   <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验 xml 配置文件</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、Refresh：创建-并注册-Bean"><a href="#4、Refresh：创建-并注册-Bean" class="headerlink" title="4、Refresh：创建 并注册 Bean"></a>4、Refresh：创建 并注册 Bean</h3><p><strong>重要：</strong>这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p><p><strong>注意点：</strong>这里可以看到，虽然ApplicationContext 继承自 BeanFactory，但是bean 的创建不是自身创建的，而是依赖一个实例化的 BeanFactory（DefaultListableBeanFactory）创建。 原因DefaultListableBeanFactory 是最底层的（子类），方法很完善。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext类方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 关闭旧的 BeanFactory (如果有)，创建新的，加载 Bean 定义、注册 Bean 等等</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取刚刚创建的 BeanFactory</span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面调用的 refreshBeanFactory() 方法，具体的注册、加载方法</span></span><br><span class="line"><span class="comment">// 注意是由 AbstractRefreshableApplicationContext 类 提供的</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 如果 当前的ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory </span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化一个 DefaultListableBeanFactory，来创建bean</span></span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      <span class="comment">// 用于 BeanFactory 的序列化</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 下面这两个方法很重要，别跟丢了，具体细节之后说</span></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环依赖</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里是从XmlBeanDefinitionReader 中加载 Bean 到 BeanFactory 中</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BeanDefinition：保存Bean的信息</p></blockquote><p> BeanDefinition 就是我们所说的 Spring 的 Bean，存储了 Bean 的信息，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中</p><p> <strong>Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanDefinition的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 默认只提供单例和多例</span></span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span></span><br><span class="line">   <span class="comment">// 一句话就是：继承父 Bean 的配置信息而已</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(String parentName)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取父 Bean</span></span><br><span class="line">   <span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 bean 的 scope</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(String scope)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置是否懒加载</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span></span><br><span class="line">   <span class="comment">// 是 depends-on=&quot;&quot; 属性设置的值。</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(String... dependsOn)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回该 Bean 的所有依赖</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span></span><br><span class="line">   <span class="comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 是否可以注入到其他 Bean 中</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是 primary 的</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span></span><br><span class="line">   <span class="comment">// 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span></span>;</span><br><span class="line">   <span class="comment">// 获取工厂名称</span></span><br><span class="line">   <span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 指定工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span></span>;</span><br><span class="line">   <span class="comment">// 获取工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器参数</span></span><br><span class="line">   <span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span></span><br><span class="line">   <span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 singleton</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 prototype</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span></span><br><span class="line">   <span class="comment">// 常用于作为 父bean 用于继承，其实也很少用......</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>customizeBeanFactory方法：设置两个属性</p></blockquote><p><strong>方法本类提供：</strong>配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 定义覆盖</span></span><br><span class="line"> beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 间的循环依赖  </span></span><br><span class="line">    beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>覆盖问题：</strong>配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p><p><strong>循环依赖：</strong>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p><blockquote><p> loadBeanDefinitions方法：加载Bean、注册Bean等</p></blockquote><p><strong>此方法由  AbstractXmlApplicationContext 类提供。</strong></p><p>根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">   <span class="comment">// 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span></span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 使用此上下文的环境加载资源</span></span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span></span><br><span class="line">   <span class="comment">// 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   <span class="comment">// 重点来了，继续往下</span></span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面的 loadBeanDefinitions方法</strong>，把配置文件解析称为DOM树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">   Resource[] configResources = getConfigResources();</span><br><span class="line">   <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 往下看</span></span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   &#125;</span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 注意这里是个 for 循环，也就是每个文件是一个 resource</span></span><br><span class="line">   <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">      <span class="comment">// 继续往下看</span></span><br><span class="line">      counter += loadBeanDefinitions(resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 最后返回 counter，表示总共加载了多少的 BeanDefinition</span></span><br><span class="line">   <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 303</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 314</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource.getResource());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 用一个 ThreadLocal 来存放配置文件资源</span></span><br><span class="line">   Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentResources = <span class="keyword">new</span> HashSet&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">         <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 核心部分是这里，往下面看</span></span><br><span class="line">         <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还在这个文件中，第 388 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里就不看了，将 xml 文件转换为 Document 对象</span></span><br><span class="line">      Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">      <span class="comment">// 继续</span></span><br><span class="line">      <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还在这个文件中，第 505 行</span></span><br><span class="line"><span class="comment">// 返回值：返回从当前配置文件加载了多少数量的 Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">   <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">   <span class="comment">// 这里</span></span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader 90</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">   logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line">   Element root = doc.getDocumentElement();</span><br><span class="line">   <span class="comment">// 从 xml 根节点开始解析文件</span></span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure><p><strong>上面的 doRegisterBeanDefinitions方法，从根节点解析文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader 116</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，</span></span><br><span class="line">   <span class="comment">// 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，</span></span><br><span class="line">   <span class="comment">// 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了</span></span><br><span class="line">   BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">   <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="comment">// 这块说的是根节点 &lt;beans ... profile=&quot;dev&quot; /&gt; 中的 profile 是否是当前环境需要的，</span></span><br><span class="line">      <span class="comment">// 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析</span></span><br><span class="line">      <span class="comment">// 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区</span></span><br><span class="line">      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">         <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                     <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   preProcessXml(root); <span class="comment">// 钩子</span></span><br><span class="line">   <span class="comment">// 往下看</span></span><br><span class="line">   parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">   postProcessXml(root); <span class="comment">// 钩子</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两种解析方式</p></blockquote><p>上面的 parseBeanDefinitions 方法，每个配置来说会分别进入到 parseDefaultElement(ele, delegate) 或者 delegate.parseCustomElement(ele) 分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span></span><br><span class="line"><span class="comment">// 其他的属于 custom 的</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      NodeList nl = root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node = nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               <span class="comment">// 解析 default namespace 下面的几个元素</span></span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 解析其他 namespace 的元素</span></span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>parseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code>、<code>&lt;bean /&gt;</code>、<code>&lt;beans /&gt;</code> 这几个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这里的四个标签之所以是 default 的，是因为它们是处于 namespace 下定义的</span><br><span class="line">http://www.springframework.org/schema/beans</span><br></pre></td></tr></table></figure></li><li><p>对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code>&lt;mvc /&gt;</code>、<code>&lt;task /&gt;</code>、<code>&lt;context /&gt;</code>、<code>&lt;aop /&gt;</code>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些标签需要加入额外的命名空间</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>Default标签的处理方法</strong>：解析生成BeanDefinitionHolder 实例，然后注册Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;import /&gt; 标签</span></span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;alias /&gt; 标签定义</span></span><br><span class="line">      <span class="comment">// &lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;</span></span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧</span></span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重要的Bean标签处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看，，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：</span></span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的</span></span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//  我们把这步叫做 注册Bean 吧</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册完成后，发送事件，本文不展开说这个</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注册Bean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册Bean、保存别名信息等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   <span class="comment">// 注册这个 Bean</span></span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span></span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">         <span class="comment">// alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span></span><br><span class="line">         <span class="comment">// 获取的时候，会先将 alias 转换为 beanName，然后再查找</span></span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部注册方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">   Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span></span><br><span class="line">   BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span></span><br><span class="line">   oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理重复名称的 Bean 定义的情况</span></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">         <span class="comment">// 如果不允许覆盖的话，抛异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription()...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">         <span class="comment">// log...用框架定义的 Bean 覆盖用户自定义的 Bean </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">         <span class="comment">// log...用新的 Bean 覆盖旧的 Bean</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 覆盖</span></span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.</span></span><br><span class="line">      <span class="comment">// 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span></span><br><span class="line">      <span class="comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">      <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">         <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">            updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">               Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 最正常的应该是进到这个分支。</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">         <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">         <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">         <span class="comment">// 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span></span><br><span class="line">         <span class="comment">// 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span></span><br><span class="line">         <span class="comment">// 手动指的是通过调用以下方法注册的 bean ：</span></span><br><span class="line">         <span class="comment">//     registerSingleton(String beanName, Object singletonObject)</span></span><br><span class="line">         <span class="comment">// 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面&quot;手动&quot;注册一些 Bean，</span></span><br><span class="line">         <span class="comment">// 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span></span><br><span class="line">         <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这个不重要，在预初始化的时候会用到，不必管它。</span></span><br><span class="line">      <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、Refresh：准备Bean容器"><a href="#5、Refresh：准备Bean容器" class="headerlink" title="5、Refresh：准备Bean容器"></a>5、Refresh：准备Bean容器</h3><p>Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p><p>这块代码中，Spring 对一些特殊的 bean 进行了处理，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span></span><br><span class="line">   <span class="comment">// 这里设置为加载当前 ApplicationContext 类的类加载器</span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 BeanExpressionResolver</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 添加一个 BeanPostProcessor，这个 processor 比较简单：</span></span><br><span class="line">   <span class="comment">// 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span></span><br><span class="line">   <span class="comment">// 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span></span><br><span class="line">   <span class="comment">// 注意：它不仅仅回调 ApplicationContextAware，</span></span><br><span class="line">   <span class="comment">//   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span></span><br><span class="line">   <span class="comment">// Spring 会通过其他方式来处理这些依赖。</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span></span><br><span class="line"><span class="comment">    * 之前我们说过，&quot;当前 ApplicationContext 持有一个 BeanFactory&quot;，这里解释了第一行。</span></span><br><span class="line"><span class="comment">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span></span><br><span class="line"><span class="comment">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span></span><br><span class="line"><span class="comment">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span></span><br><span class="line">   <span class="comment">// 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span></span><br><span class="line">   <span class="comment">// tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，</span></span><br><span class="line">   <span class="comment">//    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从下面几行代码我们可以知道，Spring 往往很 &quot;智能&quot; 就是因为它会帮我们默认注册一些有用的 bean，</span></span><br><span class="line"><span class="comment">    * 我们也可以选择覆盖</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果没有定义 &quot;environment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 &quot;systemProperties&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 &quot;systemEnvironment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、Refresh：实例化所有单例的Bean"><a href="#6、Refresh：实例化所有单例的Bean" class="headerlink" title="6、Refresh：实例化所有单例的Bean"></a>6、Refresh：实例化所有单例的Bean</h3><ol><li>目前为止，BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</li><li> 接下来就是实例化，<code>finishBeanFactoryInitialization(beanFactory);</code> 这里会负责初始化所有的 singleton beans。Spring 会在这个阶段完成所有的 singleton beans 的实例化，懒加载的除外。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化剩余的 singleton beans</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span></span><br><span class="line">   <span class="comment">// 什么，看代码这里没有初始化 Bean 啊！</span></span><br><span class="line">   <span class="comment">// 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 先初始化 LoadTimeWeaverAware 类型的 Bean</span></span><br><span class="line">   <span class="comment">// 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span></span><br><span class="line">   <span class="comment">// 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 开始初始化</span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">   <span class="comment">// 该方法由DefaultListableBeanFactory 这个类提供</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一行初始化又回到 DefaultListableBeanFactory 这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// this.beanDefinitionNames 保存了所有的 beanNames</span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 合并父 Bean 中的配置，注意 &lt;bean id=&quot;&quot; class=&quot;&quot; parent=&quot;&quot; /&gt; 中的 parent，用的不多吧，</span></span><br><span class="line">      <span class="comment">// 考虑到这可能会影响大家的理解，我在附录中解释了一下 &quot;Bean 继承&quot;，不了解的请到附录中看一下</span></span><br><span class="line">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 非抽象、非懒加载的 singletons。如果配置了 &#x27;abstract = true&#x27;，那是不需要初始化的</span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">         <span class="comment">// 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)</span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            <span class="comment">// FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急</span></span><br><span class="line">            <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="comment">// 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过</span></span><br><span class="line">            <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">               isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line"></span><br><span class="line">               getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了</span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span></span><br><span class="line">   <span class="comment">// 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      Object singletonInstance = getSingleton(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>getBean方法</p></blockquote><p>AbstractBeanFactory提供的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，</span></span><br><span class="line"><span class="comment">// 已经初始化过了就从容器中直接返回，否则就先初始化再返回</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span></span><br><span class="line">   <span class="comment">// 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span></span><br><span class="line">   <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注意跟着这个，这个是返回值</span></span><br><span class="line">   Object bean; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查下是不是已经创建过了</span></span><br><span class="line">   Object sharedInstance = getSingleton(beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span></span><br><span class="line">   <span class="comment">// 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span></span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span></span><br><span class="line">      <span class="comment">// 如果是 FactoryBean 的话，返回它创建的那个实例对象</span></span><br><span class="line">      <span class="comment">// (FactoryBean 知识，读者若不清楚请移步附录)</span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，</span></span><br><span class="line">         <span class="comment">// 往往是因为陷入了循环引用</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查一下这个 BeanDefinition 在容器中是否存在</span></span><br><span class="line">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span></span><br><span class="line">         String nameToLookup = originalBeanName(name);</span><br><span class="line">         <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回父容器的查询结果</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">         <span class="comment">// typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span></span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 稍稍总结一下：</span></span><br><span class="line"><span class="comment">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span></span><br><span class="line"><span class="comment">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 先初始化依赖的所有 Bean，这个很好理解。</span></span><br><span class="line">         <span class="comment">// 注意，这里的依赖指的是 depends-on 中定义的依赖</span></span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">               <span class="comment">// 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span></span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 注册一下依赖关系</span></span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               <span class="comment">// 先初始化被依赖项</span></span><br><span class="line">               getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是 singleton scope 的，创建 singleton 的实例</span></span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="comment">// 执行创建 Bean，详情后面再说</span></span><br><span class="line">                     <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                     destroySingleton(beanName);</span><br><span class="line">                     <span class="keyword">throw</span> ex;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是 prototype scope 的，创建 prototype 的实例</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">            Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               <span class="comment">// 执行创建 Bean</span></span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            String scopeName = mbd.getScope();</span><br><span class="line">            <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                     beforePrototypeCreation(beanName);</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 执行创建 Bean</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterPrototypeCreation(beanName);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                     <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span></span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><ul><li><strong>BeanDefinition ：</strong>存放类的信息（继承自父Bean的信息、Bean 的名称、Bean的Scope、启动所必需的Bean但是不一定是Java的依赖关系、工厂名称、属性值等等）</li><li><strong>BeanDefinitionHolder：</strong>内部封装BeanDefinition 的实例和它的 beanName、aliases </li></ul><p><strong>Bean的启动：</strong>以ClassPathXmlApplicationContext为例 </p><ol><li>ClassPathXmlApplicationContext的构造函数中，会调用refresh() 进行bean的初始化。refresh 方法 由 ClassPathXmlApplicationContext的父类AbstractApplicationContext提供</li><li>refresh 方法是一个同步方法保证线程安全，首先调用 prepareRefresh()进行准备工作，记录下容器的启动时间、标记“已启动”状态、</li><li>接着调用 obtainFreshBeanFactory(); 进行 bean的初始化 、加载、注册等操作。<ul><li>obtainFreshBeanFactory() 主要是通过调用  refreshBeanFactory()方法（AbstractRefreshableApplicationContext 类 提供）来进行具体的操作。</li><li> refreshBeanFactory()方法首先判断 BeanFactory 是否加载过，加载过就销毁。</li><li> refreshBeanFactory()方法接着会初始化一个（ DefaultListableBeanFactory）BeanFactory 的后代，通过该对象对 bean 进行操作。</li><li> refreshBeanFactory()方法接着会调用 customizeBeanFactory 方法进行两个属性的配置：是否允许 Bean 覆盖 和 是否允许循环依赖。</li><li> refreshBeanFactory()方法接着会调用 loadBeanDefinitions 方法（由AbstractXmlApplicationContext 类提供的方法）进行 <code>Bean 的加载</code>。</li><li> loadBeanDefinitions 方法会实例化一个XmlBeanDefinitionReader 类对象来读取信息并且加载各个Bean，通过重载调用方法 loadBeanDefinitions 。</li><li>重载的loadBeanDefinitions 方法会获取资源文件，然后再次调用二次重载方法 loadBeanDefinitions 方法。二次重载的 loadBeanDefinitions 方法会把获得的资源数组进行循环，每个资源（文件）会调用三次重载的loadBeanDefinitions 方法 进行单独的加载。</li><li>三次重载的 的loadBeanDefinitions 方法会把把配置文件解析称为DOM树，然后调用doRegisterBeanDefinitions方法进入分支选择，Spring默认的 标签用parseDefaultElement(ele, delegate) 方法进行解析，扩展的 标签用 delegate.parseCustomElement(ele) 方法进行解析。</li><li>解析过程中将 &lt; bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder中，然后调用 BeanDefinitionReaderUtils.registerBeanDefinition 方法进行注册；最后发送事件。</li><li>注册Bean的过程：把BeanDefinitionHolder内部封装的 BeanDefinition对象提取出来，然后根据 放入beanDefinitionMap 这个 map 中， Bean的名字作为键，BeanDefinition对象作为值。接着使用ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字。</li></ul></li><li>refresh 方法会进行初始化前的准备工作，调用 prepareBeanFactory 方法会”手动”注册一些特殊的 bean。</li><li>refresh 方法会调用 finishBeanFactoryInitialization 方法进行类的实例化，会负责初始化所有的 非懒加载、非抽象 的 singleton beans。实例化的核心方法由 DefaultListableBeanFactory 这个类提供，取出 ArrayList 里面存放的 Bean 的名称，依次 通过 getBean 方法（ AbstractBeanFactory 提供）进行初始化<ul><li>getBean 方法获取 Bean的 名称之后，会先判断是否存在，若已存在就直接返回，否则初始化后再返回。</li><li>getBean 方法会针对  singleton 和 prototype （非单例的容器启动不会实例化，获取时才会实例化）和其他的分别创建不同的 Bean，创建完成之后还会进行类型检查。</li><li>getBean 方法是工厂模式的创建Bean，通过反射。完成之后注入属性，如果依赖其他对象，会先对其他对象进行实例化。</li></ul></li></ol><h1 id="3、HelloSpring"><a href="#3、HelloSpring" class="headerlink" title="3、HelloSpring"></a>3、HelloSpring</h1><h2 id="3-1、创建Maven项目"><a href="#3-1、创建Maven项目" class="headerlink" title="3.1、创建Maven项目"></a>3.1、创建Maven项目</h2><h2 id="3-2、添加依赖"><a href="#3-2、添加依赖" class="headerlink" title="3.2、添加依赖"></a>3.2、添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring 框架坐标依赖添加 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- aop --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mysql --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.39<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   </span><br><span class="line"><span class="comment">&lt;!-- c3p0 连接池 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring jdbc --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springs事务 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-3、配置spring-config-xml"><a href="#3-3、配置spring-config-xml" class="headerlink" title="3.3、配置spring-config.xml"></a>3.3、配置spring-config.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloSpring&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wzh.Hello&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">name</span>=<span class="string">&quot;hello2 h2,h3;h4&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> id表示名字，class表示该类的位置加.类名 </span></span><br><span class="line"><span class="comment">name表示取多个别名。获取 Bean 的时候，可以根据 name，也可以通过别名</span></span><br><span class="line"><span class="comment">如com.xxx.wzh.Hello表示com.xxx.wzh包里的Hello类</span></span><br><span class="line"><span class="comment">配置成功的话长按ctrl鼠标左点击能够跳转</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 取别名，为上面的helloSpring --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;helloSpring&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;h1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 取别名，使用注解，没有手动配置bean的配置情况下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;h1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用其他特性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- AOP  --&gt;</span></span><br><span class="line">1.添加命名空间</span><br><span class="line">xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; http://www.springframework.org/schema/aop </span><br><span class="line">http://www.springframework.org/schema/aop/spring-aop.xsd</span><br><span class="line">2.配置Aop代理</span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 事务  --&gt;</span></span><br><span class="line">1.修改 xml 命名空间</span><br><span class="line">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line"></span><br><span class="line">2.配置事物管理器，需要配置数据源</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">3.开始事务，标注@Transactional的类和方法将具有事务性 </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用注解 --&gt;</span></span><br><span class="line">1.修改 xml 命名空间</span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">http://www.springframework.org/schema/context </span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">2.添加扫描</span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span> 只含DI</span><br><span class="line">或者<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.mage&quot;</span>/&gt;</span> IOC和DI</span><br><span class="line"><span class="comment">&lt;!-- c、p方式注入属性 --&gt;</span></span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br></pre></td></tr></table></figure><h2 id="3-4、代码编写bean"><a href="#3-4、代码编写bean" class="headerlink" title="3.4、代码编写bean"></a>3.4、代码编写bean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello Spring!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5、测试代码"><a href="#3-5、测试代码" class="headerlink" title="3.5、测试代码"></a>3.5、测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext=<span class="keyword">new</span> </span><br><span class="line">ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>); </span><br><span class="line">    Hello hello=(Hello) applicationContext.getBean(<span class="string">&quot;helloSpring&quot;</span>);</span><br><span class="line">    hello.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello对应别名，Hello对应类名</span></span><br></pre></td></tr></table></figure><h2 id="3-6、加载多个spring配置文件（XML）"><a href="#3-6、加载多个spring配置文件（XML）" class="headerlink" title="3.6、加载多个spring配置文件（XML）"></a>3.6、加载多个spring配置文件（XML）</h2><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法一：</span></span><br><span class="line"><span class="comment">同时加载多个xml文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ApplicationContext applicationContext=<span class="keyword">new</span> </span><br><span class="line">ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>,<span class="string">&quot;dao.xml&quot;</span>);</span><br><span class="line">Hello hello=(Hello) applicationContext.getBean(<span class="string">&quot;helloSpring&quot;</span>);</span><br><span class="line">Dao dao= applicationContext.getBean(<span class="string">&quot;dao&quot;</span>,Dao.class);</span><br><span class="line">hello.print();</span><br><span class="line">dao.print();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法二:</span></span><br><span class="line"><span class="comment">import把dao.xml导入hello.xml，用于团队项目</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;<span class="keyword">import</span> resource=<span class="string">&quot;Dao.xml&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="3-7、禁止覆盖和循环依赖问题"><a href="#3-7、禁止覆盖和循环依赖问题" class="headerlink" title="3.7、禁止覆盖和循环依赖问题"></a>3.7、禁止覆盖和循环依赖问题</h3><ul><li>默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。但是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖。</li><li>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoBeanOverridingContextLoader</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeContext</span><span class="params">(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.customizeContext(servletContext, applicationContext);</span><br><span class="line">    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;</span><br><span class="line">    arac.setAllowBeanDefinitionOverriding(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> ContextLoader <span class="title">createContextLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NoBeanOverridingContextLoader();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.wzh.MyContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-8、多环境配置"><a href="#3-8、多环境配置" class="headerlink" title="3.8、多环境配置"></a>3.8、多环境配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">&quot;http://www.springframework.org/schema/jee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;production&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">jndi-name</span>=<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4、Spring-Ioc实例化Bean对象"><a href="#4、Spring-Ioc实例化Bean对象" class="headerlink" title="4、Spring Ioc实例化Bean对象"></a>4、Spring Ioc实例化Bean对象</h1><ul><li>BeanFactory是个Factory，也就是IOC容器或对象工厂，在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。</li><li>FactoryBean是个Bean。但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能<code>生产或者修饰对象生成的工厂Bean</code>,它的实现与设计模式中的工厂模式和修饰器模式类似</li></ul><h2 id="4-1、构造器的方式实例化-bean-对象"><a href="#4-1、构造器的方式实例化-bean-对象" class="headerlink" title="4.1、构造器的方式实例化 bean 对象"></a>4.1、构造器的方式实例化 bean 对象</h2><p>在Xml里面添加，通过默认构造器创建，必须有空构造方法，否则创建失败</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;com.xxx.wzh.Hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-2、静态工厂模式"><a href="#4-2、静态工厂模式" class="headerlink" title="4.2、静态工厂模式"></a>4.2、静态工厂模式</h2><ul><li>要有该工厂类及工厂方法</li><li>工厂方法是静态的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米11&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂类:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GoodsService <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GoodsService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xml声明：</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;goodsService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.wzh.StaticFactory&quot;</span> </span><br><span class="line">    factory-method=<span class="string">&quot;create&quot;</span>&gt; &lt;/bean&gt;</span><br><span class="line"><span class="comment">//注：id为别名 class为工厂类位置 factory-method为工厂类方法</span></span><br></pre></td></tr></table></figure><h2 id="4-3、实例化工厂方式创建Bean"><a href="#4-3、实例化工厂方式创建Bean" class="headerlink" title="4.3、实例化工厂方式创建Bean"></a>4.3、实例化工厂方式创建Bean</h2><p>相比较静态工厂实现</p><ul><li>工厂方法为非静态方法</li><li>需要配置工厂bean，并在业务bean中配置factory-bean,factory-method属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;暂未发货&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderService <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Xml注解：</span></span><br><span class="line"><span class="comment">//工厂类，先配置工厂类的bean，然后实体类依靠工厂类制造</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;instanceFactory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.wzh.InstanceFactory&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;orderService&quot;</span> factory-bean=<span class="string">&quot;instanceFactory&quot;</span> </span><br><span class="line">    factory-method=<span class="string">&quot;create&quot;</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：获得的bean为子bean  applicationContext.getBean(&quot;orderService&quot;);</span></span><br></pre></td></tr></table></figure><h1 id="5、Spring依赖注入（DI）"><a href="#5、Spring依赖注入（DI）" class="headerlink" title="5、Spring依赖注入（DI）"></a>5、Spring依赖注入（DI）</h1><h2 id="5-1、set注入"><a href="#5-1、set注入" class="headerlink" title="5.1、set注入"></a>5.1、set注入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">userLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserDao里的方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用到了UserDao类并且没有通过new获得</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String r = userDao.userLogin();</span><br><span class="line">        System.out.print(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userdao&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.test01.UserDao&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.test01.UserService&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userdao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"><span class="comment">//注意下面bean中的ref要与上面的id内容对应</span></span><br><span class="line"><span class="comment">//              name与注入的属性名称对应</span></span><br></pre></td></tr></table></figure><ul><li>set注入根据bean实例化的三种形式也有三种</li></ul><h2 id="5-2、构造器注入"><a href="#5-2、构造器注入" class="headerlink" title="5.2、构造器注入"></a>5.2、构造器注入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">userLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;UserDao里的方法&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用到了UserDao类并且没有通过new获得</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String r = userDao.userLogin();</span><br><span class="line">        System.out.print(r);</span><br><span class="line">        System.out.print(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(UserDao userDao, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Xml配置：</span></span><br><span class="line">    &lt;bean id=<span class="string">&quot;userdao1&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.test02.UserDao&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService1&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.test02.UserService&quot;</span>&gt;</span><br><span class="line">        &lt;constructor-arg index=<span class="string">&quot;0&quot;</span> ref=<span class="string">&quot;userdao1&quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg index=<span class="string">&quot;1&quot;</span> value=<span class="string">&quot;我爱中国&quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">形式<span class="number">1</span>：index属性为参数顺序，如果只有一个参数index可以不设置，外部引用时设置ref</span><br><span class="line">形式<span class="number">2</span>：name属性根据构造器中属性的名字。</span><br><span class="line">形式<span class="number">3</span>：type属性，根据构造器中属性的类型来匹配的。如果相同类型属性不唯一，注入的属性按照顺序注入进来</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line">Type=”String” value=”userdao”  Type=”String” value=”爱我中华”</span><br></pre></td></tr></table></figure><h2 id="5-3、P命名空间注入（对应set）"><a href="#5-3、P命名空间注入（对应set）" class="headerlink" title="5.3、P命名空间注入（对应set）"></a>5.3、P命名空间注入（对应set）</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 命名空间 --&gt;</span></span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置 P: 格式注入属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wzh.pojo.User&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;h3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User类，必须有无参构造方法，以及get、set方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hello hello;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hello <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHello</span><span class="params">(Hello hello)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hello = hello;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4、C命名空间注入（对应构造器）"><a href="#5-4、C命名空间注入（对应构造器）" class="headerlink" title="5.4、C命名空间注入（对应构造器）"></a>5.4、C命名空间注入（对应构造器）</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 命名空间 --&gt;</span></span><br><span class="line">xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wzh.pojo.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;1&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">c:hello-ref</span>=<span class="string">&quot;h3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li> 实体类同上，要有构造器方法</li></ul><h2 id="5-5、循环依赖的问题的产生："><a href="#5-5、循环依赖的问题的产生：" class="headerlink" title="5.5、循环依赖的问题的产生："></a>5.5、循环依赖的问题的产生：</h2><p>Bean通过构造器注入，之间彼此相互依赖对方导致bean无法实例化。</p><p>原因：</p><ul><li>构造器注入时：<strong>必须先注入在创建对象</strong></li><li>Setter注入时：先创建对象再注入</li></ul><p><strong>解决办法：使用setter注入</strong></p><h2 id="5-7、IoC集合类型属性注入"><a href="#5-7、IoC集合类型属性注入" class="headerlink" title="5.7、IoC集合类型属性注入"></a>5.7、IoC集合类型属性注入</h2><h3 id="1、-list集合注入"><a href="#1、-list集合注入" class="headerlink" title="1、 list集合注入"></a>1、 list集合注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>河南烩面<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>南方臊子面<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>油泼面<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>方便面<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- name属性为list集合类的属性 private List&lt;String&gt; food; --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、set集合注入"><a href="#2、set集合注入" class="headerlink" title="2、set集合注入"></a>2、set集合注入</h3><p>①中的list标签换成set</p><h3 id="3、map类型属性注入"><a href="#3、map类型属性注入" class="headerlink" title="3、map类型属性注入"></a>3、map类型属性注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prop&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>河南<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>云台山风景<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">entry</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>宝塔<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">entry</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4、properties属性注入"><a href="#4、properties属性注入" class="headerlink" title="4、properties属性注入"></a>4、properties属性注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prop&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;北京&quot;</span>&gt;</span>长城<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;上海&quot;</span>&gt;</span>东方明珠<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;西安&quot;</span>&gt;</span>兵马俑<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-8、DI注入Bean"><a href="#5-8、DI注入Bean" class="headerlink" title="5.8、DI注入Bean"></a>5.8、DI注入Bean</h2><p><strong>FactoryBean接口</strong>：其实就是注解 @Resource的的xml 化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getObjectType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要创建一个Person 的 Bean，首先我们需要一个 Car 的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> Car car ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span></span>&#123; <span class="keyword">this</span>.car = car;  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以把创建 Car 的复杂过程包装起来</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCarFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String make; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMake</span><span class="params">(String m)</span></span>&#123; <span class="keyword">this</span>.make =m ; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setYear</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">this</span>.year = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span></span>&#123; </span><br><span class="line">      <span class="comment">// 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种</span></span><br><span class="line">      CarBuilder cb = CarBuilder.car();</span><br><span class="line">      <span class="keyword">if</span>(year!=<span class="number">0</span>) cb.setYear(<span class="keyword">this</span>.year);</span><br><span class="line">      <span class="keyword">if</span>(StringUtils.hasText(<span class="keyword">this</span>.make)) cb.setMake( <span class="keyword">this</span>.make ); </span><br><span class="line">      <span class="keyword">return</span> cb.factory(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;Car&gt; <span class="title">getObjectType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Car.class ; &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的xml</span></span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span> </span>= <span class="string">&quot;com.wzh.MyCarFactoryBean&quot;</span> id = <span class="string">&quot;car&quot;</span>&gt;</span><br><span class="line">  &lt;property name = <span class="string">&quot;make&quot;</span> value =<span class="string">&quot;Honda&quot;</span>/&gt;</span><br><span class="line">  &lt;property name = <span class="string">&quot;year&quot;</span> value =<span class="string">&quot;1984&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span> </span>= <span class="string">&quot;com.wzh.Person&quot;</span> id = <span class="string">&quot;josh&quot;</span>&gt;</span><br><span class="line">  &lt;property name = <span class="string">&quot;car&quot;</span> ref = <span class="string">&quot;car&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p><h2 id="5-9、DI方法注入"><a href="#5-9、DI方法注入" class="headerlink" title="5.9、DI方法注入"></a>5.9、DI方法注入</h2><h3 id="1、方案注入解决-singleton-依赖-prototype"><a href="#1、方案注入解决-singleton-依赖-prototype" class="headerlink" title="1、方案注入解决 singleton 依赖 prototype"></a>1、方案注入解决 singleton 依赖 prototype</h3><p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。</p><p>但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean，那么如何获取我们需要的指定的Bean呢？</p><ol><li>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。</li><li>另一种解决方案就是通过使用 Lookup method。</li></ol><blockquote><p>案例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        Command command = createCommand();       </span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//    @Lookup(&quot;myCommand&quot;) 注解方式不必配置  </span></span><br><span class="line"><span class="comment">//    protected abstract Command createCommand();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;myCommand&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fiona.apple.AsyncCommand&quot;</span> scope=<span class="string">&quot;prototype&quot;</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;commandManager&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fiona.apple.CommandManager&quot;</span>&gt;</span><br><span class="line">    &lt;lookup-method name=<span class="string">&quot;createCommand&quot;</span> bean=<span class="string">&quot;myCommand&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>Spring 采用 <strong>CGLIB 生成字节码</strong>的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。</p><h3 id="2、replaced-method-替换掉-bean-中的一些方法"><a href="#2、replaced-method-替换掉-bean-中的一些方法" class="headerlink" title="2、replaced-method 替换掉 bean 中的一些方法"></a>2、replaced-method 替换掉 bean 中的一些方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValueCalculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">computeValue</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">beans</span>.<span class="title">factory</span>.<span class="title">support</span>.<span class="title">MethodReplacer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String input = (String) args[<span class="number">0</span>];</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;myValueCalculator&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;x.y.z.MyValueCalculator&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;</span><br><span class="line">    &lt;replaced-method name=<span class="string">&quot;computeValue&quot;</span> replacer=<span class="string">&quot;replacementComputeValue&quot;</span>&gt;</span><br><span class="line">        &lt;arg-type&gt;String&lt;/arg-type&gt; &lt;!-- 这个不是必须的，除非存在方法重载 --&gt;</span><br><span class="line">    &lt;/replaced-method&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;replacementComputeValue&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;a.b.c.ReplacementComputeValue&quot;</span>/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="6、Bean的自动装配"><a href="#6、Bean的自动装配" class="headerlink" title="6、Bean的自动装配"></a>6、Bean的自动装配</h1><p>自动装配是Spring满足bean依赖的一种方式Spring会在上下文中自动寻找，并自动给bean装配属性Spring中bean有三种装配机制，分别是：</p><ul><li>xml显式的配置</li><li>java显式的配置</li><li>隐式的自动装配</li></ul><p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p><ul><li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li><li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li></ul><p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p><p>例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bean的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wzh.pojo.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">autowire=&quot;byName&quot;表示为按名字自动装配</span></span><br><span class="line"><span class="comment">User类内属性有  private Hello hello;</span></span><br><span class="line"><span class="comment">程序会自动在spring上下文找名字为hello的bean并自动装配</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;com.wzh.Hello&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  <span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello1&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;com.wzh.Hello&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> <span class="comment">&lt;!-- 报错 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">autowire=&quot;byType&quot;  寻找类型相同的的，</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;com.wzh.Hello&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  <span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello1&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;com.wzh.Hello&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> <span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上面两个单独出现都正确，如果同时配置两个就会报错 --&gt;</span></span><br></pre></td></tr></table></figure><h1 id="7、使用注解开发"><a href="#7、使用注解开发" class="headerlink" title="7、使用注解开发"></a>7、使用注解开发</h1><p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p><h2 id="7-1、注解方式属性注入bean"><a href="#7-1、注解方式属性注入bean" class="headerlink" title="7.1、注解方式属性注入bean"></a>7.1、注解方式属性注入bean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以放在属性的定义上，也可以放在set方法上，优先set方法</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Hello hello;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHello</span><span class="params">(Hello hello)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.hello = hello;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、注入bean"><a href="#1、注入bean" class="headerlink" title="1、注入bean"></a>1、注入bean</h3><ul><li><p>@Autowired （spring提供注解）</p><ul><li>通过autowire=”byType”方式自动装配，必须要求对象存在</li><li>@Autowired(required=false) ：对象可以为null</li><li>需要导入 spring-aop的包！</li><li>加上@Qualifier则可以根据byName的方式自动装配，@Qualifier不能单独使用</li><li>可以用于参数上</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;cat2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure><ul><li><p>@Resource （JDK提供的注解）</p><ul><li>通过byName方式实现，找不到名字，则通过byType实现，找不到报错</li><li>JDK1.5以上即可使用</li><li>不能用于参数上</li></ul></li></ul><h3 id="2、注入属性"><a href="#2、注入属性" class="headerlink" title="2、注入属性"></a>2、注入属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure><h2 id="7-2、Spring-IoC容器自动扫描管理bean"><a href="#7-2、Spring-IoC容器自动扫描管理bean" class="headerlink" title="7.2、Spring IoC容器自动扫描管理bean"></a>7.2、Spring IoC容器自动扫描管理bean</h2><p>不需要再配置<code>&lt;context:annotation-config/&gt;</code> 只含DI</p><p>只需<code>&lt;context:component-scan base-package=&quot;com.xxx&quot;/&gt;</code>包含loc和DI</p><ul><li>Dao层：@Repository </li><li> Service层：@Service  </li><li>视图控制层：@Controller</li><li>比较中立的类：@Component </li></ul><p>在类定义前面添加注解，其他类创建该类对象的时候就不用使用new，获取的bean的名称自动变为首字母小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span>   <span class="comment">//配置作用域为单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello Spring!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，销毁所有对象</li><li>prototype：多例模式。Spring不会管理这个Bean。</li></ul><h2 id="7-3、-Bean注解"><a href="#7-3、-Bean注解" class="headerlink" title="7.3、@Bean注解"></a>7.3、@Bean注解</h2><ul><li>@用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。</li><li> @Bean就放在方法上，就是让方法去产生一个Bean，然后交给Spring容器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AccountDao <span class="title">ao</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AccountDao();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>让a方法产生一个AccountDao 对象，然后这个AccountDao 对象交给Spring管理</li></ul><blockquote><p>使用的原因</p></blockquote><ul><li>类似@Component , @Repository , @ Controller , @Service 这些注册Bean的注解存在局限性，只能局限作用于自己编写的类</li><li>需要对Spring的默认功能进行扩展</li></ul><h1 id="8、JavaConfig配置（SpringBoot）"><a href="#8、JavaConfig配置（SpringBoot）" class="headerlink" title="8、JavaConfig配置（SpringBoot）"></a>8、JavaConfig配置（SpringBoot）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java实体类</span></span><br><span class="line"><span class="comment">//这里注解的意思，就是说明</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Hello hello;</span><br><span class="line">    <span class="meta">@Value(&quot;2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hello <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHello</span><span class="params">(Hello hello)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hello = hello;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java代码实现配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代表这是一个配置类，和spring.xml类似</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.wzh&quot;)</span>  <span class="comment">//扫描</span></span><br><span class="line"><span class="meta">@Import(WzhConfig2.class)</span>  <span class="comment">//导入其他类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WzhConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册一个bean，相当于bean标签</span></span><br><span class="line">    <span class="comment">//该方法的名字就相当于bean标签的id属性，方法的返回值就相当于class</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hello <span class="title">getHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WzhConfig.class);</span><br><span class="line">        User user= (User) context.getBean(<span class="string">&quot;getUser&quot;</span>);</span><br><span class="line">        System.out.println(user.getAge());</span><br><span class="line">        user.getHello().print();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9、Bean的一些问题"><a href="#9、Bean的一些问题" class="headerlink" title="9、Bean的一些问题"></a>9、Bean的一些问题</h1><h2 id="9-1、作用域问题"><a href="#9-1、作用域问题" class="headerlink" title="9.1、作用域问题"></a>9.1、作用域问题</h2><p>默认情况下，我们从spring容器中拿到的对象均是<strong>单例</strong>的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);  </span><br><span class="line"></span><br><span class="line">UserController u1 = (UserController) applicationContext.getBean(<span class="string">&quot;userController&quot;</span>);</span><br><span class="line"></span><br><span class="line">UserController u2 = (UserController) applicationContext.getBean(<span class="string">&quot;userController&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(u1);</span><br><span class="line">System.out.println(u2);  <span class="comment">//输出结果一致</span></span><br></pre></td></tr></table></figure><h3 id="1、singleton作用域-默认，即单例模式"><a href="#1、singleton作用域-默认，即单例模式" class="headerlink" title="1、singleton作用域(默认，即单例模式)"></a>1、singleton作用域(默认，即单例模式)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.wzh.Bean1&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>singleton作用域：默认情况下，被管理的bean只会在IoC容器中存在一个共享实例，(对于同一个bean只会产生唯一实例)，所有获取该Bean的操作Spring容器将<strong>只返回同一个Bean，地址一样。</strong></p><p>容器在<strong>启动的情况下就实例化所有</strong>的singleton的bean对象，并缓存于容器中</p><ul><li><p>提前发现潜在的配置问题</p></li><li><p>Bean对象存在于缓存中，使用时不用再去实例化bean，加快程序运行效率</p></li></ul><ul><li>若xml中bean配置时设置lazy-init=”true”spring容器启动的时候不会去实例化这个bean(交给spring托管)，而是在程序调用时才去实例化，默认是false即spring容器启动时实例化</li></ul><p><strong>使用singleton作用域规范：</strong></p><ul><li><p>无状态或状态不可改变的对象适合单例模式，如service，dao，Controller等</p></li><li><p>对象状态的变化往往均是由于属性值得改变而引起的，实体类如user的属性比如password容易改变，</p></li><li><p>无状态对象没有实例变量的存在，保证了线程的安全性，service层业务对象即是无状态对象。线程安全的。</p></li></ul><h3 id="2、-prototype作用域（原型模式）"><a href="#2、-prototype作用域（原型模式）" class="headerlink" title="2、 prototype作用域（原型模式）"></a>2、 prototype作用域（原型模式）</h3><p>调用bean的时候创建，而且每次向Spring容器请求获取Bean都<strong>返回一个全新的Bean，地址不一样。</strong>即不缓存Bean，每次根据Bean定义创建一个全新Bean。</p><p>注意：</p><ul><li>Spring不能对一个 prototype bean的整个生命周期负责</li><li>容器在初始化、配置、装饰或装配完一个prototype实例后，将它交给客户端随后就对该prototype实例不闻不问了。</li><li>清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责。</li></ul><h3 id="3、Web中的作用域（request、session、application）"><a href="#3、Web中的作用域（request、session、application）" class="headerlink" title="3、Web中的作用域（request、session、application）"></a>3、Web中的作用域（request、session、application）</h3><ul><li><p>request作用域：表示每个请求需要容器创建一个全新的Bean，</p></li><li><p>session作用域：表示每个会话需要容器创建一个全新Bean，</p></li><li><p>global-session作用域：全局</p></li></ul><h2 id="9-2、线程安全问题"><a href="#9-2、线程安全问题" class="headerlink" title="9.2、线程安全问题"></a>9.2、线程安全问题</h2><p>多个对象操作一个Bean时，会产生线程安全问题</p><p>解决办法：</p><ol><li>在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在其中</li><li>加锁</li></ol><h2 id="9-3、-Component和-Bean的区别"><a href="#9-3、-Component和-Bean的区别" class="headerlink" title="9.3、@Component和@Bean的区别"></a>9.3、@Component和@Bean的区别</h2><ol><li>@Component用于类，@Bean用于方法。</li><li>@Component通过类路径扫描的方式自动装配到 Spring 容器中，@Bean 通常是我们在标有该注解的方法中定义产生这个bean, @Bean 告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li><li>SpringBoot 中  @Component 和@ComponentScan 搭配， @Bean 和 @Configuration搭配使用。</li><li>@Bean 的自定义性更强，很多时候只能通过 @Bean 实现功能。如当我们引用第三⽅库中的类需要装配到 Spring 容器时，则只能通过 @Bean 来实现。</li></ol><h1 id="10、bean的生命周期"><a href="#10、bean的生命周期" class="headerlink" title="10、bean的生命周期"></a>10、bean的生命周期</h1><p>Bean的初始化：调用 init-method 方法 后完成。</p><p><img src="C:\Users\admin\Desktop\Java学习笔记\Web和SSM\img\web\图片41.jpg"></p><p><strong>大体上的流程</strong></p><ol><li>Bean 容器找到配置文件中 Spring Bean 的定义，根据信息生成 BeanDefinition 对象，然后放到 map 里面 ，完成加载、注册 等工作。</li><li>Bean 容器利用 Java Reflection API 创建⼀个Bean的实例<ul><li>如果涉及到⼀些属性值 利用 set() 方法设置⼀些属性值。</li><li>如果 Bean 实现了 BeanNameAware 接口，调⽤ setBeanName() 方法，传⼊Bean的名字。</li><li>如果 Bean 实现了 BeanClassLoaderAware 接口，调⽤ setBeanClassLoader() 方法，传入ClassLoader 对象的实例。</li><li>与上面的类似，如果实现了其他 *.Aware 接口，就调用相应的方法。</li></ul></li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法</li><li>如果Bean实现了 InitializingBean 接口，执行 afterPropertiesSet() 方法。</li><li>如果 Bean 在配置⽂件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() ⽅法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ol><p>注册—-&gt; 实例化 —-&gt; set注入属性值 —&gt; 实现Aware 接口对应的方法 —&gt;  执行初始化方法 — &gt; 执行销毁方法</p><p><strong>初始化和销毁的顺序：</strong></p><ol><li>加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象</li><li> Bean 实现了  InitializingBean 接口、DisposableBean 接口</li><li>配置文件指定的 init-method 和 destroy-method </li></ol><blockquote><p>Aware举例</p></blockquote><p><strong>Aware接口作用：</strong>让自身<code>Bean</code>能够感知到，获取到自身在Spring容器中的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span></span>&#123;</span><br><span class="line"><span class="comment">// 省略其他方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以获取到Bean的名称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BeanPostProcessor</p></blockquote><p><strong>BeanPostProcessor接口：</strong>在 bean 实例化完成、属性注入完成之后，会执行回调方法</p><p>aop 中，他的前置before方法就是用来寻找出所有的切面并且解析切面类；</p><p>在bean 初始化完毕后调用后置方法 after，生成相关的代理类，renturn 回去。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">   <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">   <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-1、Bean的定义"><a href="#10-1、Bean的定义" class="headerlink" title="10.1、Bean的定义"></a>10.1、Bean的定义</h2><ul><li>xml配置文件</li><li>注解</li><li>Java配置文件</li></ul><h2 id="10-2、Bean的初始化"><a href="#10-2、Bean的初始化" class="headerlink" title="10.2、Bean的初始化"></a>10.2、Bean的初始化</h2><p>单例模式的Bean对象实例化过程是在spring容器初始化（BeanFactory加载配置文件，执行完 refresh 方法时）时被实例化的，但也不是不可改变的，可以通过lazy-init=“true”属性延迟bean对象的初始化操作，此时再调用getbean方法时才会进行bean的初始化操作 </p><p>原型模式的Bean不受Spring容器管理，生命周期和普通的new一样。</p><blockquote><p>初始化Bean的回调操作</p></blockquote><p>初始化的时候会执行方法，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1、在bean的配置文件中配置方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、继承接口，重写方法，该类会自动执行方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3、指定初始化方法</span></span><br><span class="line"><span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4、使用注解表明是一个初始化方法</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="10-3、Bean的使用"><a href="#10-3、Bean的使用" class="headerlink" title="10.3、Bean的使用"></a>10.3、Bean的使用</h2><p> ApplicationContext 从 BeanFactory 获取。</p><h2 id="10-4、Bean的销毁"><a href="#10-4、Bean的销毁" class="headerlink" title="10.4、Bean的销毁"></a>10.4、Bean的销毁</h2><p>1、实现销毁方式(spring 容器会维护 bean 对象的管理，可以指定 bean 对象的销毁所要执行的方法)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、继承接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、注解表明方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bar <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、表明自己是一个销毁方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11、Bean的继承问题"><a href="#11、Bean的继承问题" class="headerlink" title="11、Bean的继承问题"></a>11、Bean的继承问题</h1><p>初始化Bean的地方涉及了 <code>&lt;bean parent=&quot;&quot; /&gt;</code> 中的 parent 属性，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br></pre></td></tr></table></figure><ul><li>这里的继承<code>和 java 语法中的继承没有任何关系</code>，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</li><li>Spring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。</li></ul><blockquote><p>案例</p></blockquote><p>parent bean 设置了 <code>abstract=&quot;true&quot;</code> 所以它不会被实例化（设置与否与本文无关），child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。</p><p><strong>child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.TestBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritsWithDifferentClass&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.DerivedTestBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initialize&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;override&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这类Bean没有指定具体对应的Class类，所以目的就是作为父Bean，abstract必须设置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="12、AOP"><a href="#12、AOP" class="headerlink" title="12、AOP"></a>12、AOP</h1><h2 id="12-1、概念"><a href="#12-1、概念" class="headerlink" title="12.1、概念"></a>12.1、概念</h2><ul><li>AOP（Aspect Oriented Programming）意为：<code>面向切面编程</code>，通过预编译方式和运行期<code>动态代理</code>实现程序功能的统一维护的一种技术。如何代理的对象实现了接口，AOP会使用JDK动态代理，如果没有就会使用Cglib动态代理。</li><li>AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。</li><li>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</li><li> Aop关注的不再是程序代码中某个类，某些方法，而 aop 考虑的更多的是一种面到面的切入，即层与层之间的一种切入，所以称之为切面。 </li></ul><h2 id="12-2、用途"><a href="#12-2、用途" class="headerlink" title="12.2、用途"></a>12.2、用途</h2><p>日志记录，性能统计，安全控制,事务处理等方面，实现公共功能性的重复使用</p><p>优点：</p><ul><li>降低模块与模块之间的耦合度，提高业务代码的聚合度（高内聚低耦合）</li><li>提高了代码的复用性</li><li>提高系统的扩展性</li></ul><h2 id="12-3、原理"><a href="#12-3、原理" class="headerlink" title="12.3、原理"></a>12.3、原理</h2><p>AOP不是Spring特有的，但在Spring发展壮大的，成为Spring的核心技术之一。当然我们也可以使用也可以使⽤ AspectJ ,Spring AOP 已经集成了AspectJ 。切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多</p><p>AOP属于运行时增强，基于反射，<code>只能对实现了接口的类</code>生成代理类；AspectJ属于编译时增强，对代理对象类的class文件加载进来，通过修改其字节码<code>生成子类</code>来处理。</p><ul><li>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP，可以强制使用CGlib   &lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;</li><li>如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</li></ul><h2 id="12-3、Aop在Spring中的作用"><a href="#12-3、Aop在Spring中的作用" class="headerlink" title="12.3、Aop在Spring中的作用"></a>12.3、Aop在Spring中的作用</h2><ul><li>切面（Aspect）：配置通知的类</li><li>通知（Advice）：切面必须完成的工作，即一个方法<ul><li>前置通知 ———before：执行方法前通知</li><li>最终通知———-after：无论方法是否发生异常，均会执行该通知。</li><li>返回通知———-afterReturning：正常结束通知</li><li>异常抛出通知—-afetrThrow：</li><li>环绕通知———–around：</li></ul></li><li>目标（Target）：被代理的目标对象</li><li>代理（Proxy）</li><li>切入点（Pointcut）：对连接点进行拦截的定义</li><li>连接点（JointPoint）：与切入点匹配的执行点</li></ul><h2 id="12-4、实例"><a href="#12-4、实例" class="headerlink" title="12.4、实例"></a>12.4、实例</h2><h3 id="方法一：使用Spring的API接口"><a href="#方法一：使用Spring的API接口" class="headerlink" title="方法一：使用Spring的API接口"></a>方法一：使用Spring的API接口</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- xml配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用原生Spring ApI接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明对哪些类的哪些方法进行代理，并且配置切入点     --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.wzh.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给被代理类的类，配置进行环绕增强的具体类   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理类的定义：通过接口实现</span></span><br><span class="line"><span class="comment">//AfterReturningAdvice</span></span><br><span class="line"><span class="comment">//After</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Method:要实现的目标方法</span></span><br><span class="line">    <span class="comment">//object[]：参数</span></span><br><span class="line">    <span class="comment">//Object:参数对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;        System.out.println(o.getClass().getName()+<span class="string">&quot;的&quot;</span>+method.getName()+<span class="string">&quot;方法被执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口目标类的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">        UserService userService = (UserService) applicationContext.getBean(<span class="string">&quot;userServiceImpl&quot;</span>);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：自定义方法"><a href="#方法二：自定义方法" class="headerlink" title="方法二：自定义方法"></a>方法二：自定义方法</h3><p>上述的代理类和xml配置更改如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义方法当做切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiyPointCut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aop 切面配置，ref指定bean当做切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diyPointCut&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义 aop 切入点，同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=</span></span><br><span class="line"><span class="tag"><span class="string">&quot;(* com.wzh.service.UserServiceImpl.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cut&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 为切入点配置环绕增强通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;cut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方法三：基于注解"><a href="#方法三：基于注解" class="headerlink" title="方法三：基于注解"></a>方法三：基于注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先配置Aop代理</span></span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aop</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义切入点，配置切入点的拦截路径，即代理哪些类</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.wzh.service..*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前置通知，匹配对应的切入点</span></span><br><span class="line">    <span class="meta">@Before(value=&quot;cut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回通知</span></span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;cut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回通知....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最终通知，匹配对应的切入点</span></span><br><span class="line">    <span class="meta">@After(value=&quot;cut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value=&quot;cut()&quot;,throwing=&quot;e&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知....方法执行异常时执行:&quot;</span>+e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(value=&quot;cut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前置...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知&quot;</span>);</span><br><span class="line">        System.out.println(pjp.getTarget()+<span class="string">&quot;--&quot;</span>+pjp.getSignature());</span><br><span class="line">        Object result=pjp.proceed();</span><br><span class="line">        <span class="comment">//执行目标对象方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后置...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他同上</p><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">环绕前置...</span></span><br><span class="line"><span class="comment">环绕通知</span></span><br><span class="line"><span class="comment">com.wzh.service.UserServiceImpl@411f53a0--void    com.wzh.service.UserService.add()</span></span><br><span class="line"><span class="comment">前置通知</span></span><br><span class="line"><span class="comment">增</span></span><br><span class="line"><span class="comment">环绕后置...</span></span><br><span class="line"><span class="comment">最终通知</span></span><br><span class="line"><span class="comment">返回通知....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="12-5、-Aop-匹配方法规则表达式语言解释"><a href="#12-5、-Aop-匹配方法规则表达式语言解释" class="headerlink" title="12.5、 Aop 匹配方法规则表达式语言解释"></a>12.5、 Aop 匹配方法规则表达式语言解释</h2><p><code>execution(* com.wzh.service.UserServiceImpl.*(..))</code></p><ul><li>第一个   *   代表修饰符public、private等</li><li>第二个   com.wzh.service 代表包的位置</li><li>第三个   UserServiceImpl  表示类</li><li>第四个   *   表示该类下的所以方法</li><li>第五个  (..)  表示方法的参数</li></ul><p><code>execution(public *(..))</code></p><ul><li>执行任意公共方法</li></ul><p><code>execution(* set*(..))</code></p><ul><li>执行任意的 set 方法</li></ul><p><code>execution(* com.wzh.service.*.*(..))</code></p><ul><li>执行 com.wzh.service 包下任意类的任意方法</li></ul><p><code>execution(* com.wzh.service..*.*(..))</code></p><ul><li>执行 com.wzh.service包<strong>及其子包</strong>下所有类的方所有法</li></ul><p><code>execution(* com.xxx.test06.UserService.Login())</code></p><ul><li>执行com.xxx.test06包下UserService类里的Login方法</li></ul><h2 id="12-6、总结"><a href="#12-6、总结" class="headerlink" title="12.6、总结"></a>12.6、总结</h2><h4 id="1、JDK代理模式实现三要素"><a href="#1、JDK代理模式实现三要素" class="headerlink" title="1、JDK代理模式实现三要素"></a>1、JDK代理模式实现三要素</h4><ul><li>接口定义</li><li>目标对象与代理对象必须实现统一接口</li><li>代理对象持有目标对象的引用 增强目标对象行为</li></ul><h4 id="2、代理模式实现分类以及对应区别"><a href="#2、代理模式实现分类以及对应区别" class="headerlink" title="2、代理模式实现分类以及对应区别"></a>2、代理模式实现分类以及对应区别</h4><ul><li>静态代理：手动为目标对象制作代理对象，在程序<strong>编译阶段完成</strong>。</li><li>动态代理：在程序运行期<strong>动态创建</strong>目标对象对应代理对象。<ul><li>jdk动态代理：实现接口方式<code>通过反射</code>对<code>实现接口</code>的类生成代理类。</li><li>cglib动态代理：继承被代理目标对象<code>生成子类</code>并且修改字节码</li></ul></li></ul><p><strong>动态代理对比静态代理：</strong>开发效率高，可以批量化创建代理，代码复用率高</p><h4 id="3、Aop理解"><a href="#3、Aop理解" class="headerlink" title="3、Aop理解"></a>3、Aop理解</h4><ul><li>面向切面，相比oop关注的是代码中的层或面</li><li>解耦，提高系统扩展性</li><li>提高代码复用</li></ul><h4 id="4、-Aop-关键词"><a href="#4、-Aop-关键词" class="headerlink" title="4、 Aop 关键词"></a>4、 Aop 关键词</h4><ul><li>连接点：与切入点匹配的执行点</li><li>切入点：要 ‘ 代理 ‘ 的方法，指定为一个点，与具体的通知相匹配。</li><li>切面：自定义类，类里面的就是 具体的通知，进行增强的类。</li><li> 通知：几种通知方法</li><li> 目标对象:被代理对象</li><li> 织入：程序运行期将切面应用到目标对象 并生成代理对象的过程</li><li> 引入：在不修改原始代码情况下，在程序运行期为程序动态引入方法或字段的过程</li></ul><h1 id="13、Spring整合Mybatis"><a href="#13、Spring整合Mybatis" class="headerlink" title="13、Spring整合Mybatis"></a>13、Spring整合Mybatis</h1><h3 id="13-1、导入依赖"><a href="#13-1、导入依赖" class="headerlink" title="13.1、导入依赖"></a>13.1、导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring 核心jar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring 测试jar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--   spring jdbc  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring事物 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring  aop --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- c3p0 连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加mybatis与Spring整合的核心包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mysql 驱动包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志打印相关的jar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  bulid里面： --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="13-2、编写配置文件"><a href="#13-2、编写配置文件" class="headerlink" title="13.2、编写配置文件"></a>13.2、编写配置文件</h2><h3 id="1、Spring-文件-spring-xml"><a href="#1、Spring-文件-spring-xml" class="headerlink" title="1、Spring 文件 spring.xml"></a>1、Spring 文件 spring.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzh&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载数据库资源文件db.properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开始事务，标注@Transactional的类和方法将具有事务性  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启Aop代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置c3p0 数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 整合 框架（Spring与Mybatis） --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 sqlSessionFactory 数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 框架的配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 映射文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/wzh/dao/mapper/*.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置扫描器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperScanner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 扫描com.mage.dao这个包以及它的子包下的所有映射接口类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.wzh.dao&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、Mybatis-文件-mybatis-xml"><a href="#2、Mybatis-文件-mybatis-xml" class="headerlink" title="2、Mybatis 文件 mybatis.xml"></a>2、Mybatis 文件 mybatis.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--别名的配置 每个人必须会 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.wzh.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、数据库连接-properties-文件-db-properties"><a href="#3、数据库连接-properties-文件-db-properties" class="headerlink" title="3、数据库连接 properties 文件 db.properties"></a>3、数据库连接 properties 文件 db.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><h3 id="4、日志输出文件-log4j-properties"><a href="#4、日志输出文件-log4j-properties" class="headerlink" title="4、日志输出文件 log4j.properties"></a>4、日志输出文件 log4j.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global logging configuration</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG, stdout</span></span><br><span class="line"><span class="comment"># Consoleoutput...</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p [%t] - %m%n</span></span><br></pre></td></tr></table></figure><h3 id="5、注意点"><a href="#5、注意点" class="headerlink" title="5、注意点"></a>5、注意点</h3><ul><li>当Mybatis整合Spring后，每个Mapper的每次查询操作都对应一个全新的SqlSession实例，这个时候就不会有一级缓存的命中，但是在同一个事务中时共用的是同一个SqlSession。</li></ul><h2 id="13-3、案例"><a href="#13-3、案例" class="headerlink" title="13.3、案例"></a>13.3、案例</h2><p>1、接口UserDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、mapper文件UserDao.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.wzh.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select id,name &#x27;userName&#x27;,pwd &#x27;userPwd&#x27;from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、实体类User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">userLogin</span><span class="params">(<span class="keyword">int</span> id,String userPwd)</span></span>&#123;</span><br><span class="line">        User user = userDao.queryUserById(id);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        String upwd = user.getUserPwd();</span><br><span class="line">        <span class="keyword">if</span>(upwd.equals(userPwd))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">        UserService userService = (UserService) applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        Boolean result = userService.userLogin(<span class="number">1</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">if</span>(result==<span class="keyword">true</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合之后获取接口类的bean，然后调用接口方法（mapper里面的SQL语句）</p><h1 id="14、Spring事务"><a href="#14、Spring事务" class="headerlink" title="14、Spring事务"></a>14、Spring事务</h1><h2 id="14-1、回顾"><a href="#14-1、回顾" class="headerlink" title="14.1、回顾"></a>14.1、回顾</h2><p>事务ACID原则：一组业务当做一个业务执行：要么都成功，要么都失败，事务ACID原则</p><ul><li>原子性</li><li>一致性</li><li>隔离性：防止多个任务同时执行时导致脏读等</li><li>持久性</li></ul><h2 id="14-2、Spring声明式事务实现"><a href="#14-2、Spring声明式事务实现" class="headerlink" title="14.2、Spring声明式事务实现"></a>14.2、Spring声明式事务实现</h2><ul><li>声明式事务：AOP</li><li>编程式事务：不用</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1、注解实现"><a href="#1、注解实现" class="headerlink" title="1、注解实现"></a>1、注解实现</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring.xml文件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开始事务方式一，标注@Transactional的类和方法将具有事务性  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mapper文件--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.wzh.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">        insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;userName&#125;,#&#123;userPwd&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- delete故意写错 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> &gt;</span></span><br><span class="line">        deletes from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPwd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span>  <span class="comment">//使用注解具有事务性</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserPwd(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        user.setUserName(<span class="string">&quot;小王&quot;</span>);</span><br><span class="line">        user.setId(<span class="number">4</span>);</span><br><span class="line">        UserMapper mapper = getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">        mapper.addUser(user);</span><br><span class="line">        mapper.deleteUser(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(UserMapper.class).addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(UserMapper.class).deleteUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">        UserMapperImpl userMapper = applicationContext.getBean(UserMapperImpl.class);</span><br><span class="line">        userMapper.selectUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果，报错，但因为使用了事务所以id为4的信息不能能插入进去</span></span><br></pre></td></tr></table></figure><p>总结：在需要的类或者方法上面使用<code>@Transactional</code>就具有事务性</p><h3 id="2、XML实现（结合AOP）"><a href="#2、XML实现（结合AOP）" class="headerlink" title="2、XML实现（结合AOP）"></a>2、XML实现（结合AOP）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开始事务方式二，不通过注解  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务的传播特性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务切入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.wzh.dao.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointCut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">拦截com.wzh.dao下的selectUser方法</span></span><br><span class="line"><span class="comment">该方法是批量语句，参照上面，所以id为4的不会插入进去</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>总结：需要手动配置哪些方法具有事务性</p><h2 id="14-3、事务传播行为"><a href="#14-3、事务传播行为" class="headerlink" title="14.3、事务传播行为"></a>14.3、事务传播行为</h2><ul><li>&lt;tx:method name=”selectUser” propagation=”REQUIRED”/&gt;</li><li>@Transactional(propagation=Propagation.REQUIRED)</li></ul><table><thead><tr><th>事务传播行为类型</th><th>说明</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果已经存在一个事务中，加入到这个事务中，如果当前没有事务，就新建一个事务。这是最常见的选择。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>如果已经存在一个事务中，加入到这个事务中，如果当前没有事务，以非事务的方式运行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>如果已经存在一个事务中，加入到这个事务中，如果当前没有事务，抛出异常。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>创建一个事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务执行；如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><h2 id="14-4、事务异常"><a href="#14-4、事务异常" class="headerlink" title="14.4、事务异常"></a>14.4、事务异常</h2><p>Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应应用来说是至关重要的，即使出现异常情况，它也可以保证数据的⼀致性。</p><p>Spring默认只有在碰到<code>运行时异常</code>的时候才会自动回滚；</p><p>使用了注解@Transactional(rollbackFor = Exception.class) 注解，非运行时异常也会回滚。</p><h1 id="15、JPA"><a href="#15、JPA" class="headerlink" title="15、JPA"></a>15、JPA</h1><p>如何使用JPA在数据库中非持久化⼀个字段？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">//</span></span><br><span class="line"><span class="keyword">final</span> String transient2 = “Satish”; <span class="comment">// </span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// </span></span><br></pre></td></tr></table></figure><p>16、Spring 的事件机制</p><h1 id="16、Spring中的设计模式"><a href="#16、Spring中的设计模式" class="headerlink" title="16、Spring中的设计模式"></a>16、Spring中的设计模式</h1><h2 id="16-1、工厂设计模式"><a href="#16-1、工厂设计模式" class="headerlink" title="16.1、工厂设计模式"></a>16.1、工厂设计模式</h2><p>Spring可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。二者使用的方式基本相同，但是功能有差异。</p><ul><li><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>BeanFactory</code>来说会占用更少的内存，程序启动速度更快。</li><li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。功能更多，如AOP、载入多个（有继承关系）上下文、访问资源、国际化等。</li></ul><p>ApplicationContext的三个实现类：</p><ol><li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li><li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li><li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li></ol><h2 id="16-2、单例模式"><a href="#16-2、单例模式" class="headerlink" title="16.2、单例模式"></a>16.2、单例模式</h2><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p><ul><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li><li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li><li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li></ul><p><strong>Spring 实现单例的方式：</strong></p><ul><li>xml:&lt; bean id=”userService” class=”top.snailclimb.UserService” scope=”singleton”/&gt;``</li><li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li></ul><p>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例  </span></span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="keyword">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="keyword">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-3、代理模式"><a href="#16-3、代理模式" class="headerlink" title="16.3、代理模式"></a>16.3、代理模式</h2><p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><blockquote><p>Spring AOP 和 AspectJ AOP 有什么区别?</p></blockquote><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><h2 id="16-4、模板方法模式"><a href="#16-4、模板方法模式" class="headerlink" title="16.4、模板方法模式"></a>16.4、模板方法模式</h2><p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p><h2 id="16-5、观察者模式"><a href="#16-5、观察者模式" class="headerlink" title="16.5、观察者模式"></a>16.5、观察者模式</h2><p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring <code>事件驱动模型</code>就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p><blockquote><p>Spring 事件驱动模型中的三种角色</p></blockquote><h4 id="事件角色"><a href="#事件角色" class="headerlink" title="事件角色"></a>事件角色</h4><p><code>ApplicationEvent</code> (<code>org.springframework.context</code>包下)充当事件的角色,这是一个抽象类，它继承了<code>java.util.EventObject</code>并实现了 <code>java.io.Serializable</code>接口。</p><p>Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自<code>ApplicationContextEvent</code>)：</p><ul><li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li><li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li><li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li><li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件。</li></ul><p><img src="/img/web/%E5%9B%BE%E7%89%8742.jpg" alt="图片">ApplicationEvent-Subclass</p><h4 id="事件监听者角色"><a href="#事件监听者角色" class="headerlink" title="事件监听者角色"></a>事件监听者角色</h4><p><code>ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code>onApplicationEvent（）</code>方法来处理<code>ApplicationEvent</code>。<code>ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code>ApplicationEvent</code>就可以了。所以，在 Spring中我们只要实现 <code>ApplicationListener</code> 接口实现 <code>onApplicationEvent()</code> 方法即可完成监听事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件发布者角色"><a href="#事件发布者角色" class="headerlink" title="事件发布者角色"></a>事件发布者角色</h4><p><code>ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publishEvent((Object)event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationEventPublisher</code> 接口的<code>publishEvent（）</code>这个方法在<code>AbstractApplicationContext</code>类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过<code>ApplicationEventMulticaster</code>来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</p><blockquote><p>Spring 的事件流程总结</p></blockquote><ol><li>定义一个事件: 实现一个继承自 <code>ApplicationEvent</code>，并且写相应的构造函数；</li><li>定义一个事件监听者：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法；</li><li>使用事件发布者发布消息: 可以通过 <code>ApplicationEventPublisher</code> 的 <code>publishEvent()</code> 方法发布消息。</li></ol><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoEvent</span><span class="params">(Object source,String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> message;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">DemoEvent</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用onApplicationEvent接收消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(DemoEvent event)</span> </span>&#123;</span><br><span class="line">        String msg = event.getMessage();</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的信息是：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPublisher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">//发布事件</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> DemoEvent(<span class="keyword">this</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>DemoPublisher</code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish(&quot;你好&quot;)</code> ，控制台就会打印出:<code>接收到的信息是：你好</code> 。</p><h2 id="16-6、适配器模式"><a href="#16-6、适配器模式" class="headerlink" title="16.6、适配器模式"></a>16.6、适配器模式</h2><blockquote><p>AOP</p></blockquote><p> Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code> 。Advice 常用的类型有：<code>BeforeAdvice</code>（目标方法调用前,前置通知）、<code>AfterAdvice</code>（目标方法调用后,后置通知）、<code>AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。Spring预定义的通知要通过对应的适配器，适配成 <code>MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</p><blockquote><p>Spring MVC</p></blockquote><p>在Spring MVC中，<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由<code>HandlerAdapter</code> 适配器处理。<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</p><h2 id="16-7、装饰器模式"><a href="#16-7、装饰器模式" class="headerlink" title="16.7、装饰器模式"></a>16.7、装饰器模式</h2><p>当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code>InputStream</code>家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code>InputStream</code> 代码的情况下扩展了它的功能。</p><p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code>或者 <code>Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb(一):Servlet</title>
      <link href="/2021/07/01/Web/JavaWeb%20(%20%E4%B8%80%20)%20Servlet/"/>
      <url>/2021/07/01/Web/JavaWeb%20(%20%E4%B8%80%20)%20Servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h1><h2 id="1-1、前言"><a href="#1-1、前言" class="headerlink" title="1.1、前言"></a>1.1、前言</h2><p>web开发：</p><ul><li>web指网站</li><li>静态Web<ul><li>HTML，css</li><li>提供给所有人的数据始终不会改变</li></ul></li><li>动态Web<ul><li>每个人在不同时间，不同地点看到的信息各不相同</li><li>提供给所有人的数据始终不会改变</li><li>技术栈：Servlet/JSP、ASP、PHP</li></ul></li></ul><p>在java中，动态web资源开发的技术统称为JavaWeb</p><h2 id="1-2、Web应用程序"><a href="#1-2、Web应用程序" class="headerlink" title="1.2、Web应用程序"></a>1.2、Web应用程序</h2><p>概念：可以提供浏览器访问的程序</p><h2 id="1-3、静态Web"><a href="#1-3、静态Web" class="headerlink" title="1.3、静态Web"></a>1.3、静态Web</h2><ul><li><p>*.html *.html 这些都是网页的后缀，如果服务器上存在，就可以访问</p></li><li><p>缺点：无法更新，所有用户看到的都是同一页面</p><ul><li>轮播图，点击特效：伪动态</li><li>JavaScript[实际开发者，他用的最多]</li><li>无法和数据库交互（数据无法持久化）</li></ul></li></ul><h2 id="1-4、动态Web"><a href="#1-4、动态Web" class="headerlink" title="1.4、动态Web"></a>1.4、动态Web</h2><p>页面会动态展示：</p><p><img src="/img/web/%E5%9B%BE%E7%89%871.jpg"></p><p>缺点：</p><ul><li>加入服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序，重新发布</li></ul><p>优点：</p><ul><li>动态更新</li><li>数据交互（数据持久化）</li></ul><h1 id="2、Web服务器"><a href="#2、Web服务器" class="headerlink" title="2、Web服务器"></a>2、Web服务器</h1><h2 id="2-1、技术讲解"><a href="#2-1、技术讲解" class="headerlink" title="2.1、技术讲解"></a>2.1、技术讲解</h2><p>ASP</p><ul><li>微软：国内最早流行的</li><li>在HTML中嵌入的VB的脚本</li><li>ASP开发中，基本一个页面都有几千行业务代码</li><li>维护成本高</li><li>C#</li></ul><p>PHP</p><ul><li>开发速度快，功能强大，代码简单</li><li>无法承载大访问量（局限）</li></ul><p>JSP</p><ul><li>Sun公司主推的B/S架构本质就是Servlet</li><li>基于Java语言</li><li>可以承载三高（高并发、高可用、高性能）问题带来的影响</li><li>语法像ASP</li></ul><h2 id="2-2、Web服务器"><a href="#2-2、Web服务器" class="headerlink" title="2.2、Web服务器"></a>2.2、Web服务器</h2><p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息</p><p>IIS</p><ul><li>微软的：跑ASP和Windows中自带的</li></ul><p>Tomcat</p><ul><li>轻量级服务器</li><li>可以运行HTML和JSP/Sevlet</li><li>初学者来说，是最好的服务器</li></ul><h1 id="3、Tomcat"><a href="#3、Tomcat" class="headerlink" title="3、Tomcat"></a>3、Tomcat</h1><h2 id="3-1、文件夹解释"><a href="#3-1、文件夹解释" class="headerlink" title="3.1、文件夹解释"></a>3.1、文件夹解释</h2><ul><li>bin：启动、关闭就脚本文件</li><li>conf：配置文件</li><li>lib：依赖的jar包</li><li>logs：日志</li><li>temp：临时文件</li><li>webapps：存放网站，文件夹下面一个目录代表一个应用</li><li>work：存放JSP和解析的java文件</li></ul><h2 id="3-2、启动关闭Tomcat"><a href="#3-2、启动关闭Tomcat" class="headerlink" title="3.2、启动关闭Tomcat"></a>3.2、启动关闭Tomcat</h2><ul><li>启动：bin文件夹下的startup.bat</li><li>关闭：bin文件夹下的shutdown.bat</li></ul><h2 id="3-3、配置"><a href="#3-3、配置" class="headerlink" title="3.3、配置"></a>3.3、配置</h2><p>核心文件：conf文件夹下的server.xml</p><p><strong>可以配置端口号</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>可以配置主机名称</strong></p><ul><li>默认主机名：localhost 127.0.0.1</li><li>默认网站应用的存放位置：webapps</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>高难度面试题：</strong></p><p>网站是如何进行访问的</p><ol><li>输入一个域名</li><li>检查本机的C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射<ul><li>有，则直接返回对应的IP地址，这个地址中，有我们需要访问的Web程序    ，可访问</li><li>没有，去DNS服务器（管理域名的地方），找到就返回，找不到就404        </li></ul></li></ol><h2 id="3-4、发布一个Web网站"><a href="#3-4、发布一个Web网站" class="headerlink" title="3.4、发布一个Web网站"></a>3.4、发布一个Web网站</h2><p>webapps下每个文件夹名字对应一个应用</p><p>localhost:8080/wzh     访问wzh文件夹的index.html文件（index为默认的首页）</p><h1 id="4、Http讲解"><a href="#4、Http讲解" class="headerlink" title="4、Http讲解"></a>4、Http讲解</h1><h2 id="4-1、什么是HTTP"><a href="#4-1、什么是HTTP" class="headerlink" title="4.1、什么是HTTP"></a>4.1、什么是HTTP</h2><p>HTTP（超文本传输协议）是一个简单地请求-响应协议，通常运行于TCP之上</p><ul><li>文本：HTML、字符串</li><li>超文本：图片、音乐、视频、定位</li></ul><p>Http默认端口：80     Https：43</p><h2 id="4-2、两个时代"><a href="#4-2、两个时代" class="headerlink" title="4.2、两个时代"></a>4.2、两个时代</h2><ul><li><p>http1.0 </p><ul><li>客户端可以与web服务器连接，只能获得一个web资源，二次请求不到，只能断开连接再次请求                            </li></ul></li><li><p>http1.1</p><ul><li>客户端可以与web服务器连接，可以获得多个web资源                              </li></ul></li></ul><h2 id="4-3、Http请求"><a href="#4-3、Http请求" class="headerlink" title="4.3、Http请求"></a>4.3、Http请求</h2><ul><li>客户端——-发请求———服务器</li><li>请求行、请求头、请求正文组成</li><li>get方法没有请求体</li></ul><p>百度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求行</span></span><br><span class="line">Request URL: https:<span class="comment">//www.baidu.com/</span></span><br><span class="line">Request Method: GET</span><br><span class="line">Status Code: <span class="number">200</span> OK      <span class="comment">//状态码</span></span><br><span class="line">Remote Address: <span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span>:<span class="number">443</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息头</span></span><br><span class="line">Accept:text/html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=<span class="number">0.9</span>   <span class="comment">//语言</span></span><br><span class="line">Cache-Control: max-age=<span class="number">0</span></span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><h3 id="1、请求行"><a href="#1、请求行" class="headerlink" title="1、请求行"></a>1、请求行</h3><ul><li>请求方式<ul><li>get：请求携带的参数少，大小有限制，会在浏览器URL内显示内容，不安全，但是效率高</li><li>post：携带参数无限制，安全，但是效率低一些                 </li></ul></li></ul><h3 id="2、消息头"><a href="#2、消息头" class="headerlink" title="2、消息头"></a>2、消息头</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept:           告诉浏览器，它所支持的类型</span><br><span class="line">Accept-Encoding:  支持那些编码格式</span><br><span class="line">Accept-Language:  浏览器的语言环境 </span><br><span class="line">Cache-Control:    缓存控制</span><br><span class="line">Connection:       告诉浏览器请求完成是断开还是保持连接</span><br></pre></td></tr></table></figure><h2 id="4-4、Http响应"><a href="#4-4、Http响应" class="headerlink" title="4.4、Http响应"></a>4.4、Http响应</h2><ul><li>服务器———响应———客户端</li><li>状态行、消息报头、响应正文组成</li></ul><p>百度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部分响应头</span></span><br><span class="line">Cache-Control: <span class="keyword">private</span>                  <span class="comment">//缓存控制</span></span><br><span class="line">Connection: keep-alive                  <span class="comment">//保持连接</span></span><br><span class="line">Content-Encoding: gzip                  <span class="comment">//编码</span></span><br><span class="line">Content-Type: text/html;charset=utf-<span class="number">8</span>   <span class="comment">//类型</span></span><br></pre></td></tr></table></figure><h3 id="1-响应体"><a href="#1-响应体" class="headerlink" title="1.响应体"></a>1.响应体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Accept:           告诉浏览器，它所支持的类型</span><br><span class="line">Accept-Encoding:  支持那些编码格式</span><br><span class="line">Accept-Language:  浏览器的语言环境 </span><br><span class="line">Cache-Control:    缓存控制</span><br><span class="line">Connection:       告诉浏览器请求完成是断开还是保持连接</span><br><span class="line">Refresh           告诉客户端多久刷新一次</span><br><span class="line">Location          网页重新定位    </span><br></pre></td></tr></table></figure><h3 id="2-响应状态码"><a href="#2-响应状态码" class="headerlink" title="2.响应状态码"></a>2.响应状态码</h3><ul><li>200：请求响应成功</li><li>3**：请求重定向     </li><li>4**：请求不存在</li><li>5**：服务器代码错误<ul><li>502：网关错误</li></ul></li></ul><p><strong>常见面试题：</strong></p><p>当你的浏览器中地址栏输入地址并回车，页面展示回来，此过程经历了什么？</p><h1 id="5、Maven"><a href="#5、Maven" class="headerlink" title="5、Maven"></a>5、Maven</h1><p><strong>核心思想：约定大于配置</strong></p><ul><li>有约束不要去违反</li></ul><p>Maven会规定你改如何去编写java代码，必须按照规范来</p><h2 id="5-1、Maven四大特性"><a href="#5-1、Maven四大特性" class="headerlink" title="5.1、Maven四大特性"></a>5.1、Maven四大特性</h2><p>1.依赖管理系统：groupId、artifactId、version组成一个依赖</p><ul><li>groupId：定义当前 Maven 项目隶属的实际项目-公司名称。（jar 包所在仓库路径）</li><li>artifactId：该元素定义实际项目中的一个 Maven 模块-项目名，</li><li>Version：该元素定义 Maven 项目当前所处的版本。</li></ul><p>2.多模块构建：</p><p>3.一致的项目结构：</p><p>4.一致的构建模型和插件机制：通过pom 配置tomcat、jetty 插件</p><h2 id="5-2、Maven生成的包"><a href="#5-2、Maven生成的包" class="headerlink" title="5.2、Maven生成的包"></a>5.2、Maven生成的包</h2><ul><li>Java：jar包</li><li>Web：war包</li><li>多模块的父类：pom包</li></ul><h2 id="5-3、Maven仓库的概念"><a href="#5-3、Maven仓库的概念" class="headerlink" title="5.3、Maven仓库的概念"></a>5.3、Maven仓库的概念</h2><ul><li>本地仓库：Maven根据坐标在本地仓库找构架，找不到去远程仓库下载</li><li>远程仓库<ul><li>中央仓库：默认配置下，Maven 下载 jar 包的地方</li><li>私服：特殊的远程仓库，只局域网内使用</li><li>其他公共库</li></ul></li></ul><h2 id="5-4、Maven依赖详解"><a href="#5-4、Maven依赖详解" class="headerlink" title="5.4、Maven依赖详解"></a>5.4、Maven依赖详解</h2><p>根元素 project 下的 dependencies 可以包含多个 dependence 元素，以声明多个依赖。</p><p>依赖可以包含以下元素：</p><ul><li>groupId、artifactId、version</li><li>Type：依赖的类型，默认为jar</li><li>Scope：依赖范围<ul><li>compile：编译依赖范围</li><li>test：        测试依赖范围</li><li>provided：已提供依赖范围</li><li>runtime：  运行时依赖范围</li><li>system：   系统依赖范围</li></ul></li><li>Optional：标记依赖是否可选</li><li>Exclusions：用来排除传递性依赖</li></ul><h1 id="6、第一个Servlet"><a href="#6、第一个Servlet" class="headerlink" title="6、第一个Servlet"></a>6、第一个Servlet</h1><h2 id="6-1、Servlet简介"><a href="#6-1、Servlet简介" class="headerlink" title="6.1、Servlet简介"></a>6.1、Servlet简介</h2><ul><li>Servlet是Sun公司开发动态Web的一门技术</li><li>Sun在这些API提供一个接口Servlet，如果你想开发一个Servlet程序，只需要完成两点<ul><li>编写一个类<strong>实现Httpservlet接口</strong></li><li>把开发好的java类部署到web服务器里</li></ul></li></ul><h2 id="6-2、HelloServlet"><a href="#6-2、HelloServlet" class="headerlink" title="6.2、HelloServlet"></a>6.2、HelloServlet</h2><p>1.创建maven项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jsp依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JSTL表达式依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- standard标签库依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>taglibs-standard-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">注意：如果子模块没有parent标签，去父类删除scope标签，然后重建模块</span><br><span class="line"></span><br><span class="line">子模块失败时手动添加</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Demo2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="comment">&lt;!--抄父模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wzh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Servlet-02<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>      <span class="comment">&lt;!--子模块属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.更新web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置首页 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.编写Servlet</p><ul><li>Servlet有两个默认的实现类，继承即可</li><li>继承HttpServlet接口</li><li>重写doGet和doPost方法，（<strong>service方法也行但是最好不用</strong>）</li><li>由于get和post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.println(<span class="string">&quot;Hello,Servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//doPost方法调用doGet，实现代码复用</span></span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.web.xml里面编写Servlet的映射</p><p>为什么？我们写的是JAVA程序，要通过浏览器访问，而浏览器要连接web浏览器，所以需要在web服务中注册我们写的Servlet。还需要给他一个浏览器的访问路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.wzh.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>      <span class="comment">&lt;!--访问路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5.配置Tomcat</p><p><img src="/img/web/%E5%9B%BE%E7%89%872.jpg"></p><p>上面表示部署了Servlet-1项目，下面表示访问路径，即<a href="http://localhost:8080/s1/%E8%BF%9B%E5%85%A5%E8%AF%A5%E9%A1%B9%E7%9B%AE%E4%B8%BB%E9%A1%B5">http://localhost:8080/s1/进入该项目主页</a></p><p>6.启动测试</p><p><a href="http://localhost:8080/s1/hello%E8%BE%93%E5%87%BAHello,Servlet">http://localhost:8080/s1/hello输出Hello,Servlet</a></p><h2 id="6-3、Servlet原理"><a href="#6-3、Servlet原理" class="headerlink" title="6.3、Servlet原理"></a>6.3、Servlet原理</h2><p><img src="/img/web/%E5%9B%BE%E7%89%873.jpg"></p><blockquote><p>Mapping问题（web.xml里面）</p></blockquote><p><strong>注意：</strong>servlet必须注册之后才能指定映射路径</p><ul><li>一个servlet可以指定一个映射路径</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>      <span class="comment">&lt;!--访问路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>一个servlet可以指定多个映射路径</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>      <span class="comment">&lt;!--访问路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>      <span class="comment">&lt;!--访问路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>一个Servlet可以指定通用映射</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>      <span class="comment">&lt;!--任意路径都能访问--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>特殊情况</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>      <span class="comment">&lt;!--优先级比首页index.jsp高--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>自定义后缀</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>hello/*.wzh<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--不能直接/*.wzh  可以*.wzh--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>扩展</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--定义为404页面--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意这样通配符形式的优先级低于，如http://localhost:8080/s1/hello有限到/hello里--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-4、Servlet生命周期"><a href="#6-4、Servlet生命周期" class="headerlink" title="6.4、Servlet生命周期"></a>6.4、Servlet生命周期</h2><p>三个方法由HttpServlet类的父类GenericServlet提供，GenericServlet继承了Servlet类</p><blockquote><p>1、实例和初始化实际：（init方法）</p></blockquote><ul><li>请求到达容器时，若servlet 对象不存在，则会创建实例并初始化</li></ul><blockquote><p>2、就绪/调用/服务阶段：（Service方法）</p></blockquote><ul><li><p>请求到达容器，容器调用 servlet 对象的 service() 方法</p></li><li><p>service() 方法会依据请求方式来调用 doGet() 或者 doPost() </p></li><li><p>但是两个do 方法默认情况下，会抛出异常，需要子类去 重写</p></li></ul><blockquote><p>3、销毁阶段：（destory方法）</p></blockquote><ul><li>​    当容器关闭时（应用程序停止时），会将程序中的 Servlet 实例进行销毁。</li></ul><h1 id="7、ServletContext"><a href="#7、ServletContext" class="headerlink" title="7、ServletContext"></a>7、ServletContext</h1><p>web容器启动的时候，会给<strong>每个web程序</strong>创建一个对应的ServletContext，代表了当前的web应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法获取当前服务器信息</span></span><br><span class="line"><span class="function">String <span class="title">getServerInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//以流的形式获取某个资源</span></span><br><span class="line"><span class="function">InputStream <span class="title">getResourceAsStream</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取资源的真实路径等</span></span></span><br><span class="line"><span class="function">String <span class="title">getRealPath</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获得项目路径，http://localhost:8080之后跟着的</span></span></span><br><span class="line"><span class="function">String <span class="title">getContextPath</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//设置参数值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String var1, Object var2)</span></span>;</span><br><span class="line"><span class="comment">//获得参数值</span></span><br><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="comment">//获得初始化参数</span></span><br><span class="line"><span class="function">String <span class="title">getInitParameter</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="comment">//获得RequestDispatcher对象，用来请求转发</span></span><br><span class="line"><span class="function">RequestDispatcher <span class="title">getRequestDispatcher</span><span class="params">(String var1)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>获取ServletContext的方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServletContext s = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">ServletContext s = request.getServletContext();</span><br><span class="line">ServletContext s = session.getServletContext();</span><br><span class="line">ServletContext s = servletConfig.getServletContext();</span><br><span class="line"><span class="comment">// servletConfig保存servlet的配置信息，由容器创建的</span></span><br></pre></td></tr></table></figure><h2 id="7-1、共享数据"><a href="#7-1、共享数据" class="headerlink" title="7.1、共享数据"></a>7.1、共享数据</h2><p>在不同的servlet中，可以共享ServletContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//servlet上下文</span></span><br><span class="line">        ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String username = <span class="string">&quot;wzh&quot;</span>;</span><br><span class="line">        <span class="comment">//把一个数据保存在Servlet中</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//doPost方法调用doGet，实现代码复用</span></span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String username = (String)servletContext.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">//防止中文乱码</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().println(<span class="string">&quot;名字&quot;</span>+username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2、获取初始化参数"><a href="#7-2、获取初始化参数" class="headerlink" title="7.2、获取初始化参数"></a>7.2、获取初始化参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">String url = servletContext.getInitParameter(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">System.out.println(url);</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:msql://localhost:3306/user<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-3、请求转发（一般不用）"><a href="#7-3、请求转发（一般不用）" class="headerlink" title="7.3、请求转发（一般不用）"></a>7.3、请求转发（一般不用）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求转发路径不会改变,转发到本项目下的get的servlet</span></span><br><span class="line">ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">servletContext.getRequestDispatcher(<span class="string">&quot;/get&quot;</span>).forward(req,resp);</span><br></pre></td></tr></table></figure><h2 id="7-4、读取资源文件"><a href="#7-4、读取资源文件" class="headerlink" title="7.4、读取资源文件"></a>7.4、读取资源文件</h2><p>properties</p><ul><li>在java目录下新建properties</li><li>在resources目录下新建properties</li></ul><p>结果：都被打包到了target下面的classes文件夹下面，我们称这个路径为：<strong>classpath</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo04</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">this</span>.getServletContext().getResourceAsStream(<span class="string">&quot;/WEB-INF/classes/db.properties&quot;</span>);</span><br><span class="line">        <span class="comment">// 当然通过获得类加载器再获得也可以</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(in);</span><br><span class="line">        String username = properties.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        PrintWriter printWriter = resp.getWriter();</span><br><span class="line">        printWriter.println(username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8、HttpServletResponse对象"><a href="#8、HttpServletResponse对象" class="headerlink" title="8、HttpServletResponse对象"></a>8、HttpServletResponse对象</h1><p>web服务器接收到客户端的请求后，会对每一次请求分别创建一个代表请求的request对象和代表响应的response对象。</p><ul><li>如果要获取客户端请求过来的参数，找HttpServletRequest</li><li>如果要给客户端响应一些信息，找HttpServletResponse</li><li>HttpServletResponse是ServletResponse的子接口。以后新协议出现时，只需把新协议继承 ServletRequest 接口即可。</li></ul><p>简单分类:</p><p><strong>负责向浏览器发送数据的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServletResponse类方法</span></span><br><span class="line"><span class="function">ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function">PrintWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p><strong>负责向浏览器发送一些响应头的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServletResponse类方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharacterEncoding</span><span class="params">(String var1)</span></span>;     <span class="comment">//设置客户端的编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentType</span><span class="params">(String var1)</span></span>;           <span class="comment">//设置MIME响应类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentLength</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentLengthLong</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HttpServletResponse类方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDateHeader</span><span class="params">(String var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDateHeader</span><span class="params">(String var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(String var1, String var2)</span></span>;     <span class="comment">//设置响应头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addHeader</span><span class="params">(String var1, String var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIntHeader</span><span class="params">(String var1, <span class="keyword">int</span> var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addIntHeader</span><span class="params">(String var1, <span class="keyword">int</span> var2)</span></span>;</span><br></pre></td></tr></table></figure><p>设置状态码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="8-1、向浏览器输出消息"><a href="#8-1、向浏览器输出消息" class="headerlink" title="8.1、向浏览器输出消息"></a>8.1、向浏览器输出消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServletResponse类方法</span></span><br><span class="line"><span class="comment">// 字符流，只能响应字符，中文会乱码，可设置解决</span></span><br><span class="line"><span class="function">PrintWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">PrintWriter writer = resp.getWriter();</span><br><span class="line">writer.write(<span class="string">&quot;HelloResponse&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字节流，可以响应一切数据，中文乱码看人品，可能设置UTF-8反而出错</span></span><br><span class="line"><span class="function">ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">ServletOutputStream outputStream = resp.getOutputStream();</span><br><span class="line">outputStream.write(<span class="string">&quot;world&quot;</span>.getBytes());<span class="comment">//转成字节数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面二者不能同时使用</span></span><br></pre></td></tr></table></figure><h2 id="8-2、文件下载"><a href="#8-2、文件下载" class="headerlink" title="8.2、文件下载"></a>8.2、文件下载</h2><p>设置MIME 格式，把文件加载成输入流，然后读取并且写入到 ServletOutputStream流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">response</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取下载文件路径</span></span><br><span class="line">        String realPath = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">&quot;/1.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取文件名</span></span><br><span class="line">        String filename = realPath.substring(realPath.lastIndexOf(<span class="string">&quot;\\&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//3.让浏览器支持,设置文件名中文显示</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename&quot;</span>+ URLEncoder.encode(filename,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="comment">//4.获取下载文件输入流</span></span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//5.创建缓冲区</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//6.获取OutputStream对象</span></span><br><span class="line">        ServletOutputStream out = resp.getOutputStream();</span><br><span class="line">        <span class="comment">//7.将FileOutputStream流写入Buffer缓冲区</span></span><br><span class="line">        <span class="keyword">while</span>((len=in.read(buffer))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//8.使用OutputStream将缓冲区的数据输出到客户端</span></span><br><span class="line">            out.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-3、响应图片"><a href="#8-3、响应图片" class="headerlink" title="8.3、响应图片"></a>8.3、响应图片</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述代码第三步删除，修改MIME响应类型为</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;image/jpeg;charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者直接输出图片</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html;charest=UTF-8&quot;</span>);</span><br><span class="line">resp.getWriter().write(<span class="string">&quot;&lt;img src=&#x27;/1.jpg&#x27; /&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="8-4、重定向"><a href="#8-4、重定向" class="headerlink" title="8.4、重定向"></a>8.4、重定向</h2><ul><li><strong>一种客户端行为</strong></li><li>客户端发送请求，servlet A处理请求 ，并且响应给客户端</li><li>客户端自动发送请求给Servlet B处理请求，</li><li><strong>Servlet B 不能共享到客户端发送个 Servlet A的数据</strong></li><li>客户端 —- &gt;  Servlet A ——- &gt;  客户端 ———-&gt; Servlet B ——- &gt; 客户端</li><li><strong>地址栏中的 URL 地址会改变，一共有2个请求发出</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面加上项目名</span></span><br><span class="line">resp.sendRedirect(<span class="string">&quot;/servlet_02_war/r2&quot;</span>);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">resp.setHeader(&quot;Location&quot;,&quot;/servlet_02_war/r2&quot;);</span></span><br><span class="line"><span class="comment">resp.setStatus(302);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//或者直接r2，当前前提是请求的服务路径也是/servlet_02_war路径下直接的</span></span><br><span class="line"><span class="comment">//若为/servlet_02_war/sys/index.jsp访问，也无法访问</span></span><br><span class="line">resp.sendRedirect(<span class="string">&quot;r2&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="8-5、刷新和页面自动跳转"><a href="#8-5、刷新和页面自动跳转" class="headerlink" title="8.5、刷新和页面自动跳转"></a>8.5、刷新和页面自动跳转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resp.setHeader(<span class="string">&quot;refresh&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">//不加https://就根据就在当前项目下跳转，3指3秒后跳转</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;refresh&quot;</span>,<span class="string">&quot;3;URL=https://www.baidu.com/&quot;</span>);</span><br><span class="line"><span class="comment">//访问r2项目的servlet默认从当前项目跳转不能写成/r2</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;refresh&quot;</span>,<span class="string">&quot;3;r2&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="8-6、解决乱码问题"><a href="#8-6、解决乱码问题" class="headerlink" title="8.6、解决乱码问题"></a>8.6、解决乱码问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置客户端的编码格式，即读取响应的数据</span></span><br><span class="line">resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>); </span><br><span class="line"><span class="comment">//设置客户端的解码格式，即显示数据</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html; charset=UTF-8&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//或者同时指定</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>getWriter()的字符响应中文必定乱码，getOutputStream()字节响应看人品</p><h1 id="9、HttpServletRequest对象"><a href="#9、HttpServletRequest对象" class="headerlink" title="9、HttpServletRequest对象"></a>9、HttpServletRequest对象</h1><p>基本概念</p><ul><li>HttpServletRequest 是 ServletRequest的子接口。以后新协议出现时，只需把新协议继承 ServletRequest 接口即可。</li><li>HttpServletRequest用来接收客户端发送的请求信息。</li></ul><h2 id="9-1、获取客户端参数"><a href="#9-1、获取客户端参数" class="headerlink" title="9.1、获取客户端参数"></a>9.1、获取客户端参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request01</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.write(username);</span><br><span class="line">        ServletContext servletContext = getServletContext();</span><br><span class="line">        System.out.println(servletContext.getContextPath());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- r4为上面servlet的路径，注意一定要加上前面的来指定本项目  --&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/r4&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">    用户名:&lt;input type =<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>/&gt;</span><br><span class="line">    密码:  &lt;input type =<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>/&gt;</span><br><span class="line">    &lt;input type =<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><strong>获取客户端参数的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getParameter</span><span class="params">(String var1)</span></span>;          <span class="comment">//获得指定名称参数的值</span></span><br><span class="line">String[] getParameterValues(String var1);  <span class="comment">//获得指定名称参数所有值，如多选框</span></span><br><span class="line"><span class="function">Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span></span>;</span><br><span class="line">Map&lt;String, String[]&gt; getParameterMap();</span><br></pre></td></tr></table></figure><h2 id="9-2、解决乱码问题"><a href="#9-2、解决乱码问题" class="headerlink" title="9.2、解决乱码问题"></a>9.2、解决乱码问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只针对POST有效,Tomcat8之后Get不会乱码</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="function">New <span class="title">String</span><span class="params">(request.getParameter(name)</span>.<span class="title">getBytes</span><span class="params">(<span class="string">&quot;ISO-8859-1&quot;</span>)</span>,&quot;UTF-8&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="9-3、请求转发"><a href="#9-3、请求转发" class="headerlink" title="9.3、请求转发"></a>9.3、请求转发</h2><ul><li>一种<strong>服务器的行为</strong></li><li>客户端发出请求，Servlet A处理请求后，携带参数向Tomcat请求访问Servlet B</li><li>Servlet B带着 Servlet A 请求中包含的参数等处理请求</li><li>Servlet B处理请求后，响应给客户端</li><li>客户端 —- &gt;  Servlet A ——- &gt;  Servlet B ——- &gt; 客户端</li><li><strong>地址栏中的 URL 地址不会改变，从始至终只有一个请求发出</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转发到当前项目下的r2的servlet，里面的&#x27;/&#x27;就代表本项目</span></span><br><span class="line">req.getRequestDispatcher(<span class="string">&quot;/r2&quot;</span>).forward(req,resp);</span><br><span class="line"><span class="comment">//访问webapp下面的user.jsp</span></span><br><span class="line">req.getRequestDispatcher(<span class="string">&quot;/user.jsp&quot;</span>).forward(req,resp);</span><br></pre></td></tr></table></figure><h2 id="9-4、作为域对象"><a href="#9-4、作为域对象" class="headerlink" title="9.4、作为域对象"></a>9.4、作为域对象</h2><p>作用范围：在一次请求中有效，即服务器跳转有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object o)</span></span>;     <span class="comment">//设置域对象内容 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAttribute</span><span class="params">(String name)</span></span>;               <span class="comment">//获取域对象内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;            <span class="comment">//删除域对象内容</span></span><br></pre></td></tr></table></figure><h2 id="9-5、获取请求头"><a href="#9-5、获取请求头" class="headerlink" title="9.5、获取请求头"></a>9.5、获取请求头</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getHeader</span><span class="params">(String var1)</span></span>;                <span class="comment">//获取单个请求头内容</span></span><br><span class="line"><span class="function">Enumeration&lt;String&gt; <span class="title">getHeaders</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="function">Enumeration&lt;String&gt; <span class="title">getHeaderNames</span><span class="params">()</span></span>;         <span class="comment">//获取所有请求头</span></span><br></pre></td></tr></table></figure><h2 id="9-6、其他方法"><a href="#9-6、其他方法" class="headerlink" title="9.6、其他方法"></a>9.6、其他方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getContextPath</span><span class="params">()</span></span>;      <span class="comment">//获取 webapp 名字</span></span><br><span class="line"><span class="function">String <span class="title">getRequestURL</span><span class="params">()</span></span>;       <span class="comment">//客户端发出的请求时的完整 URL</span></span><br><span class="line"><span class="function">String <span class="title">getQueryString</span><span class="params">()</span>       <span class="comment">//获取请求行中的参数部分</span></span></span><br><span class="line"><span class="function">String <span class="title">getMethod</span><span class="params">()</span></span>;           <span class="comment">//获取客户端请求方式</span></span><br><span class="line"><span class="function">String <span class="title">getProtocol</span><span class="params">()</span></span>;         <span class="comment">//获取 HTTP 版本号</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">getRequestURI</span><span class="params">()</span></span>; <span class="comment">//获取请求行中的资源名称部分项目名称开始</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="10、Cookie"><a href="#10、Cookie" class="headerlink" title="10、Cookie"></a>10、Cookie</h1><p>概念：能将一些只须保存在客户端，或者在客户端进行处理的数据，放在本地的计算机上，提高网页处理的效率</p><h2 id="10-1、Cookie的创建和发送"><a href="#10-1、Cookie的创建和发送" class="headerlink" title="10.1、Cookie的创建和发送"></a>10.1、Cookie的创建和发送</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Cookie对象 </span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line"><span class="comment">//响应给客户端 </span></span><br><span class="line">resp.addCookie(cookie);</span><br></pre></td></tr></table></figure><h2 id="10-2、Cookie-的获取"><a href="#10-2、Cookie-的获取" class="headerlink" title="10.2、Cookie 的获取"></a>10.2、Cookie 的获取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能获取数组</span></span><br><span class="line">Cookie[] cookies = req.getCookies();</span><br><span class="line"><span class="keyword">if</span>(cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (Cookie cookie : cookies) &#123; </span><br><span class="line">        <span class="comment">// 获取键名称</span></span><br><span class="line">String name = cookie.getName(); </span><br><span class="line">        <span class="comment">// 获取值</span></span><br><span class="line">String value = cookie.getValue();</span><br><span class="line">System.out.println(<span class="string">&quot;键：&quot;</span> + name + <span class="string">&quot;，值：&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：Cookie不能直接包含中文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cookie包含中文的处理情况</span></span><br><span class="line"><span class="comment">//加入Cookie前通过URLEncoder.encode()来进行编码</span></span><br><span class="line">String name = <span class="string">&quot;姓名&quot;</span>;</span><br><span class="line">name = URLEncoder.encode(name,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//获取Cookie时通过URLDecoder.decode()来进行解码</span></span><br><span class="line">String name = URLDecoder.decode(coo.getName(),<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="10-3、Cookie-到期时间的设定"><a href="#10-3、Cookie-到期时间的设定" class="headerlink" title="10.3、Cookie 到期时间的设定"></a>10.3、Cookie 到期时间的设定</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码，设定 cookie 的最大有效时间，以秒为单位。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxAge</span><span class="params">(<span class="keyword">int</span> expiry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxAge = expiry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大于 0 的整数，表示存储的秒数</span></span><br><span class="line"><span class="comment">//若为负数，则表示不存储该 cookie(只在浏览器里存活)</span></span><br><span class="line"><span class="comment">//若为 0，则删除该cookie。</span></span><br></pre></td></tr></table></figure><h2 id="10-4、Cookie-的覆盖"><a href="#10-4、Cookie-的覆盖" class="headerlink" title="10.4、Cookie 的覆盖"></a>10.4、Cookie 的覆盖</h2><p>发送重复名称且路径一致的Cooki覆盖原有的Cookie</p><h2 id="10-5、Cookie的路径"><a href="#10-5、Cookie的路径" class="headerlink" title="10.5、Cookie的路径"></a>10.5、Cookie的路径</h2><p>浏览器在访问 BServlet 时，是否会带上 AServlet 保存的 Cookie，这取决于 Cookie 的 path。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line">cookie.setPath(<span class="string">&quot;/&quot;</span>);                <span class="comment">//代表当前服务器所有资源都能访问</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/cookie&quot;</span>);          <span class="comment">//代表当前服务器cookie所有资源都能访问</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/cookie/test&quot;</span>);     <span class="comment">//服务器cookie下名为test的servlet才能访问  </span></span><br></pre></td></tr></table></figure><h1 id="11、Session"><a href="#11、Session" class="headerlink" title="11、Session"></a>11、Session</h1><p>作用：</p><ul><li>标识一次会话，或者说确认一个用户；</li><li>在一次会话（一个用户的多次请求）期间共享数据。</li></ul><h2 id="11-1、原理"><a href="#11-1、原理" class="headerlink" title="11.1、原理"></a>11.1、原理</h2><p>会话（Session）的底层依赖Cookie来实现：</p><p><strong>JSESSION：</strong>一个比较特殊的 cookie，用户第一次会话，服务器会创建一个 cookie，名字为JSESSION，值为session对象的ID，然后把cookie 对象，添加到 response 对象中，响应给客户端，有效时间为关闭浏览器。</p><p>每次请求到服务器时，如开启了会话，服务器会查看是否回传JSESSION</p><ul><li>若没有，则创建，定义为新的会话</li><li>若有，则比较JSESSION的值，看是否有对应的session对象<ul><li>有，则认为是之前标志过的一次会话，返回该 session 对象，</li><li>没有，则认为是一个新的会话，重新创建一个新的 session 对象</li></ul></li></ul><h2 id="11-2、操作session对象（获取、添加、修改）"><a href="#11-2、操作session对象（获取、添加、修改）" class="headerlink" title="11.2、操作session对象（获取、添加、修改）"></a>11.2、操作session对象（获取、添加、修改）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过request对象获取session对象</span></span><br><span class="line">HttpSession session = req.getSession(); </span><br><span class="line"><span class="comment">//给session对象添加值</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line"><span class="comment">//获取session对象的值</span></span><br><span class="line">String key = (String) session.getAttribute(<span class="string">&quot;key&quot;</span>); </span><br><span class="line"><span class="comment">//移除session对象</span></span><br><span class="line">session.removeAttribute(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="11-3、Session其他常用方法"><a href="#11-3、Session其他常用方法" class="headerlink" title="11.3、Session其他常用方法"></a>11.3、Session其他常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getId</span><span class="params">()</span></span>;          <span class="comment">//获取session的ID属性，用来判断是否是同一个用户</span></span><br></pre></td></tr></table></figure><h2 id="11-4、session对象的销毁"><a href="#11-4、session对象的销毁" class="headerlink" title="11.4、session对象的销毁"></a>11.4、session对象的销毁</h2><ul><li><p>默认：30min未使用自动销毁</p></li><li><p>自己设定到期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = req.getSession(); </span><br><span class="line">session.setMaxInactiveInterval(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p>设置立刻失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.invalidate();</span><br></pre></td></tr></table></figure></li><li><p>关闭服务器失效</p></li></ul><h2 id="11-5、在web-xml配置Session"><a href="#11-5、在web-xml配置Session" class="headerlink" title="11.5、在web.xml配置Session"></a>11.5、在web.xml配置Session</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如配置超时时间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>13<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="12、JSP"><a href="#12、JSP" class="headerlink" title="12、JSP"></a>12、JSP</h1><h2 id="12-1、概念"><a href="#12-1、概念" class="headerlink" title="12.1、概念"></a>12.1、概念</h2><p>Java Server Pages：Java服务器端页面，也和servlet一样，用于动态Web技术</p><p>特点</p><ul><li>写Jsp就像在写Html</li><li>区别<ul><li>HTML只给用户提供静态数据</li><li>JSP页面中可以嵌入JAVA代码，为用户提供动态数据</li></ul></li></ul><h2 id="12-2、JSP原理"><a href="#12-2、JSP原理" class="headerlink" title="12.2、JSP原理"></a>12.2、JSP原理</h2><ul><li><p>代码层面没有任何问题</p></li><li><p>服务器内部工作</p><ul><li><p>在tomcat的work文件夹下（IDEA启动tomcat则在IDEA目录下）</p><p>C:\Users\admin.IntelliJIdea2019.3\system\tomcat\Tomcat_9_0_44_web-01\work\Catalina\localhost\servlet_03_war\org\apache\jsp</p><p><img src="/img/web/%E5%9B%BE%E7%89%874.jpg"></p><p>发现index.jsp变成了java文件（Servlet）</p></li></ul></li></ul><p>该文件里的类实现了JspSourceDependent接口，而JspSourceDependent继承了HttpServlet</p><p><strong>所以：JSP就是一个Servlet</strong></p><p>index_jsp.java代码详解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(<span class="keyword">final</span> javax.servlet.http.HttpServletRequest request, <span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span>&#123;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>1.判断请求：_jspService方法里面判断get和post</p><p>2.内置对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;     <span class="comment">//页面上下文</span></span><br><span class="line">javax.servlet.http.HttpSession session = <span class="keyword">null</span>;       <span class="comment">//session</span></span><br><span class="line"><span class="keyword">final</span> javax.servlet.ServletContext application;      <span class="comment">//applicationContext</span></span><br><span class="line"><span class="keyword">final</span> javax.servlet.ServletConfig config;            <span class="comment">//Config</span></span><br><span class="line">javax.servlet.jsp.JspWriter out = <span class="keyword">null</span>;              <span class="comment">//out</span></span><br><span class="line"><span class="keyword">final</span> java.lang.Object page = <span class="keyword">this</span>;                  <span class="comment">//page</span></span><br><span class="line"><span class="keyword">final</span> javax.servlet.http.HttpServletRequest request  <span class="comment">//请求 </span></span><br><span class="line"><span class="keyword">final</span> javax.servlet.http.HttpServletResponse response<span class="comment">//响应 </span></span><br></pre></td></tr></table></figure><p>3、输出页面前增加的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>);                <span class="comment">//MIME响应类型</span></span><br><span class="line">pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,<span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">_jspx_page_context = pageContext;</span><br><span class="line">application = pageContext.getServletContext();</span><br><span class="line">config = pageContext.getServletConfig();</span><br><span class="line">session = pageContext.getSession();</span><br><span class="line">out = pageContext.getOut();</span><br><span class="line">_jspx_out = out;</span><br></pre></td></tr></table></figure><p>4、以上这些对象可以在JSP页面中直接使用</p><p>在JSP页面中</p><p>JAVA代码会原封不动的输出</p><p>HTML代码会转换成下面的格式输出到前端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.write(<span class="string">&quot;&lt;h2&gt;Hello World!&lt;/h2&gt;\n&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="12-3、JSP语法"><a href="#12-3、JSP语法" class="headerlink" title="12.3、JSP语法"></a>12.3、JSP语法</h2><p>Java语法+自己新的语法</p><p><strong>JSP表达式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= <span class="keyword">new</span> java.util.Date()%&gt;    &lt;%-- 输出时间 --%&gt;</span><br></pre></td></tr></table></figure><p>作用：将程序的结果输出到客户端，单行代码</p><p><strong>JSP脚本片段</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%  <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    out.println(<span class="string">&quot;&lt;h1&gt;Sum=&quot;</span>+sum+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%-- 可以直接调用sum，因为本质还是servlet --%&gt;</span><br><span class="line">&lt;% </span><br><span class="line">out.println(<span class="string">&quot;&lt;h1&gt;Sum=&quot;</span>+sum+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p><strong>在代码嵌入HTML元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- 连续输出<span class="number">5</span>个helloworld --%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">%&gt;</span><br><span class="line">    &lt;h1&gt;hello,world&lt;/h1&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;    </span><br></pre></td></tr></table></figure><p>以上变量都是定义在<strong>service方法</strong>里面，如何定义在方法外面（全局变量）？</p><p><strong>JSP声明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- 编译到JSP生成的类中，其他的都在service方法里 --%&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span>  globalVar = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wzh</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入了wzh方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="12-4、JSP指令标签"><a href="#12-4、JSP指令标签" class="headerlink" title="12.4、JSP指令标签"></a>12.4、JSP指令标签</h2><h3 id="1、page指令"><a href="#1、page指令" class="headerlink" title="1、page指令"></a>1、page指令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- 设置MIME类型，编码 --%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%-- 导包 --%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Date&quot;</span> %&gt;</span><br><span class="line">    </span><br><span class="line">&lt;%-- 自定义出错页面，出错跳转到error文件夹下的<span class="number">500.</span>jsp --%&gt;   </span><br><span class="line">&lt;%@ page errorPage=<span class="string">&quot;error/500.jsp&quot;</span> %&gt;</span><br><span class="line">&lt;% <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;%&gt;  &lt;%-- 定义一个错误 --%&gt;</span><br></pre></td></tr></table></figure><p>自定义错误页面也可以通过配置web.xml文件实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/error/500.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、include静态包含"><a href="#2、include静态包含" class="headerlink" title="2、include静态包含"></a>2、include静态包含</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;/common/header.jsp&quot;</span>%&gt;</span><br><span class="line">&lt;h1&gt;主体&lt;/h1&gt;</span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;/common/footer.jsp&quot;</span>%&gt;  </span><br></pre></td></tr></table></figure><ul><li>本质是3个页面拼接成一个页面，</li><li>不能在其中声明一样的参数，会报错 </li><li>可以在header页面定义参数i，然后到本页面直接使用   </li></ul><h3 id="3、taglib-导入标签库"><a href="#3、taglib-导入标签库" class="headerlink" title="3、taglib 导入标签库"></a>3、taglib 导入标签库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class="string">&quot;c&quot;</span>%&gt;</span><br></pre></td></tr></table></figure><ul><li>导入第三方标签库</li></ul><h2 id="12-5、JSP动作标签"><a href="#12-5、JSP动作标签" class="headerlink" title="12.5、JSP动作标签"></a>12.5、JSP动作标签</h2><h3 id="1、include动态包含"><a href="#1、include动态包含" class="headerlink" title="1、include动态包含"></a>1、include动态包含</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- 三个页面 --%&gt;    </span><br><span class="line">&lt;jsp:include page=<span class="string">&quot;common/header.jsp&quot;</span>/&gt;</span><br><span class="line">&lt;h1&gt;主体&lt;/h1&gt;</span><br><span class="line">&lt;jsp:include page=<span class="string">&quot;common/footer.jsp&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><ul><li>在代码的编译阶段，包含和被包含部分是两个独立的部分</li><li>只有当页面被请求的时候时才会动态包含进来，好比方法的调用</li><li>动态包含，中间不要加任何内容，包括空格</li></ul><p>动态包含传参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">&quot;common/footer.jsp&quot;</span>&gt;</span><br><span class="line">&lt;jsp:param value=<span class="string">&quot;wzh&quot;</span> name=<span class="string">&quot;uname&quot;</span>/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br><span class="line"></span><br><span class="line">&lt;%=request.getParameter(<span class="string">&quot;uname&quot;</span>)%&gt;</span><br></pre></td></tr></table></figure><ul><li>本页面动态包含了footer页面，就可以添加参数</li><li>footer页面用下面的指令可以获得参数</li></ul><h3 id="2、-forward请求转发"><a href="#2、-forward请求转发" class="headerlink" title="2、 forward请求转发"></a>2、 forward请求转发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">&quot;common/footer.jsp&quot;</span>&gt;&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure><ul><li>里面的可以用&lt;%=表达式%&gt;替代</li><li>可以传参，参照动态包含传参的用法</li></ul><h3 id="3、useBean"><a href="#3、useBean" class="headerlink" title="3、useBean"></a>3、useBean</h3><p>创建实体类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">&quot;user&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.po.User&quot;</span> scope=<span class="string">&quot;page&quot;</span>&gt;</span><br><span class="line">&lt;/jsp:useBean&gt;</span><br></pre></td></tr></table></figure><ul><li>scope表明范围page（默认）、request、application、session</li></ul><p>添加属性：可以卸载<a href="jsp:useBean">jsp:useBean</a>标签里面或者外面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:setProperty property=<span class="string">&quot;uname&quot;</span> name=<span class="string">&quot;user&quot;</span> value=<span class="string">&quot;张三&quot;</span>/&gt; </span><br></pre></td></tr></table></figure><p>获取属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:setProperty property=<span class="string">&quot;uname&quot;</span> name=<span class="string">&quot;user&quot;</span> value=<span class="string">&quot;张三&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h2 id="12-6、JSP九大内置对象"><a href="#12-6、JSP九大内置对象" class="headerlink" title="12.6、JSP九大内置对象"></a>12.6、JSP九大内置对象</h2><p>九大内置对象不用由用户自己进行对象的实例化操作，而可以直接进行使用</p><table><thead><tr><th align="left">内置对象</th><th>类型</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">pageContext</td><td>javax.servlet.jsp.PageContext</td><td>JSP的页面容器</td></tr><tr><td align="left">request</td><td>javax.servlet.http.HttpServletRequest</td><td>得到用户的请求信息</td></tr><tr><td align="left">response</td><td>javax.servlet.http.HttpServletResponse</td><td>服务器向客户端的回应消息</td></tr><tr><td align="left">session</td><td>javax.servlet.http.HttpSession</td><td>用来保存每一个用户的信息</td></tr><tr><td align="left">application</td><td>javax.servlet.ServletContext</td><td>表示所有用户的共享信息</td></tr><tr><td align="left">config</td><td>javax.servlet.ServletConfig</td><td>服务器配置，可以取得初始化参数</td></tr><tr><td align="left">out</td><td>javax.servlet.jsp.JspWriter</td><td>页面输出</td></tr><tr><td align="left">page</td><td>java.lang.Object</td><td>表示从该页面中表示出来的一个Servlet实例</td></tr><tr><td align="left">exception</td><td>java.lang.Throwable</td><td>表示JSP页面所发生的异常，在错误页中才起作用</td></tr></tbody></table><h2 id="12-7、四大作用域比较"><a href="#12-7、四大作用域比较" class="headerlink" title="12.7、四大作用域比较"></a>12.7、四大作用域比较</h2><blockquote><h3 id="1、application（ServletContext）"><a href="#1、application（ServletContext）" class="headerlink" title="1、application（ServletContext）"></a>1、application（ServletContext）</h3></blockquote><p>作用域：整个Web应用，所有用户都可以用。</p><blockquote><h3 id="2、Request-域"><a href="#2、Request-域" class="headerlink" title="2、Request 域"></a>2、Request 域</h3></blockquote><p>作用域：一次请求中，服务器跳转后有效</p><blockquote><h3 id="3、Session-域"><a href="#3、Session-域" class="headerlink" title="3、Session 域"></a>3、Session 域</h3></blockquote><p>作用域：一次会话，新开浏览器无法使用</p><blockquote><h3 id="4、PageContext-域"><a href="#4、PageContext-域" class="headerlink" title="4、PageContext 域"></a>4、PageContext 域</h3></blockquote><p>作用域： 只在一个页面中保存属性，跳转之后无效</p><p>四种域的公有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value)</span> <span class="comment">//设置属性的名称及内容</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> object <span class="title">getAttribute</span><span class="params">(String name)</span>             <span class="comment">//根据属性名称取得属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span>            <span class="comment">//删除指定名称的属性  </span></span></span><br></pre></td></tr></table></figure><p>PageContext 域独有的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以根据scope的属性设置存的属性的作用域的范围</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value, <span class="keyword">int</span> scope)</span></span>;</span><br><span class="line">pageContext.PAGE_SCOPE</span><br><span class="line">pageContext.REQUEST_SCOPE</span><br><span class="line">pageContext.SESSION_SCOPE</span><br><span class="line">pageContext.APPLICATION_SCOPE</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面1</span></span><br><span class="line">&lt;% pageContext.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;wzh&quot;</span>,pageContext.REQUEST_SCOPE); %&gt;</span><br><span class="line"><span class="comment">//页面2</span></span><br><span class="line">$&#123;name&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置不同的scope值，name是否显示就不同</span></span><br></pre></td></tr></table></figure><h2 id="12-8、EL表达式"><a href="#12-8、EL表达式" class="headerlink" title="12.8、EL表达式"></a>12.8、EL表达式</h2><h3 id="1、语法与使用"><a href="#1、语法与使用" class="headerlink" title="1、语法与使用"></a>1、语法与使用</h3><p>EL 表达式一般操作的都是域对象中的数据，EL 默认的查找方式为从作用域小到大查找，找到即可。当域对象全找完了还未找到则返回空字符串””。</p><p>语法：${expression}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11个隐含对象</span></span><br><span class="line">$&#123;requestScope.user.id&#125; <span class="comment">// 在 request 作用域中获取 user 对象的 id 属性</span></span><br><span class="line"></span><br><span class="line">applicationScope   <span class="comment">//应用程序范围内的scoped变量组成的集合</span></span><br><span class="line">cookie             <span class="comment">//所有cookie组成的集合</span></span><br><span class="line">header             <span class="comment">//HTTP请求头部，字符串</span></span><br><span class="line">headerValues       <span class="comment">//HTTP请求头部，字符串集合</span></span><br><span class="line">initParam          <span class="comment">//全部应用程序参数名组成的集合</span></span><br><span class="line">pageContext        <span class="comment">//当前页面的javax.servlet.jsp.PageContext对象</span></span><br><span class="line">pageScope          <span class="comment">//页面范围内所有对象的集合</span></span><br><span class="line">param              <span class="comment">//所有请求参数字符串组成的集合</span></span><br><span class="line">paramValues        <span class="comment">//所有作为字符串集合的请求参数</span></span><br><span class="line">requestScope       <span class="comment">//所有请求范围的对象的集合</span></span><br><span class="line">sessionScope       <span class="comment">//所有会话范围的对象的集合</span></span><br></pre></td></tr></table></figure><h3 id="2、运算"><a href="#2、运算" class="headerlink" title="2、运算"></a>2、运算</h3><p>1、 List 遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">    List &lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>); </span><br><span class="line">list.add(<span class="string">&quot;bbb&quot;</span>); </span><br><span class="line">list.add(<span class="string">&quot;ccc&quot;</span>); </span><br><span class="line">request.setAttribute(<span class="string">&quot;list1&quot;</span>, list); </span><br><span class="line">%&gt;</span><br><span class="line">$&#123;empty list1&#125;</span><br><span class="line">$&#123;list1[<span class="number">1</span>]&#125;</span><br></pre></td></tr></table></figure><ul><li>判断集合中是否有元素</li><li>获取list1集合的第一个值</li></ul><p>2、访问map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap(); </span><br><span class="line">map.put(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;111&quot;</span>); </span><br><span class="line">map.put(<span class="string">&quot;bbb&quot;</span>, <span class="number">2222</span>); </span><br><span class="line">map.put(<span class="string">&quot;ccc-a&quot;</span>, <span class="number">333</span>); </span><br><span class="line">request.setAttribute(<span class="string">&quot;map&quot;</span>, map); </span><br><span class="line">%&gt;</span><br><span class="line">$&#123;empty map&#125; </span><br><span class="line">$&#123;map.aaa&#125;  </span><br><span class="line">$&#123;map[<span class="string">&quot;bbb&quot;</span>]&#125; </span><br></pre></td></tr></table></figure><ul><li>取值的两种方式</li></ul><p>3、做+、-、*、/(也可以使用 div 来表示)、%、==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">    String a = <span class="string">&quot;aaa&quot;</span>; </span><br><span class="line">String b = <span class="string">&quot;aaa&quot;</span>; </span><br><span class="line">%&gt;</span><br><span class="line">    &lt;%=a == b%&gt; </span><br><span class="line">    $&#123;<span class="number">4</span> div <span class="number">2</span> &#125; </span><br></pre></td></tr></table></figure><p><strong>注意：String 也使用==比较</strong></p><h2 id="12-9、JSTL（了解）"><a href="#12-9、JSTL（了解）" class="headerlink" title="12.9、JSTL（了解）"></a>12.9、JSTL（了解）</h2><p>JSTL标签的使用就是为了弥补HTML标签的不足，他自定义许多标签，可以供我们使用</p><p> 为了在 JSP 页面使用 JSTL 类库，必须以下列格式使用 taglib 指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class="string">&quot;c&quot;</span>%&gt;</span><br></pre></td></tr></table></figure><p>JSTL标签使用步骤</p><ul><li>引入对应的标签库</li><li>使用其中的方法</li><li>可能tomcat需要导入jstl和standard标签库</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;Demo1.jsp&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;param.username&#125;&quot;</span>/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;param.username==&#x27;admin&#x27;&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;isAdmin&quot;</span>&gt;</span><br><span class="line">    &lt;c:out value=<span class="string">&quot;管理员欢迎你&quot;</span> /&gt;</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>注意EL表达式${param.username}获取了本页面的属性，使用了隐含对象</li></ul><h1 id="13、MVC三层框架"><a href="#13、MVC三层框架" class="headerlink" title="13、MVC三层框架"></a>13、MVC三层框架</h1><p>什么是MVC：Model、view、Controller            模型、视图、控制器</p><h2 id="10-1、早些年"><a href="#10-1、早些年" class="headerlink" title="10.1、早些年"></a>10.1、早些年</h2><p><img src="/img/web/%E5%9B%BE%E7%89%875.jpg"></p><p>用户直接访问控制层，控制层就可以直接操作数据库</p><p>servlet——&gt;crud——-&gt;数据库</p><p>弊端：程序臃肿，不利于维护</p><p>servlet代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码</p><h2 id="13-2、MVC三层架构（微服务之前"><a href="#13-2、MVC三层架构（微服务之前" class="headerlink" title="13.2、MVC三层架构（微服务之前"></a>13.2、MVC三层架构（微服务之前</h2><p><img src="/img/web/%E5%9B%BE%E7%89%876.jpg"></p><ul><li>Model：处理业务（Service）、数据持久化（Dao）</li><li>View：展示数据、提供链接发起Servlet请求</li><li>Controller：接收用户请求（request）、交给业务层处理对应的代码、控制视图的跳转</li></ul><p>登录——&gt;接收用户请求—–&gt;处理用户请求（获取参数）——&gt;给业务层处理（判断密码是否正确）——&gt;Dao层查询用户名和密码是否正确</p><h1 id="14、Filter过滤器"><a href="#14、Filter过滤器" class="headerlink" title="14、Filter过滤器"></a>14、Filter过滤器</h1><p>Filter：过滤器，过滤网站的数据</p><ul><li>处理乱码</li><li>登录校验</li></ul><p>实现</p><ul><li>编写 java 类实现 Filter 接口，并实现其 doFilter 方法</li><li> 在 web.xml 文件中对编写的 fifilter 类进行注册，并设置它所能拦截的资源。</li></ul><p>注意</p><ul><li>于对用户请求进行预处理，也可以对 响应进行后处理</li><li>可以修改数据</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span><span class="comment">&lt;!-- 给服务器看的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.wzh.filter.Demo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span><span class="comment">&lt;!-- 设置资源路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span><span class="comment">&lt;!-- 给服务器看的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/s1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!-- 设置要拦截的路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//servlet里面的代码</span></span><br><span class="line">resp.getWriter().write(<span class="string">&quot;你好，世界&quot;</span>);</span><br><span class="line"><span class="comment">//过滤器实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        servletResponse.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        servletRequest.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行前&quot;</span>);</span><br><span class="line">        <span class="comment">// 放行，不放行的话无法执行servlet</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        <span class="comment">// 响应到客户端之前执行的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Filter01 响应到客户端之前执行的代码...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器销毁了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15、监听器"><a href="#15、监听器" class="headerlink" title="15、监听器"></a>15、监听器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;</span><br><span class="line">        ServletContext servletContext = httpSessionEvent.getSession().getServletContext();</span><br><span class="line">        System.out.println(httpSessionEvent.getSession().getId());</span><br><span class="line">        <span class="comment">// 每次创建session对象时，人数+1</span></span><br><span class="line">        Integer onlineNumber = (Integer) servletContext.getAttribute(<span class="string">&quot;onlineNumber&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(onlineNumber==<span class="keyword">null</span>)&#123;</span><br><span class="line">            onlineNumber = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> count = onlineNumber.intValue();</span><br><span class="line">            onlineNumber = <span class="keyword">new</span> Integer(<span class="number">1</span>+count);</span><br><span class="line">        &#125;</span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;onlineNumber&quot;</span>,onlineNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;</span><br><span class="line">        ServletContext servletContext = httpSessionEvent.getSession().getServletContext();</span><br><span class="line">        <span class="comment">// 每次创建session对象时，人数+1</span></span><br><span class="line">        Integer onlineNumber = (Integer) servletContext.getAttribute(<span class="string">&quot;onlineNumber&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> count = onlineNumber.intValue();</span><br><span class="line">        onlineNumber = <span class="keyword">new</span> Integer(count--);</span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;onlineNumber&quot;</span>,onlineNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web.xml配置监听器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span><span class="comment">&lt;!-- 给服务器看的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.wzh.filter.Demo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span><span class="comment">&lt;!-- 设置资源路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JSP页面</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;onlineNumber&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="16、过滤器实现权限验证："><a href="#16、过滤器实现权限验证：" class="headerlink" title="16、过滤器实现权限验证："></a>16、过滤器实现权限验证：</h1><h3 id="1、前台进入登录页面"><a href="#1、前台进入登录页面" class="headerlink" title="1、前台进入登录页面"></a>1、前台进入登录页面</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;login&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">名字&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>/&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="2、登录逻辑"><a href="#2、登录逻辑" class="headerlink" title="2、登录逻辑"></a>2、登录逻辑</h3><ul><li>成功，则创建session，跳转success.jsp</li><li>失败跳转error.jsp</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(username.equals(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//把session的Id存到session里面</span></span><br><span class="line">req.getSession().setAttribute(<span class="string">&quot;USER_SESSION&quot;</span>,req.getSession().getId());</span><br><span class="line">resp.sendRedirect(<span class="string">&quot;sys/success.jsp&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resp.sendRedirect(<span class="string">&quot;error.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、error-jsp，可以跳转回登录界面重新登陆"><a href="#3、error-jsp，可以跳转回登录界面重新登陆" class="headerlink" title="3、error.jsp，可以跳转回登录界面重新登陆"></a>3、error.jsp，可以跳转回登录界面重新登陆</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;错误&lt;/h1&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;Login.jsp&quot;</span>&gt;重新登录&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="4、success-jsp，可以跳转到注销servlet"><a href="#4、success-jsp，可以跳转到注销servlet" class="headerlink" title="4、success.jsp，可以跳转到注销servlet"></a>4、success.jsp，可以跳转到注销servlet</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;主页&lt;/h1&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;/Servlet_04_war/loginout&quot;</span>&gt;注销&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="5、登出逻辑"><a href="#5、登出逻辑" class="headerlink" title="5、登出逻辑"></a>5、登出逻辑</h3><p>名为USER_SESSION的session不为空，就删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">String usersession = (String) req.getSession().getAttribute(<span class="string">&quot;USER_SESSION&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(usersession!=<span class="keyword">null</span>)&#123;</span><br><span class="line">req.getSession().removeAttribute(<span class="string">&quot;USER_SESSION&quot;</span>);</span><br><span class="line">resp.sendRedirect(<span class="string">&quot;Login.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、过滤器进行拦截"><a href="#6、过滤器进行拦截" class="headerlink" title="6、过滤器进行拦截"></a>6、过滤器进行拦截</h3><p>如USER_SESSION的session不存在，就阻止进入success.jsp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br><span class="line">Object usersession = request.getSession().getAttribute(<span class="string">&quot;USER_SESSION&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(usersession==<span class="keyword">null</span>)&#123;</span><br><span class="line">response.sendRedirect(<span class="string">&quot;/Servlet_04_war/error.jsp&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17、Servlet3-0注解特性"><a href="#17、Servlet3-0注解特性" class="headerlink" title="17、Servlet3.0注解特性"></a>17、Servlet3.0注解特性</h1><p>一定要更新xml里的内容，maven模板默认是2.3</p><blockquote><h3 id="17-1、-WebServlet配置Servlet"><a href="#17-1、-WebServlet配置Servlet" class="headerlink" title="17.1、@WebServlet配置Servlet"></a>17.1、@WebServlet配置Servlet</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;d1&quot;,value = &#123;&quot;/d1&quot;,&quot;/d2&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter printWriter = resp.getWriter();</span><br><span class="line">        printWriter.write(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/d1&quot;)</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="17-2、-WebFilter-配置过滤器"><a href="#17-2、-WebFilter-配置过滤器" class="headerlink" title="17.2、@WebFilter 配置过滤器"></a>17.2、@WebFilter 配置过滤器</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(filterName = &quot;filter01&quot;,urlPatterns = &quot;/*&quot;)</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="17-3、-WebListener配置监听器"><a href="#17-3、-WebListener配置监听器" class="headerlink" title="17.3、@WebListener配置监听器"></a>17.3、@WebListener配置监听器</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="17-4、-MultipartConfig实现文件上传"><a href="#17-4、-MultipartConfig实现文件上传" class="headerlink" title="17.4、 @MultipartConfig实现文件上传"></a>17.4、 @MultipartConfig实现文件上传</h3></blockquote><p>前台</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;upload&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;myfile&quot;</span>/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;上传&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/upload&quot;)</span></span><br><span class="line"><span class="meta">@MultipartConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;上传文件...&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置UTF-8</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 把上传路径设置为项目的真实路径</span></span><br><span class="line">        String path = req.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>);             </span><br><span class="line">        <span class="comment">// 开始上传文件        </span></span><br><span class="line">        <span class="comment">// 步骤一得到文件</span></span><br><span class="line">        <span class="comment">// 得到part对象req.getpart(name)：name代表的是表单中file元素的name属性值</span></span><br><span class="line">        Part part = req.getPart(<span class="string">&quot;myfile&quot;</span>);       </span><br><span class="line">        <span class="comment">// 步骤二得到文件名</span></span><br><span class="line">        String fileName = part.getSubmittedFileName(); <span class="comment">// 上传</span></span><br><span class="line">        <span class="comment">// 步骤三上传文件</span></span><br><span class="line">        part.write(path + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18、路径跳转问题"><a href="#18、路径跳转问题" class="headerlink" title="18、路径跳转问题"></a>18、路径跳转问题</h1><h2 id="18-1、JSP分析"><a href="#18-1、JSP分析" class="headerlink" title="18.1、JSP分析"></a>18.1、JSP分析</h2><p><a href="http://localhost:8080/Servlet_04_war/Login.jsp">http://localhost:8080/Servlet_04_war/Login.jsp</a> 页面表单action的取值</p><p>Login.jsp和error.jsp的路径直接在webapp下，中间没有文件夹</p><p>webapp下文件夹sys内，有success.jsp</p><h3 id="1、基于Login-jsp访问"><a href="#1、基于Login-jsp访问" class="headerlink" title="1、基于Login.jsp访问"></a>1、基于Login.jsp访问</h3><ul><li>路径加了”/“，则一定要加项目名称（如果配置tomcat没设置为”/“的话）<ul><li>如果action=”/login”，就是访问<a href="http://localhost:8080/login%EF%BC%8C%E5%A4%B1%E8%B4%A5">http://localhost:8080/login，失败</a></li><li>如果action=”/Servlet_04_war/login”,成功</li><li>访问JSP文件同理</li></ul></li><li>如果不加”/“，则是基于当前路径访问<ul><li>如表单action=”login”，就是访问<a href="http://localhost:8080/Servlet_04_war/login%EF%BC%8C%E5%8F%AF%E4%BB%A5">http://localhost:8080/Servlet_04_war/login，可以</a></li></ul></li></ul><h3 id="2、基于success-jsp访问"><a href="#2、基于success-jsp访问" class="headerlink" title="2、基于success.jsp访问"></a>2、基于success.jsp访问</h3><ul><li><p>路径加了”/“，则一定要加项目名称（如果配置tomcat没设置为”/“的话）</p></li><li><p>如果不加”/“，则是基于当前路径访问</p><ul><li>如表单action=”login”，就是访问<a href="http://localhost:8080/Servlet_04_war/sys/login">http://localhost:8080/Servlet_04_war/sys/login</a>,</li></ul><p>无法跳出sys文件加，所以必须加”/“访问</p></li></ul><h2 id="18-2、Servlet分析"><a href="#18-2、Servlet分析" class="headerlink" title="18.2、Servlet分析"></a>18.2、Servlet分析</h2><ul><li>路径加了”/“，就是默认在<a href="http://localhost:8080/Servlet_04_war/%E4%B8%8B%EF%BC%8C">http://localhost:8080/Servlet_04_war/下，</a></li><li>如果不加”/“，<ul><li><strong>请求转发：</strong>是基于当前路径访问，默认：<a href="http://localhost:8080/Servlet_04_war/">http://localhost:8080/Servlet_04_war/</a></li><li><strong>重定向：</strong>默认<a href="http://localhost:8080/">http://localhost:8080/</a></li></ul></li></ul><h2 id="18-3、总结"><a href="#18-3、总结" class="headerlink" title="18.3、总结"></a>18.3、总结</h2><p>请求路径分类</p><ul><li>相对路径：即不加”/“，相对当前资源的路径，重定向除外。</li><li>绝对路径：<ul><li>直接以”http://“或者”https://“开始，注意路径正确即可</li><li>以”/“开始<ul><li>浏览器（JSP）：”/“代表的是 http://主机|IP:端口</li><li>服务器（Servlet）：””/“代表的是 http://主机|IP:端口/站点名</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式:总结</title>
      <link href="/2021/06/30/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2021/06/30/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>创建型模式</p></blockquote><p><strong>1、单例：</strong>只产生一个对象。</p><ul><li>饿汉式：静态常量、静态代码块、</li><li>懒汉式：同步方法或锁、双重检查、普通线程不安全</li><li>其他：静态内部类、枚举</li></ul><p><strong>2、工厂模式：</strong>对象的构建和表示分离，关注创建一个对象</p><ul><li>工厂：接收参数，产生不同的对象。</li><li>工厂方法：定义一个接口，含一个方法，每个实现类表示一个工厂生产一个产品。</li><li>抽象工厂：工厂方法的扩展，接口有多个方法，对应一个工厂生产多个产品。</li></ul><p><strong>3、建造者模式：</strong>对象的构建和表示分离，关注的是<code>创建复杂的对象</code>。</p><ul><li>普通：定义 工人类，内部封装复杂的对象，里面每个方法对应复杂对象的一个参数。再定义指挥员类，负责组合 工人类的方法，并且返回复杂对象。</li><li>变种：删除指挥者，让调用者组合工人类的方法。</li></ul><p><strong>4、原型模式：</strong>产生和原类型一样的对象</p><ul><li>浅克隆：基本类型复制地址，引用类型复制地址。</li><li>深克隆：引用类型也是克隆得到的。</li></ul><blockquote><p>结构型模式</p></blockquote><p>从<strong>程序的结构</strong>上实现松耦合，扩大整体的类结构，解决更大的问题</p><p><strong>5、适配器模式：</strong>解决接口不兼容的问题</p><p><strong>角色：</strong>新、旧接口、适配器</p><ul><li>定义旧接口，和实现类。</li><li>定义一个新的接口，和旧接口名称一致，但是参数不兼容。</li><li>定义一个适配器，继承旧接口，依赖新接口，并且重写方法让原本支持的参数输入调用旧接口方法，原本不支持的参数输入经过参数转换，调用新接口方法。</li></ul><p><strong>实例：</strong></p><p><strong>6、桥接模式：</strong>抽象部分与实现部分分离，实现不同的组合。</p><ul><li>定义接口类A，和实现类。</li><li>定义抽象类B，通过依赖的方式引入接口A，二者实现桥接。</li><li>通过抽象类B的不同继承，并且引入不同的接口A的实现类，即可实现不同的B的继承类和不同的接口A的实现类的组合</li></ul><p><strong>7、装饰器模式：</strong>向一个现有的对象添加新的功能，同时又不改变其结构</p><ul><li>定义接口类A，和实现类。</li><li>定义抽象类B继承接口A，并且通过依赖的方式引入接口A。</li><li>抽象类B有不同的子类，每个子类和不同的接口A的实现类进行组合，实现装饰。</li></ul><p><strong>注意：</strong>桥接模式和装饰器模式几乎完全一致，区别在于桥接模式抽象类B与接口A无关，而装饰器模式抽象类B是接口A的实现。</p><p><strong>8、代理模式：</strong>关注的是控制对对象的访问。</p><ul><li>动态代理：一个代理类代理一个对象</li><li>静态代理：通过动态生成字节码（JDK、Cglib方式）</li></ul><p><strong>代理模式和装饰器模式区别：</strong>实际结构没有太大区别。</p><ul><li>代理模式关注的是控制对象的访问，不关注对被代理类的增强。</li><li>装饰器模式关注的组合，对被装饰类的增强。</li></ul><p><strong>9、组合模式：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p><ul><li>定义一个类A，并在类A内部定义 一个   List&lt; A &gt;，这样A既代表整体，也代表个体。</li></ul><p><strong>10、外观模式：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><ul><li>定义一个接口A，并且实现。</li><li>定义一个包装类，依赖接口A的所以实现类并且封装起来，对外提供差不多的接口。</li></ul><p><strong>11、享元模式：</strong>减少创建对象的数量，以减少内存占用和提高性能</p><ul><li>获取对象前先尝试从现有的对象寻找满足条件的对象，若没有再创建</li><li>将大量对象的公有部分抽象出来，这样共享的可能性将提高。</li></ul><blockquote><p>行为型模式</p></blockquote><p>关注对象之间的相互<strong>交互</strong>，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责，共11种模式。</p><p><strong>12、模板模式：</strong>子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><ul><li>关注方法，</li><li>在抽象类里面定义一个算法方法，由抽象方法组合而成。</li><li>继承抽象类，完成抽象方法的定义，既可实现算法的实现。</li></ul><p><strong>总结：</strong>将特定算法的实现延迟到 子类/实现类 实现。</p><p><strong>13、策略模式：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><ul><li>定义一个接口A，和实现类A1、A2等，这些实现类作为可替换的组件。</li><li>定义一个包装类B，通过调用接口A的方法实现一个算法。</li><li>包装类B接收不同的接口A的实现类，即可自由组合，最终实现不同的算法效果。</li></ul><p><strong>总结：</strong>定义一个整体算法，组合不同的组件（对象），组件可以替换并且不影响使用。</p><p><strong>注意：</strong>模板模式和策略模式大致相同，但是关注点不同</p><ul><li>模板方法模式关注的算法的<code>整体流程</code>，通过 实现/继承 完善算法，得到不同效果。</li><li>策略模式关注的是一个整体的算法实现，通过依赖组合不同的对象组件，要求的是不影响使用，不要求效果不同。</li></ul><p><strong>14、中介模式：</strong>用一个中介对象来封装一系列的对象交互，达到解耦的效果。</p><ul><li>对象A的方法1需要和对象B交互，于是对象A把具体的方法交给中介类</li><li>定义一个中介类，通过接收A对象，在中介类中完成方法的具体逻辑执行。</li><li>中介类执行完毕之后，在把消息通知给对象B。</li></ul><p><strong>总结：</strong>把原本在对象A的执行方法体，放到中介类中，这样与对象B的耦合就转移到了中介类中，这样只需与中介类交互，就可以与其他对象进行交互了。</p><p><strong>实例：</strong>QQ聊天中QQ的服务器充当中介者。</p><p><strong>15、观察者模式：</strong>管理者和观察者一对多，管理者可以控制所有观察者的状态更新。</p><ul><li>定义观察者，观察者创建时需要绑定管理者，同时把管理者添加上自己，有自己的状态，但是状态的更新依赖管理者。</li><li>定义管理者，内部 封装观察者的List集合，可以遍历集合更新每个观察者。</li></ul><p><strong>总结：</strong>管理者管理多个观察者，管理者可以通知所有观察者更新状态。</p><p><strong>16、状态模式：</strong>允许对象在内部状态发生改变时改变它的行为，就好像修改了对象一样。</p><ul><li><p>定义状态接口A，实现类A1、A2 等表示不同的状态</p></li><li><p>定义一个 Context 类，里面依赖状态接口，状态对象就表示 Context的状态。</p></li><li><p>状态实现类 A1、A2 等调用方法，会把自己绑定到 Context 上，这样状态实现类调用方法时， Context 对象的状态就会跟着改变。</p></li></ul><p><strong>17、命令模式：</strong>把请求封装成对象，可以对请求行记录、撤销或重做、事务等处理。</p><ul><li>定义一个类A，作为被封装的对象，里面每个方法对应一个请求。</li><li>定义一个接口B，只含一个方法，实现类B1、B2等分别对应类A的一个方法（请求）。</li><li>定义请求管理类，封装接口B的集合，想要添加/释放 请求(类A的方法)，就把接口B的实现类添加到集合里面去。</li></ul><p><strong>总结：</strong>把一个类的每个方法抽出封装称为对象，再定义一个类管理这些请求。</p><p><strong>18、备忘录模式：</strong>把一个对象的状态记录下来保存到备忘录中，并且可以还原。</p><ul><li>定义信息保存类A</li><li>定义备忘录B，内部封装 类A的List集合，可以放入和取出类A的对象。</li><li>把需要进行备忘的类进行修改，支持两个功能，1 是 可以把当前的状态封装成一个信息保存类对象A，2 是可以根据传进来的信息对象类 B 还原自己的状态。</li></ul><p><strong>19、访问者模式</strong>：将数据结构的存储与数据的访问操作分离</p><ul><li>定义一个类A，实现一个数据结构，内部定义访问操作方法，但是托管给类B实现。</li><li>类B通过参数接收类A的对象获取数据结构，并且进行数据结构的访问操作。</li><li>类A托管的方式是把自己作为参数，调用类 B 的方法，这样就实现了存储和操作分离。</li></ul><p><strong>总结：</strong> 数据结构在一个类存储，操作通过托管给其他类实现。</p><p><strong>20、责任链模式</strong>：定义责任标准，达不到标准的交给责任链的下一个执行。</p><p><strong>21、迭代器模式</strong>：内部维护迭代器，可以不知道数据结构的情况通过迭代器迭代一个类。</p><p><strong>22、解释器模式：</strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>]]></content>
      
      
      <categories>
          
          <category> 23种设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式:行为型模式</title>
      <link href="/2021/06/29/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/06/29/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-行为模式介绍"><a href="#1-行为模式介绍" class="headerlink" title="1.行为模式介绍"></a>1.行为模式介绍</h2><p>关注系统中对象之间的相互<strong>交互</strong>，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责，共11种模式。</p><h2 id="2、模板模式"><a href="#2、模板模式" class="headerlink" title="2、模板模式"></a>2、模板模式</h2><p><strong>意图：</strong>模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法</p><p><strong>思想：</strong>核心方法定义为Final，该方法调用其他方法（抽象方法，子类实现），这样就可以通过不同的子类改变方法的细节，但是方法大体的步骤不变</p><ul><li>定义一个游戏类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模板，子类无法更改这里的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化游戏</span></span><br><span class="line">        initialize();</span><br><span class="line">        <span class="comment">//开始游戏</span></span><br><span class="line">        startPlay();</span><br><span class="line">        <span class="comment">//结束游戏</span></span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>两个实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;足球游戏借宿!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;足球游戏初始化中，即将开始游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;足球游戏开始!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span> <span class="keyword">extends</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;板球游戏借宿!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;板球游戏初始化中，即将开始游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;板球游戏开始!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game game = <span class="keyword">new</span> Football();</span><br><span class="line">        game.play();</span><br><span class="line"></span><br><span class="line">        game = <span class="keyword">new</span> Cricket();</span><br><span class="line">        game.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、命令模式"><a href="#3、命令模式" class="headerlink" title="3、命令模式"></a>3、命令模式</h2><p><strong>意图：</strong>将一个<strong>请求封装成一个对象</strong>，从而使您可以用不同的请求对客户进行参数化。</p><p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p><p><strong>思想：</strong>把一个类的方法拆分出来，封装成不同的对象（对应不同方法），再定义一个管理类来通过list 来管理这些请求。</p><p><strong>做法：</strong>定义一个类A，类A的每个方法封装成一个对象。定义接口B，接口B有多个实现类，每个实现类都依赖类A并且调用A的一个方法，这样A的每个方法都封装成接口B的一个实现类。最后定义类C依赖接口B，通过接口管理接口B的多个实现类。</p><ul><li>定义 库存 类 ，要封装的对象，可以买和卖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;卖&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义接口，实现类分别封装2个方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyStock</span> <span class="keyword">implements</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuyStock</span><span class="params">(Stock abcStock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        abcStock.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStock</span> <span class="keyword">implements</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellStock</span><span class="params">(Stock abcStock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        abcStock.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义 经纪人类 实现  对卖命令和买命令放到对象列表中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Broker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orderList = <span class="keyword">new</span> ArrayList&lt;Order&gt;();</span><br><span class="line"><span class="comment">// 加入命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeOrder</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        orderList.add(order);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 释放命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">            order.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        orderList.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义库存类</span></span><br><span class="line">        Stock abcStock = <span class="keyword">new</span> Stock();</span><br><span class="line"><span class="comment">// 把库存类的买和卖方法，拆分成并封装成对象</span></span><br><span class="line">        BuyStock buyStockOrder = <span class="keyword">new</span> BuyStock(abcStock);</span><br><span class="line">        SellStock sellStockOrder = <span class="keyword">new</span> SellStock(abcStock);</span><br><span class="line"><span class="comment">// 定义经纪人类，处理封装成对象的请求</span></span><br><span class="line">        Broker broker = <span class="keyword">new</span> Broker();</span><br><span class="line">        broker.takeOrder(buyStockOrder);</span><br><span class="line">        broker.takeOrder(sellStockOrder);</span><br><span class="line"><span class="comment">// 处理请求列表</span></span><br><span class="line">        broker.placeOrders();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、迭代器模式"><a href="#4、迭代器模式" class="headerlink" title="4、迭代器模式"></a>4、迭代器模式</h2><p><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p><p><strong>主要解决：</strong>不同的方式来遍历整个整合对象。</p><ul><li>定义两个接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>定义内部类实现迭代器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameRepository</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] names = &#123;<span class="string">&quot;Robert&quot;</span> , <span class="string">&quot;John&quot;</span> ,<span class="string">&quot;Julie&quot;</span> , <span class="string">&quot;Lora&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得迭代器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NameIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; names.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())&#123;</span><br><span class="line">                <span class="keyword">return</span> names[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line">        NameRepository namesRepository = <span class="keyword">new</span> NameRepository(strings);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123;</span><br><span class="line">            String name = (String)iter.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;Name : &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、观察者模式"><a href="#5、观察者模式" class="headerlink" title="5、观察者模式"></a>5、观察者模式</h2><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被<strong>自动更新</strong>。</p><p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要易用和低耦合，保证高度协作。</p><p><strong>实现：</strong>类内部定义观察者集合。<code>每个观察者需要手动依赖管理者（同时把自己添加进管理者内部的观察者集合）</code>，管理者更新，每个观察者都会被通知</p><ul><li>定义一个类用来<strong>管理</strong>观察者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">// 获取状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 设置状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 添加观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 遍历所有观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义观察者，观察者初始化需要<strong>添加管理者</strong>，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OctalObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 通过管理者获取的信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">&quot;Octal 更新 : &quot;</span> + subject.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">&quot;Binary 更新 : &quot;</span> + subject.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义管理者</span></span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="comment">// 新建观察，会被添加到管理者中</span></span><br><span class="line">        <span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line">        <span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"><span class="comment">// 更新观察者的信息，管理者会被同步更新</span></span><br><span class="line">        subject.setState(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        subject.setState(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、中介者模式"><a href="#6、中介者模式" class="headerlink" title="6、中介者模式"></a>6、中介者模式</h2><p><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，如对象A改变，对象B也必须改变，这样的关系如果大量存在，就会让系统变得复杂。所以定义一个中介类，接收A的参数，执行A与B耦合部分的代码，这样A就只和中介类产生了耦合。</p><p><strong>思想：</strong>专门定义一个中介类，来处理对象之间的通信。比如QQ聊天中QQ的服务器充当中介者。</p><ul><li>中介类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(User user, String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; [&quot;</span> + user.getName() +<span class="string">&quot;] : &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用户类，通过中介类的方法与其他对象交互</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 调用中介类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        ChatRoom.showMessage(<span class="keyword">this</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User john = <span class="keyword">new</span> User(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">        john.sendMessage(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、备忘录模式"><a href="#7、备忘录模式" class="headerlink" title="7、备忘录模式"></a>7、备忘录模式</h2><p><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p><p><strong>思想：</strong>建立备忘录类，该类通过list<code>存放</code>状态<code>对象</code>。接着定义一个管理类A，可以把当前状态封装成一个状态对象返回，也可以把备忘录取出的状态对象解析并且把自己的状态还原。</p><ul><li>定义状态类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义备忘录（保存状态类对象）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;Memento&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento state)</span></span>&#123;</span><br><span class="line">        mementoList.add(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义记录当前状态，并可以把状态存放</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;      </span><br><span class="line">    <span class="comment">// 定义当前装态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前装态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前状态对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">saveStateToMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据对象获取状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento Memento)</span></span>&#123;</span><br><span class="line">        state = Memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建状态操作类</span></span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        <span class="comment">// 新建备忘录对象</span></span><br><span class="line">        CareTaker careTaker = <span class="keyword">new</span> CareTaker();</span><br><span class="line">        <span class="comment">// 设置当前装态</span></span><br><span class="line">        originator.setState(<span class="string">&quot;State 1&quot;</span>);</span><br><span class="line">        originator.setState(<span class="string">&quot;State 2&quot;</span>);</span><br><span class="line">        <span class="comment">// 把当前状态生成对象，放入备忘录</span></span><br><span class="line">        careTaker.add(originator.saveStateToMemento());</span><br><span class="line">        originator.setState(<span class="string">&quot;State 4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态: &quot;</span> + originator.getState());</span><br><span class="line">        originator.getStateFromMemento(careTaker.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次保存的状态: &quot;</span> + originator.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、解释器模式"><a href="#8、解释器模式" class="headerlink" title="8、解释器模式"></a>8、解释器模式</h2><p><strong>意图：</strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><p><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。</p><ul><li>定义解释器接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义解释方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expression expr1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Expression expr2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression expr1, Expression expr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expr1 = expr1;</span><br><span class="line">        <span class="keyword">this</span>.expr2 = expr2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expr1.interpret(context) &amp;&amp; expr2.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expression expr1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Expression expr2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrExpression</span><span class="params">(Expression expr1, Expression expr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expr1 = expr1;</span><br><span class="line">        <span class="keyword">this</span>.expr2 = expr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expr1.interpret(context) || expr2.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(context.contains(data))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义规则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpreterPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//规则：Robert 和 John 是男性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMaleExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 给Terminal对象传入数据</span></span><br><span class="line">        Expression robert = <span class="keyword">new</span> TerminalExpression(<span class="string">&quot;Robert&quot;</span>);</span><br><span class="line">        Expression john = <span class="keyword">new</span> TerminalExpression(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回对象，该对象里面的数据是&quot;Robert&quot;和&quot;John&quot;对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrExpression(robert, john);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规则：Julie 是一个已婚的女性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMarriedWomanExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 给Terminal对象传入数据</span></span><br><span class="line">        Expression julie = <span class="keyword">new</span> TerminalExpression(<span class="string">&quot;Julie&quot;</span>);</span><br><span class="line">        Expression julie = <span class="keyword">new</span> TerminalExpression(<span class="string">&quot;Married&quot;</span>);</span><br><span class="line">         <span class="comment">// 返回对象，该对象里面的数据是&quot;Julie&quot;和&quot;Married&quot;对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndExpression(julie, married);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Expression isMale = getMaleExpression();</span><br><span class="line">    Expression isMarriedWoman = getMarriedWomanExpression();</span><br><span class="line"><span class="comment">// 只要john和 robert 和john对象中和 任意数据匹配，即返回true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;John is male? &quot;</span> + isMale.interpret(<span class="string">&quot;John&quot;</span>));</span><br><span class="line">    <span class="comment">// 只有married和 juliet 和julie对象 中的data都匹配，才返回true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Julie is a married women? &quot;</span> + isMarriedWoman.interpret(<span class="string">&quot;Married Julie&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、状态模式"><a href="#9、状态模式" class="headerlink" title="9、状态模式"></a>9、状态模式</h2><p><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p><p><strong>主要解决：</strong>状态实现类A  接收对象B，A执行方法，此时对象B的状态改变（A把对象B的状态设置成自己）。</p><p><strong>具体实现：</strong>定义一个状态接口A，其实现类表示不同的状态。定义context类，依赖接口A，并表示context的状态<code>。状态类执行时通过接收参数把context依赖的状态类设置成自己。</code></p><ul><li>定义context类，可以设置对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义State状态接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现该接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartState</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Start State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopState</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Stop State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试，可以看到其他方法调用了context，但是context的状态却改变了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line"></span><br><span class="line">        StartState startState = <span class="keyword">new</span> StartState();</span><br><span class="line">        startState.doAction(context);</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getState().toString());</span><br><span class="line"></span><br><span class="line">        StopState stopState = <span class="keyword">new</span> StopState();</span><br><span class="line">        stopState.doAction(context);</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getState().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、策略模式"><a href="#10、策略模式" class="headerlink" title="10、策略模式"></a>10、策略模式</h2><p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p><strong>实现：</strong>定义一个接口A，再实现接口A作为算法的替换组件。最后定义一个工具类接收接口A的实现—算法的替换组件；最终实现不同的算法效果。</p><ul><li>定义计算接口和实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1+num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Opera</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义类封装这些方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 Context 类调用方法，可以替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> Opera());</span><br><span class="line">        context.executeStrategy(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11、责任链模式"><a href="#11、责任链模式" class="headerlink" title="11、责任链模式"></a>11、责任链模式</h2><p><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p><strong>思想：</strong></p><ol><li>定义抽象类，类内定义责任标准，只有符合标准才执行，不然交给下一个处理</li><li>创建实现类，每个实现类对应一个标准</li><li>初始化责任链，把所有实现类的对象连接起来</li><li>测试：输入标准，根据标准找到合适的实现类实现标准</li></ol><ul><li>定义抽象类日志：定义标准，只有达到标准才能处理请求</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//责任链中的下一个元素</span></span><br><span class="line">    <span class="keyword">protected</span> AbstractLogger nextLogger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextLogger = nextLogger;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有等级达到传递信息的等级才能处理信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.level &lt;= level)&#123;</span><br><span class="line">            write(message);</span><br><span class="line">            <span class="comment">// 否则交给下一个责任链</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nextLogger !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            nextLogger.logMessage(level, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>3个实现类：3种标准日志输出的标准</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;错误日志 &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造一个责任链：等级小的在前</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractLogger <span class="title">getChainOfLoggers</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        AbstractLogger errorLogger = <span class="keyword">new</span> ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">        AbstractLogger fileLogger = <span class="keyword">new</span> FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">        AbstractLogger consoleLogger = <span class="keyword">new</span> ConsoleLogger(AbstractLogger.INFO);</span><br><span class="line"></span><br><span class="line">        errorLogger.setNextLogger(fileLogger);</span><br><span class="line">        fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> errorLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得一条责任链</span></span><br><span class="line">        AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出日志信息</span></span><br><span class="line">        loggerChain.logMessage(AbstractLogger.INFO, <span class="string">&quot;This is an information.&quot;</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.DEBUG, <span class="string">&quot;This is a debug level information.&quot;</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.ERROR, <span class="string">&quot;This is an error information.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12、访问者模式"><a href="#12、访问者模式" class="headerlink" title="12、访问者模式"></a>12、访问者模式</h2><p><strong>意图：</strong>主要将数据结构与数据操作分离。</p><p><strong>主要解决：</strong>稳定的数据结构和易变的操作耦合问题。</p><p><strong>实现：</strong></p><ol><li>定义接口A，接口A的实现类表示具体的数据结构。</li><li>定义接口B，实现类通过接收接口A的实现类，来进行表示对数据的访问。</li><li>接口A实现类通过 接收接口B的对象，并且<code>把自己作为参数调用接口B的方法</code>。</li><li>这样就实现了通过接口A存储数据，接口B实现具体数据访问。</li></ol><ul><li>定义一个接口及实现类，访问方法实际不是在内部实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span>  <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span>  <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义访问者接口：可以访问上述几个类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerPartVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Mouse mouse)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Keyboard keyboard)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Monitor monitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>访问者实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerPartDisplayVisitor</span> <span class="keyword">implements</span> <span class="title">ComputerPartVisitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Mouse mouse)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Displaying Mouse.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Keyboard keyboard)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Displaying Keyboard.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Monitor monitor)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Displaying Monitor.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ComputerPart computer = <span class="keyword">new</span> Computer();</span><br><span class="line">       <span class="comment">// 方法的调用在computer中但是实现在外部，二者实现了分离。</span></span><br><span class="line">      computer.accept(<span class="keyword">new</span> ComputerPartDisplayVisitor());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 23种设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式:结构型模式</title>
      <link href="/2021/06/29/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/06/29/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1、结构型模式介绍"><a href="#1、结构型模式介绍" class="headerlink" title="1、结构型模式介绍"></a>1、结构型模式介绍</h2><p>从<strong>程序的结构</strong>上实现松耦合，扩大整体的类结构，解决更大的问题</p><h2 id="2、适配器模式"><a href="#2、适配器模式" class="headerlink" title="2、适配器模式"></a>2、适配器模式</h2><p><strong>解决问题：</strong>让接口不<strong>兼容</strong>而不能一起工作的那些类可以一起工作，即旧接口实现功能1，现在设计了新接口实现功能2，功能1和2解决的是一类问题，现在需要定义一个适配器让二者都功能结合起来。<strong>关注的是兼容性问题。</strong></p><p><strong>办法：</strong>接口A、接口B，定义类实现接口A，并且依赖接口B。</p><p><strong>优点：</strong>让任何两个没有关联的类一起运行、类复用</p><p><strong>缺点：</strong>让系统零乱，命名继承A接口，但是内部确是适配B接口</p><h3 id="2-1、对象适配器"><a href="#2-1、对象适配器" class="headerlink" title="2.1、对象适配器"></a>2.1、对象适配器</h3><ul><li>定义旧接口（旧日志功能）和实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OldLog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String tag,String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldLogImpl</span> <span class="keyword">implements</span> <span class="title">OldLog</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String tag, String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;旧日志&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在有一个新的日志接口，但是与旧日志接口不兼容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NewLog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> priority, String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义适配器，实现新日志接口，同时组合旧日志实现新旧一起工作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAdapter</span> <span class="keyword">implements</span> <span class="title">NewLog</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OldLog oldLog;</span><br><span class="line"><span class="comment">// 引入旧日志系统</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.oldLog = <span class="keyword">new</span> OldLogImpl();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  判断旧日志和新日志系统功能的调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> priority, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(priority==<span class="number">0</span>)&#123;</span><br><span class="line">            oldLog.debug(<span class="string">&quot;old&quot;</span>,message);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;新日志&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要知道调用了哪个接口，只要调用即可</span></span><br><span class="line">        LogAdapter logAdapter = <span class="keyword">new</span> LogAdapter();</span><br><span class="line">        <span class="comment">// 调用的旧日志功能</span></span><br><span class="line">        logAdapter.debug(<span class="number">0</span>,<span class="string">&quot;bug1&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用的新日志功能</span></span><br><span class="line">        logAdapter.debug(<span class="number">1</span>,<span class="string">&quot;bug2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、类适配器"><a href="#2-2、类适配器" class="headerlink" title="2.2、类适配器"></a>2.2、类适配器</h3><p>引入旧日志的方式变为继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过继承获得旧日志实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAdapter</span> <span class="keyword">extends</span> <span class="title">OldLogImpl</span> <span class="keyword">implements</span> <span class="title">NewLog</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> priority, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(priority==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">super</span>.debug(<span class="string">&quot;old&quot;</span>,message);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;新日志&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、桥接模式"><a href="#3、桥接模式" class="headerlink" title="3、桥接模式"></a>3、桥接模式</h2><p><strong>意图：</strong>抽象部分与实现部分分离，使它们都可以独立的变化。</p><p><strong>解决：</strong>某些情况，如下图，若新增一个品牌，要多3个类，会引起类爆炸。</p><p><strong>做法：</strong>接口A需要和抽象类B连接，则抽象类B<strong>依赖接口A</strong>，抽象B的子类就获得了抽象A的实例，实现类A和类B的桥接。</p><p><strong>特点：</strong>类B通过依赖的方式引入接口A，二者实现桥接。</p><p><img src="C:\Users\admin\Desktop\23设计模式\img\19.jpg"></p><p><img src="C:\Users\admin\Desktop\23设计模式\img\18.jpg"></p><p><strong>实现代码：</strong></p><ul><li>定义品牌接口和实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lenovo</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义电脑类别抽象类，并<strong>和品牌组合</strong>起来</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 组合，向上转型，可以接收所有的品牌</span></span><br><span class="line">    <span class="keyword">protected</span> Brand brand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        brand.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义电脑类的实现类：台式电脑和笔记本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desktop</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Desktop</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.info();</span><br><span class="line">        System.out.println(<span class="string">&quot;台式机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">laptop</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">laptop</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.info();</span><br><span class="line">        System.out.println(<span class="string">&quot;笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试，可以把<strong>各个品牌</strong>和<strong>电脑的样式</strong>自由拼接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属于不同的品牌和类别组合起来</span></span><br><span class="line">        Computer computer1 = <span class="keyword">new</span> Desktop(<span class="keyword">new</span> Apple());</span><br><span class="line">        computer1.info();</span><br><span class="line">        Computer computer2 = <span class="keyword">new</span> laptop(<span class="keyword">new</span> Lenovo());</span><br><span class="line">        computer2.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、装饰器模式"><a href="#4、装饰器模式" class="headerlink" title="4、装饰器模式"></a>4、装饰器模式</h2><p><strong>意图：</strong>向一个现有的对象添加新的功能，同时又不改变其结构</p><p><strong>做法：</strong>接口A的实例A1需要装饰，则定义抽象装饰类B包装接口A，定义类C继承抽象类B，则类C就有了实例A1，并且可以对这些实例进行装饰（类B本质还是类A）。</p><p><strong>特点：</strong>可以无限装饰，装饰类和被装饰的必须<strong>实现一个接口</strong>；装饰类必须持有被装饰类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口及其实现类:圆形和矩形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰器，实现了所有的形状特性注意仍然继承了Shape类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引入形状，可以引入圆形、矩形等等</span></span><br><span class="line">    <span class="keyword">protected</span> Shape decoratedShape;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.decoratedShape = decoratedShape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        decoratedShape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过继承装饰器，实现形状的扩展：红色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(decoratedShape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        decoratedShape.draw();</span><br><span class="line">        setRedBorder(decoratedShape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;红色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本质上还是圆圈形状类，只是增加了红色的装饰</span></span><br><span class="line">        ShapeDecorator shapeDecorator = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Circle());</span><br><span class="line">        shapeDecorator.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><ul><li>桥接模式：抽象类通过引入的方式，电脑和品牌属于不同的类</li><li>装饰器模式：抽象类通过继承的方式，装饰器本质还是形状类</li></ul><h2 id="5、组合模式"><a href="#5、组合模式" class="headerlink" title="5、组合模式"></a>5、组合模式</h2><p><strong>意图：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构，是用于<code>把一组相似的对象当作一个单一的对象</code>。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p><strong>解决：</strong>客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦</p><p><strong>做法：</strong>类A里面含有类A的列表（集合）。</p><ul><li>Employee对象里面定义Employee对象的**<code>对象列表</code>**</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String dept;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; subordinates;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,String dept, <span class="keyword">int</span> sal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.dept = dept;</span><br><span class="line">        <span class="keyword">this</span>.salary = sal;</span><br><span class="line">        subordinates = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">        subordinates.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">        subordinates.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getSubordinates</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subordinates;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;Employee :[ Name : &quot;</span>+ name</span><br><span class="line">                +<span class="string">&quot;, dept : &quot;</span>+ dept + <span class="string">&quot;, salary :&quot;</span></span><br><span class="line">                + salary+<span class="string">&quot; ]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee CEO = <span class="keyword">new</span> Employee(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;CEO&quot;</span>, <span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">        Employee headSales = <span class="keyword">new</span> Employee(<span class="string">&quot;Robert&quot;</span>,<span class="string">&quot;Head Sales&quot;</span>, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">        Employee headMarketing = <span class="keyword">new</span> Employee(<span class="string">&quot;Michel&quot;</span>,<span class="string">&quot;Head Marketing&quot;</span>, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">        Employee clerk1 = <span class="keyword">new</span> Employee(<span class="string">&quot;Laura&quot;</span>,<span class="string">&quot;Marketing&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        Employee clerk2 = <span class="keyword">new</span> Employee(<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Marketing&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        Employee salesExecutive1 = <span class="keyword">new</span> Employee(<span class="string">&quot;Richard&quot;</span>,<span class="string">&quot;Sales&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        Employee salesExecutive2 = <span class="keyword">new</span> Employee(<span class="string">&quot;Rob&quot;</span>,<span class="string">&quot;Sales&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        CEO.add(headSales);</span><br><span class="line">        CEO.add(headMarketing);</span><br><span class="line"></span><br><span class="line">        headSales.add(salesExecutive1);</span><br><span class="line">        headSales.add(salesExecutive2);</span><br><span class="line"></span><br><span class="line">        headMarketing.add(clerk1);</span><br><span class="line">        headMarketing.add(clerk2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印该组织的所有员工</span></span><br><span class="line">        System.out.println(CEO);</span><br><span class="line">        <span class="keyword">for</span> (Employee headEmployee : CEO.getSubordinates()) &#123;</span><br><span class="line">            System.out.println(headEmployee);</span><br><span class="line">            <span class="keyword">for</span> (Employee employee : headEmployee.getSubordinates()) &#123;</span><br><span class="line">                System.out.println(employee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、外观模式"><a href="#6、外观模式" class="headerlink" title="6、外观模式"></a>6、外观模式</h2><p><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</p><p><strong>思想：</strong>隐藏内部的复杂性，只暴露向外部提供的接口</p><p><strong>实现：</strong>定义接口A，在定义类B，把类A的多个实现类封装到内部，并且对外提供相似的接口以供访问。</p><ul><li>接口及其实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义一个类对这些接口的实现进行封装</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeMaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Shape circle;</span><br><span class="line">    <span class="keyword">private</span> Shape rectangle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeMaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        circle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过ShapeMaker即可调用Shape类的实现类，不必关心内部如何实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeMaker shapeMaker = <span class="keyword">new</span> ShapeMaker();</span><br><span class="line">        shapeMaker.drawCircle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、享元模式"><a href="#7、享元模式" class="headerlink" title="7、享元模式"></a>7、享元模式</h2><p><strong>意图：</strong>减少创建对象的数量，以减少内存占用和提高性能</p><p><strong>主要解决：</strong>大量对象时，有可能会造成内存溢出</p><p><strong>实现：</strong>获取对象前先尝试从现有的对象寻找满足条件的对象，若没有再创建。另外，将大量对象的公有部分抽象出来，这样共享的可能性将提高。</p><ul><li>定义接口形状和实现类：圆</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(String color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">int</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle: Draw() [Color : &quot;</span> + color</span><br><span class="line">                +<span class="string">&quot;, x : &quot;</span> + x +<span class="string">&quot;, y :&quot;</span> + y +<span class="string">&quot;, radius :&quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义生产圆对象的静态工厂</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把对象存放在HashMap中，用颜色做区分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, Shape&gt; circleMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getCircle</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        Circle circle = (Circle)circleMap.get(color);</span><br><span class="line">        <span class="comment">// 如果该颜色对象不存在则创建，存在则返回</span></span><br><span class="line">        <span class="keyword">if</span>(circle == <span class="keyword">null</span>) &#123;</span><br><span class="line">            circle = <span class="keyword">new</span> Circle(color);</span><br><span class="line">            circleMap.put(color, circle);</span><br><span class="line">            System.out.println(<span class="string">&quot;Creating circle of color : &quot;</span> + color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义颜色数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String colors[] = &#123; <span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Blue&quot;</span>, <span class="string">&quot;White&quot;</span>, <span class="string">&quot;Black&quot;</span> &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 通过工厂随机获取对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">            Circle circle =</span><br><span class="line">                    (Circle)ShapeFactory.getCircle(getRandomColor());</span><br><span class="line">            circle.setX(getRandomX());</span><br><span class="line">            circle.setY(getRandomY());</span><br><span class="line">            circle.setRadius(<span class="number">100</span>);</span><br><span class="line">            circle.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRandomColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> colors[(<span class="keyword">int</span>)(Math.random()*colors.length)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、代理模式"><a href="#8、代理模式" class="headerlink" title="8、代理模式"></a>8、代理模式</h2><h3 id="8-1、静态代理"><a href="#8-1、静态代理" class="headerlink" title="8.1、静态代理"></a>8.1、静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Marry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;等了这么久，终于等到你。。。 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarryCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Marry marry;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarryCompany</span><span class="params">(Marry marry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.marry = marry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        marry.toMarry();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;婚礼现场布置中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜您结婚，迈入人生第二阶段&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代理类和目标类实现同一个接口</li><li>代理类构造方法需要传入目标类</li><li>代理类的方法依次实现before方法，目标类方法，after方法</li></ul><p><strong>优点</strong></p><ul><li>真实的对象更加纯粹，不用去关注一些公共的业务</li><li>广告业务交给代理类，实现业务分工</li><li>公共业务发生拓展的时候，方便集中管理</li></ul><p><strong>缺点</strong></p><ul><li>一个真实对象会产生一个代理角色：代码量翻倍——&gt;效率低</li></ul><h3 id="8-2、动态代理（JDK反射）"><a href="#8-2、动态代理（JDK反射）" class="headerlink" title="8.2、动态代理（JDK反射）"></a>8.2、动态代理（JDK反射）</h3><ul><li>动态代理和静态代理角色一样</li><li>动态代理的代理类是动态生成字节码，不是直接写好的</li><li>动态代理分为两大类：基于接口和基于类<ul><li>基于接口：JDK代理，反射，生成效率高，执行效率低</li><li>基于类：cglib，FastClass机制直接调用方法，生成效率低，执行高</li></ul></li></ul><blockquote><p>InvocationHandler：反射包下的类，是一个接口，只有invoke方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span></span></span><br></pre></td></tr></table></figure><p>定义一个动作，所有接口的方法执行都会替换成动作执行</p><blockquote><p>Proxy：</p></blockquote><p>Proxy为创建动态代理类的实例提供了静态方法，也是所有动态代理类的父类的方法创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, </span></span></span><br><span class="line"><span class="params"><span class="function">              Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序</span></span></span><br><span class="line"><span class="function"><span class="comment">//即根据传入的父接口的子实现类，返回该父接口的对象（向上转型），通过该父接口调用子类方法</span></span></span><br></pre></td></tr></table></figure><ul><li>参数一为当前类的类加载器</li><li>参数二为需要代理的类反射获得的接口</li><li>参数三为调用处理器，即代理类（当前类）</li></ul><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Rent rent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRent</span><span class="params">(Rent rent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成得到代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),rent.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// invoke相当于执行接口的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">// 反射调用了方法，rent为对象，objects为参数</span></span><br><span class="line">        Object result = method.invoke(rent,objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真实角色</span></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        <span class="comment">//代理角色:现在没有</span></span><br><span class="line">        ProxyInvocationHandler proxyInvocationHandler = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">        <span class="comment">//传入真实角色</span></span><br><span class="line">        proxyInvocationHandler.setRent(host);</span><br><span class="line">        <span class="comment">// 获得代理类</span></span><br><span class="line">        Rent proxy = (Rent) proxyInvocationHandler.getProxy();</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3、动态代理（Cglib）"><a href="#8-3、动态代理（Cglib）" class="headerlink" title="8.3、动态代理（Cglib）"></a>8.3、动态代理（Cglib）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object o1 = methodProxy.invokeSuper(o,objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;做饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收拾餐具&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = (User) <span class="keyword">new</span> Demo().getInstance(User.class);</span><br><span class="line">        user.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 23种设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式:创建型模式</title>
      <link href="/2021/06/29/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/06/29/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h2><p>采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法(静态方法)。</p><h3 id="1-1、饿汉式（静态常量）"><a href="#1-1、饿汉式（静态常量）" class="headerlink" title="1.1、饿汉式（静态常量）"></a>1.1、饿汉式（静态常量）</h3><p><strong>步骤：</strong></p><ol><li>构造器私有化 (防止 new )</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法。</li><li>代码实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry instance = <span class="keyword">new</span> Hungry();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hungry <span class="title">getHungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong>在<strong>类加载的时候就完成实例化</strong>。避免了线程同步问题</p><p><strong>缺点：</strong>有其他方法引起类的加载，导致浪费资源。</p><h3 id="1-2、饿汉式（静态代码块）"><a href="#1-2、饿汉式（静态代码块）" class="headerlink" title="1.2、饿汉式（静态代码块）"></a>1.2、饿汉式（静态代码块）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象由直接静态创建变为静态代码块创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry2 instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Hungry2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hungry2 <span class="title">getHungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3、懒汉式（线程不安全）"><a href="#1-3、懒汉式（线程不安全）" class="headerlink" title="1.3、懒汉式（线程不安全）"></a>1.3、懒汉式（线程不安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 singleton;</span><br><span class="line">    <span class="comment">// 获取前先判断单例有没有创建，有就返回，没有就先创建再返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton1 <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong>有了懒加载，节约资源</p><p><strong>缺点：</strong>线程不安全，多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</p><h3 id="1-4、懒汉式（线程安全，同步方法或锁）"><a href="#1-4、懒汉式（线程安全，同步方法或锁）" class="headerlink" title="1.4、懒汉式（线程安全，同步方法或锁）"></a>1.4、懒汉式（线程安全，同步方法或锁）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Singleton2 <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong>解决了线程安全问题</p><p><strong>缺点：</strong>效率太低了，每个线程在想获得类的实例时候，都要进行同步，而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了，效率太低。</p><h3 id="1-5、懒汉式（同步代码块）"><a href="#1-5、懒汉式（同步代码块）" class="headerlink" title="1.5、懒汉式（同步代码块）"></a>1.5、懒汉式（同步代码块）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Singleton3 <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3.class) &#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种同步**<code>并不能起到线程同步</code>**的作用，若同时两个线程进入判断，只要判断了为null进去了，即使没有获锁，也只是会等待，等结束之后会继续创建</p><h3 id="1-6、懒汉式（线程安全，双重检查）"><a href="#1-6、懒汉式（线程安全，双重检查）" class="headerlink" title="1.6、懒汉式（线程安全，双重检查）"></a>1.6、懒汉式（线程安全，双重检查）</h3><ul><li>1.5方式的基础上使用 volatile 保证可见性，并增加一个判断</li><li> volatile 的作用还有禁止指令重排</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton4 singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton4 <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 创建后会刷新回主内存</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line"> <span class="comment">//  1、初始化   2、分配地址  </span></span><br><span class="line"><span class="comment">// 没有volatile线程1先分配地址,再初始化，初始化期间线程2获得不完整对象   </span></span><br><span class="line">                <span class="keyword">if</span> (singleton==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong>线程安全；延迟加载；效率较高</p><p><strong>结论：</strong>在实际开发中，推荐使用这种单例设计模式</p><h3 id="1-7、静态内部类"><a href="#1-7、静态内部类" class="headerlink" title="1.7、静态内部类"></a>1.7、静态内部类</h3><ul><li>在内部类创建外部类的一个单例</li><li>调用方法返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Inner</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">staticInner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Inner instance = <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Inner <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> staticInner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>采用了类装载的机制来保证初始化实例时只有一个线程</li><li>只有调用getInner（）方法才会导致内部类初始化，外部类初始化不会</li><li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，<code>JVM帮助我们保证了线程的安全性</code>，在类进行初始化时，别的线程是无法进入的。</li></ol><h3 id="1-8、枚举"><a href="#1-8、枚举" class="headerlink" title="1.8、枚举"></a>1.8、枚举</h3><ul><li>每个枚举都是枚举类的一个对象</li><li>每个枚举类型都是final static类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnuSingleton</span></span>&#123;</span><br><span class="line">    instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;枚举实现单例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnuSingleton.instance.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</p><h3 id="1-9、单例模式的破坏"><a href="#1-9、单例模式的破坏" class="headerlink" title="1.9、单例模式的破坏"></a>1.9、单例模式的破坏</h3><blockquote><p>反射：通过反射创建对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预防</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PersonLazyInnerClassSafe</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (PersonLazyInnerClassSafe.class)&#123;</span><br><span class="line">        <span class="comment">//第一次被调用，仅修改标志位；后续被调用抛异常</span></span><br><span class="line">        <span class="keyword">if</span>(alreadyNew == <span class="keyword">false</span>)&#123;</span><br><span class="line">            alreadyNew = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;单例模式被破坏！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>序列化</p></blockquote><p><strong>破坏：</strong>序列化的对象传输出去，再重新接收变为对象，新对象与原对象不一样，即产生了2个对象。</p><p><strong>原因：</strong>反序列化是通过Object的构造函数去反射，生成了新的实例</p><p><strong>预防：</strong>不实现序列化接口即可、增加readReslove方法返回单例</p><blockquote><p>克隆</p></blockquote><p><strong>破坏：</strong>克隆一个对象，会生成地址不同的另一个对象。</p><p><strong>防止：</strong>不实现 cloneable 接口、重写clone方法。</p><h2 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h2><p><strong>作用：</strong>实现类创建在和调用者的分离，关注的生产一个产品，</p><p><strong>总结</strong>：创建一个对象，不关心对象内部结构，只关心产品的生产。</p><p><strong>分类</strong></p><ul><li>简单工厂模式：新增产品需要覆盖已有方法</li><li>工厂方法模式：新增产品需要新增方法</li><li>抽象工厂模式：生成工厂的工厂</li></ul><p><strong>思想：</strong></p><ul><li>实例化对象不通过new，用工厂方法替代</li><li>将选择实现类，创建对象同一管理和控制，**<code>让调用者和实现类解耦</code>**</li></ul><h3 id="2-1、简单（静态）工厂"><a href="#2-1、简单（静态）工厂" class="headerlink" title="2.1、简单（静态）工厂"></a>2.1、简单（静态）工厂</h3><p><strong>思想：</strong>把类的创建交给<strong>工厂类</strong>来实现，工厂类根据传递的参数决定生产哪个牌子的产品。</p><p><strong>优点：</strong>不必关心车是怎么生产出来的，只需要根据名字去取即可</p><p><strong>缺点：</strong>违背了开闭原则，修改仍然需要修改工厂方法或者增加<strong>获取新车的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 车类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 车实现类：特斯拉</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是特斯拉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂类：根据名字，生产车</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">&quot;tesla&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 未使用工厂模式</span></span><br><span class="line">        Car car1 = <span class="keyword">new</span> Tesla();</span><br><span class="line">        car1.name();</span><br><span class="line">        <span class="comment">// 使用工厂模式</span></span><br><span class="line">        Car car2 = Factory.createCar(<span class="string">&quot;tesla&quot;</span>);</span><br><span class="line">        car2.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、工厂方法"><a href="#2-2、工厂方法" class="headerlink" title="2.2、工厂方法"></a>2.2、工厂方法</h3><p><strong>思想：</strong>定义一个接口作为工厂，实现类代表不同的工厂（品牌），每个工厂生产同一种产品，但是品牌不同。</p><p><strong>优点：</strong>普通工厂的扩展，增加了开闭原则。</p><ul><li>工厂接口只有一个方法，只生产一个产品</li><li>有多个工厂实现该接口，每个工厂生产自己的产品（车）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 车类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是特斯拉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BWM</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是宝马&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">getCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BWMCarFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BWM();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeslaCarFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BWMCarFactory bwmCarFactory = <span class="keyword">new</span> BWMCarFactory();</span><br><span class="line">        Car BWM = bwmCarFactory.getCar();</span><br><span class="line">        BWM.name();</span><br><span class="line"></span><br><span class="line">        TeslaCarFactory teslaCarFactory = <span class="keyword">new</span> TeslaCarFactory();</span><br><span class="line">        Car tesla = teslaCarFactory.getCar();</span><br><span class="line">        tesla.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、抽象工厂"><a href="#2-3、抽象工厂" class="headerlink" title="2.3、抽象工厂"></a>2.3、抽象工厂</h3><p><strong>思想：</strong>定义一个工厂接口 包含多个产品，工厂的具体实现类对应不同的工厂。每个工厂生产的产品种类相同，但是品牌不同。</p><p><strong>缺点：</strong>违背了开闭原则，接口修改了（工厂产品种类更改），每个工厂都要更改扩展新产品比较麻烦系统抽象性，理解度高。</p><p><img src="C:\Users\admin\Desktop\23设计模式\img\17.jpg"></p><p>小米手机、小米路由器有同一个工厂生产，属于同一个产品族</p><p>华为手机、和小米手机属于同一种产品，单不是同一个产品族</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手机产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setting</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现类：华为、小米的手机和路由器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiRouter</span> <span class="keyword">implements</span> <span class="title">Router</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接小米路由器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;设置参数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品工厂</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成手机</span></span><br><span class="line">    <span class="function">Phone <span class="title">createPhone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 生成路由器</span></span><br><span class="line">    <span class="function">Router <span class="title">createRouter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体工厂：小米、华为的工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaWeiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Router <span class="title">createRouter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Router <span class="title">createRouter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HuaWeiFactory huaWeiFactory = <span class="keyword">new</span> HuaWeiFactory();</span><br><span class="line">        MiFactory miFactory = <span class="keyword">new</span> MiFactory();</span><br><span class="line"></span><br><span class="line">        Phone phone1 = miFactory.createPhone();</span><br><span class="line">        Phone phone2 = huaWeiFactory.createPhone();</span><br><span class="line"></span><br><span class="line">        Router router = miFactory.createRouter();</span><br><span class="line">        phone1.start();</span><br><span class="line">        phone2.start();</span><br><span class="line">        router.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4、小结"><a href="#2-4、小结" class="headerlink" title="2.4、小结"></a>2.4、小结</h3><blockquote><p>三种方式</p></blockquote><ul><li>简单：不符合开闭原则，但是广泛使用</li><li>方法：工厂抽象成接口，有多个工厂可以生产产品</li><li>抽象：工厂抽象成接口，工厂生产多个产品，多个工厂可以生产产品</li></ul><blockquote><p>应用场景</p></blockquote><ul><li>JDK中Calendar的getInstance方法</li><li>JDBC的Connection对象的获取</li><li>Spring中IOC容器创建管理Bean对象</li><li>反射中Class对象的newInstance方法</li></ul><h2 id="3、建造者模式"><a href="#3、建造者模式" class="headerlink" title="3、建造者模式"></a>3、建造者模式</h2><p><strong>概念：</strong>对象的<strong>构建和表示分离</strong>，关心对象内部的复杂结构。不必知道对象的创建过程和细节时，直接创建复杂的对象。</p><p><strong>总结：</strong>通过指定类的内容，创建出复杂的对象，关心的是产品的具体结构。</p><p><strong>实现：</strong>定义一个接口，接口每个方法对应一个类内部一个部分的复杂实现，每个实现类即代表具体的对象，最后定义建造者类负责<strong>隐藏实现类内部的复杂结构</strong>，返回对象给调用者。</p><h3 id="3-1、常规实现"><a href="#3-1、常规实现" class="headerlink" title="3.1、常规实现"></a>3.1、常规实现</h3><ul><li>定义复杂的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str1;</span><br><span class="line">    <span class="keyword">private</span> String str2;</span><br><span class="line">    <span class="keyword">private</span> String str3;</span><br><span class="line">    <span class="keyword">private</span> String str4;</span><br><span class="line"><span class="comment">// 省略get 、set、toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造者接口及实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象的建造者，方法为前四个的参数，最后一个方法获得对象</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 工人</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="comment">// 创建一个产品</span></span><br><span class="line">    Worker()&#123;</span><br><span class="line">        <span class="keyword">this</span>.product = <span class="keyword">new</span> Product();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setStr1(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;步骤1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setStr2(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;步骤2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setStr3(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;步骤3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setStr4(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;步骤4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>指挥者指挥工人，得到产品</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">        worker.build1();</span><br><span class="line">        worker.build2();</span><br><span class="line">        worker.build3();</span><br><span class="line">        worker.build4();</span><br><span class="line">        <span class="keyword">return</span> worker.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Director director = <span class="keyword">new</span> Director();</span><br><span class="line">        Product product = director.getProduct();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、变种的方式"><a href="#3-2、变种的方式" class="headerlink" title="3.2、变种的方式"></a>3.2、变种的方式</h3><p><strong>概念：</strong>删除建造者类，让调用者<strong>自己调用实现类</strong>决定类的复杂实现</p><ul><li>复杂的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str1;</span><br><span class="line">    <span class="keyword">private</span> String str2;</span><br><span class="line">    <span class="keyword">private</span> String str3;</span><br><span class="line">    <span class="keyword">private</span> String str4;</span><br><span class="line"><span class="comment">// 省略get 、set、toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>建造者方法，注意返回Worker类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象的建造者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function">Worker <span class="title">build1</span><span class="params">(String str)</span></span>;</span><br><span class="line">    <span class="function">Worker <span class="title">build2</span><span class="params">(String str)</span></span>;</span><br><span class="line">    <span class="function">Worker <span class="title">build3</span><span class="params">(String str)</span></span>;</span><br><span class="line">    <span class="function">Worker <span class="title">build4</span><span class="params">(String str)</span></span>;</span><br><span class="line">    <span class="function">Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>建造者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="comment">// 创建一个产品</span></span><br><span class="line">    Worker()&#123;</span><br><span class="line">        <span class="keyword">this</span>.product = <span class="keyword">new</span> Product();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">build1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        product.setStr1(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">build2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        product.setStr2(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">build3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        product.setStr3(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">build4</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        product.setStr4(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">        <span class="comment">// 流式编程</span></span><br><span class="line">        Product product = worker.build1(<span class="string">&quot;全家桶&quot;</span>).build2(<span class="string">&quot;方便面&quot;</span>).getProduct();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><p>优点：</p><ol><li>建造和表示分离，实现类解耦</li><li>建造者类之间相互独立，利于系统的扩展，符合开闭原则</li></ol><p>缺点：</p><ol><li>建造者模式的产品一般共同点比较多，<strong>若产品之间差异很大则不适合建造者模式</strong></li><li>若产品内部变化复杂，则需要定义很多建造者，这样会导致系统复杂</li></ol><h2 id="4、原型模式"><a href="#4、原型模式" class="headerlink" title="4、原型模式"></a>4、原型模式</h2><h3 id="4-1、浅克隆"><a href="#4-1、浅克隆" class="headerlink" title="4.1、浅克隆"></a>4.1、浅克隆</h3><p><strong>实现：</strong>内部基本类型复制值，引用类型复制地址。</p><p><strong>思想：</strong>克隆出和原对象一模一样的对象，但是地址不同</p><ul><li>实现Cloneable接口即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="comment">// 克隆方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 原型对象</span></span><br><span class="line">        Video video1 = <span class="keyword">new</span> Video(<span class="string">&quot;wzh&quot;</span>,<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(video1 + <span class="string">&quot; &quot;</span> + video1.hashCode());</span><br><span class="line"><span class="comment">// 克隆对象</span></span><br><span class="line">        Video video2 = (Video) video1.clone();</span><br><span class="line">        System.out.println(video2 + <span class="string">&quot; &quot;</span> + video2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>浅拷贝弊端</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 原型对象</span></span><br><span class="line">        Video video1 = <span class="keyword">new</span> Video(<span class="string">&quot;wzh&quot;</span>,date);</span><br><span class="line">        Video video2 = video1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(video1 + <span class="string">&quot; &quot;</span> + video1.hashCode());</span><br><span class="line">        System.out.println(video2 + <span class="string">&quot; &quot;</span> + video2.hashCode());</span><br><span class="line">        </span><br><span class="line">        date.setTime(<span class="number">2000000</span>);</span><br><span class="line">        System.out.println(video1 + <span class="string">&quot; &quot;</span> + video1.hashCode());</span><br><span class="line">        System.out.println(video2 + <span class="string">&quot; &quot;</span> + video2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出，二者都被修改了</span></span><br><span class="line">Video&#123;name=<span class="string">&#x27;wzh&#x27;</span>, createTime=Sat May <span class="number">22</span> <span class="number">20</span>:<span class="number">31</span>:<span class="number">18</span> CST <span class="number">2021</span>&#125; <span class="number">356573597</span></span><br><span class="line">Video&#123;name=<span class="string">&#x27;wzh&#x27;</span>, createTime=Sat May <span class="number">22</span> <span class="number">20</span>:<span class="number">31</span>:<span class="number">18</span> CST <span class="number">2021</span>&#125; <span class="number">1735600054</span></span><br><span class="line">Video&#123;name=<span class="string">&#x27;wzh&#x27;</span>, createTime=Thu Jan <span class="number">01</span> 08:<span class="number">33</span>:<span class="number">20</span> CST <span class="number">1970</span>&#125; <span class="number">356573597</span></span><br><span class="line">Video&#123;name=<span class="string">&#x27;wzh&#x27;</span>, createTime=Thu Jan <span class="number">01</span> 08:<span class="number">33</span>:<span class="number">20</span> CST <span class="number">1970</span>&#125; <span class="number">1735600054</span></span><br></pre></td></tr></table></figure><ul><li>这说明，并不是真正意义上的克隆，而是用<strong>原变量重新创建对象</strong></li><li>解决：深克隆</li></ul><h3 id="4-3、深克隆"><a href="#4-3、深克隆" class="headerlink" title="4.3、深克隆"></a>4.3、深克隆</h3><blockquote><p>方法1：深度克隆</p></blockquote><p><strong>实现：</strong>引用类型同样使用克隆，保证地址不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 克隆方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">super</span>.clone();</span><br><span class="line">    Video video = (Video) obj;</span><br><span class="line">    </span><br><span class="line">    video.createTime = (Date) <span class="keyword">this</span>.createTime.clone();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果，只有原型被修改了</span></span><br><span class="line">Video&#123;name=<span class="string">&#x27;wzh&#x27;</span>, createTime=Sat May <span class="number">22</span> <span class="number">20</span>:<span class="number">34</span>:<span class="number">20</span> CST <span class="number">2021</span>&#125; <span class="number">356573597</span></span><br><span class="line">Video&#123;name=<span class="string">&#x27;wzh&#x27;</span>, createTime=Sat May <span class="number">22</span> <span class="number">20</span>:<span class="number">34</span>:<span class="number">20</span> CST <span class="number">2021</span>&#125; <span class="number">1735600054</span></span><br><span class="line">Video&#123;name=<span class="string">&#x27;wzh&#x27;</span>, createTime=Thu Jan <span class="number">01</span> 08:<span class="number">33</span>:<span class="number">20</span> CST <span class="number">1970</span>&#125; <span class="number">356573597</span></span><br><span class="line">Video&#123;name=<span class="string">&#x27;wzh&#x27;</span>, createTime=Sat May <span class="number">22</span> <span class="number">20</span>:<span class="number">34</span>:<span class="number">20</span> CST <span class="number">2021</span>&#125; <span class="number">1735600054</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>方法2、序列化和反序列化</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 23种设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式:规则</title>
      <link href="/2021/06/28/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99%E5%92%8CUML%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/06/28/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99%E5%92%8CUML%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><p>设计模式是为了让程序(软件)，具有更好的以下特性</p><ol><li>代码重用性 (即：相同功能的代码，不用多次编写)</li><li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解)</li><li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li><li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li><li>使程序呈现<strong>高内聚</strong>，<strong>低耦合</strong>的特性</li></ol><h3 id="1-2、分类"><a href="#1-2、分类" class="headerlink" title="1.2、分类"></a>1.2、分类</h3><ol><li><strong>创建型模式</strong>：单例模式、抽象工厂模式、原型模式、建造者模式、<strong>工厂模式</strong>。</li><li><strong>结构型模式</strong>：适配器模式、桥接模式、<strong>装饰模式</strong>、组合模式、外观模式、享元模式、<strong>代理模式</strong>。</li><li><strong>行为型模式</strong>：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。</li></ol><h2 id="2、七大设计原则"><a href="#2、七大设计原则" class="headerlink" title="2、七大设计原则"></a>2、七大设计原则</h2><h3 id="2-1、单一职责原则"><a href="#2-1、单一职责原则" class="headerlink" title="2.1、单一职责原则"></a>2.1、单一职责原则</h3><p><strong>概念：</strong>对类来说的，即一个类应该只负责一项职责。</p><blockquote><p>不使用规则</p></blockquote><p>如类A负责两个不同职责：职责1，职责2。<code>当职责1需求变更而改变A时，可能造成职责2执行错误</code>，所以需要将类A的粒度分解为 A1，A2</p><h3 id="2-2、接口隔离原则"><a href="#2-2、接口隔离原则" class="headerlink" title="2.2、接口隔离原则"></a>2.2、接口隔离原则</h3><p><strong>概念：</strong>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><p><strong>总结：</strong>减少接口的粒度，保证一个类能尽可能使用接口的全部</p><blockquote><p>不使用接口隔离原则</p></blockquote><p>假设类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，</p><p>此时类A只需要使用interface1的部分方法，但却必须实现interface1的全部的方法，这样就造成了浪费。</p><h3 id="2-3、依赖倒转原则"><a href="#2-3、依赖倒转原则" class="headerlink" title="2.3、依赖倒转原则"></a>2.3、依赖倒转原则</h3><p><strong>概念：</strong>一个方法依赖（参数）的是一个接口，这样调用方法时可以根据需要选择合适的参数，（接口的实现类）去完成合适的方法。即不依赖具体细节而是依赖抽象。</p><p><strong>总结：</strong>依赖接口或者父类，不要依赖具体的类。</p><blockquote><p>没有使用依赖倒转原则</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInversion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完成接收消息的功能</span></span><br><span class="line"><span class="comment">// 只能接收Email的消息，如果是微信就必须再次写其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span></span>&#123;</span><br><span class="line">        System.out.println(email.getInfo());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用依赖倒转原则</p></blockquote><ul><li>可以看到<strong>方法的参数</strong>不再是具体的实现类，<strong>而是接口</strong></li><li>调用方法传递的参数是**<code>接口的具体实现类</code>**</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInversion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">        person.receive(<span class="keyword">new</span> WeChat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeChat</span> <span class="keyword">implements</span> <span class="title">IReceiver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;WeChat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完成接收消息的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver)</span></span>&#123;</span><br><span class="line">        System.out.println(receiver.getInfo());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4、里氏替换原则"><a href="#2-4、里氏替换原则" class="headerlink" title="2.4、里氏替换原则"></a>2.4、里氏替换原则</h3><p><strong>概念：</strong>使用父类的地方，使用子类的方法，结果没有变化（没有重写方法）</p><p><strong>总结：</strong>继承时，在子类中尽量不要重写父类的方法</p><h3 id="2-5、开闭原则"><a href="#2-5、开闭原则" class="headerlink" title="2.5、开闭原则"></a>2.5、开闭原则</h3><p><strong>概念：</strong>一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。当软件需要变化时，尽量通过扩展，而不是通过修改。</p><p><strong>总结：</strong>对扩展开放，对修改关闭。</p><blockquote><p>未遵循开闭原则</p></blockquote><ul><li>此时如果需要增加功能（画其它图形），那么处理新增一个图形类继承shape外</li><li>GraphicEditor画图的类也需要进行修改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GraphicEditor g = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        g.drawCircle(<span class="keyword">new</span> Rectangle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据接收的对象来判断对象并且绘制图形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">            drawRectangle(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)  <span class="comment">// 判断多次，</span></span><br><span class="line">            drawCircle(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;矩形&quot;</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义各种图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化父类的成员变量</span></span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>遵循</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GraphicEditor g = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        g.draw(<span class="keyword">new</span> Rectangle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制长方形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6、迪米特法则"><a href="#2-6、迪米特法则" class="headerlink" title="2.6、迪米特法则"></a>2.6、迪米特法则</h3><p><strong>概念：</strong>迪米特法则(<strong>Demeter Principle</strong>)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息</p><p><strong>总结：</strong>隐藏自己的内部复杂结构，只给外部提供简单的接口</p><h3 id="2-7、合成复用原则"><a href="#2-7、合成复用原则" class="headerlink" title="2.7、合成复用原则"></a>2.7、合成复用原则</h3><p><strong>概念：</strong>原则是尽量使用**<code>合成/聚合</code>**的方式，而不是使用继承</p><p>让B调用A的方法</p><ol><li>B继承A，这样B和A之间的耦合性高</li><li>B通过构造方法，获得A的对象实例（组合、合成）</li><li>B设置一个属性，属性就为A的实例，（聚合）</li><li>B通过方法参数，接收获得A的对象实例</li></ol><p><strong>总结：</strong>通过合成，聚合的方式调用其他对象，而不是通过继承。</p><h3 id="2-8、总结"><a href="#2-8、总结" class="headerlink" title="2.8、总结"></a>2.8、总结</h3><ol><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的松耦合设计而努力</li></ol><h2 id="3、UML图简介"><a href="#3、UML图简介" class="headerlink" title="3、UML图简介"></a>3、UML图简介</h2><p>3.1、概念</p><ol><li>UML——Unified modeling language UML (<strong>统一建模语言</strong>)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果</li><li>UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如右图:</li><li>使用UML来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模</li></ol><p><img src="/img/23/1.jpg"></p><h3 id="3-2、分类"><a href="#3-2、分类" class="headerlink" title="3.2、分类"></a>3.2、分类</h3><ol><li>用例图</li><li>静态结构图：类图、对象图、包图、组件图、部署图</li><li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li></ol><h3 id="3-3、用例图"><a href="#3-3、用例图" class="headerlink" title="3.3、用例图"></a>3.3、用例图</h3><p>由参与者、用例，边界以及它们之间的关系 构成的用于<strong>描述系统功能</strong>的视图</p><p><strong>用例图中包含以下四种关系：</strong></p><ul><li>包含关系使用符号《include》，想要查看订单列表，前提是需要先登录。<strong>（必须）</strong></li><li>扩展关系使用符号《extend》，基于查询订单列表的功能，可以增加一个导出数据的功能<strong>（非必须）</strong></li><li>泛化关系：子用例**<code>继承</code><strong>父用例</strong>所有结构、行为和关系**，如下图请假审批和审批</li><li>关联关系：<strong>参与者与用例</strong>之间的关系，图中的部门领导和审批</li></ul><p><strong>注意：</strong></p><ul><li>包含和扩展：只能是用例之间的关系</li><li>关联关系：参与者与用例之间的关系</li></ul><p><img src="/img/23/2.jpg"></p><h3 id="3-4、类图"><a href="#3-4、类图" class="headerlink" title="3.4、类图"></a>3.4、类图</h3><p>描述类与类之间的关系的，是UML图中最<strong>核心</strong>的</p><p><strong>类与类之间的关系</strong></p><blockquote><p>依赖关系</p></blockquote><ul><li>【依赖关系】是一种使用关系，即一个类的实现需要另一个类的协助。</li><li>【箭头指向】带普通箭头的虚线，普通箭头指向被使用者。</li><li>老司机只管开车，车是谁的不重要，给什么车开什么车。</li></ul><p><img src="/img/23/11.jpg"></p><blockquote><p>泛化关系（继承）</p></blockquote><ul><li>【泛化关系】是一种**<code>继承关系</code><strong>，表示子类继承父类的</strong>所有特征和行为**。</li><li>【箭头指向】带三角箭头的实线，箭头指向父类。</li><li>圆是形状的一个子类</li></ul><p><img src="/img/23/12.jpg"></p><blockquote><p>实现关系</p></blockquote><ul><li>【实现关系】是一种类与接口的关系，表示类是接口所有特征和行为的实现。</li><li>【箭头指向】带三角箭头的虚线，箭头指向接口。</li><li>Alipay继承了IPay这个方式</li></ul><p><img src="/img/23/13.jpg"></p><blockquote><p>关联关系</p></blockquote><ul><li>【关联关系】是一种拥有关系，它使得一个类知道另一个类的<strong>属性和方法</strong>。</li><li>【代码体现】成员变量</li><li>【箭头指向】带普通箭头的实线，指向被拥有者。双向的关联可以有两个箭头，或者没有箭头。单向的关联有一个箭头。</li></ul><p><strong>关系的特性</strong></p><ul><li><p><strong><code>特殊的依赖关系</code></strong></p></li><li><p>导航性：可以单向或者多项</p></li><li><p>多重性：“1”（表示有且仅有一个），“0…”（表示0个或者多个），“0，1”（表示0个或者一个），“n…m”(表示n到 m个都可以),“m…*”（表示至少m个）</p></li></ul><p><img src="/img/23/14.jpg"></p><blockquote><p>聚合关系：</p></blockquote><ul><li>聚合关系是关联关系的特例，表示的是<strong>整体和部分</strong>的关系，且部分可以离开整体而单独存在</li><li>关联和聚合在语法上无法区分，必须考察具体的<strong>逻辑关系</strong></li><li>电脑有键盘才能输入信息，电脑是整体，键盘是部分，键盘也可以离开电脑，单纯的拿去敲。、</li></ul><p><img src="/img/23/15.jpg"></p><blockquote><p>组合关系：</p></blockquote><ul><li>也是整体与部分的关系，但是<strong>部分不能离开整体而单独存在</strong></li><li>组合关系是关联关系的一种，是比聚合关系还要强的关系。</li><li>翅膀依赖鸟存在</li></ul><p><img src="/img/23/16.jpg"></p><p>注意：</p><ul><li>A使用了B和C则表示之间存在依赖关系</li><li>依赖关系可以具体到<strong>关联</strong>情况</li><li>若A由B和C组成，可分则表示聚合，不可分则表示组合</li></ul><h3 id="3-5、对象图"><a href="#3-5、对象图" class="headerlink" title="3.5、对象图"></a>3.5、对象图</h3><ul><li>【概念】对象图是<strong>类图的一个实例</strong>，是系统在某个时间点的详细状态的快照。</li><li>【目的】用来表示两个或者多个对象之间在某一时刻之间的关系。</li></ul><p>表示某时间点bat这个公司有一个研发部，一个销售部，两个部门只有一个人iisheng</p><p><img src="/img/23/10.jpg"></p><h3 id="3-6、包图"><a href="#3-6、包图" class="headerlink" title="3.6、包图"></a>3.6、包图</h3><ul><li>【概念】描绘了系统在包层面上的结构设计。</li><li>【目的】用来表示包和包之间的依赖关系。</li></ul><h3 id="3-7、组件图"><a href="#3-7、组件图" class="headerlink" title="3.7、组件图"></a>3.7、组件图</h3><ul><li>【概念】描绘了系统中组件提供的、需要的接口、端口等，以及它们之间的关系。</li><li>【目的】用来展示各个组件之间的依赖关系。</li></ul><h3 id="3-8、部署图"><a href="#3-8、部署图" class="headerlink" title="3.8、部署图"></a>3.8、部署图</h3><ul><li>【概念】描述了系统内部的软件如何分布在不同的节点上。</li><li>【目的】用来表示<strong>软件和硬件的映射关系</strong>。</li></ul><h3 id="3-9、活动图"><a href="#3-9、活动图" class="headerlink" title="3.9、活动图"></a>3.9、活动图</h3><ul><li>【概念】描述了具体业务用例的<strong>实现流程</strong>。</li><li>【目的】用来表示用例实现的工作流程。</li><li>描述了登录查看订单的流程图</li></ul><p><img src="/img/23/4.jpg"></p><h3 id="3-10、状态机图"><a href="#3-10、状态机图" class="headerlink" title="3.10、状态机图"></a>3.10、状态机图</h3><ul><li>【概念】状态机图对**<code>一个单独对象</code>**的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。</li><li>【目的】用来表示指定对象，在整个生命周期，响应不同事件的不同状态。</li><li>图中描述了，门在其生命周期内所经历的状态。</li></ul><p><img src="/img/23/5.jpg"></p><h3 id="3-11、时序图"><a href="#3-11、时序图" class="headerlink" title="3.11、时序图"></a>3.11、时序图</h3><ul><li>【概念】时序图被用来显示随时间变化，<strong>一个或多个元素的值或状态的更改</strong>。也显示时控事件之间的交互和管理它们的时间和期限约束。</li><li>【目的】用来表示元素状态或者值随时间的变化而变化的视图。</li></ul><p><img src="/img/23/8.jpg"></p><h3 id="3-12、序列图"><a href="#3-12、序列图" class="headerlink" title="3.12、序列图"></a>3.12、序列图</h3><ul><li>【概念】序列图根据<strong>时间序列</strong>展示**<code>对象如何进行协作</code>**。它展示了在用例的特定场景中，对象如何与其他对象交互。</li><li>【目的】通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作</li><li>图中展示了一个线上书店的通讯图，方框和小人表示生命线，不同生命线之间可以传递消息，消息前面的数字可以表达序列顺序。</li></ul><p><img src="/img/23/6.jpg"></p><h3 id="3-13、通讯图（协作图）"><a href="#3-13、通讯图（协作图）" class="headerlink" title="3.13、通讯图（协作图）"></a>3.13、通讯图（协作图）</h3><ul><li>【概念】描述了收发消息的对象的组织关系，强调对象之间的合作关系而不是时间顺序。</li><li>【目的】用来显示<strong>不同对象的关系</strong></li></ul><p><img src="/img/23/7.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 23种设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(三):JVM类加载和对象加载</title>
      <link href="/2021/06/22/JVM/JVM%20(%20%E4%B8%89%20)%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2021/06/22/JVM/JVM%20(%20%E4%B8%89%20)%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1、JVM简介"><a href="#1、JVM简介" class="headerlink" title="1、JVM简介"></a>1、JVM简介</h2><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现<br>（Windows，Linux，macOS），⽬的是使用相同的字节码，它们都会给出相同的结果。</p><blockquote><p>字节码</p></blockquote><p><strong>概念：</strong>JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），只面向虚拟机。</p><p>Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时又保留了解释型语⾔可移植的特点。所以 Java 程序运行时比较高效，同时，由于字节码并不针对⼀种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><h2 id="2、Java程序从源码到执行"><a href="#2、Java程序从源码到执行" class="headerlink" title="2、Java程序从源码到执行"></a>2、Java程序从源码到执行</h2><p><img src="/img/JVM/19.jpg"></p><h2 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h2><p> <strong>语法糖：</strong></p><ul><li>其实就是指 java 编译器把 .java 源码编译为 .class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</li></ul><p><strong>注意：</strong></p><p>以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h3 id="3-1、默认构造器"><a href="#3-1、默认构造器" class="headerlink" title="3.1、默认构造器"></a>3.1、默认构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这个无参构造器是java编译器帮我们加上的</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Candy1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、自动拆装箱"><a href="#3-2、自动拆装箱" class="headerlink" title="3.2、自动拆装箱"></a>3.2、自动拆装箱</h3><p>基本类型和其包装类型的相互转换过程，称为拆装箱，在 JDK 5 以后，它们的转换可以在编译期自动完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Integer x = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> y = x;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转换之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 基本类型赋值给包装类型，称为装箱</span></span><br><span class="line">      Integer x = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 包装类型赋值给基本类型，称谓拆箱</span></span><br><span class="line">      <span class="keyword">int</span> y = x.intValue();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、泛型集合取值"><a href="#3-3、泛型集合取值" class="headerlink" title="3.3、泛型集合取值"></a>3.3、泛型集合取值</h3><p>泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行泛型擦除的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy3</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      list.add(<span class="number">10</span>);</span><br><span class="line">      Integer x = list.get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以调用 get 函数取值时，会有一个类型转换的操作（JDK帮我们自动做的）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer x = (Integer) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>如果要将返回结果赋值给一个 int 类型的变量，则还有自动拆箱的操作</strong></p><p>如果要将返回结果赋值给一个 int 类型的变量，则还有自动拆箱的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = (Integer) list.get(<span class="number">0</span>).intValue();</span><br></pre></td></tr></table></figure><p><strong>但是不是全部都被擦除，可以看到类型被记录了</strong></p><p><img src="/img/JVM/17.jpg"></p><p><strong>通过反射可以获取（只有为参数和返回类型时可以获取）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 拿到方法</span></span><br><span class="line">    Method method = Code_20_ReflectTest.class.getMethod(<span class="string">&quot;test&quot;</span>, List.class, Map.class);</span><br><span class="line">    <span class="comment">// 2. 得到泛型参数的类型信息</span></span><br><span class="line">    Type[] types = method.getGenericParameterTypes();</span><br><span class="line">    <span class="keyword">for</span>(Type type : types) &#123;</span><br><span class="line">        <span class="comment">// 3. 判断参数类型是否，带泛型的类型。</span></span><br><span class="line">        <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 得到原始类型</span></span><br><span class="line">            System.out.println(<span class="string">&quot;原始类型 - &quot;</span> + parameterizedType.getRawType());</span><br><span class="line">            <span class="comment">// 5. 拿到泛型类型</span></span><br><span class="line">            Type[] arguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Integer&gt; <span class="title">test</span><span class="params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-4、可变参数"><a href="#3-4、可变参数" class="headerlink" title="3.4、可变参数"></a>3.4、可变参数</h3><p>可变参数也是 JDK 5 开始加入的新特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy4</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 将 args 赋值给 arr ，可以看出 String... 实际就是 String[]  </span></span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      foo(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy4</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Candy4 &#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      foo(<span class="keyword">new</span> String[]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果调用的是 foo() ，即未传递参数时，等价代码为 foo(new String[]{}) ，创建了一个空数组，而不是直接传递的 null </p><h3 id="3-5、foreach循环"><a href="#3-5、foreach循环" class="headerlink" title="3.5、foreach循环"></a>3.5、foreach循环</h3><ul><li>数组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Candy5 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // 数组赋初值的简化写法也是一种语法糖。</span><br><span class="line">int[] arr = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for(int x : arr) &#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 转换</span><br><span class="line">public class Candy5 &#123;</span><br><span class="line">    public Candy5() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = new int[]&#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for(int i = 0; i &lt; arr.length; ++i) &#123;</span><br><span class="line">int x = arr[i];</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy5</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span> (Integer x : list) &#123;</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合要使用 foreach ，需要该集合类实现了 Iterable 接口，因为集合的遍历需要用到迭代器 Iterator.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy5</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="comment">// 获得该集合的迭代器</span></span><br><span class="line">      Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">         Integer x = iterator.next();</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-6、switch字符串"><a href="#3-6、switch字符串" class="headerlink" title="3.6、switch字符串"></a>3.6、switch字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cnady6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;world&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器的操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Candy6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 通过字符串的 hashCode + value 来判断是否匹配</span></span><br><span class="line">      <span class="keyword">switch</span> (str.hashCode()) &#123;</span><br><span class="line">         <span class="comment">// hello 的 hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">99162322</span> :</span><br><span class="line">            <span class="comment">// 再次比较，因为字符串的 hashCode 有可能相等</span></span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">// world 的 hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">11331880</span> :</span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 用第二个 switch 在进行输出判断</span></span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在编译期间，单个的 switch 被分为了<strong>两个</strong></p><ul><li><p>第一个用来匹配字符串，并给 x 赋值</p><p>字符串的匹配用到了字符串的 hashCode ，还用到了 equals 方法使用 hashCode 是为了提高比较效率，使用 equals 是防止有 hashCode 冲突（如 BM 和 C .）</p></li><li><p>第二个用来根据x的值来决定输出语句</p></li></ul><h3 id="3-7、swtich枚举"><a href="#3-7、swtich枚举" class="headerlink" title="3.7、swtich枚举"></a>3.7、swtich枚举</h3><h3 id="3-8、枚举类"><a href="#3-8、枚举类" class="headerlink" title="3.8、枚举类"></a>3.8、枚举类</h3><p>JDK 7 新增了枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Sex</span>&gt; </span>&#123;   </span><br><span class="line">   <span class="comment">// 对应枚举类中的元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> &#123;       </span><br><span class="line">    <span class="comment">// 调用构造函数，传入枚举元素的值及 ordinal</span></span><br><span class="line">    MALE = <span class="keyword">new</span> Sex(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);    </span><br><span class="line">        FEMALE = <span class="keyword">new</span> Sex(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);   </span><br><span class="line">        $VALUES = <span class="keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用父类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">super</span>(name, ordinal);    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;  </span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Sex.class, name);  </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-9、try-with-resources"><a href="#3-9、try-with-resources" class="headerlink" title="3.9、try-with-resources"></a>3.9、try-with-resources</h3><h3 id="3-10、方法重写时的桥接方法"><a href="#3-10、方法重写时的桥接方法" class="headerlink" title="3.10、方法重写时的桥接方法"></a>3.10、方法重写时的桥接方法</h3><h3 id="3-11、匿名内部类"><a href="#3-11、匿名内部类" class="headerlink" title="3.11、匿名内部类"></a>3.11、匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用匿名内部类创建线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 用额外创建的类来创建匿名内部类对象</span></span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Candy10$<span class="number">1</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个额外的类，实现了 Runnable 接口</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Demo8$<span class="number">1</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用引用局部变量的匿名内部类，源代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123; </span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;ok:&quot;</span> + x); </span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 额外生成的类 </span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> val$x; </span><br><span class="line">Candy11$<span class="number">1</span>(<span class="keyword">int</span> x) &#123; </span><br><span class="line"><span class="keyword">this</span>.val$x = x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;ok:&quot;</span> + <span class="keyword">this</span>.val$x); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Candy11$<span class="number">1</span>(x); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>所以匿名内部类引用局部变量时，局部变量必须是 final 的：</li><li>因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 值后，如果不是 final 声明的，若 x 值发生了改变，匿名内部类则值不一致。</li></ol><h2 id="4、类加载过程"><a href="#4、类加载过程" class="headerlink" title="4、类加载过程"></a>4、类加载过程</h2><h3 id="4-1、加载"><a href="#4-1、加载" class="headerlink" title="4.1、加载"></a>4.1、加载</h3><p>将类的<strong>字节码</strong>载入<strong>方法区</strong>（1.8后为元空间，在本地内存）中，内部采用 <strong><code>C++ 的 instanceKlass</code></strong> 描述 java 类</p><p>它的重要 ﬁeld 有：</p><ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul><p>如果这个类还有父类没有加载，先加载父类</p><p><strong>加载和链接可能是交替运行的</strong><br><img src="/img/JVM/18.jpg"></p><ul><li>instanceKlass保存在方法区。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<code>堆内存</code>中</li><li>instanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h3 id="4-2、链接"><a href="#4-2、链接" class="headerlink" title="4.2、链接"></a>4.2、链接</h3><p><strong>验证</strong></p><ul><li>验证类是否符合 JVM规范，安全性检查</li><li>用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行</li></ul><p><strong>准备</strong></p><ul><li>为 static 变量分配空间，设置默认值</li></ul><p><strong>注意：</strong></p><ul><li>static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾</li><li>static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，**<code>赋值在初始化阶段完成</code>**</li><li>如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li><li>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成将常量池中的符号引用解析为直接引用</li></ul><h3 id="4-3、初始化"><a href="#4-3、初始化" class="headerlink" title="4.3、初始化"></a>4.3、初始化</h3><p><strong>&lt; clinit &gt;()v 方法</strong></p><ul><li>初始化即调用 &lt; clinit &gt;()V ，虚拟机会保证这个类的『构造方法』的线程安全</li></ul><p><strong>作用：</strong></p><ul><li>为静态变量赋予初始值</li><li>执行静态代码块</li></ul><p><strong>发生的时机</strong></p><ul><li>概括得说，类初始化是【懒惰的】</li></ul><p><strong>会导致类初始化的情况（类的主动引用）</strong></p><ul><li>虚拟机启动时，先初始化main方法所在类</li><li>new类对象</li><li>对类进行反射</li><li>首次调用类的<code>静态成员和方法</code>(final 常量除外)</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>初始化一个类时，若其父类没有被初始化，会先初始化其父类</li></ul><p><strong>不会导致类初始化的情况（类的被动使用）</strong></p><ul><li><p>访问静态域时，只有真正声明的这个域的类才会被初始化</p><p>如子类引用父类的静态变量，子类不会初始化</p></li><li><p>通过数组定义类引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Son[] array = <span class="keyword">new</span> Son[<span class="number">5</span>];  <span class="comment">//Son为一个类</span></span><br></pre></td></tr></table></figure></li><li><p>引用常量(常量在链接阶段就存入调用类的常量池中了)</p></li><li><p>类对象.class 不会触发初始化</p></li></ul><h2 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h2><h3 id="5-1、简介"><a href="#5-1、简介" class="headerlink" title="5.1、简介"></a>5.1、简介</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，<strong>只要加载它们的类加载器不同，那这两个类就必定不相等</strong>！</p><p><strong>作用：</strong></p><p>​        将class文件字节码内容加载到内存中，并把静态数据转化成方法区的运行时数据结构，然后再<code>堆</code>中生成一个代表这个类的java.lang.Class对象作为方法区中类数据的访问入口。</p><p>​        <strong>总而言之，就是把JVM编译的class文件加载到内存并且生成一个class对象便于访问</strong></p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>AVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，显示为null</td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>classpath    上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>自定义    上级为Application</td></tr></tbody></table><p><strong>启动类的加载器</strong></p><ul><li>可通过在控制台输入指令，使得类被启动类加器加载</li></ul><p><strong>扩展类的加载器</strong></p><ul><li>如果 classpath 和 JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。</li></ul><h3 id="5-2、双亲委派机制"><a href="#5-2、双亲委派机制" class="headerlink" title="5.2、双亲委派机制"></a>5.2、双亲委派机制</h3><p><strong>概述：</strong></p><ol><li>类加载器**<code>需要加载类时</code>**，会调用应用程序/拓展类加载器，向上委托父类加载器，直到根加载器。</li><li>根加载器寻找有没有需要加载的类，能加载结束，没有则抛出异常通知子类加载，</li><li>重复步骤②，</li></ol><p>优点1：自定义String类会报错，可以保护系统核心类</p><p>优点2：避免全限定命名的类重复加载</p><h3 id="5-3、线程上下文加载器"><a href="#5-3、线程上下文加载器" class="headerlink" title="5.3、线程上下文加载器"></a>5.3、线程上下文加载器</h3><p>线程上下文加载器会打破双亲委派机制</p><ol><li>Java存在第三方接口（SPI），属于核心库，在rt.jar包中，需要根类加载去加载</li><li>而这些接口的实现，常见的比如JDBC一般存放在ClassPath路径下，</li><li>SPI需要调用第三方包，但是SPI是通过根加载器去加载的，显然按照双亲委派机制，已经是根加载器就无法向上托管了，<strong>这种情况就只能通过线程上下文加载器去加载了</strong>。</li></ol><h3 id="5-4、自定义类加载器"><a href="#5-4、自定义类加载器" class="headerlink" title="5.4、自定义类加载器"></a>5.4、自定义类加载器</h3><p><strong>使用场景</strong></p><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><p><strong>步骤</strong></p><ul><li><p>继承 ClassLoader 父类</p></li><li><p>要遵从双亲委派机制，重写 ﬁndClass 方法</p><p>如果重写 loadClass 方法，就不会走双亲委派机制</p></li><li><p>读取类文件的字节码</p></li><li><p>调用父类的 deﬁneClass 方法来加载类</p></li><li><p>使用者调用该类加载器的 loadClass 方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Demo2 demo2 = <span class="keyword">new</span> Demo2();</span><br><span class="line">        demo2.loadClass(<span class="string">&quot;要加载的类名&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String s) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 定义路径</span></span><br><span class="line">            String path = <span class="string">&quot;路径&quot;</span>+s+<span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            Files.copy(Paths.get(path),os);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = os.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> defineClass(s,bytes,<span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;未找到类加载器&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>破坏双亲委派模式</strong></p><ol><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<br>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<br>如果有**<code>基础类型又要调用回用户的代码</code>**，此时也会破坏双亲委派模式</li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<br>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ol><h2 id="6、对象创建的过程"><a href="#6、对象创建的过程" class="headerlink" title="6、对象创建的过程"></a>6、对象创建的过程</h2><h3 id="6-1、类加载检查"><a href="#6-1、类加载检查" class="headerlink" title="6.1、类加载检查"></a>6.1、类加载检查</h3><p>虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在常量池中定位到<code>这个类的符号引⽤</code>，并且检查这个符号引⽤代表的类<code>是否已被加载过、解析和初始化过</code>。如果没有，那必须先执⾏相应的类加载过程。</p><h3 id="6-2、分配内存"><a href="#6-2、分配内存" class="headerlink" title="6.2、分配内存"></a>6.2、分配内存</h3><p>虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定大小的内存从 Java 堆中划分出来。有两种分配方式，根据Java内存是否整齐来决定，取决于GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p><ul><li>指针碰撞：整理内存，把没有的内存整理到一起，再分配内存</li><li>空闲列表：虚拟机维护一个列表，记录哪些位置可用，分配内存</li></ul><blockquote><p>内存分配并发问题</p></blockquote><p>作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用<code>两种方式</code>一起来保证线程安全</p><ul><li>TLAB：为每⼀个线程预先在 Eden 区分配⼀块⼉内存，JVM 在给线程中的对象分配内存时，首先先在 TLAB 分配，当对象⼤于 TLAB 中的剩余内存或 TLAB 的内存已⽤尽时，使用上述的 CAS 进行内存分配</li><li>CAS + 失败重试</li></ul><h3 id="6-3、初始化零值"><a href="#6-3、初始化零值" class="headerlink" title="6.3、初始化零值"></a>6.3、初始化零值</h3><h3 id="6-4、设计对象头"><a href="#6-4、设计对象头" class="headerlink" title="6.4、设计对象头"></a>6.4、设计对象头</h3><p>这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄、偏向锁信息等，这些信息存放在对象头中。</p><h3 id="6-5、执行init方法"><a href="#6-5、执行init方法" class="headerlink" title="6.5、执行init方法"></a>6.5、执行init方法</h3><p>把对象按照程序员的意愿进行初始化</p><h2 id="7、对象访问的定位方式"><a href="#7、对象访问的定位方式" class="headerlink" title="7、对象访问的定位方式"></a>7、对象访问的定位方式</h2><p>对象的访问方式有虚拟机实现而定，⽬前主流的访问方式有使⽤<strong>句柄、直接指针</strong>两种：</p><ul><li>句柄：Java堆中将会划分出⼀块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li><li>直接指针： Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(二):垃圾回收</title>
      <link href="/2021/06/22/JVM/JVM%20(%20%E4%BA%8C%20)%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2021/06/22/JVM/JVM%20(%20%E4%BA%8C%20)%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1、判断对象可以回收"><a href="#1、判断对象可以回收" class="headerlink" title="1、判断对象可以回收"></a>1、判断对象可以回收</h2><h3 id="1-1、引用计数法"><a href="#1-1、引用计数法" class="headerlink" title="1.1、引用计数法"></a>1.1、引用计数法</h3><p>当一个对象<strong>被引用时</strong>，就当引用对象的值加一，当值为 0 时，就表示该对象不被引用，可以被垃圾收集器回收。</p><p><strong>缺陷：</strong>循环引用时，两个对象的计数都为1，导致两个对象都无法被释放。</p><p><img src="/img/JVM/9.jpg"></p><h3 id="1-2、可达性分析算法"><a href="#1-2、可达性分析算法" class="headerlink" title="1.2、可达性分析算法"></a>1.2、可达性分析算法</h3><p>扫描堆中的对象，看能否沿着 GC Root 对象为起点的引用链找到该对象，如果找不到，则表示可以回收</p><p><strong>GC Root 对象</strong>：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的Native方法）引用的对象</li></ul><h3 id="1-3、如何判断⼀个常量是废弃常量"><a href="#1-3、如何判断⼀个常量是废弃常量" class="headerlink" title="1.3、如何判断⼀个常量是废弃常量"></a>1.3、如何判断⼀个常量是废弃常量</h3><p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p><h3 id="1-4、-如何判断⼀个类是无用的类"><a href="#1-4、-如何判断⼀个类是无用的类" class="headerlink" title="1.4、 如何判断⼀个类是无用的类"></a>1.4、 如何判断⼀个类是无用的类</h3><p>满足下面3个条件，可能被回收，不是一定</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地⽅被引⽤，⽆法在任何地⽅通过反射访问该类的方法。</li></ul><h3 id="1-5、四种引用"><a href="#1-5、四种引用" class="headerlink" title="1.5、四种引用"></a>1.5、四种引用</h3><p><img src="/img/JVM/10.jpg"></p><ol><li><strong>强引用</strong>：宁愿抛出OOM异常也不会被回收，除非不再被强引用</li><li><strong>软引用</strong>（SoftReference）：在垃圾回收后，**<code>内存仍不足时</code>**会被回收。实现对内存敏感的高速缓存。</li><li><strong>弱引用</strong>（WeakReference）：在垃圾回收时，无论内存是否充足，都会回收弱引用对象。</li><li><strong>虚引用</strong>（PhantomReference）：如果⼀个对象仅持有虚引用，那么它就和没有任何引用⼀样，在任何时候都可能被回收；虚引用必须配合引用队列使用，主要配合 ByteBuffer 使用，<strong>被引用对象回收时</strong>，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法<strong>释放</strong>直接内存</li></ol><p><strong>注意点：</strong></p><ul><li>软引用、弱引用、虚引用都可以和⼀个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加⼊到与之关联的引⽤队列中。</li><li>在程序设计中⼀般很少使用弱引用与虚引用，使用软引用的情况多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出OOM等问题的产⽣。</li></ul><p><strong>终结器引用</strong>（FinalReference）：无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</p><h2 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h2><h3 id="2-1、标记清除算法"><a href="#2-1、标记清除算法" class="headerlink" title="2.1、标记清除算法"></a>2.1、标记清除算法</h3><ol><li>标记：把需要清除的垃圾标记起来</li><li>清除：定义一张表，记录垃圾占用空间的<strong>首地址</strong>和<strong>尾地址</strong>，这些空间下次就可以继续分配</li></ol><p>优点：速度快</p><p>缺点：会产生内存碎片</p><p><img src="/img/JVM/11.jpg"></p><h3 id="2-2、标记整理"><a href="#2-2、标记整理" class="headerlink" title="2.2、标记整理"></a>2.2、标记整理</h3><ol><li>标记：把需要清除的垃圾标记起来</li><li>整理：把垃圾清除后，再把剩余的空间整理，确保没有内存碎片</li></ol><p>缺点：速度慢</p><p>优点：没有内存碎片</p><p><img src="/img/JVM/12.jpg"></p><h3 id="2-3、复制"><a href="#2-3、复制" class="headerlink" title="2.3、复制"></a>2.3、复制</h3><ol><li>标记：把需要清除的垃圾标记起来</li><li>复制：把from的区域的存活的对象全部复制到to区域</li><li>交换：复制完后，to区变成原来的from区，from区变为to区</li></ol><p>优点：没有内存的碎片</p><p>缺点：浪费内存空间，一半空间永远为空</p><p><img src="/img/JVM/13.jpg"></p><h2 id="3、分代垃圾回收算法"><a href="#3、分代垃圾回收算法" class="headerlink" title="3、分代垃圾回收算法"></a>3、分代垃圾回收算法</h2><h3 id="3-1、堆内存介绍及算法"><a href="#3-1、堆内存介绍及算法" class="headerlink" title="3.1、堆内存介绍及算法"></a>3.1、堆内存介绍及算法</h3><p><img src="/img/JVM/14.jpg"></p><p><strong>特点：</strong>新生代采用复制算法，老年代采用标记整理算法，提高效率</p><p><strong>新生代：</strong>有伊甸园区、幸存区</p><ol><li>新创建的对象首先分配在 eden 区</li><li>新生代空间不足时，触发 minor gc（轻GC） ，eden 区 和 from 区存活的对象使用 <strong><code>复制算法</code></strong> 复制到 to 中，存活的对象年龄加一，然后交换 from to区</li><li>minor gc（轻GC）会引发 stop the world，暂停其他线程，等垃圾回收结束后，恢复用户线程运行</li><li>当幸存区对象的寿命超过阈值时，会晋升到老年代，最大的寿命是 15（4bit）</li><li>当老年代空间不足时，会先触发 minor gc（轻GC），如果空间仍然不足，那么就触发 full fc （重GC），停止的时间更长！</li></ol><p><strong>老年代：</strong>当幸存区对象的寿命超过阈值时，会晋升到老年代</p><p><strong>永久代：</strong>常驻内存，存java运行时的环境，<strong>不存在垃圾回收</strong>，虚拟机关闭时释放</p><ul><li>JDK6之前，叫永久代，常量池在方法区</li><li>JDK7时，  叫永久代，但是慢慢退化，去永久代，常量池在堆中</li><li>JDK8之后，无永久代，常量池还在堆里，方法区在元空间里</li></ul><blockquote><p>分配担保机制</p></blockquote><p>当新生代几乎全部被分配完的时候，会发生轻GC，如果此时需要分配内存空间给对象，但是空间有不足，就会提前把新生代的转移到老年代中</p><blockquote><p>大对象直接进入老年代</p></blockquote><p>字符串、数组等，为了避免为⼤对象分配内存时由于分配担保机制带来的复制⽽降低效率。</p><blockquote><p>Hotsopt 更新阈值</p></blockquote><p>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的⼀半时，取这个年龄和MaxTenuringThreshold 中更小的⼀个值，作为新的晋升年龄阈值</p><p>Hotsopt 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的⼀半时，取这个年龄和MaxTenuringThreshold 中更小的⼀个值，作为新的晋升年龄阈值</p><h3 id="3-2、JVM参数"><a href="#3-2、JVM参数" class="headerlink" title="3.2、JVM参数"></a>3.2、JVM参数</h3><p>堆初始大小：-Xms<br>堆最大大小：-Xmx 或 -XX:MaxHeapSize=size<br>新生代大小：-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )<br>幸存区比例：   -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy<br>幸存区比例：    -XX:SurvivorRatio=ratio<br>晋升阈值：    -XX:MaxTenuringThreshold=threshold<br>晋升详情：    -XX:+PrintTenuringDistribution<br>GC详情：                      -XX:+PrintGCDetails -verbose:gc<br>FullGC 前 MinorGC：    -XX:+ScavengeBeforeFullGC</p><h3 id="3-3、测试"><a href="#3-3、测试" class="headerlink" title="3.3、测试"></a>3.3、测试</h3><p>public class Code_10_GCTest {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _512KB = <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _6MB = <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _7MB = <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _8MB = <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_6MB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_512KB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_6MB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_512KB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_6MB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h2><h3 id="4-1、串行"><a href="#4-1、串行" class="headerlink" title="4.1、串行"></a>4.1、串行</h3><ul><li>单线程</li><li>堆内存较少，适合个人电脑</li></ul><h3 id="4-2、吞吐量优先"><a href="#4-2、吞吐量优先" class="headerlink" title="4.2、吞吐量优先"></a>4.2、吞吐量优先</h3><ul><li>多线程</li><li>堆内存较大，多核 cpu</li><li>让单位时间内，STW 的时间最短 0.2 0.2 = 0.4</li></ul><h3 id="4-3、响应时间优先"><a href="#4-3、响应时间优先" class="headerlink" title="4.3、响应时间优先"></a>4.3、响应时间优先</h3><ul><li>多线程</li><li>堆内存较大，多核 cpu</li><li>尽可能让 STW 的单次时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5</li></ul><h3 id="4-4、G1回收器"><a href="#4-4、G1回收器" class="headerlink" title="4.4、G1回收器"></a>4.4、G1回收器</h3><p><strong>定义：</strong> Garbage First</p><p><strong>适用场景：</strong></p><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域</li><li>整体上是标记-整理算法，两个区域之间是复制算法</li></ul><p><strong>相关参数：</strong></p><ul><li>JDK8 并不是默认开启的，所需要参数开启</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br><span class="line">-XX:G1HeapRegionSize=size</span><br><span class="line">-XX:MaxGCPauseMillis=time</span><br></pre></td></tr></table></figure><h4 id="G1-垃圾回收阶段"><a href="#G1-垃圾回收阶段" class="headerlink" title="G1 垃圾回收阶段"></a>G1 垃圾回收阶段</h4><p><img src="/img/JVM/15.jpg"></p><ul><li>Young Collection：对新生代垃圾收集</li><li>Young Collection + Concurrent Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。</li><li>Mixed Collection：会对新生代 + 老年代 + 幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(一):内存结构</title>
      <link href="/2021/06/22/JVM/JVM%20(%20%E4%B8%80%20)%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2021/06/22/JVM/JVM%20(%20%E4%B8%80%20)%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><ul><li>栈、本地方法栈、程序计数器100%不会有垃圾</li><li>JVM调优99%在调整堆(方法区属于特殊的堆)</li><li>一般插件都是在执行引擎上动手脚</li></ul><p><img src="/img/JVM/1.jpg"></p><p><strong>Program Counter Register 程序计数器（寄存器）</strong></p><p><strong>作用：</strong></p><ul><li>每条JVM指令都会交给JVM解释器，解释器把字节码变成机器码，让CPU执行，然后此时<code>下一条 jvm 指令的执行地址行号</code>会被放入程序计数器中，然后解释器根据地址去取指令并执行。</li><li>多线程的环境下，如果两个线程发生了上下文切换，那么程序计数器会记录线程下一条指令的地址行号，以便线程切换回来继续执行命令。</li><li>总而言之，程序计数器就是存放<strong>JVM下一条指令的地址</strong>，特殊的：执行本地方法时，无法定位地址</li></ul><p><strong>特点：</strong></p><ul><li>是线程<strong>私有</strong>的，每个程序有自己的程序计数器</li><li>JVM中<code>唯一一个</code>不会存在内存溢出</li></ul><p><strong>实现方式：</strong></p><ul><li>通过<code>寄存器</code>来实现的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左边是JVM指令(二进制字节码)      右边是Java源代码</span></span><br><span class="line"><span class="number">0</span>: getstatic #<span class="number">20</span>        <span class="comment">// PrintStream out = System.out; </span></span><br><span class="line"><span class="number">3</span>: astore_1             <span class="comment">// -- </span></span><br><span class="line"><span class="number">4</span>: aload_1              <span class="comment">// out.println(1); </span></span><br><span class="line"><span class="number">5</span>: iconst_1             <span class="comment">// -- </span></span><br><span class="line"><span class="number">6</span>: invokevirtual #<span class="number">26</span>    <span class="comment">// -- </span></span><br><span class="line"><span class="number">9</span>: aload_1              <span class="comment">// out.println(2); </span></span><br><span class="line"><span class="number">10</span>: iconst_2            <span class="comment">// -- </span></span><br><span class="line"><span class="number">11</span>: invokevirtual #<span class="number">26</span>   <span class="comment">// -- </span></span><br><span class="line"><span class="number">14</span>: aload_1             <span class="comment">// out.println(3); </span></span><br><span class="line"><span class="number">15</span>: iconst_3            <span class="comment">// -- </span></span><br><span class="line"><span class="number">16</span>: invokevirtual #<span class="number">26</span>   <span class="comment">// -- </span></span><br><span class="line"><span class="number">19</span>: aload_1             <span class="comment">// out.println(4); </span></span><br><span class="line"><span class="number">20</span>: iconst_4            <span class="comment">// -- </span></span><br><span class="line"><span class="number">21</span>: invokevirtual #<span class="number">26</span>   <span class="comment">// -- </span></span><br><span class="line"><span class="number">24</span>: aload_1             <span class="comment">// out.println(5); </span></span><br><span class="line"><span class="number">25</span>: iconst_5            <span class="comment">// -- </span></span><br><span class="line"><span class="number">26</span>: invokevirtual #<span class="number">26</span>   <span class="comment">// -- </span></span><br><span class="line"><span class="number">29</span>: <span class="keyword">return</span></span><br><span class="line"><span class="comment">//     </span></span><br></pre></td></tr></table></figure><h2 id="2、虚拟机栈（线程运行时需要的内存空间）"><a href="#2、虚拟机栈（线程运行时需要的内存空间）" class="headerlink" title="2、虚拟机栈（线程运行时需要的内存空间）"></a>2、虚拟机栈（线程运行时需要的内存空间）</h2><h3 id="2-1、定义"><a href="#2-1、定义" class="headerlink" title="2.1、定义"></a>2.1、定义</h3><p><strong>概念：</strong></p><ul><li>每个线程运行需要的内存空间，称为虚拟机栈，栈是**<code>私有</code>**的</li><li>每个栈由多个栈帧（Frame）组成，对应着每次<code>调用方法</code>时所占用的内存（参数、变量等）</li><li>每个线程只能有一个<code>活动栈帧</code>，对应着当前正在执行的<code>方法</code>，每⼀次函数调用都会有⼀个对应的栈帧被压⼊ Java 栈，每⼀个函数调⽤结束后（或抛出异常导致结束），都会有⼀个栈帧被弹出</li><li>先进后出，main方法最先执行，最晚结束</li></ul><p><strong>栈帧的信息：</strong>局部变量表(编译期可知的各种基本数据类型、对象引用)、操作数栈、动态链接、⽅法出⼝信息。</p><p><img src="/img/JVM/2.jpg"></p><h3 id="2-2、几个问题"><a href="#2-2、几个问题" class="headerlink" title="2.2、几个问题"></a>2.2、几个问题</h3><ol><li><p>垃圾回收是否涉及栈内存？</p><ul><li>不会。栈内存是<strong>方法调用</strong>产生的，方法调用结束后会弹出栈。</li></ul></li><li><p>栈内存分配越大越好吗？</p><ul><li>不是，栈内存越大，每个线程的栈就越大，但是可执行的线程数就会越少。</li></ul></li><li><p>方法内的局部变量是否线程安全？</p><ul><li><p>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的</p></li><li><p>如果是局部变量引用了对象，<strong>并逃离了方法的访问</strong>（其他线程也能访问到），就要考虑线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">// 这样不会导致线程安全，因为只在线程内部有效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不安全的几种情况</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">// 静态变量被多个线程共享，导致线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(StringBuilder sb)</span></span>&#123; </span><br><span class="line">    <span class="comment">// 引用外部的对象，不安全</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 返回值可能被其他线程获取到修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="2-3、线程溢出"><a href="#2-3、线程溢出" class="headerlink" title="2.3、线程溢出"></a>2.3、线程溢出</h3><ul><li>栈帧太多（如无限递归，java.lang.StackOverflowError）</li><li>栈帧太大（一般不太可能发生）</li></ul><h3 id="2-4、线程运行诊断"><a href="#2-4、线程运行诊断" class="headerlink" title="2.4、线程运行诊断"></a>2.4、线程运行诊断</h3><p><strong>案例一：cpu 占用过多</strong></p><p><strong>描述：</strong>Linux 环境下运行某些程序的时候，可能导致 CPU 的占用过高，这时需要定位占用 CPU 过高的线程</p><ol><li>输入 top 命令，查看是哪个进程占用 CPU 过高</li><li>输入 ps H -eo pid, tid, %cpu | grep 加进程号（刚刚的进程号）可以过滤进程</li><li>输入 jstack 进程 id  ，即可显示java的线程信息</li><li>刚才通过 ps 命令看到的 tid 来对比定位，注意 jstack 查找出的线程 id 是 16 进制的，需要转换。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、 top   // 会显示进程这里假设是 32655 进制占用CPU过高</span><br><span class="line">2、 ps H -eo pid, tid, %cpu | grep 32655   // 查看进行信息,假设 32665进程占用过高</span><br><span class="line">3、 jstack 32665 // 获取java的线程信息</span><br><span class="line">4、 根据线程号32665比对线程找出，先换成16进制，找出错误所在</span><br></pre></td></tr></table></figure><p><img src="/img/JVM/3.jpg"></p><p><strong>案例二：线程很长时间未响应</strong></p><p>同上，排查异常情况</p><h3 id="2-5、本地方法栈"><a href="#2-5、本地方法栈" class="headerlink" title="2.5、本地方法栈"></a>2.5、本地方法栈</h3><p><img src="/img/JVM/4.jpg"></p><p>调用<strong>本地方法</strong>时需要使用本地方法栈</p><p>本地方法：native修饰的方法，底层调用的是C/C++方法等</p><h2 id="3、堆"><a href="#3、堆" class="headerlink" title="3、堆"></a>3、堆</h2><h3 id="3-1、定义："><a href="#3-1、定义：" class="headerlink" title="3.1、定义："></a>3.1、定义：</h3><p><strong>Heap 堆</strong></p><ul><li>通过new关键字创建的对象都会被放在堆中，在堆里面分配内存。</li></ul><p><strong>特点</strong></p><ul><li>它是所有<code>线程共享</code>，堆内存中的对象都需要考虑<code>线程安全</code>问题</li><li>有垃圾回收机制</li></ul><p><strong>注意：</strong>从jdk 1.7开始已经默认开启逃逸分析，如果某些⽅法中的对象引⽤没有被返回或者未被外⾯使⽤（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p><h3 id="3-2、堆内存溢出"><a href="#3-2、堆内存溢出" class="headerlink" title="3.2、堆内存溢出"></a>3.2、堆内存溢出</h3><p><strong>OOM错误：</strong></p><ul><li>java.lang.OutOfMemoryError: Java heap space  堆内存满了，堆内存不够</li><li>即 新生区 + 老年区 大小等于总堆内存</li></ul><p><strong>默认情况：</strong>JVM分配总内存为电脑四分之一，初始化的内存为六十四分之一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> max = Runtime.getRuntime().maxMemory();</span><br><span class="line"><span class="keyword">long</span> total = Runtime.getRuntime().totalMemory();</span><br><span class="line">System.out.println((<span class="keyword">double</span>)max/<span class="number">1024</span>/<span class="number">1024</span>);</span><br><span class="line">System.out.println((<span class="keyword">double</span>)total/<span class="number">1024</span>/<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p><strong>修改堆空间大小：</strong>-Xmx1024m 指定大小</p><p>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</p><p><img src="/img/JVM/5.jpg"></p><h3 id="3-3、堆内存诊断"><a href="#3-3、堆内存诊断" class="headerlink" title="3.3、堆内存诊断"></a>3.3、堆内存诊断</h3><ol><li>jps 工具：查看当前系统中有哪些 java 进程</li><li>jmap 工具：查看堆内存占用情况 jmap - heap 进程id</li><li>jconsole 工具：图形界面的，多功能的监测工具，可以连续监测</li><li>jvisualvm 工具：</li></ol><h3 id="3-4、垃圾回收"><a href="#3-4、垃圾回收" class="headerlink" title="3.4、垃圾回收"></a>3.4、垃圾回收</h3><p>垃圾回收主要发生在堆里，因为几乎所有的对象都在堆中分配。</p><h2 id="4、方法区："><a href="#4、方法区：" class="headerlink" title="4、方法区："></a>4、方法区：</h2><h3 id="4-1、定义"><a href="#4-1、定义" class="headerlink" title="4.1、定义"></a>4.1、定义</h3><ol><li><p>方法区被所有 Java 虚拟机线程之间**<code>共享</code>**的方法区域。</p></li><li><p>它存储每个<strong>类的结构</strong>，常量、静态变量、即时编译器编译后的代码等数据</p></li><li><p>方法区域是在**<code>虚拟机启动时</code>**创建的。</p></li><li><p>尽管方法区域<strong>在逻辑上是堆的一部分</strong>，但是并不强制要求，而且名字也叫做<strong>非堆</strong>。</p></li><li><p><strong>HotSpot</strong>（其他不一定）使用永久代实现方法区，在JDK1.8时移除，采用**<code>元空间</code>**实现（不再占用堆的空间，在本地内存占用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整个永久代有⼀个 JVM 本身设置固定⼤⼩上限，⽆法进⾏调整，⽽元空间使⽤的是直接内存，受本机可⽤内存的限制，虽然元空间仍旧可能溢出，但是⽐原来出现的⼏率会更⼩。</span><br><span class="line"><span class="comment">// 元空间溢出仍然是OOM，因为逻辑上是堆的一部分</span></span><br></pre></td></tr></table></figure></li><li><p>也存在垃圾回收，但是较少可以忽略</p></li></ol><p><img src="/img/JVM/6.jpg"></p><h3 id="4-2、方法区内存溢出"><a href="#4-2、方法区内存溢出" class="headerlink" title="4.2、方法区内存溢出"></a>4.2、方法区内存溢出</h3><ul><li>1.8 之前会导致**<code>永久代</code>**内存溢出<ul><li>使用 -XX:MaxPermSize=8m 指定永久代内存大小</li></ul></li><li>1.8 之后会导致**<code>元空间</code>**内存溢出<ul><li>使用 -XX:MaxMetaspaceSize=8m 指定元空间大小</li></ul></li></ul><h3 id="4-3、各种常量池剖析"><a href="#4-3、各种常量池剖析" class="headerlink" title="4.3、各种常量池剖析"></a>4.3、各种常量池剖析</h3><p><strong>常量池：</strong>每个class文件都有类的基本信息，<code>常量池</code>、类方法定义、虚拟机指令等信息，常量池用于存放编译期间生成的各种字面量和符号引用。</p><p><strong>运行时常量池：</strong>程序运行到某个类时，即类加载到方法区时，<code>Class文件的信息</code>就会被解析到内存的<code>方法区</code>中的运行时常量池，因此每个类都有一个运行时常量池。加载之后，运行时常量池自然获得了常量池的各种信息。</p><p><strong>字符串常量池：</strong>JDK7之前在方法区的运行时常量池中，JDK7开始<strong>被单独拿到堆</strong>；当类加载的时候，常量池的字符串文本就会加载进入字符串常量池中</p><p><strong>原因：</strong>方法区的永久代回收要等到FullGC，频率太低，所以容易导致内存不够用。</p><p>注意：</p><ul><li>运行时常量池自始至终在方法区，JDK7在方法区（堆），JDK8在元空间</li><li>字符串常量池JDK7之前在方法区的运行时常量池，JDK7开始单独放到堆中</li></ul><h3 id="4-4、StringTable字符串常量池"><a href="#4-4、StringTable字符串常量池" class="headerlink" title="4.4、StringTable字符串常量池"></a>4.4、StringTable字符串常量池</h3><p><strong>存储</strong></p><ul><li>字符串用**<code>哈希表</code>**存储</li><li>常量池的信息加载到字符串常量池，不过开始仅是符号，**<code>只有用到时才会转化为对象</code>**</li></ul><p><strong>创建字符串：</strong></p><ul><li><p>字面量创建字符串时，对象指向的是字符串常量池里的对象</p></li><li><p>new方法创建或者拼接字符串变量时，对象指向的是堆里的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;a&quot;</span>;  <span class="comment">//此时创建1个对象，放在常量池中</span></span><br><span class="line">String s2 = <span class="string">&quot;a&quot;</span>;  <span class="comment">//此时创建0个对象，指向s1</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>); <span class="comment">// 此时创建2个对象，先在常量池中创建，再在堆创建</span></span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>); <span class="comment">// 此时创建1个对象，在堆创建,常量池已经存在</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>字符串拼接：</strong></p><ul><li>字符串变量拼接的原理是**<code>StringBuilder</code>**，所以结果在堆里</li><li>字符串常量拼接的原理是**<code>编译器优化</code>**，所以结果在常量池里</li></ul><p><strong>intern方法（1.8）：</strong>假设 字符串str调用</p><ul><li>若字符串常量池中没有a，就会**<code>添加到常量池</code>**中，返回常量池的对象</li><li>若字符串常量池中有a，就会**<code>添加失败</code>**，不过仍然返回常量池的对象</li></ul><p><strong>intern方法（1.6）：</strong>假设 字符串str调用</p><ul><li><p>添加成功，会创建新对象放入常量池</p><p><strong>注意：</strong>intern不会改变原对象，只是会返回常量池的对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// StringTable&#123;&quot;a&quot; ,&quot;b&quot;,&quot;ab&quot; &#125; 哈希表结构，不能扩容</span></span><br><span class="line"><span class="comment">// 常量池中的信息，都会被加载到运行时常量池，不过字符串默认都是符号，还不是String对象</span></span><br><span class="line"></span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;  <span class="comment">// 当调用该行代码时，若不存在字面量“a”，才会创建String对象</span></span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2;   <span class="comment">// 字符串变量拼接的原理是StringBuilder</span></span><br><span class="line">        <span class="comment">// String s4 = new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString();</span></span><br><span class="line">        <span class="comment">// toString方法  等于 new String(&quot;ab&quot;)</span></span><br><span class="line">        String s5 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;      <span class="comment">// 字符串常量拼接的原理是编译器优化</span></span><br><span class="line">                                    <span class="comment">// 因为&quot;a&quot; &quot;b&quot;是确定的，而s1 s2 不确定</span></span><br><span class="line">        System.out.println(s3==s4); <span class="comment">// false s3是常量池 ，s4在堆中</span></span><br><span class="line">        System.out.println(s3==s5); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s3==s4.intern());<span class="comment">// 1.8是true intern()方法会放到常量池中</span></span><br><span class="line">System.out.println(s3==s4);  <span class="comment">// false 注意intern不会改变原对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 还需注意一点</span></span><br><span class="line">        String x1 = <span class="keyword">new</span> String(<span class="string">&quot;A&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        x1.intern();</span><br><span class="line">        String x2 = <span class="string">&quot;AB&quot;</span>;</span><br><span class="line">        System.out.println(x1 == x2);   </span><br><span class="line">        <span class="comment">// 此时返回true，因为x1对象成功放到了常量池，所以此时常量池和堆中的对象是同一个</span></span><br><span class="line">        <span class="comment">// 注意1.6也为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5、StringTable垃圾回收"><a href="#4-5、StringTable垃圾回收" class="headerlink" title="4.5、StringTable垃圾回收"></a>4.5、StringTable垃圾回收</h3><p>-Xmx10m 指定堆内存大小<br>-XX:+PrintStringTableStatistics 打印字符串常量池信息<br>-XX:+PrintGCDetails<br>-verbose:gc 打印 gc 的次数，耗费时间等信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 StringTable 垃圾回收</span></span><br><span class="line"><span class="comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_05_StringTableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123; <span class="comment">// j = 100, j = 10000</span></span><br><span class="line">                String.valueOf(j).intern();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6、StringTable性能调优"><a href="#4-6、StringTable性能调优" class="headerlink" title="4.6、StringTable性能调优"></a>4.6、StringTable性能调优</h3><p><strong>一：</strong>上面说过StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=桶个数（最少设置为 <span class="number">1009</span> 以上）</span><br></pre></td></tr></table></figure><p><strong>二：</strong>可以通过 intern 方法减少重复入池</p><h2 id="5、直接内存"><a href="#5、直接内存" class="headerlink" title="5、直接内存"></a>5、直接内存</h2><h3 id="5-1、定义"><a href="#5-1、定义" class="headerlink" title="5.1、定义"></a>5.1、定义</h3><ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>由系统直接管理，不受 JVM 内存回收管理，但是仍然可能导致OOM</li></ul><h3 id="5-2、直接内存的优点"><a href="#5-2、直接内存的优点" class="headerlink" title="5.2、直接内存的优点"></a>5.2、直接内存的优点</h3><p><strong>文件读写流程</strong></p><p><img src="/img/JVM/7.jpg"></p><p>因为 java 不能直接操作文件管理，需要切换到内核态，使用本地方法进行操作，然后读取磁盘文件，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区， 然后在将系统缓冲区数据，复制到 java 堆内存中。缺点是数据存储了两份，在系统内存中有一份，java 堆中有一份，造成了不必要的复制</p><p><strong>使用了 DirectBuffer 文件读取流程</strong></p><p>直接内存是操作系统和 Java 代码**<code>都可以访问</code>**的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率</p><p><img src="/img/JVM/8.jpg"></p><h3 id="5-3、直接内存的内存回收"><a href="#5-3、直接内存的内存回收" class="headerlink" title="5.3、直接内存的内存回收"></a>5.3、直接内存的内存回收</h3><ul><li>使用了 Unsafe 类来完成直接内存的分配回收，回收需要主动调用freeMemory 方法</li><li>ByteBuffer 的实现内部使用了 Cleaner（虚引用）来检测 ByteBuffer 。一旦ByteBuffer 被垃圾回收，那么会由 ReferenceHandler（守护线程） 来调用 Cleaner 的 clean 方法调用 freeMemory 来释放内存</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE知识精简</title>
      <link href="/2021/06/21/JavaSE/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/06/21/JavaSE/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1、char和string"><a href="#1、char和string" class="headerlink" title="1、char和string"></a>1、char和string</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">码点与代码单元</span><br><span class="line">String a = “<span class="number">43</span>”; </span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(a);</span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">ValueOf</span><span class="params">(String s)</span></span>;   </span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">ValueOf</span><span class="params">(String s,<span class="keyword">int</span> rad/2ix)</span></span>;方法的重载和重写</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>JDK9之后 String采用 byte[] 数组存储字符串</p><ul><li>操作少量的数据: 适⽤ String</li><li>单线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder</li><li>多线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer</li></ul><h3 id="2、方法问题"><a href="#2、方法问题" class="headerlink" title="2、方法问题"></a>2、方法问题</h3><p><strong>重载与重写</strong></p><ol><li>静态方法可以重载但是不可以重写</li><li><strong>方法重写约束:</strong><ul><li>方法必须具有相同的<strong>名称和参数</strong></li><li>返回值类型、异常类型要和父类一致，或为父类返回类型的子类</li><li><strong>访问权限要比父类的高或者相等</strong></li><li>无法重写static、final、private方法，因为static方法是类方法，不是成员方法</li></ul></li><li>子类对象实例化时不会实例化父类对象</li><li><strong>方法的签名：</strong>方法的名字和参数构成方法的签名，与返回值无关，重载需要签名不同</li></ol><p><strong>值传递：</strong>Java里方法的参数传递方式只有一种：值传递。 将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。 </p><h3 id="3、构造器"><a href="#3、构造器" class="headerlink" title="3、构造器"></a>3、构造器</h3><p><strong>特点：</strong>不能重写可以重载、没有修饰符、子类构造器必须调用父类构造器（默认自动调用无参）</p><p><strong>构造器调用构造器：</strong>最多调用一个；必须放在最上面</p><p><strong>初始化顺序：</strong></p><ol><li>声明成员变量的默认初始化</li><li>显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）</li><li>构造器再对成员进行初始化操作</li><li>通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值</li></ol><p><strong>注意：</strong>构造器被调用后，会先判断是否调用了其他构造器</p><ul><li>若调用了，则转到另一个构造器执行</li><li>若没调用，<strong>先调用初始化块，在调用构造器剩下的部分</strong></li></ul><p><strong>静态代码块：</strong>优先于类的构造，<strong>只能对静态成员变量初始化</strong>，从上而下执行</p><h3 id="4、static和final"><a href="#4、static和final" class="headerlink" title="4、static和final"></a>4、static和final</h3><p><strong>final：</strong></p><ul><li>变量：不能修改，直接定义或者构造函数处赋值</li><li>方法：不能被重写，可以重载</li><li>类：不能被继承</li></ul><p><strong>static</strong></p><ul><li>变量：不再属于某个对象，而是属于类被共享</li><li>方法：独立于类，静态方法不能调用非静态字段，类和对象都可以调用静态方法。</li></ul><h3 id="5、多态问题"><a href="#5、多态问题" class="headerlink" title="5、多态问题"></a>5、多态问题</h3><p><strong>多态：</strong>多态是运行时实现的，一个引用变量在运行时才能确定指向哪个对象。</p><p><strong>数组向上转型的问题：</strong>数组对象转型问题，数组向上转型之后，只能添加子类对象而不能添加父类对象，因为子类和父类引用都是指向该地址，添加父类对象，就相当于子类指向父类对象属于向下转型不安全。</p><h3 id="6、枚举类"><a href="#6、枚举类" class="headerlink" title="6、枚举类"></a>6、枚举类</h3><ul><li>枚举是一个特殊的类，一般表示一组常量，参数默认用public static final 修饰，</li><li>枚举类构造器只能是private，</li><li>枚举类初始化对象，里面成员变量全部初始化</li></ul><h3 id="7、接口和抽象"><a href="#7、接口和抽象" class="headerlink" title="7、接口和抽象"></a>7、接口和抽象</h3><p><strong>接口：</strong></p><ul><li>接口只含 静态常量值，抽象方法，jdk8新增默认方法，静态方法，jdk9允许私有</li><li>接口继承规则<ul><li>超子类冲突超类优先：如果超类提供了一个具体方法，子类方法签名一致的默认方法将被忽略</li><li>超类之间冲突： 子类需要重写</li></ul></li></ul><p><strong>抽象：</strong>抽象只是可能含有抽象方法，其他和普通类完全一致。</p><p><strong>注意点：</strong></p><ul><li><p>抽象类可以实现多个接口，只能继承实现一个抽象类</p></li><li><p>一个接口可以继承多个接口。</p></li><li><p>从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接口是对行为的抽象，是⼀种行</p><p>为的规范。</p></li></ul><h3 id="8、内部类"><a href="#8、内部类" class="headerlink" title="8、内部类"></a>8、内部类</h3><ul><li>局部内部类的this指向外部，只能获得外部不改变的值</li><li>普通成员内部类不能含静态方法属性，可以重写外部方法。</li><li>静态成员内部类，静态方法只能调静态属性和静态方法，和外部资源。</li></ul><h3 id="9、成员变量和局部变量"><a href="#9、成员变量和局部变量" class="headerlink" title="9、成员变量和局部变量"></a>9、成员变量和局部变量</h3><table><thead><tr><th></th><th><strong>成员变量</strong></th><th><strong>局部变量</strong></th></tr></thead><tbody><tr><td>声明的位置</td><td>直接声明在类中</td><td>方法形参或内部、代码块内、构造器内等</td></tr><tr><td>修饰符</td><td>用权限修饰符修饰</td><td>只能使用final</td></tr><tr><td>初始化值</td><td>有默认值</td><td>没有默认值</td></tr><tr><td>内存加载位置</td><td><strong>堆空间或静态域内</strong></td><td><strong>栈空间</strong></td></tr></tbody></table><h3 id="10、集合"><a href="#10、集合" class="headerlink" title="10、集合"></a>10、集合</h3><ul><li>hashset 可以为null，<strong>保证equals相等的对象，hashcode也必须相等</strong>，HashTable不支持</li><li>treeset不能为Null</li><li>weakhashmap 弱引用</li><li>IdentityHashMap hashcode比较就是比较地址，比较两个对象使用＝＝，也就是说永远不会用相等的对象</li></ul><h3 id="11、队列"><a href="#11、队列" class="headerlink" title="11、队列"></a>11、队列</h3><p>queue是一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>; <span class="comment">// 队列满回跑出异常</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>; <span class="comment">// 若队列没空，则从队首取出，不然抛出异常，返回false</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">peak</span><span class="params">()</span></span>; <span class="comment">// 获取队首的元素,失败抛出异常</span></span><br></pre></td></tr></table></figure><p>Deque是一个双端队列接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Object obj)</span>       <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(Object obj)</span>  <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 移除数据</span></span></span><br><span class="line"><span class="function">Object <span class="title">removeFirst</span><span class="params">()</span>           Object <span class="title">removeLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">pollFirst</span><span class="params">(Object obj)</span>   Object <span class="title">pollLast</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 获得数据</span></span></span><br><span class="line"><span class="function">Object <span class="title">getFirst</span><span class="params">()</span>               Object <span class="title">getLast</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">Object <span class="title">peekFirst</span><span class="params">()</span>              Object <span class="title">peekLast</span><span class="params">()</span>   </span></span><br></pre></td></tr></table></figure><ul><li>ArrayDeque<E></li><li>PriorityQueue()：优先级队列，需要传入构造器或元素实现排序接口</li></ul><p>8、Collections工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步集合</span></span><br><span class="line">synchronizedCollection()   <span class="comment">// 把Collection替换成下面的即可</span></span><br><span class="line">List/Map/Set/SortedSet/SortedMap/NavigableSet/NavigableMap</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 分割集合</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; List &lt;E&gt; asList(E...array);                      <span class="comment">// Arrays类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> firstIncluded,<span class="keyword">int</span> firstExcluded)</span></span>;<span class="comment">// List类</span></span><br><span class="line"></span><br><span class="line">subset(E firstIncluded,E firstExcluded);</span><br><span class="line">headSet(E firstExcluded);    <span class="comment">// SortedSet、SortedMap(Map方法把set换成Map即可)</span></span><br><span class="line">tailSet(E firstExcluded);     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List)</span>          <span class="comment">// 反转 List 中元素的顺序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List)</span>          <span class="comment">// 对 List 集合元素进行随机排序</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List)</span>             <span class="comment">// 根据元素的自然顺序对按升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List，Comparator)</span> <span class="comment">// </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List，<span class="keyword">int</span>， <span class="keyword">int</span>)</span>  <span class="comment">// 将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 查找和替换</span></span></span><br><span class="line"><span class="function"><span class="comment">// 最值</span></span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection)</span>             <span class="comment">// 自然排序，或者自己实现接口</span></span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection,Comparator)</span>  <span class="comment">// 传入一个实现排序接口的对象</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection)</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection，Comparator)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置值    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span>      <span class="comment">// 将src中的内容复制到dest中 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List dest,Object value)</span>  <span class="comment">// 所有值变为value </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c,T...values)</span> <span class="comment">// 把所有值添加到集合里面    </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list,Object old,Object new)</span>  <span class="comment">// 替换</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">// 查询    </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection，Object o)</span>        <span class="comment">// 返回指定集合中指定元素的出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">disjoint</span><span class="params">(Collection c1,Collection c2)</span>   <span class="comment">// 没有公共元素，返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List father,List son)</span>  <span class="comment">// 返回子集合在父集合的索引索引 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfSubList</span><span class="params">(List father,List son)</span></span></span><br></pre></td></tr></table></figure><h3 id="12、栈：stack"><a href="#12、栈：stack" class="headerlink" title="12、栈：stack"></a>12、栈：stack</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">push</span><span class="params">(E item)</span></span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="13、泛型简单使用"><a href="#13、泛型简单使用" class="headerlink" title="13、泛型简单使用"></a>13、泛型简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span>&lt;<span class="title">T</span>&gt;</span>&#123;                        <span class="comment">// 泛型类</span></span><br><span class="line">    T t;                                      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T...a)</span></span>&#123;     <span class="comment">// 泛型方法</span></span><br><span class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">compare</span><span class="params">(T...a)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;进行比较&quot;</span>);</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    <span class="keyword">for</span> (T num: a) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14、泛型原理"><a href="#14、泛型原理" class="headerlink" title="14、泛型原理"></a>14、泛型原理</h3><p><strong>原理：</strong>编译器把数据存为Object，再通过泛型知道了数据的类型，自动帮我们把数据转换回来</p><p><strong>泛型多态性问题：</strong>父类被重写的方法的参数类型被擦除，不构成重写，如何保持多态？</p><p>描述：子类继承泛型父类（泛型参数string），并且重写方法create（string str），由于泛型擦除，子类父类方法参数不一致，被重载了，如何恢复原来的重写多态？</p><p>桥方法解决：实际调用父类的擦除的方法，但是此方法内部调用子类的方法，也就是说实际调用子类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很明显是两个不同的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">Demo1</span>&lt;<span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 子类本身方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从父类继承的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会在Demo2里面生成一个新的桥方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setSecond((Date) second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>协变问题：</strong>非继承关系下自动继承Object，泛型擦除导致的方法重复</p><p>解决：JVM会采用重写的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CLone........</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="comment">// Employee会有两个clone类,称为有协变的返回类型</span></span></span><br><span class="line"><span class="function">Employee <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">clone</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="15、泛型局限性"><a href="#15、泛型局限性" class="headerlink" title="15、泛型局限性"></a>15、泛型局限性</h3><ol><li><p><strong>不能使用基本类型实例化参数</strong>：基本类无法转换成Object</p></li><li><p><strong>无法使用instanceof判断泛型类型：</strong>类型被转换成Object，无法判断</p></li><li><p><strong>不能创建参数化类型的数组：</strong>数组不知道里面具体要加入的类型，但是由于Obejct[] 是父类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数化类型的数组</span></span><br><span class="line">Demo1&lt;String&gt;[] demo1 = <span class="keyword">new</span> Demo1&lt;String&gt;[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 泛型擦除之后，可以转换成object</span></span><br><span class="line">Demo1[] demo1 = <span class="keyword">new</span> Demo1[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把demo1赋值给Object数组</span></span><br><span class="line">Object[] object = demo1;   <span class="comment">// 相当于Object[] object = new Demo1[5];</span></span><br><span class="line"><span class="comment">// 数组记录了类型为demo1,但是因为泛型擦除，不知道应该为Demo1&lt;String&gt;，所以下面编译通过</span></span><br><span class="line">object[<span class="number">0</span>] = <span class="keyword">new</span> Demo1&lt;String&gt;();</span><br><span class="line">object[<span class="number">1</span>] = <span class="keyword">new</span> Demo1&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于object和demo1的引用指向一个对象，所以等效为,于是编译通过，但是报错</span></span><br><span class="line">demo1[<span class="number">0</span>] = <span class="keyword">new</span> Demo1&lt;String&gt;();</span><br><span class="line">demo1[<span class="number">1</span>] = <span class="keyword">new</span> Demo1&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原因</span></span><br><span class="line">Employee  是Manage 的 父类</span><br><span class="line">但是 Demo1&lt; Employee &gt; 不是 Demo1&lt; Manage &gt;的父类</span><br><span class="line"></span><br><span class="line">Employee  是Manage 的 父类</span><br><span class="line">Employee[]  是Manage[] 的 父类</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>不能 new 泛型变量：</strong>new不知道要创建的具体类型，无法直到调用哪个构造器。</p></li><li><p><strong>不能 new 泛型数组：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] create(<span class="keyword">int</span> length)&#123;</span><br><span class="line">    T[] result = <span class="keyword">new</span> T[length];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型擦除后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparable[] create(<span class="keyword">int</span> length)&#123;</span><br><span class="line">Comparable[] result = <span class="keyword">new</span> Comparable[length];</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 若T为User实现了接口，获取结果时 (User[]) result ，不安全，因为很明显Comparable对象不含User对象的属性和方法</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不能捕获抛出泛型类实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类不能捕获</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// catch语句不能使用泛型</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T) t;</span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">    &#125;<span class="keyword">catch</span> (T t)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型类的泛型变量不能使用static：静态变量初始化时无法获得变量类型</p></li><li><p>擦除后和Object的方法冲突：只能改名字或者不用泛型</p></li><li><p>继承多个泛型类会出现冲突：生成的桥方法冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt; ....</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Manage</span>&gt;.....</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">// 泛型擦除后，编译能通过    </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>....</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>..... </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">// 但是使用会报错,由于继承，所以会生成两个桥方法，而这两个桥方法完全一致，所以报错</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">int</span> <span class="title">compareTo</span>(<span class="title">Object</span> <span class="title">object</span>)</span>&#123;  </span><br><span class="line">    <span class="comment">// 调用Comparable&lt;Employee&gt;的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object object)</span></span>&#123;  </span><br><span class="line">    <span class="comment">// 调用Comparable&lt;Manage&gt;的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="16、通配符"><a href="#16、通配符" class="headerlink" title="16、通配符"></a>16、通配符</h3><p><strong>作用：</strong>对泛型类的使用进行优化，把其中的泛型参数替换成 ? </p><p><strong>泛型继承规则带来的局限</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Demo1&lt;Employee&gt; demo)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Manage 为 Employee 的子类，根据泛型继承规则</span></span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Employee&gt;());  <span class="comment">// 编译通过</span></span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Manage&gt;()); </span><br><span class="line"><span class="comment">// 报错，因为Demo1&lt;Manage&gt; 不是 Demo1&lt;Employee&gt;的子类</span></span><br></pre></td></tr></table></figure><p><strong>使用泛型通配符解决局限性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样限定范围之后，就可以解决上述问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Demo1&lt;? extends Employee&gt; demo)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型 ArrayList&lt;Demo2&gt; 是ArrayList&lt;? extends Demo1&gt;的子类</span></span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Employee&gt;()); </span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Manage&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然,不使用通配符也可以，只是麻烦一些</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Employee&gt; <span class="function">Demo1&lt;T&gt; <span class="title">print</span><span class="params">(Demo1&lt;T&gt; demo)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> demo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java对泛型通配符的限定</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Demo1是一个泛型类Demo1&lt;T&gt; ,里面有泛型属性 T first</span><br><span class="line"></span><br><span class="line">Demo1&lt;? extends Employee&gt; e = m;  <span class="comment">// 里面变成 ? first</span></span><br><span class="line">e.setFirst(<span class="keyword">new</span> Manage());         <span class="comment">// 编译不通过,因为不知道? 代表的类型</span></span><br><span class="line">e.setFirst(<span class="keyword">new</span> Employee());       <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure><p><strong>通配符捕获，解决对泛型通配符的限定</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Demo1&lt;?&gt; demo1)</span></span>&#123;</span><br><span class="line">   swapHelper(demo1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Demo1&lt;T&gt; demo1)</span></span>&#123;</span><br><span class="line">T t = demo1.getFirst();</span><br><span class="line">demo1.setFirst(demo1.getSecond());</span><br><span class="line">demo1.setSecond(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17、异常层次结构"><a href="#17、异常层次结构" class="headerlink" title="17、异常层次结构"></a>17、异常层次结构</h3><p>Throwable类是所有<strong>异常类</strong>的 ‘ 祖先’ ，即所有异常类都是由Throwable继承而来</p><p>Throwable有两个子类：Error（错误，处理不了）、Exception（异常）</p><p>Exception有两个子类：：IOException 和 RuntimeException（非受检查型异常，可以不处理）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span>     <span class="comment">// 返回关于发生的异常的详细信息。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Throwable <span class="title">getCause</span><span class="params">()</span>    <span class="comment">// 返回一个Throwable 对象代表异常原因。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span>  <span class="comment">// 打印toString()结果和栈层次到System.err，即错误输出流。</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StackTraceElement [] <span class="title">getStackTrace</span><span class="params">()</span>          </span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</span></span></span><br></pre></td></tr></table></figure><h3 id="18、异常处理"><a href="#18、异常处理" class="headerlink" title="18、异常处理"></a>18、异常处理</h3><ul><li>try-catch-finally处理：注意一般情况 finally 都会执行，甚至 finally的返回值 可以覆盖 try </li><li>throws 把异常向上抛出</li></ul><h3 id="19、自定义异常"><a href="#19、自定义异常" class="headerlink" title="19、自定义异常"></a>19、自定义异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常类必须继承现有的异常类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line">    <span class="comment">// 初始化，给money赋初始值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取剩余的钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 抛出 自定义异常类的对象</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MyException(balance - <span class="keyword">this</span>.balance);</span><br><span class="line">&#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">    <span class="comment">// 根据捕获的对象，我们可以获取money信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;缺少&quot;</span>+e.getMoney()+<span class="string">&quot;元钱&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20、元注解"><a href="#20、元注解" class="headerlink" title="20、元注解"></a>20、元注解</h3><ol><li><p><code>@Target</code>：描述注解的使用范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">- TYPE : 类、接口或<span class="class"><span class="keyword">enum</span>声明</span></span><br><span class="line"><span class="class">- <span class="title">FIELD</span>: 域(属性)声明</span></span><br><span class="line"><span class="class">- <span class="title">METHOD</span>: 方法声明</span></span><br><span class="line"><span class="class">- <span class="title">PARAMETER</span>: 参数声明</span></span><br><span class="line"><span class="class">- <span class="title">CONSTRUCTOR</span>: 构造方法声明 <span class="title">LOCAL_VARIABLE</span>:局部变量声明</span></span><br><span class="line"><span class="class">- <span class="title">ANNOTATION_TYPE</span>:注释类型声明</span></span><br><span class="line"><span class="class">- <span class="title">PACKAGE</span>: 包声明</span></span><br></pre></td></tr></table></figure></li><li><p><code>@Rentention</code>：描述该注解的生命周期，即在什么时候有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">- SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃</span><br><span class="line">- CLASS:在<span class="class"><span class="keyword">class</span>文件中有效（即<span class="title">class</span>保留） ， 当运行 <span class="title">Java</span> 程序时, <span class="title">JVM</span>不会保留注解</span></span><br><span class="line"><span class="class">- <span class="title">RUNTIME</span>:在运行时有效（即运行时保留），当运行 <span class="title">Java</span>程序, <span class="title">JVM</span>会保留注释，此时可以通过反射获取注解。</span></span><br></pre></td></tr></table></figure></li><li><p><code>@Document</code>：说明该注解将被包含在Javadoc中</p></li><li><p><code>@Inherited</code>：说明子类可以继承父类中的注解</p></li></ol><h3 id="21、注解简单使用"><a href="#21、注解简单使用" class="headerlink" title="21、注解简单使用"></a>21、注解简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> &quot;20&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnnotation(age = &quot;30&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22、反射"><a href="#22、反射" class="headerlink" title="22、反射"></a>22、反射</h3><p><strong>反射：</strong>类加载器加载完类之后，堆里面就会生成<strong>一个Class类型的对象</strong>（一个类只有一个Class对象，JVM创建，每个类的实例都会记得自己是由哪个 Class 实例所生成），这个对象包含类的<strong>完整信息</strong>，通过这个对象来访问类的过程就是反射</p><ul><li>正常方式： 引入包名—-&gt;new实例化——&gt;取得实例化对象</li><li>反射方式： 实例化对象—–&gt;getClass()方法——-&gt;得到完整的”包类”名称</li></ul><p><strong>反射用途：</strong></p><ul><li>运行时取得类的<strong>内部信息</strong>，</li><li>运行时检查对象，直接操作对象的内部属性和方法。</li><li>实现泛型数组操作代码</li></ul><p><strong>获取Class对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class 类实际是一个泛型类</span></span><br><span class="line">Class c = User.class;           <span class="comment">// 通过类名,可以为基本数据类型 int.class</span></span><br><span class="line">Class c = user.getClass();      <span class="comment">// 通过对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">&quot;com.xxx.reflection.User&quot;</span>);   <span class="comment">//通过类的全限定名</span></span><br><span class="line">Class c = <span class="keyword">int</span>.TYPE;             <span class="comment">// 通过包装类</span></span><br></pre></td></tr></table></figure><h3 id="23、反射API操作类"><a href="#23、反射API操作类" class="headerlink" title="23、反射API操作类"></a>23、反射API操作类</h3><p>Java.lang.reflect 包有3个类 Field、method、Constructor 分别获取属性、方法、构造器（不含父类的方法）</p><ul><li>获取类名，包名（Class对象方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>;              <span class="comment">// 获取包名 + 类名</span></span><br><span class="line"><span class="function">String <span class="title">getSimpleName</span><span class="params">()</span></span>;        <span class="comment">// 只获得类名</span></span><br><span class="line"><span class="function">String <span class="title">getPackageName</span><span class="params">()</span></span>;</span><br><span class="line">Class[] getInterfaces();       <span class="comment">// 获得接口</span></span><br></pre></td></tr></table></figure><ul><li> 获取Feild对象及FeildAPI</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Field对象</span></span><br><span class="line">Field[] getFields();               <span class="comment">// 获取public的类变量，返回数组</span></span><br><span class="line">Field[] getDeclaredFields();       <span class="comment">// 获取全部类变量，包括private</span></span><br><span class="line"></span><br><span class="line">Field[] getField(Strning name);</span><br><span class="line">Field[] getDeclaredField(Strning name);    <span class="comment">// 获取指定名称的 </span></span><br></pre></td></tr></table></figure><ul><li>获取method对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method[] getMethods();              <span class="comment">// 获取public的method</span></span><br><span class="line">Method[] getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">Method[] getMethod(String name,String.class...);  <span class="comment">// 要指定方法名和参数的类型</span></span><br><span class="line">Method[] getDeclaredMethod(String name,<span class="keyword">null</span>);     <span class="comment">// 无参可以使用null或者不填</span></span><br></pre></td></tr></table></figure><ul><li>获取Constructor对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] getConstructors();</span><br><span class="line">Constructor[] getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">Constructor[] getDeclaredConstructor(String.class...); <span class="comment">// 需要指定参数类型</span></span><br><span class="line">Constructor[] getConstructor();             <span class="comment">// 无参则不填</span></span><br></pre></td></tr></table></figure><p>三个类对象常用API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>                   <span class="comment">// 返回的 Field对象表示的字段的名称。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>         <span class="comment">// 比较这 Field与指定对象。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span>                 <span class="comment">// 返回的 对构造器、方法、字段的修饰符的描述</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>;     <span class="comment">// 操作私有的必须设置为true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field  </span></span><br><span class="line"><span class="function">Class <span class="title">getType</span><span class="params">()</span>                    <span class="comment">// 返回类型  </span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object obj)</span>             <span class="comment">// 传入对象，获取该对象的属性  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span> <span class="comment">// 传入对象，把该字段设置为该值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// Method 和 Constructor通用</span></span></span><br><span class="line"><span class="function">Class <span class="title">getReturnType</span><span class="params">()</span>      <span class="comment">// 返回类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParameterCount</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">Class[] <span class="title">getParameterTypes</span><span class="params">()</span>  <span class="comment">// 返回参数类型</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// Method</span></span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span>  <span class="comment">// 调用方法,需要传入对象和参数</span></span></span><br><span class="line"><span class="function"><span class="comment">// Constructor </span></span></span><br><span class="line"><span class="function"><span class="title">newInstance</span><span class="params">(Object... initargs)</span>  <span class="comment">// 调用构造器创建对象,需要传入参数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//扩展 通过Class对象调用newInstance是调用无参构造    </span></span></span><br></pre></td></tr></table></figure><h3 id="24、反射API操作注解"><a href="#24、反射API操作注解" class="headerlink" title="24、反射API操作注解"></a>24、反射API操作注解</h3><p>API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] getAnnotations();  <span class="comment">// 获取注解</span></span><br><span class="line">Annotation[] getAnnotation(Annotation annotation);  <span class="comment">// 根据注解类型获取</span></span><br><span class="line">Annotation[] getDeclaredAnnotation();</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>可以获得类对象，然后调用方法；获得类对象在获得Method对象，调用方法；或者获得类对象再获得Field对象，再获得字段注解</p><h3 id="25、IO分类"><a href="#25、IO分类" class="headerlink" title="25、IO分类"></a>25、IO分类</h3><blockquote><p>按照数据单位分类</p></blockquote><ul><li><strong>字节流（8bit）</strong>：处理一个字节</li><li><strong>字符流（16bit）</strong>：面向字节的流不便于处理Unicode形式的信息，而一个字符16字节专门处理Unicode字符</li></ul><blockquote><p>按照数据流向</p></blockquote><ul><li><strong>输入流：</strong>可以读取一个字节序列</li><li><strong>输出流：</strong>可以写入一个字节序列</li></ul><blockquote><p>安装流的角色</p></blockquote><ul><li>节点流</li><li>处理流</li></ul><h3 id="26、API"><a href="#26、API" class="headerlink" title="26、API"></a>26、API</h3><p>字节输入流：InputStream</p><p>注意：InputStream是父类抽象类，有些方法没有具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据到输入流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>              <span class="comment">// 读取并返回一个字节到输入流，末尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;     <span class="comment">// 读取所有数据并且放到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="comment">// off开始，读到len</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readNBytes</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span>[] <span class="title">readAllBytes</span><span class="params">()</span> <span class="comment">// 读所有字节到输入流并返回数组</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 对输入流进行操作和分析    </span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(OutputStream out)</span> <span class="comment">// 转换成输出流并返回字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span>                 <span class="comment">// 输入流跳过n个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">available</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 标记 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span>   <span class="comment">// 在输入流当前位置打上标记</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span>               <span class="comment">// 返回到最后一个标记重写读取数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span>       <span class="comment">// 是否支持标记    </span></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> close    </span></span><br></pre></td></tr></table></figure><p>字符输入流：Read</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">// 读取单个字符，范围在0 到65535之间,已到末尾返回-1 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 将字符读入数组。返回读取的数量，如果已到达流的末尾，则返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">//  将字符读入数组的某一部分。从off处开始存储，最多读len个字</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException  <span class="comment">// 关闭</span></span></span><br></pre></td></tr></table></figure><p>字节输出流：OutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> n)</span>  <span class="comment">// 写出一个字节数据给n</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span>        <span class="comment">// 写出所有数据给字节数据byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,<span class="keyword">int</span> len)</span>  <span class="comment">// 最多写出len个字节 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;  <span class="comment">// 需要先刷新，再关闭</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>字符输出流：Writer</p><ul><li>Writer 可以用字符串来替换字符数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span>     <span class="comment">// 写入字符数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span>                 <span class="comment">// 写入字符串。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="comment">// 写入一部分到字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="comment">//刷新该流的缓冲，则立即将它们写入预期目标。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><h3 id="27、File类"><a href="#27、File类" class="headerlink" title="27、File类"></a>27、File类</h3><p>创建File对象：目录或文件的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以pathname为路径创建File对象，可以是**绝对路径或者相对路径，如果是相对路径，则默认的当前路径在系统属性user.dir中存储。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent,String child)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以parent为父路径，child为子路径创建File对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent,String child)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">// 根据一个父File对象和子文件路径创建File对象    </span></span></span><br></pre></td></tr></table></figure><ul><li>获取功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getAbsolutePath</span><span class="params">()</span> <span class="comment">// 获取绝对路径</span></span></span><br><span class="line"><span class="function">String <span class="title">getPath</span><span class="params">()</span>         <span class="comment">// 获取路径</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>         <span class="comment">// 获取名称</span></span></span><br><span class="line"><span class="function">String <span class="title">getParent</span><span class="params">()</span>       <span class="comment">// 获取上层文件目录路径。若无，返回null</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span>         <span class="comment">// 获取文件长度，不能是目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span>   <span class="comment">// 获取最后一次的修改时间，毫秒值</span></span></span><br><span class="line"><span class="function">String[] <span class="title">list</span><span class="params">()</span>       <span class="comment">// 目录下的所有文件或者目录的名称数组</span></span></span><br><span class="line"><span class="function">File[] <span class="title">listFiles</span><span class="params">()</span>    <span class="comment">// File数组</span></span></span><br></pre></td></tr></table></figure><ul><li>判断功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span>  <span class="comment">// 判断是否是文件目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span>       <span class="comment">// 判断是否是文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span>       <span class="comment">// 判断是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span>      <span class="comment">// 判断是否可读</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span>     <span class="comment">// 判断是否可写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span>     <span class="comment">// 判断是否隐藏</span></span></span><br></pre></td></tr></table></figure><ul><li>创建功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="comment">// 创建文件。若存在，则返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span>  <span class="comment">// 上层目录存在，file对象的目录不存在时创建</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> <span class="comment">// 创建文件目录。如果上层文件目录不存在，一并创建</span></span></span><br></pre></td></tr></table></figure><ul><li>修改功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span>  <span class="comment">// 把文件重命名为指定的文件路径</span></span></span><br></pre></td></tr></table></figure><ul><li>删除功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span>     <span class="comment">// 不进windows的回收站</span></span></span><br></pre></td></tr></table></figure><h3 id="28、常见的IO流"><a href="#28、常见的IO流" class="headerlink" title="28、常见的IO流"></a>28、常见的IO流</h3><ul><li><p>文件流：FileInputStream 和  FileOutputStream、FileReader 和 FileWriter</p></li><li><p>缓冲流：转换其他流 BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</p></li><li><p>转换流：把字节流转换成字符流</p><ul><li><p>InputStreamReader：将InputStream转换为Reader、</p></li><li><p>OutputStreamWriter：将Writer转换为OutputStream</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public InputStreamReader(InputStream in)    </span><br><span class="line">public InputSreamReader(InputStream in,String charsetName)</span><br><span class="line">// 参数二为字符集</span><br><span class="line">    </span><br><span class="line">public OutputStreamWriter(OutputStream out)</span><br><span class="line">public OutputSreamWriter(OutputStream out,String charsetName)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>标准输入输出流：System.out 、System.in</p></li><li><p>对象流：ObjectInputStream和OjbectOutputSteam，通常和序列化反序列化配合使用</p></li><li><p>管道流：在单线程里面使用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件字节流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件对象</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取文件流</span></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">    in.read(bytes);  <span class="comment">// 文件里的数据放到bytes里了</span></span><br><span class="line"></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\2.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出流</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file2);</span><br><span class="line">    <span class="comment">// 把数据写到输出流里面</span></span><br><span class="line">    out.write(bytes);</span><br><span class="line">    in.close();</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件字符流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得输入流</span></span><br><span class="line">    FileReader reader = <span class="keyword">new</span> FileReader(file1);</span><br><span class="line">    <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="comment">// 把内容写入到字符数组</span></span><br><span class="line">    reader.read(ch);</span><br><span class="line"></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\2.txt&quot;</span>);</span><br><span class="line">    FileWriter writer = <span class="keyword">new</span> FileWriter(file2);</span><br><span class="line">    <span class="comment">// 可以传入字符串，也可以传入字符数组</span></span><br><span class="line">    writer.write(ch);</span><br><span class="line">    writer.close();</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="29、同步、异步，阻塞和非阻塞"><a href="#29、同步、异步，阻塞和非阻塞" class="headerlink" title="29、同步、异步，阻塞和非阻塞"></a>29、同步、异步，阻塞和非阻塞</h3><p><strong>异步同步关心的是消息通信机制</strong></p><ul><li>同步：发出一个请求时，在没有得到结果之前，该请求就<strong>不返回</strong>直到得到结果</li><li>异步：请求后，这个调用就<strong>直接返回</strong>了，等结果出来后通过回调函数、通知等方法 返回结果。</li></ul><p><strong>阻塞非阻塞关心的是程序的状态</strong></p><ul><li>阻塞：发出一个请求，得到结果之前，会一直被阻塞。</li><li>非阻塞：发出一个请求，得到结果之前，自己可以做其他事情。</li></ul><h3 id="30、BIO、NIO、和AIO"><a href="#30、BIO、NIO、和AIO" class="headerlink" title="30、BIO、NIO、和AIO"></a>30、BIO、NIO、和AIO</h3><p><strong>BIO：</strong>同步阻塞式IO，服务器实现模式为<strong>一个连接一个线程（多线程）</strong>，即客户端有连接请求时服务器端就需要启动一个线程进行 IO 操作。虽然此时服务器具备了高并发能力，但是随着开启的线程数目增多，将会消耗过多的内存资源，导致服务器变慢甚至崩溃，NIO可以一定程度解决这个问题。 </p><p><strong>NIO：</strong>同步非阻塞式IO，服务器实现模式为 IO 多路复用，<strong>只需要开启一个线程</strong>就可以处理来自多个客户端的IO事件，客户端发送的连接请求都会<code>注册到多路复用器</code>上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 </p><ul><li>若服务端监听到客户端连接请求，便为其建立通信套接字(java中就是通道)，然后返回继续监听，若同时有多个客户端连接请求到来也可以全部收到，依次为它们都建立通信套接字。</li><li>若服务端监听到来自已经创建了通信套接字的客户端发送来的数据，就会调用对应接口处理接收到的数据，若同时有多个客户端发来数据也可以依次进行处理。 </li><li> 监听多个客户端的连接请求和接收数据请求同时还能监听自己时候有数据要发送。 </li></ul><p><strong>AIO(NIO.2)：</strong>异步非阻塞式IO，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p><blockquote><p>总结</p></blockquote><ul><li>NIO适合处理连接数目特别多，但是连接比较短（轻操作）的场景，Jetty，Mina，ZooKeeper等都是基于java nio实现。</li><li>BIO方式适用于连接数目比较小且固定的场景，这种方式对服务器资源要求比较高，并发局限于应用中。</li></ul><h3 id="31、序列化"><a href="#31、序列化" class="headerlink" title="31、序列化"></a>31、序列化</h3><ul><li><strong>序列化：</strong>用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</li><li><strong>反序列化：</strong>用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制</li></ul><p>注意：不能序列化static和transient修饰的成员变量</p><p><strong>目的：</strong>实现Java对象的运输和存储，如果不序列化，存储Java对象，然后再取出来可能会乱码。</p><p><strong>实现：</strong>让某个类是可序列化的，该类必须实现如下两个接口之一。Serializable  Externalizable</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID;  // 序列化版本标识符的静态变量</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(十):JDBC</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E5%8D%81%20)%20JDBC/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E5%8D%81%20)%20JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="1、数据库驱动"><a href="#1、数据库驱动" class="headerlink" title="1、数据库驱动"></a>1、数据库驱动</h1><p>驱动：声卡、显卡、数据库</p><h1 id="2、JDBC"><a href="#2、JDBC" class="headerlink" title="2、JDBC"></a>2、JDBC</h1><p>sun公司为了简化开发人员对数据库统一的操作，提供了java对数据库的统一规范，俗称JDBC</p><p>规定的具体实现由具体的厂商去做</p><h1 id="3、第一个JDBC程序"><a href="#3、第一个JDBC程序" class="headerlink" title="3、第一个JDBC程序"></a>3、第一个JDBC程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.wzh;</span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Connection;</span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Statement;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcdemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1：加载驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2：获取连接对象</span></span><br><span class="line">            conn = (Connection)                 </span><br><span class="line">conn = (Connection) DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/school?useUnicode=true&amp;characterEncoding=utf8&amp;userSSL=true&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);        </span><br><span class="line">            <span class="comment">//3：声明sql语句</span></span><br><span class="line">            String sql = <span class="string">&quot;SELECT * FROM student WHERE id = 1&quot;</span>;</span><br><span class="line">            <span class="comment">//4：创建处理对象</span></span><br><span class="line">            stmt = (Statement) conn.createStatement();</span><br><span class="line">            <span class="comment">//5：发送sql语句获取结果集(如果是查询操作才存在结果集)</span></span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="comment">//6. 迭代结果集</span></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="comment">//7：分析结果集</span></span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//8：关闭资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>URL</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/school?useUnicode=true&amp;characterEncoding=utf8&amp;userSSL=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 协议://主机地址：端口号/数据库名</span></span><br></pre></td></tr></table></figure><blockquote><p>Connection对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conn = (Connection) DriverManager.getConnection(url,name,password); </span><br><span class="line"><span class="comment">//connection代表数据库，所以conn是数据库的对象</span></span><br><span class="line"></span><br><span class="line">conn.rollback();           <span class="comment">//回滚</span></span><br><span class="line">conn.commit();             <span class="comment">//提交</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>); <span class="comment">//把每条数据自动提交关闭，即开启手动提交事务</span></span><br></pre></td></tr></table></figure><blockquote><p>Statement对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行SQL语句的对象</span></span><br><span class="line">stmt = (Statement) conn.createStatement();</span><br><span class="line">                </span><br><span class="line">stmt.executeQuery(sql);      <span class="comment">//查询操作，返回结果集</span></span><br><span class="line">stmt.execute(sql);           <span class="comment">//都可以，但是效率慢</span></span><br><span class="line">stmt.executeUpdate(sql);     <span class="comment">//增删改，返回受影响行数</span></span><br><span class="line">stmt.executeBatch(sql);      <span class="comment">//批处理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>ResultSet对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得结果集</span></span><br><span class="line">rs = stmt.executeQuery(sql);</span><br><span class="line"><span class="comment">//遍历结果集</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));   <span class="comment">// 获取名为name的String类型数据</span></span><br><span class="line">    System.out.println(rs.getString(<span class="number">1</span>));        <span class="comment">// 获取第1列数据</span></span><br><span class="line">    System.out.println(rs.findColumn(<span class="string">&quot;name&quot;</span>));  <span class="comment">// 获取name在第几列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>释放资源：必须做</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs.close();</span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h1 id="4、Statement和preparedStatement的对比"><a href="#4、Statement和preparedStatement的对比" class="headerlink" title="4、Statement和preparedStatement的对比"></a>4、Statement和preparedStatement的对比</h1><blockquote><p>创建方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Statement,不需要sql</span></span><br><span class="line">stmt = (Statement) Connection.createStatement(); </span><br><span class="line">rs = stmt.executeQuery(sql); </span><br><span class="line"><span class="comment">//PreparedStatement,需要sql</span></span><br><span class="line">stmt = (Statement)Connection.preparedStatement(sql);</span><br><span class="line">rs = stmt.executeQuery(); </span><br></pre></td></tr></table></figure><blockquote><p> 安全性</p></blockquote><ul><li>Statement：不能防止sql注入</li><li>PreparedStatement：可以防止SQL注入</li></ul><blockquote><p> 效率</p></blockquote><ul><li>Statement ：不会初始化，没有预处理，每次都是从0开始执行SQL</li><li>PreparedStatement：会先初始化SQL，先把这个SQL提交到数据库中进行预处理，多次使用可提高效率</li></ul><blockquote><p> 可读性</p></blockquote><ul><li>Statement：当多次执行参数不同的语句时，需要不断的拼接字符串，使得阅读变得极为耗时以及费力。</li><li>PreparedStatement ：通过SetXXX()这样的方式，提高了阅读性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT * FROM student WHERE id = ?&quot;</span>;</span><br><span class="line">PreparedStatement  stmt = conn.prepareStatement(sql);</span><br><span class="line">stmt.setInt(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><p>性能</p></blockquote><ul><li>Statement ：没有预编译的过程，每次都需要在DB中重新编译一下</li><li>PreparedStatement：语句被db的编译器编译后的执行代码就会被缓存下来， 那么下次调用时只要相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行就可以。 相当于一个函数 ， 对于整个db来说，只有预编译的语句和缓存中匹配，那么任何时候，就可以不需要再次编译从而直接执行。并不是所有的预编译语句都会被缓存起来，数据库本身会用一种策略，频繁使用的语句可能被缓存起来，以保存有更多的空间存储新的预编译语句。</li></ul><h1 id="5、SQL注入问题"><a href="#5、SQL注入问题" class="headerlink" title="5、SQL注入问题"></a>5、SQL注入问题</h1><p>在用户登录的时候，我们往往需要输入账号和密码，通过账号和密码和数据库中保存的账号密码进行匹配，匹配成功则登录成功，但是在匹配的时候会存在注入攻击的安全隐患，在输入账号和密码的时候，在末尾加上 “or” 再接上任何为真的语句，这样一来，有真就为真，这样也能登录成功。</p><p> 解决办法：使用PrepareStatement</p><h1 id="6、编写工具类"><a href="#6、编写工具类" class="headerlink" title="6、编写工具类"></a>6、编写工具类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用preparement方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明获取值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String uname = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String pwd = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//通过静态代码块将配置文件信息加载进来，保证加载驱动只需要执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建配置对象</span></span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">//获取输入流读取</span></span><br><span class="line">            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">            <span class="comment">//读取数据信息</span></span><br><span class="line">            properties.load(in);</span><br><span class="line">            <span class="comment">//通过方法获取配置文件中的数据信息</span></span><br><span class="line">            driver = properties.getProperty(<span class="string">&quot;mysql-driver&quot;</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">&quot;mysql-url&quot;</span>);</span><br><span class="line">            uname = properties.getProperty(<span class="string">&quot;mysql-username&quot;</span>);</span><br><span class="line">            pwd = properties.getProperty(<span class="string">&quot;mysql-password&quot;</span>);</span><br><span class="line">            <span class="comment">//加载驱动,只用一次</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取连接对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn = (Connection) DriverManager.getConnection(url,uname,pwd);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    //创建Statement对象</span></span><br><span class="line"><span class="comment">//    public static PreparedStatement getPreparedStatement(Connection conn,String sql) &#123;</span></span><br><span class="line"><span class="comment">//        if(conn==null) &#123;</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;连接为空&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        PreparedStatement stmt = null;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            stmt = (PreparedStatement) conn.prepareStatement(sql);</span></span><br><span class="line"><span class="comment">//        &#125; catch (SQLException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;创建Statement对象失败&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return stmt;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//关闭所有资源  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement stmt, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM student WHERE id = 1&quot;</span>;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JdbcUtils.getConn();</span><br><span class="line">            pstmt = (PreparedStatement) conn.prepareStatement(sql);</span><br><span class="line">            rs = pstmt.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、事务及批处理"><a href="#7、事务及批处理" class="headerlink" title="7、事务及批处理"></a>7、事务及批处理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用前面封装的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;UPDATE student set age = 15 WHERE id = ?&quot;</span>;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JdbcUtils.getConn();</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);              <span class="comment">//开启事务</span></span><br><span class="line">            pstmt = conn.prepareStatement(sql);     <span class="comment">//获得prepareStatement对象</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                pstmt.setInt(<span class="number">1</span>,i);</span><br><span class="line">                pstmt.addBatch();                   <span class="comment">//不断添加到批处理里面</span></span><br><span class="line">            &#125;</span><br><span class="line">            pstmt.executeBatch();                   <span class="comment">//批处理执行</span></span><br><span class="line">            conn.commit();                          <span class="comment">//提交事务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8、数据库连接池"><a href="#8、数据库连接池" class="headerlink" title="8、数据库连接池"></a>8、数据库连接池</h1><p>数据库连接—-&gt;执行—–&gt;释放 </p><p>该过程十分消耗资源</p><p>池化技术：准备一些预先的资源，过来就连接预先准备好的</p><ul><li>最小连接数：大小和常用连接数差不多</li><li>最大连接数：业务承载上限</li><li>等待超时：超过最大连接数时等待，等待过一定时间就超时，</li></ul><p>编写连接池：实现DataSource的接口</p><p>常见开源数据源：</p><ul><li>DBCP</li><li>C3P0</li><li>Druid：阿里巴巴</li></ul><p>使用了这些数据库连接池后，我们在项目开发中就不需要编写连接数据库的代码了</p><blockquote><p>DBCP</p></blockquote><p>需要coomos-dbcp-1.4    commos-pool-1.6包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.wzh;</span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Connection;</span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Statement;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcpconfig.properties&quot;</span>);</span><br><span class="line">            properties.load(in);</span><br><span class="line">            <span class="comment">//创建数据源 工厂模式</span></span><br><span class="line">            dataSource = BasicDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取连接对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> dataSource.getConnection(); <span class="comment">//从数据源获取连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement stmt, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>C3P0</p></blockquote><p>​      </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(九):Java的时间日期API使用</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%B9%9D%20)%20%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E4%B9%9D%20)%20%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1、JDK8之前"><a href="#1、JDK8之前" class="headerlink" title="1、JDK8之前"></a>1、JDK8之前</h2><h3 id="1-1、-时间戳"><a href="#1-1、-时间戳" class="headerlink" title="1.1、 时间戳"></a>1.1、 时间戳</h3><ul><li>java.lang.System类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差</span></span></span><br></pre></td></tr></table></figure><h3 id="1-2、-Date对象"><a href="#1-2、-Date对象" class="headerlink" title="1.2、 Date对象"></a>1.2、 Date对象</h3><ul><li><p>java.util.Date类</p></li><li><p>表示特定的瞬间，精确到毫秒</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器</span></span><br><span class="line">Date()          <span class="comment">// 取本地当前时间。</span></span><br><span class="line">Date(<span class="keyword">long</span> date) <span class="comment">// 通过时间戳获得时间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 常用方法    </span></span><br><span class="line">getTime()       <span class="comment">// 返回时间戳</span></span><br><span class="line">toString()    </span><br><span class="line"><span class="comment">// 把Date 对象转换为:dow mon ddhh:mm:ss zzz yyyy </span></span><br><span class="line"><span class="comment">// Sun Jun 06 11:57:16 CST 2021</span></span><br><span class="line"><span class="comment">// dow 是一周中的某一天 zzz是时间标准。</span></span><br></pre></td></tr></table></figure><h3 id="1-3、-格式化Date"><a href="#1-3、-格式化Date" class="headerlink" title="1.3、 格式化Date"></a>1.3、 格式化Date</h3><ul><li>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</li><li>它允许进行格式化：日期–&gt;文本、解析：文本–&gt;日期</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式化</span></span><br><span class="line">SimpleDateFormat()   <span class="comment">// 默认的模式和语言环境创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDateFormat</span><span class="params">(String pattern)</span><span class="comment">// 参数pattern格式创建对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(Date date)</span>        <span class="comment">// 方法格式化时间对象date</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 解析</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 按照给定的SimpleDateFormat格式解析字符串    </span></span></span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(time);</span><br><span class="line">    SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 EEE HH:mm:ss&quot;</span>);</span><br><span class="line">    System.out.println(format.format(date));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>格式化编码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">G<span class="comment">// 纪元标记AD</span></span><br><span class="line">y<span class="comment">// 四位年份2001</span></span><br><span class="line">M<span class="comment">// 月份July or 07</span></span><br><span class="line">d<span class="comment">// 一个月的日期10</span></span><br><span class="line">h<span class="comment">// A.M./P.M. (1~12)格式小时12</span></span><br><span class="line">H<span class="comment">// 一天中的小时 (0~23)22</span></span><br><span class="line">m<span class="comment">// 分钟数30</span></span><br><span class="line">s<span class="comment">// 秒数55</span></span><br><span class="line">S<span class="comment">// 毫秒数234</span></span><br><span class="line">E<span class="comment">// 星期几Tuesday</span></span><br><span class="line">D<span class="comment">// 一年中的日子360</span></span><br><span class="line">F<span class="comment">// 一个月中第几周的周几2 (second Wed. in July)</span></span><br><span class="line">w<span class="comment">// 一年中第几周40</span></span><br><span class="line">W<span class="comment">// 一个月中第几周1</span></span><br><span class="line">a<span class="comment">// vA.M./P.M. 标记PM</span></span><br><span class="line">k<span class="comment">// 一天中的小时(1~24)24</span></span><br><span class="line">K<span class="comment">// A.M./P.M. (0~11)格式小时10</span></span><br><span class="line">z<span class="comment">// 时区Eastern Standard Time</span></span><br><span class="line"><span class="string">&#x27;// 文字定界符Delimiter</span></span><br><span class="line"><span class="string">&quot;// 单引号</span></span><br></pre></td></tr></table></figure><h3 id="1-4、字符串格式化"><a href="#1-4、字符串格式化" class="headerlink" title="1.4、字符串格式化"></a>1.4、字符串格式化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">String s = String.format(<span class="string">&quot;%te&quot;</span>,date); <span class="comment">// 返回当天是几号</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日期格式化  </span></span><br><span class="line">%te  <span class="comment">// 几号</span></span><br><span class="line">%tb  <span class="comment">// 月份简称   %tB  全称</span></span><br><span class="line">%ta  <span class="comment">// 星期简称   %tA  全称    </span></span><br><span class="line">%tc  <span class="comment">// 全部日期和时间信息   星期二 二月 25 13:37:22 CST 2008</span></span><br><span class="line">%tY  <span class="comment">// 四位年份    %ty  二位年份   %tj   当年的第几天  085</span></span><br><span class="line">%tm  <span class="comment">// 月份     03    %tm:当月第几天   02</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  时间格式化</span></span><br><span class="line">%tH或者%tK   <span class="comment">// 2位数字的24时制的小时         </span></span><br><span class="line">%tI或者%tl   <span class="comment">// 2位数字的12时制的小时    </span></span><br><span class="line">%tM   <span class="comment">// 2位数字的分钟                      </span></span><br><span class="line">%tS   <span class="comment">// 2位数字的秒数   </span></span><br><span class="line">%tL   <span class="comment">// 3位数字的毫秒              </span></span><br><span class="line">%tN   <span class="comment">// 9位数字的毫秒  </span></span><br><span class="line">%tp   <span class="comment">// 上午或下午                     </span></span><br><span class="line">%tZ   <span class="comment">// 时区缩写形式的字符串</span></span><br><span class="line">%tz   <span class="comment">// 相对于GMT RFC 82 格式的数字时区偏移量    +0800</span></span><br><span class="line">%ts   <span class="comment">// 从1970年1月1日0时到现在经过的秒数      %tQ:毫秒数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 常见的日期时间组合</span></span><br><span class="line">%tF   <span class="comment">// 年-月-日   2008-03-25             </span></span><br><span class="line">%tD   <span class="comment">// 月/日/年   03/25/08</span></span><br><span class="line">%tc   <span class="comment">// 全部日期和时间信息   星期二 二月 25 13:37:22 CST 2008</span></span><br><span class="line">%tr   <span class="comment">// 时:分:秒 上午   12小时制    03:22:06下午         </span></span><br><span class="line">%tT   <span class="comment">// 时:分:秒 24小时制     %tR:时:分:秒 12小时制</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 常规类型格式化</span></span><br><span class="line">%b、%B  <span class="comment">// 结果格式化为布尔类型                </span></span><br><span class="line">%h、%H  <span class="comment">// 散列码              </span></span><br><span class="line">%s、%S  <span class="comment">// 字符串类型           </span></span><br><span class="line">%c、%C  <span class="comment">// 字符类型          </span></span><br><span class="line">%d      <span class="comment">// 十进制整数                </span></span><br><span class="line">%o      <span class="comment">// 八进制整数         </span></span><br><span class="line">%x、%X  <span class="comment">// 十</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 进制整数      </span></span><br><span class="line">%e  <span class="comment">// 科学计算法表示的十进制整数       1.700000e+01</span></span><br><span class="line">%a  <span class="comment">// 带有有效位和指数的十六进制浮点数  0X1.C0000000000001P4</span></span><br><span class="line">%n  <span class="comment">// 行分隔符                        %%:输出%</span></span><br></pre></td></tr></table></figure><h3 id="1-5、日历类"><a href="#1-5、日历类" class="headerlink" title="1.5、日历类"></a>1.5、日历类</h3><ul><li>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</li></ul><p><strong>创建对象</strong></p><ul><li> 使用Calendar.getInstance()方法</li><li> 调用它的子类GregorianCalendar的构造器。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar1 = Calendar.getInstance();</span><br><span class="line">Calendar calendar2 = new GregorianCalendar();</span><br></pre></td></tr></table></figure><p><strong>操作时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date)</span>    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title">getTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(Date date)</span></span></span><br></pre></td></tr></table></figure><ul><li>实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    calendar.set(<span class="number">2021</span>,<span class="number">6</span>,<span class="number">6</span>);    <span class="comment">// 设置时间</span></span><br><span class="line">    calendar.set(Calendar.AM,<span class="number">1</span>);        <span class="comment">// 设置一个字段</span></span><br><span class="line">    calendar.add(Calendar.DATE,-<span class="number">1</span>);  <span class="comment">// 推迟-1天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6、GregorianCalendar类"><a href="#1-6、GregorianCalendar类" class="headerlink" title="1.6、GregorianCalendar类"></a>1.6、GregorianCalendar类</h3><p>Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GregorianCalendar()  <span class="comment">// 默认</span></span><br><span class="line">GregorianCalendar(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date) </span><br><span class="line">GregorianCalendar(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date, <span class="keyword">int</span> hour, <span class="keyword">int</span> min) </span><br><span class="line">GregorianCalendar(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date, <span class="keyword">int</span> hour, <span class="keyword">int</span> min, <span class="keyword">int</span> sec) </span><br><span class="line"></span><br><span class="line">GregorianCalendar(Locale aLocale)  <span class="comment">// 指定语言环境和当前时间</span></span><br><span class="line">GregorianCalendar(TimeZone zone)   <span class="comment">// 给定时区</span></span><br><span class="line">GregorianCalendar(TimeZone zone, Locale aLocale) </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> amount)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">computeFields</span><span class="params">()</span>        <span class="comment">// 转换UTC毫秒值为时间域值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">computeTime</span><span class="params">()</span>          <span class="comment">// 覆盖Calendar ，转换时间域值为UTC毫秒值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>  <span class="comment">// 比较此 GregorianCalendar 与指定的 Object。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getActualMaximum</span><span class="params">(<span class="keyword">int</span> field)</span> <span class="comment">// 返回当前日期，给定字段的最大值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getActualMinimum</span><span class="params">(<span class="keyword">int</span> field)</span> <span class="comment">// 返回当前日期，给定字段的最小值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGreatestMinimum</span><span class="params">(<span class="keyword">int</span> field)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 GregorianCalendar 实例给定日历字段的最高的最小值。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Date <span class="title">getGregorianChange</span><span class="params">()</span> <span class="comment">// 获得格里高利历的更改日期。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLeastMaximum</span><span class="params">(<span class="keyword">int</span> field)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 GregorianCalendar 实例给定日历字段的最低的最大值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaximum</span><span class="params">(<span class="keyword">int</span> field)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 GregorianCalendar 实例的给定日历字段的最大值。</span></span></span><br><span class="line"><span class="function">Date <span class="title">getTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取日历当前时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getTimeInMillis</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获取用时间戳</span></span></span><br><span class="line"><span class="function">TimeZone <span class="title">getTimeZone</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获取时区。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinimum</span><span class="params">(<span class="keyword">int</span> field)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回给定字段的最小值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 重写hashCode.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">int</span> year)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 确定给定的年份是否为闰年。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">roll</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">boolean</span> up)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 用给定的值设置时间字段。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 设置年、月、日的值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 设置年、月、日、小时、分钟的值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 设置年、月、日、小时、分钟、秒的值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGregorianChange</span><span class="params">(Date date)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 设置 GregorianCalendar 的更改日期。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(Date date)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 用给定的日期设置Calendar的当前时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTimeInMillis</span><span class="params">(<span class="keyword">long</span> millis)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 用给定的long型毫秒数设置Calendar的当前时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTimeZone</span><span class="params">(TimeZone value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 用给定时区值设置当前时区。</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回代表日历的字符串。</span></span></span><br></pre></td></tr></table></figure><h2 id="2、JDK8之后"><a href="#2、JDK8之后" class="headerlink" title="2、JDK8之后"></a>2、JDK8之后</h2><p><strong>Calendar并不比Date好多少。它们面临的问题是：</strong></p><ul><li>可变性：像日期和时间这样的类应该是不可变的。</li><li>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</li><li>格式化：格式化只对Date有用，Calendar则不行。</li><li>此外，它们也不是线程安全的；不能处理闰秒等。</li></ul><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了日期时间和本地化的管理。</p><p><strong>新时间日期API</strong></p><ul><li>java.time – 包含值对象的基础包</li><li>java.time.chrono – 提供对不同的日历系统的访问</li><li>java.time.format – 格式化和解析时间和日期</li><li>java.time.temporal – 包括底层框架和扩展特性</li><li>java.time.zone – 包含时区支持的类</li></ul><h3 id="2-1、时间日期"><a href="#2-1、时间日期" class="headerlink" title="2.1、时间日期"></a>2.1、时间日期</h3><p>LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。 </p><ul><li>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。</li><li>LocalTime表示一个时间，而不是日期。 </li><li>LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">now() /  now(ZoneId zone)  <span class="comment">// 静态方法，根据当前时间创建对象/指定时区的对象</span></span><br><span class="line">of()                   <span class="comment">// 静态方法，根据指定日期/时间创建对象</span></span><br><span class="line">getDayOfMonth()/getDayOfYear() 获得月份天数(<span class="number">1</span>-<span class="number">31</span>) /获得年份天数(<span class="number">1</span>-<span class="number">366</span>)</span><br><span class="line">getDayOfWeek() 获得星期几(返回一个 DayOfWeek 枚举值)</span><br><span class="line">getMonth() 获得月份, 返回一个 Month 枚举值</span><br><span class="line">getMonthValue() / getYear() 获得月份(<span class="number">1</span>-<span class="number">12</span>) /获得年份</span><br><span class="line">getHour()/getMinute()/getSecond() 获得当前对象对应的小时、分钟、秒</span><br><span class="line">withDayOfMonth()/withDayOfYear()/</span><br><span class="line">withMonth()/withYear() 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</span><br><span class="line">plusDays(), plusWeeks(), </span><br><span class="line">plusMonths(), plusYears(),plusHours() 向当前对象添加几天、几周、几个月、几年、几小时</span><br><span class="line">minusMonths() / minusWeeks()/</span><br><span class="line">minusDays()/minusYears()/minusHours() 从当前对象减去几月、几周、几天、几年、几小时</span><br></pre></td></tr></table></figure><h3 id="2-2、瞬时"><a href="#2-2、瞬时" class="headerlink" title="2.2、瞬时"></a>2.2、瞬时</h3><p>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">now()   <span class="comment">// 静态方法，返回默认UTC时区的Instant类的对象</span></span><br><span class="line">ofEpochMilli(<span class="keyword">long</span> epochMilli) </span><br><span class="line"><span class="comment">// 静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象</span></span><br><span class="line">atOffset(ZoneOffset offset) <span class="comment">//结合即时的偏移来创建一个 OffsetDateTime</span></span><br><span class="line">toEpochMilli()              <span class="comment">//返回时间戳</span></span><br></pre></td></tr></table></figure><h3 id="2-3、格式化"><a href="#2-3、格式化" class="headerlink" title="2.3、格式化"></a>2.3、格式化</h3><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p><ul><li>预定义：如ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</li><li>本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)</li><li>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ofPattern(String pattern)  <span class="comment">// 指定字符串格式</span></span><br><span class="line">format(TemporalAccessor t) <span class="comment">// 格式化一个日期、时间，返回字符串</span></span><br><span class="line">parse(CharSequence text)   <span class="comment">// 将指定格式的字符序列解析为一个日期、时间</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(八):流式编程</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E5%85%AB%20)%20%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E5%85%AB%20)%20%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念及步骤"><a href="#1、概念及步骤" class="headerlink" title="1、概念及步骤"></a>1、概念及步骤</h2><p><strong>概念：</strong>可以对指定的集合执行非常复杂的查找、过滤和映射数据等操作</p><p><strong>使用步骤：</strong></p><ol><li>创建 Stream：一个数据源（如：集合、数组），获取一个流</li><li>中间操作：一个中间操作链，对数据源的数据进行处理</li><li>终止操作(终端操作) 一旦执行终止操作，就执行中间操作链，并产生结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(list.stream().filter((value)-&gt; value==<span class="string">&quot;1&quot;</span>).count());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、流的创建"><a href="#2、流的创建" class="headerlink" title="2、流的创建"></a>2、流的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、Collection方法 list.stream()</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span>          <span class="comment">// 返回一个顺序流</span></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span>  <span class="comment">// 返回一个并行流</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 2、Stream类的方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span>     <span class="comment">// 传入数组或者数组列表</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">empty</span><span class="params">()</span>             <span class="comment">// 产生空流</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span>    <span class="comment">// 函数式接口生成流</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T t)</span>     <span class="comment">// 创建只有一个元素的流</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// T作为函数式接口的参数,调用方法成为参数，这样无限递归    </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed,UnaryOperator&lt;T&gt; f)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，第二个函数用于判断是否结束流的创建    </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed,predicate&lt;? <span class="keyword">super</span> T&gt; hashNext ,UnaryOperator&lt;T&gt; f)</span>     </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 3、Arrays的方法   </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span>   <span class="comment">// 可以增加参数，让部分变成流</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 利用Stream的静态方法，把数组变成流</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(strs);</span><br><span class="line">        <span class="comment">// 利用Arrays的静态方法，把数组变成流，可以选择范围</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = Arrays.stream(strs,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建无限流方式1</span></span><br><span class="line">        Stream&lt;String&gt; stream3 = Stream.generate(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(Math.random());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建无限流方式2 ： 第一个元素f(n)，第二个f(f(n))，n为&quot;1&quot;</span></span><br><span class="line">        Stream&lt;String&gt; stream4 = Stream.iterate(<span class="string">&quot;1&quot;</span>,(n)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> n + <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建无限流方式3 ： 两个函数，函数1判断为false就结束流</span></span><br><span class="line">        Stream&lt;String&gt; stream5 = Stream.iterate(<span class="string">&quot;1&quot;</span>,(n)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(n.length()&lt;<span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,(n)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> n + <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、流的转换"><a href="#3、流的转换" class="headerlink" title="3、流的转换"></a>3、流的转换</h2><p><strong>流的转换会产生一个新流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选与切片</span></span><br><span class="line">filter(Predicate p)    <span class="comment">// 参数为lambda表达式，对流进行筛选</span></span><br><span class="line">distinct()             <span class="comment">// 根据流生成元素的hashcode和equals方法来去重</span></span><br><span class="line">limit(<span class="keyword">long</span> maxSieze)   <span class="comment">// 截断流让元素不超过一定数量</span></span><br><span class="line">skip(<span class="keyword">long</span> n)           <span class="comment">// 去除前n个元素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">sorted()               <span class="comment">// 按自然排序</span></span><br><span class="line">sorted(Comparator com) <span class="comment">// 按比较器排序，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射</span></span><br><span class="line">map(Function f)      <span class="comment">// 函数返回一个值，该值替换参数</span></span><br><span class="line">flatMap(Function f)  <span class="comment">//  函数返回一个流，把结果流拼接起来</span></span><br><span class="line">mapToDouble()        <span class="comment">// 同上，但是返回类型不同</span></span><br><span class="line">mapToInt()        </span><br><span class="line">mapToLong() </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">concat(Stream s1,Stream s2)</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><ul><li><p>filter：过滤不符合条件的，函数返回boolean类型</p></li><li><p>map：定义映射，函数返回类型为流里面数据的类型</p></li><li><p>floatmap：定义映射，函数返回类型为流</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">toStream</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            list.add(str.substring(i,i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;T,o,m&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;J,a,c,k&quot;</span>);</span><br><span class="line"><span class="comment">// 过滤长度小于1的</span></span><br><span class="line">        list.stream().filter((i)-&gt; &#123; </span><br><span class="line">            <span class="keyword">return</span> i.length() &gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 让所有参数加上1这个字符串                     </span></span><br><span class="line">        ).map((i)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="comment">// 把所有参数逗号分割开，结果转换成流    </span></span><br><span class="line">        &#125;).flatMap(str-&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> toStream(str);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>takewhile(function)：和 filter一样</li><li>dropwhile(function)：取所有不符合标准的</li></ul><h2 id="4、最终结果"><a href="#4、最终结果" class="headerlink" title="4、最终结果"></a>4、最终结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配与查找</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate p)</span>    <span class="comment">//检查是否匹配全部元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findFirst</span><span class="params">()</span>    <span class="comment">// 返回第一个元素</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findAny</span><span class="params">()</span>      <span class="comment">// 返回任意元素</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span>                        <span class="comment">// 返回总数</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">max</span><span class="params">(Comparator c)</span>    <span class="comment">// 传入比较器</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">min</span><span class="params">(Comparator c)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 过滤    </span></span></span><br><span class="line"><span class="function"><span class="title">mapping</span><span class="params">(Function f)</span>   <span class="comment">// 函数返回一个值，该值替换参数</span></span></span><br><span class="line"><span class="function"><span class="title">flatMap</span><span class="params">(Function f)</span>   <span class="comment">// 函数返回一个流，把结果流拼接起来</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 归约 t1,t2 -&gt; return</span></span></span><br><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T iden, BinaryOperator b)</span>   <span class="comment">// 把iden添加到流里计算</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator b)</span> </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 迭代  t -&gt; void</span></span></span><br><span class="line"><span class="function">Interator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span>    <span class="comment">// 产生迭代器    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(function)</span></span>;  </span><br><span class="line"><span class="comment">// 转换成数组</span></span><br><span class="line">Object[] toArray()</span><br><span class="line">T[] toArray(T[]::<span class="keyword">new</span>);   <span class="comment">// 传入构造器</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用Collectors的转换成集合  </span></span><br><span class="line">collect(Collectors.toList());  </span><br><span class="line">toList / toSet / toCollection</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Collectors计算 </span></span><br><span class="line"><span class="function">Long <span class="title">counting</span><span class="params">()</span>          <span class="comment">// 计算数量</span></span></span><br><span class="line"><span class="function">Integer <span class="title">summingInt</span><span class="params">()</span>     <span class="comment">// 对流中元素的整数属性求和</span></span></span><br><span class="line"><span class="function">Double <span class="title">veragingInt</span><span class="params">()</span>  <span class="comment">// 计算流中元素Integer属性的平均值</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">maxBy</span><span class="params">(Coompator)</span> <span class="comment">// 传入比较器</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">minBy</span><span class="params">(Coompator)</span></span></span><br><span class="line"><span class="function">String <span class="title">joining</span><span class="params">()</span>             <span class="comment">// 连接流中每个字符串 </span></span></span><br><span class="line"><span class="function"><span class="title">reducing</span><span class="params">()</span>                   <span class="comment">// 规约</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 映射到Map里面</span></span></span><br><span class="line"><span class="function">Map <span class="title">toMap</span><span class="params">(funcation1,function2)</span> <span class="comment">// 分别生成键和值  t-&gt; return   </span></span></span><br><span class="line"><span class="function">Map <span class="title">toConcurrentMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 分组</span></span></span><br><span class="line"><span class="function">Map&lt;K, List&lt;T&gt;&gt; <span class="title">groupingBy</span><span class="params">(function)</span> <span class="comment">// t-&gt;return 根据结果分组</span></span></span><br><span class="line"><span class="function">Map&lt;K, List&lt;T&gt;&gt; <span class="title">groupingByConcurrent</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">Map&lt;Boolean, List&lt;T&gt;&gt; <span class="title">partitioningBy</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 下游收集器，针对分组后里面的List处理 </span></span></span><br><span class="line"><span class="function">Map&lt;K, List&lt;T&gt;&gt; <span class="title">groupingBy</span><span class="params">(function,Collectors.方法()</span>)</span></span><br><span class="line"><span class="function"><span class="comment">// 先把结果进行处理，在执行方法 t -&gt; return    </span></span></span><br><span class="line"><span class="function">Collectors.<span class="title">collectingAndThen</span><span class="params">(Coolectors.方法()</span>,function)</span></span><br><span class="line"><span class="function">Collectors.<span class="title">counting</span><span class="params">()</span></span>;</span><br><span class="line">Collectors.summmingInt()</span><br><span class="line">Collectors.maxBy()</span><br><span class="line">Collectors.counting()</span><br></pre></td></tr></table></figure><ul><li>映射Map实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.stream().collect(Collectors.toMap((i)-&gt;&#123; </span><br><span class="line">        <span class="keyword">return</span> i.toString(); </span><br><span class="line">    &#125;,(i)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> i +<span class="number">1</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>collectingAndThen实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.stream().collect(Collectors.groupingBy((k)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;,Collectors.collectingAndThen(Collectors.counting(),(i)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、Optinal类型"><a href="#5、Optinal类型" class="headerlink" title="5、Optinal类型"></a>5、Optinal类型</h2><p>Optional<T>对象是一种包装器对象，要么包装了T的对象，要么没有包装任何对象，<strong>使用Optional可以很好的处理结果含有null的情况，</strong>通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">Optional.of(T t)  <span class="comment">// 创建一个 Optional 实例，t必须非空</span></span><br><span class="line">Optional.empty()  <span class="comment">// 创建一个空的 Optional 实例</span></span><br><span class="line">Optional.ofNullable(T t)  <span class="comment">// 可以为null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断对象是否包含值</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span>       <span class="comment">// 判断是否包含对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifresent</span><span class="params">(function)</span>   <span class="comment">// 不空执行函数，有参，有返回值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifPresentOrElse</span><span class="params">(function1,function2)</span></span>; <span class="comment">// 为空执行函数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤对象</span></span><br><span class="line"><span class="function">Optional <span class="title">map</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Optional <span class="title">flatMap</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function">Optional <span class="title">filter</span><span class="params">()</span>      <span class="comment">// 这三个函数与前面用法一致</span></span></span><br><span class="line"><span class="function">Optional <span class="title">or</span><span class="params">(function)</span>  <span class="comment">// 为空，使用函数(无参，有返回值)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 获取结果</span></span></span><br><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span>        <span class="comment">// 没有值抛出异常</span></span></span><br><span class="line"><span class="function">T <span class="title">orElse</span><span class="params">(T t)</span>  <span class="comment">// 没有值返回t</span></span></span><br><span class="line"><span class="function">T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span>  <span class="comment">// 没有值返回函数结果</span></span></span><br><span class="line"><span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSUpplier)</span>         </span></span><br></pre></td></tr></table></figure><h3 id="5-1、获取Optional值"><a href="#5-1、获取Optional值" class="headerlink" title="5.1、获取Optional值"></a>5.1、获取Optional值</h3><ul><li>供给函数式接口，无参，有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span>        <span class="comment">// 没有值抛出异常</span></span></span><br><span class="line"><span class="function">T <span class="title">orElse</span><span class="params">(T t)</span>  <span class="comment">// 没有值返回t</span></span></span><br><span class="line"><span class="function">T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span>  <span class="comment">// 没有值返回函数结果</span></span></span><br><span class="line"><span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSUpplier)</span>     </span></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 返回5</span></span><br><span class="line">    list.stream().max(Integer::compareTo).orElse(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 返回函数结果1</span></span><br><span class="line">    list.stream().max(Integer::compareTo).orElseGet(</span><br><span class="line">            ()-&gt;&#123; <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 返回一个异常</span></span><br><span class="line">    list.stream().max(Integer::compareTo).orElseThrow(</span><br><span class="line">            ()-&gt;&#123; <span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">&quot;没有数据&quot;</span>); &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2、判断Optional值"><a href="#5-2、判断Optional值" class="headerlink" title="5.2、判断Optional值"></a>5.2、判断Optional值</h3><ul><li>消费型函数式接口，有参，无返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span>       <span class="comment">// 判断是否包含对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifresent</span><span class="params">(function)</span>   <span class="comment">// 有参，有返回值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifPresentOrElse</span><span class="params">(function1,function2)</span></span>;</span><br><span class="line"><span class="comment">// 值为空，执行消费型函数function1，否则执行function2</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 不为空则输出i</span></span><br><span class="line">    list.stream().max(Integer::compareTo).ifPresent((i)-&gt;&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 不为空执行函数1，为空执行2</span></span><br><span class="line">    list.stream().max(Integer::compareTo).ifPresentOrElse((i)-&gt;&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;,()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="number">4</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3、处理Optional值"><a href="#5-3、处理Optional值" class="headerlink" title="5.3、处理Optional值"></a>5.3、处理Optional值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional <span class="title">map</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Optional <span class="title">flatMap</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">Optional <span class="title">filter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Optional <span class="title">or</span><span class="params">(function)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 为空，使用函数(无参，有返回值)产生一个新Optional</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.stream().max(Integer::compareTo).map((i)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    list.stream().max(Integer::compareTo).filter((i)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    list.stream().max(Integer::compareTo).or(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4、创建Optinal"><a href="#5-4、创建Optinal" class="headerlink" title="5.4、创建Optinal"></a>5.4、创建Optinal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional.of(T t)  <span class="comment">// 创建一个 Optional 实例，t必须非空</span></span><br><span class="line">Optional.empty()  <span class="comment">// 创建一个空的 Optional 实例</span></span><br><span class="line">Optional.ofNullable(T t)  <span class="comment">// 可以为null</span></span><br></pre></td></tr></table></figure><h3 id="5-5、转换成流"><a href="#5-5、转换成流" class="headerlink" title="5.5、转换成流"></a>5.5、转换成流</h3><p>通过stream() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = list.stream().max(Integer::compareTo).or(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(<span class="number">1</span>);</span><br><span class="line">&#125;).stream();</span><br></pre></td></tr></table></figure><h2 id="6、基本类型流"><a href="#6、基本类型流" class="headerlink" title="6、基本类型流"></a>6、基本类型流</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(七):IO流</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%83%20)%20IO%E6%B5%81/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%83%20)%20IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1、IO流分类简介"><a href="#1、IO流分类简介" class="headerlink" title="1、IO流分类简介"></a>1、IO流分类简介</h2><h3 id="1-1、分类"><a href="#1-1、分类" class="headerlink" title="1.1、分类"></a>1.1、分类</h3><blockquote><p>按照数据单位分类</p></blockquote><ul><li><strong>字节流（8bit）</strong>：处理一个字节</li><li><strong>字符流（16bit）</strong>：面向字节的流不便于处理Unicode形式的信息，而一个字符16字节专门处理Unicode字符</li></ul><blockquote><p>按照数据流向</p></blockquote><ul><li><strong>输入流：</strong>可以读取一个字节序列</li><li><strong>输出流：</strong>可以写入一个字节序列</li></ul><blockquote><p>安装流的角色</p></blockquote><ul><li>节点流</li><li>处理流</li></ul><h3 id="1-2、Java流分类"><a href="#1-2、Java流分类" class="headerlink" title="1.2、Java流分类"></a>1.2、Java流分类</h3><p><img src="/img/JavaSE/6.jpg"></p><h3 id="1-3、字节输入流：InputStream"><a href="#1-3、字节输入流：InputStream" class="headerlink" title="1.3、字节输入流：InputStream"></a>1.3、字节输入流：InputStream</h3><p>注意：InputStream是父类抽象类，有些方法没有具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据到输入流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>              <span class="comment">// 读取并返回一个字节到输入流，末尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;     <span class="comment">// 读取所有数据并且放到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="comment">// off开始，读到len</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readNBytes</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span>[] <span class="title">readAllBytes</span><span class="params">()</span> <span class="comment">// 读所有字节到输入流并返回数组</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 对输入流进行操作和分析    </span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(OutputStream out)</span> <span class="comment">// 转换成输出流并返回字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span>                 <span class="comment">// 输入流跳过n个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">available</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 标记 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span>   <span class="comment">// 在输入流当前位置打上标记</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span>               <span class="comment">// 返回到最后一个标记重写读取数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span>       <span class="comment">// 是否支持标记    </span></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> close    </span></span><br></pre></td></tr></table></figure><h3 id="1-4、字符输入流：Read"><a href="#1-4、字符输入流：Read" class="headerlink" title="1.4、字符输入流：Read"></a>1.4、字符输入流：Read</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">// 读取单个字符，范围在0 到65535之间,已到末尾返回-1 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 将字符读入数组。返回读取的数量，如果已到达流的末尾，则返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">//  将字符读入数组的某一部分。从off处开始存储，最多读len个字</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException  <span class="comment">// 关闭</span></span></span><br></pre></td></tr></table></figure><h3 id="1-5、字节输出流：OutputStream"><a href="#1-5、字节输出流：OutputStream" class="headerlink" title="1.5、字节输出流：OutputStream"></a>1.5、字节输出流：OutputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> n)</span>  <span class="comment">// 写出一个字节数据给n</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span>        <span class="comment">// 写出所有数据给字节数据byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off,<span class="keyword">int</span> len)</span>  <span class="comment">// 最多写出len个字节 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;  <span class="comment">// 需要先刷新，再关闭</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="1-6、字符输出流：Writer"><a href="#1-6、字符输出流：Writer" class="headerlink" title="1.6、字符输出流：Writer"></a>1.6、字符输出流：Writer</h3><ul><li>Writer 可以用字符串来替换字符数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span>     <span class="comment">// 写入字符数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span>                 <span class="comment">// 写入字符串。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="comment">// 写入一部分到字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="comment">//刷新该流的缓冲，则立即将它们写入预期目标。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><h3 id="1-7、注意点"><a href="#1-7、注意点" class="headerlink" title="1.7、注意点"></a>1.7、注意点</h3><p>Java流都实现了Closeable接口，可以使用 try-with-resource方式</p><h2 id="2、File类使用"><a href="#2、File类使用" class="headerlink" title="2、File类使用"></a>2、File类使用</h2><p><strong>File的作用：</strong></p><ul><li>文件和文件目录路径的抽象表示形式，与平台无关</li><li>新建、删除、重命名文件和目录</li><li>作为参数传递给流的构造器</li></ul><h3 id="2-1、创建File对象"><a href="#2-1、创建File对象" class="headerlink" title="2.1、创建File对象"></a>2.1、创建File对象</h3><ul><li>目录：</li><li>文件的路径：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以pathname为路径创建File对象，可以是**绝对路径或者相对路径，如果是相对路径，则默认的当前路径在系统属性user.dir中存储。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent,String child)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以parent为父路径，child为子路径创建File对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent,String child)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">// 根据一个父File对象和子文件路径创建File对象    </span></span></span><br></pre></td></tr></table></figure><ul><li>实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 根据路径创建File对象</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据父路径创建File对象</span></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo&quot;</span>,<span class="string">&quot;test\\1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据父File对象创建File对象</span></span><br><span class="line">    File file3 = <span class="keyword">new</span> File(file1,<span class="string">&quot;test\\2.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里不是文件名，所以会抛出异常</span></span><br><span class="line">    file1.createNewFile();</span><br><span class="line">    <span class="comment">// 创建文件</span></span><br><span class="line">    file2.createNewFile();</span><br><span class="line">    file3.createNewFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、File类方法"><a href="#2-2、File类方法" class="headerlink" title="2.2、File类方法"></a>2.2、File类方法</h3><ul><li>获取功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getAbsolutePath</span><span class="params">()</span> <span class="comment">// 获取绝对路径</span></span></span><br><span class="line"><span class="function">String <span class="title">getPath</span><span class="params">()</span>         <span class="comment">// 获取路径</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>         <span class="comment">// 获取名称</span></span></span><br><span class="line"><span class="function">String <span class="title">getParent</span><span class="params">()</span>       <span class="comment">// 获取上层文件目录路径。若无，返回null</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span>         <span class="comment">// 获取文件长度，不能是目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span>   <span class="comment">// 获取最后一次的修改时间，毫秒值</span></span></span><br><span class="line"><span class="function">String[] <span class="title">list</span><span class="params">()</span>       <span class="comment">// 目录下的所有文件或者目录的名称数组</span></span></span><br><span class="line"><span class="function">File[] <span class="title">listFiles</span><span class="params">()</span>    <span class="comment">// File数组</span></span></span><br></pre></td></tr></table></figure><ul><li>判断功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span>  <span class="comment">// 判断是否是文件目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span>       <span class="comment">// 判断是否是文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span>       <span class="comment">// 判断是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span>      <span class="comment">// 判断是否可读</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span>     <span class="comment">// 判断是否可写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span>     <span class="comment">// 判断是否隐藏</span></span></span><br></pre></td></tr></table></figure><ul><li>创建功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="comment">// 创建文件。若存在，则返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span>  <span class="comment">// 上层目录存在，file对象的目录不存在时创建</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> <span class="comment">// 创建文件目录。如果上层文件目录不存在，一并创建</span></span></span><br></pre></td></tr></table></figure><ul><li>修改功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span>  <span class="comment">// 把文件重命名为指定的文件路径</span></span></span><br></pre></td></tr></table></figure><ul><li>删除功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span>     <span class="comment">// 不进windows的回收站</span></span></span><br></pre></td></tr></table></figure><h2 id="3、文件流"><a href="#3、文件流" class="headerlink" title="3、文件流"></a>3、文件流</h2><h3 id="3-1、字节流"><a href="#3-1、字节流" class="headerlink" title="3.1、字节流"></a>3.1、字节流</h3><ul><li><p>FileInputStream 和  FileOutputStream</p></li><li><p>取出 1.txt  的内容写入到  2.txt</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件对象</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取文件流</span></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">    in.read(bytes);  <span class="comment">// 文件里的数据放到bytes里了</span></span><br><span class="line"></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\2.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出流</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file2);</span><br><span class="line">    <span class="comment">// 把数据写到输出流里面</span></span><br><span class="line">    out.write(bytes);</span><br><span class="line">    in.close();</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、字符流"><a href="#3-2、字符流" class="headerlink" title="3.2、字符流"></a>3.2、字符流</h3><ul><li>FileReader 和 FileWriter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得输入流</span></span><br><span class="line">    FileReader reader = <span class="keyword">new</span> FileReader(file1);</span><br><span class="line">    <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="comment">// 把内容写入到字符数组</span></span><br><span class="line">    reader.read(ch);</span><br><span class="line"></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\2.txt&quot;</span>);</span><br><span class="line">    FileWriter writer = <span class="keyword">new</span> FileWriter(file2);</span><br><span class="line">    <span class="comment">// 可以传入字符串，也可以传入字符数组</span></span><br><span class="line">    writer.write(ch);</span><br><span class="line">    writer.close();</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、缓冲流"><a href="#4、缓冲流" class="headerlink" title="4、缓冲流"></a>4、缓冲流</h2><p>为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类</p><p>时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。</p><p><strong>根据数据操作单位可以把缓冲流分为：</strong></p><ul><li>BufferedInputStream</li><li>BufferedOutputStream</li><li>BufferedReader </li><li>BufferedWriter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    FileReader inputStream = <span class="keyword">new</span> FileReader(file1);</span><br><span class="line">    <span class="comment">// 缓存流需要其他流的转换</span></span><br><span class="line">    BufferedReader in = <span class="keyword">new</span> BufferedReader(inputStream,<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">16</span>];</span><br><span class="line">    in.read(ch);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">        System.out.println(ch[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、转换流"><a href="#5、转换流" class="headerlink" title="5、转换流"></a>5、转换流</h2><p><strong>Java API提供了两个转换流：</strong></p><ul><li>InputStreamReader：将InputStream转换为Reader</li><li>OutputStreamWriter：将Writer转换为OutputStream</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in)</span>    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputSreamReader</span><span class="params">(InputStream in,String charsetName)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 参数二为字符集</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutputSreamWriter</span><span class="params">(OutputStream out,String charsetName)</span>    </span></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line"><span class="comment">// 把字节流转换成字符流</span></span><br><span class="line">    InputStreamReader in = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br><span class="line">    <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">16</span>];</span><br><span class="line">    in.read(ch);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">        System.out.println(ch[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字符编码</p></blockquote><p><strong>编码表：</strong></p><p>计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表，这就是编码表</p><p><strong>常见的编码表</strong></p><ul><li>ASCII：美国标准信息交换码。 用一个字节的7位可以表示。</li><li>ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。</li><li>GB2312：中国的中文编码表。最多两个字节编码所有字符</li><li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字</li><li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。<strong>所有的文字都用两个字节</strong>来表示。</li><li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</li></ul><p><strong>注意：</strong></p><ul><li>GBK等双字节编码方式，用最高位是1或0表示两个字节和一个字节</li><li>Unicode只是一种全球标准的字符集，定义了字符的集合和唯一编号，但是实际传输并没有使用，<strong>主要是使用是UTF-8和UTF-16</strong>，这是Unicode编码集的实现。</li></ul><p>编码：字符串     —-&gt;  字节数组</p><p>解码：字节数组  —-&gt; 字符串</p><h2 id="6、-标准输入、输出流"><a href="#6、-标准输入、输出流" class="headerlink" title="6、 标准输入、输出流"></a>6、 标准输入、输出流</h2><p><strong>标准输入输出流</strong></p><ul><li>System.in的类型是InputStream</li><li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</li></ul><p><strong>重定向</strong>：通过<strong>System类的setIn，setOut方法</strong>对默认设备进行改变</p><ul><li>public static void setIn(InputStream in)</li><li>public static void setOut(PrintStream out)</li></ul><p><strong>通过Scanner接收数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取密码可以通过Console,这样输入不可见。并且一次只能读一行</span></span><br><span class="line">    Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="comment">// 获取一行的输入 输入 124 d 读取 124 d</span></span><br><span class="line">    String str1 = in.nextLine();</span><br><span class="line">    System.out.println(str1);</span><br><span class="line">    <span class="comment">// 读取到空格 输入 124 d 读取 124</span></span><br><span class="line">    String str2 = in.next();</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">    <span class="comment">// 判断数据是否还有其他词 true</span></span><br><span class="line">    System.out.println(in.hasNext());</span><br><span class="line">    <span class="comment">// 直接获取下一个</span></span><br><span class="line">    System.out.println(in.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 BufferedReader</span></span><br><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();    </span><br></pre></td></tr></table></figure><p><strong>把输入流转换成其他流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入信息(退出输入e或exit):&quot;</span>);</span><br><span class="line">    <span class="comment">// 把&quot;标准&quot;输入流(键盘输入)这个字节流包装成字符流,再包装成缓冲流</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    String s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">// 读取用户输入的一行数据 --&gt; 阻塞程序</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(s) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;安全退出!!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="comment">// 将读取到的整行字符串转成大写输出</span></span><br><span class="line">            System.out.println(<span class="string">&quot;--&gt;:&quot;</span> + s.toUpperCase());</span><br><span class="line">            System.out.println(<span class="string">&quot;继续输入信息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                br.close(); <span class="comment">// 关闭过滤流时,会关闭它包装的底层节点流</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、打印流"><a href="#7、打印流" class="headerlink" title="7、打印流"></a>7、打印流</h2><p><strong>PrintStream</strong>和<strong>PrintWriter</strong></p><ul><li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li><li>PrintStream和PrintWriter的输出不会抛出IOException异常</li><li>PrintStream和PrintWriter有自动flush功能</li></ul><h2 id="8、数据流"><a href="#8、数据流" class="headerlink" title="8、数据流"></a>8、数据流</h2><ul><li>方便地操作Java语言的基本数据类型和String的数据</li><li>数据流有两个类：(用于读取和写出基本数据类型、String类型DataInputStream 和 DataOutputStream分别套接在 InputStream和OutputStream子类的流上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataInputStream中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span>  <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span>        <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span>    <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span>        <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">readUTF</span><span class="params">()</span>       <span class="keyword">void</span> <span class="title">readFully</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span></span><br><span class="line"><span class="function"><span class="comment">// DataOutputStream中的方法,换成write   </span></span></span><br></pre></td></tr></table></figure><h2 id="9、对象流"><a href="#9、对象流" class="headerlink" title="9、对象流"></a>9、对象流</h2><p><strong>ObjectInputStream和OjbectOutputSteam</strong></p><ul><li>用于存储和读取<strong>基本数据类型</strong>数据或<strong>对象</strong>的处理流。</li><li>可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li></ul><h3 id="9-1、序列化"><a href="#9-1、序列化" class="headerlink" title="9.1、序列化"></a>9.1、序列化</h3><ul><li><strong>序列化：</strong>用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</li><li><strong>反序列化：</strong>用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制</li></ul><p>注意：不能序列化static和transient修饰的成员变量</p><p><strong>优点：</strong></p><ul><li>把内存中的Java对象转换成<strong>平台无关</strong>的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。</li><li>可将任何实现了Serializable接口的对象转化为<strong>字节数据</strong>，使其在保存和传输时可被还原</li></ul><p><strong>实现</strong>：</p><p>​        必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。</p><ul><li>Serializable</li><li>Externalizable</li></ul><p><strong>原理：</strong></p><ul><li><p>实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID;</span><br><span class="line"><span class="comment">// 表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容</span></span><br><span class="line"><span class="comment">// 值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明</span></span><br></pre></td></tr></table></figure></li><li><p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，<strong>如果相同就认为是一致的，可以进行反序列化</strong>，否则就会出现序列化版本不一致的异常。(InvalidCastException)</p></li></ul><h3 id="9-2、使用对象流序列化对象"><a href="#9-2、使用对象流序列化对象" class="headerlink" title="9.2、使用对象流序列化对象"></a>9.2、使用对象流序列化对象</h3><p>序列化写入文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">    ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    out.writeObject(user);  <span class="comment">// 把对象写入</span></span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Demo\\test\\1.txt&quot;</span>);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">User user = (User) in.readObject();</span><br><span class="line">System.out.println(user); <span class="comment">// 获取对象</span></span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、NIO"><a href="#10、NIO" class="headerlink" title="10、NIO"></a>10、NIO</h2><h3 id="10-1、简介"><a href="#10-1、简介" class="headerlink" title="10.1、简介"></a>10.1、简介</h3><ul><li>NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。</li><li>NIO将以更加高效的方式进行文件的读写操作。</li><li>Java API中提供了两套NIO，<strong>一套是针对标准输入输出NIO，另一套就是网络编程NIO</strong></li><li>JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。</li></ul><h3 id="10-2、Path、Paths和Files核心API"><a href="#10-2、Path、Paths和Files核心API" class="headerlink" title="10.2、Path、Paths和Files核心API"></a>10.2、Path、Paths和Files核心API</h3><ul><li>FIle的功能不足，并且不会提供异常信息</li><li>Path接口：可以看成是File类的升级，代表一个平台无关的平台路径</li></ul><p><strong>Paths方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Path <span class="title">get</span><span class="params">(String first, String … more)</span> <span class="comment">// 用于将多个字符串串连成路径</span></span></span><br><span class="line"><span class="function">Path <span class="title">get</span><span class="params">(URI uri)</span>    <span class="comment">// 返回指定uri对应的Path路径</span></span></span><br></pre></td></tr></table></figure><p><strong>Path方法：获取信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span>  <span class="comment">// 返回调用 Path 对象的字符串表示形式</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String path)</span> <span class="comment">// 判断是否以 path 路径开始</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String path)</span> <span class="comment">// 判断是否以 path 路径结束</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAbsolute</span><span class="params">()</span> <span class="comment">// 判断是否是绝对路径</span></span></span><br><span class="line"><span class="function">Path <span class="title">getParent</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"><span class="comment">// 返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</span></span></span><br><span class="line"><span class="function">Path <span class="title">getRoot</span><span class="params">()</span>        <span class="comment">// 返回调用 Path 对象的根路径</span></span></span><br><span class="line"><span class="function">Path <span class="title">getFileName</span><span class="params">()</span>    <span class="comment">// 返回与调用 Path 对象关联的文件名</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNameCount</span><span class="params">()</span>    <span class="comment">// 返回Path 根目录后面元素的数量</span></span></span><br><span class="line"><span class="function">Path <span class="title">getName</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="comment">// 返回指定索引位置 idx 的路径名称</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Path <span class="title">toAbsolutePath</span><span class="params">()</span> <span class="comment">// 作为绝对路径返回调用 Path 对象</span></span></span><br><span class="line"><span class="function">Path <span class="title">resolve</span><span class="params">(Path p)</span>  <span class="comment">// 合并两个路径，返回合并后的路径对应的Path对象</span></span></span><br><span class="line"><span class="function">File <span class="title">toFile</span><span class="params">()</span>         <span class="comment">// 将Path转化为File类的对象</span></span></span><br></pre></td></tr></table></figure><p><strong>Files类：用于操作文件或目录的工具类</strong></p><ul><li>常用方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="function">Path <span class="title">createDirectory</span><span class="params">(Path path, FileAttribute&lt;?&gt; … attr)</span>  <span class="comment">// 目录  </span></span></span><br><span class="line"><span class="function">Path <span class="title">createFile</span><span class="params">(Path path, FileAttribute&lt;?&gt; … arr)</span>        <span class="comment">// 文件</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Path path)</span>         <span class="comment">// 删除一个文件/目录，不存在则报错</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteIfExists</span><span class="params">(Path path)</span> <span class="comment">// 不存在不报错</span></span></span><br><span class="line"><span class="function"><span class="comment">// 移动</span></span></span><br><span class="line"><span class="function">Path <span class="title">copy</span><span class="params">(Path src, Path dest, CopyOption … how)</span> <span class="comment">// 文件的复制    </span></span></span><br><span class="line"><span class="function">Path <span class="title">move</span><span class="params">(Path src, Path dest, CopyOption…how)</span> <span class="comment">// 移动到 dest</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">size</span><span class="params">(Path path)</span>           <span class="comment">// 返回 path 指定文件的大小</span></span></span><br></pre></td></tr></table></figure><ul><li>判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(Path path, LinkOption … opts)</span>        <span class="comment">// 是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">(Path path, LinkOption … opts)</span>   <span class="comment">// 是否是目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRegularFile</span><span class="params">(Path path, LinkOption … opts)</span> <span class="comment">// 是否是文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">(Path path)</span>   <span class="comment">// 判断是否是隐藏文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">(Path path)</span> <span class="comment">// 判断文件是否可读</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">(Path path)</span> <span class="comment">// 判断文件是否可写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">notExists</span><span class="params">(Path path, LinkOption … opts)</span> <span class="comment">// 是否不存在</span></span></span><br></pre></td></tr></table></figure><ul><li>操作内容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SeekableByteChannel <span class="title">newByteChannel</span><span class="params">(Path path, OpenOption…how)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获取与指定文件的连接，how 指定打开方式。</span></span></span><br><span class="line"><span class="function">DirectoryStream&lt;Path&gt; <span class="title">newDirectoryStream</span><span class="params">(Path path)</span> :</span></span><br><span class="line"><span class="function"><span class="comment">// 打开 path 指定的目录</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">newInputStream</span><span class="params">(Path path, OpenOption…how)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">// 获取 InputStream 对象</span></span></span><br><span class="line"><span class="function">OutputStream <span class="title">newOutputStream</span><span class="params">(Path path, OpenOption…how)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获取 OutputStream 对象</span></span></span><br></pre></td></tr></table></figure><h2 id="11、BIO、NIO、和AIO"><a href="#11、BIO、NIO、和AIO" class="headerlink" title="11、BIO、NIO、和AIO"></a>11、BIO、NIO、和AIO</h2><p><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写⼊必须阻塞在⼀个线程内等待其完<br>成。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型是⽐᫾不错的，可以<br>让每⼀个连接专注于⾃⼰的 I/O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问<br>题。线程池本身就是⼀个天然的漏⽃，可以缓冲⼀些系统处理不了的连接或请求。但是，当<br>⾯对⼗万甚⾄百万级连接的时候，传统的 BIO 模型是⽆能为⼒的。因此，我们需要⼀种更⾼<br>效的 I/O 处理模型来应对更⾼的并发量。<br><strong>NIO (Non-blocking/New I/O):</strong> NIO 是⼀种同步⾮阻塞的 I/O 模型，在 Java 1.4 中引⼊了<br>NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以<br>理解为 Non-blocking，不单纯是 New。它⽀持⾯向缓冲的，基于通道的 I/O 操作⽅法。<br>NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和<br>ServerSocketChannel 两种不同的套接字通道实现,两种通道都⽀持阻塞和⾮阻塞两种模式。<br>阻塞模式使⽤就像传统中的⽀持⼀样，⽐᫾简单，但是性能和可靠性都不好；⾮阻塞模式正<br>好与之相反。对于低负载、低并发的应⽤程序，可以使⽤同步阻塞 I/O 来提升开发速率和更<br>好的维护性；对于⾼负载、⾼并发的（⽹络）应⽤，应使⽤ NIO 的⾮阻塞模式来开发<br><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引⼊了 NIO 的改进版 NIO 2,它<br>是异步⾮阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应⽤操作之后会直<br>接返回，不会堵塞在那⾥，当后台处理完成，操作系统会通知相应的线程进⾏后续的操作。<br>AIO 是异步 IO 的缩写，虽然 NIO 在⽹络操作中，提供了⾮阻塞的⽅法，但是 NIO 的 IO ⾏<br>为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就<br>由这个线程⾃⾏进⾏ IO 操作，IO 操作本身是同步的。查阅⽹上相关资料，我发现就⽬前来<br>说 AIO 的应⽤还不是很⼴泛，Netty 之前也尝试使⽤过 AIO，不过⼜放弃了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(六):注解</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E5%85%AD%20)%20%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E5%85%AD%20)%20%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><ul><li>JDK5.0开始引入</li><li>作用类似于注释，可以对程序<strong>作出解释</strong>，这些信息可以在编译、类加载、运行时被读取</li><li>通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息，现在的主流Java框架均大量使用注解，可以这么说：<strong>框架 = 注解 + 反射 + 设计模式</strong></li></ul><h2 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h2><h3 id="2-1、内置注解："><a href="#2-1、内置注解：" class="headerlink" title="2.1、内置注解："></a>2.1、内置注解：</h3><p>​        比如@Override、@Depercated、@SuppressWarnings等等，在Java代码能经常看到</p><p>​        如**@Override**就是表明该方法是重写了父类的方法。</p><h3 id="2-2、元注解："><a href="#2-2、元注解：" class="headerlink" title="2.2、元注解："></a>2.2、元注解：</h3><p>​        负责<strong>注解其他注解</strong>，为meta-annotation类型，一共有4个，通过元注解就可以自定义注解，上面提到的Java内置注解其实就是Java预先用元注解帮我们定义好的，基本的4个元注解的作用如下</p><ol><li><code>@Target</code>：描述注解的使用范围</li><li><code>@Rentention</code>：描述该注解的生命周期，即在什么时候有效</li><li><code>@Document</code>：说明该注解将被包含在Javadoc中</li><li><code>@Inherited</code>：说明子类可以继承父类中的注解</li></ol><p><strong>@Target、@Rentention都是有参数的，各参数的定义如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="comment">// 形式：ElementType. 后面加上参数</span></span><br><span class="line"><span class="comment">// 当然也可以直接写参数 TYPE，不写前面的ElementType，不过需要import 静态常量</span></span><br></pre></td></tr></table></figure><ul><li><code>TYPE</code> : 类、接口或enum声明</li><li><code>FIELD</code>: 域(属性)声明</li><li><code>METHOD</code>: 方法声明</li><li><code>PARAMETER</code>: 参数声明</li><li><code>CONSTRUCTOR</code>: 构造方法声明 LOCAL_VARIABLE:局部变量声明</li><li><code>ANNOTATION_TYPE</code>:注释类型声明</li><li><code>PACKAGE</code>: 包声明</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br></pre></td></tr></table></figure><ul><li><code>SOURCE</code>:在源文件中有效（即源文件保留），编译器直接丢弃</li><li><code>CLASS</code>:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM不会保留注解</li><li><code>RUNTIME</code>：在运行时有效（即运行时保留），当运行 Java程序, JVM会保留注释，此时可以通过反射获取注解。</li></ul><h3 id="2-3、自定义注解"><a href="#2-3、自定义注解" class="headerlink" title="2.3、自定义注解"></a>2.3、自定义注解</h3><h2 id="3、自定义注解"><a href="#3、自定义注解" class="headerlink" title="3、自定义注解"></a>3、自定义注解</h2><h3 id="3-1、实例："><a href="#3-1、实例：" class="headerlink" title="3.1、实例："></a>3.1、实例：</h3><p>定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> &quot;20&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(age = &quot;30&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、分析"><a href="#3-2、分析" class="headerlink" title="3.2、分析"></a>3.2、分析</h3><p>注解的格式： public @interface 注解名 {   定义体  }     <strong>并且再加上元注解</strong></p><p><strong>这里我们先：</strong></p><ol><li>使用  <strong>@Retention(RetentionPolicy.RUNTIME)</strong>   表明 该注解是在 运行时 有效的</li><li>使用  <strong>@Target(ElementType.TYPE)</strong>  表明该接口定义在  类、接口或enum上</li><li>指定名称为  MyAnnotation</li></ol><p><strong>接着定义方法体的内容：</strong></p><ul><li>String age() default “20”; 表明定义了一个参数，名字为age，类型为String，默认值为20(可以不用默认值)</li></ul><p><strong>使用：</strong></p><ul><li>@MyAnnotation(age = “30”) 使用注解，给参数age赋值30并且标记在test<strong>类</strong>上面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法体里面的类型是数组时</span></span><br><span class="line">String[] value();</span><br><span class="line"><span class="meta">@MyAnnotation(&#123;&quot;4&quot;,&quot;1&quot;&#125;)</span></span><br><span class="line">myAnnotation.value()[<span class="number">0</span>];   <span class="comment">// myAnnotation为通过反射获取的注解对象</span></span><br></pre></td></tr></table></figure><blockquote><p>注意点</p></blockquote><ul><li>类型只能是基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组</li><li>没有成员定义的 Annotation 称为<strong>标记</strong>; 包含成员变量的 Annotation 称为<strong>元数据</strong> Annotation</li><li>如果只有一个注解，可以这么定义：String value() default “20”  ，这样使用时可以@MyAnnotation(“30”)</li></ul><h2 id="4、Java8新增特性"><a href="#4、Java8新增特性" class="headerlink" title="4、Java8新增特性"></a>4、Java8新增特性</h2><h3 id="4-1、可重复注解"><a href="#4-1、可重复注解" class="headerlink" title="4.1、可重复注解"></a>4.1、可重复注解</h3><p>​        在 Java 8 之前我们不能在<code>同一个类</code>、<code>同一方法</code>上重复使用同一个注解，在 JDK 8 中引入了一个注解<code> @Repeatable</code> 来标识某个注解是可被重复使用的，但是需要一个容器注解</p><p><strong>使用：</strong></p><p>定义可重复的注解容器注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(MyTests.class)</span></span><br><span class="line"><span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个可以重复的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyTests &#123;</span><br><span class="line">    MyTest[] value();       <span class="comment">//这是重复的容器注解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyTest(&quot;1&quot;)</span></span><br><span class="line"><span class="meta">@MyTest(&quot;2&quot;)</span></span><br><span class="line"><span class="meta">@MyTest(&quot;3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射获取注解并输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test表示使用注解的那个类</span></span><br><span class="line">    <span class="comment">// 反射是通过MyTest来获取，而不是通过容器注解来获取</span></span><br><span class="line">    MyTest[] annotationsByType = test.class.getAnnotationsByType(MyTest.class);</span><br><span class="line">    <span class="keyword">for</span> (MyTest myTest: annotationsByType) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类上的注解:&quot;</span>+myTest.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的理解：</p><ul><li>要让A注解支持重复注解，需要新定义B注解，里面属性的名为value，返回数组，类型为A注解。</li></ul><h3 id="4-2、类型注解"><a href="#4-2、类型注解" class="headerlink" title="4.2、类型注解"></a>4.2、类型注解</h3><p>DK 8 为 @Target 元注解新增了两种类型：<code>TYPE_PARAMETER</code>、<code>TYPE_USE</code></p><ol><li><p><code>TYPE_PARAMETER</code>：表示该注解能够写在 声明为 <code>泛型</code> 的语句中，类型参数声明如：<T>、&lt;T extends 某个类&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.TYPE_PARAMETER:表示注解能够放在泛型上面</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_PARAMETER)</span></span><br><span class="line"><span class="meta">@interface</span> TypeParam&#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用，</span></span><br><span class="line"><span class="keyword">public</span> &lt;<span class="meta">@TypeParam</span> T&gt; <span class="function">T <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>TYPE_USE</code>：表示注解可以用在[任何用到类型]的地方使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示注解可以用在[任何用到类型]的地方使用</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_USE)</span></span><br><span class="line"><span class="meta">@interface</span> NotNull&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@NotNull</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(五):异常处理</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%BA%94%20)%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E4%BA%94%20)%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1、处理错误"><a href="#1、处理错误" class="headerlink" title="1、处理错误"></a>1、处理错误</h2><p>Java程序运行区间，可能会出现错误，出现错误后，导致任务没有完成，程序应该：</p><ul><li>返回安全状态，让程序能运行其他命令</li><li>允许用户保存所有工作的结果，并以妥善的方式终止程序</li></ul><p>但是通常情况下很难实现，因为出现错误的代码，离实现上述功能的代码之间没有联系，依次引入了异常处理，异常处理就是将控制权从产生错误的地方<strong>转移到能正常处理这种情况的错误处理器</strong></p><p>为了能正确处理错误，需要考虑以下问题：</p><ul><li>用户输入错误</li><li>设备错误：硬件可能出现问题</li><li>物理限制：如堆内存溢出oom</li><li>代码错误：</li></ul><p>通常对于错误是返回一个错误码，如读取不到文件返回 - 1，但是并不是任何情况都能够返回一个错误码，所以异常处理机制没有采用返回值，而是选择遇到错误时，会通过一个路径退出方法，该方法抛出一个<strong>封装了错误信息</strong>的对象，需要注意的是，该方法会立即退出，并且原调用该方法的代码不会接着执行，而是会搜索能够处理这种异常状态的<strong>异常处理器</strong></p><h2 id="2、异常分类"><a href="#2、异常分类" class="headerlink" title="2、异常分类"></a>2、异常分类</h2><p>Throwable类是所有<strong>异常类</strong>的 ‘ 祖先’ ，即所有异常类都是由Throwable继承而来</p><p>Throwable有两个子类：Error（错误）、Exception（异常）</p><p>Exception有两个子类：：IOException 和 RuntimeException</p><p><strong>注意点</strong>：</p><ul><li>Error：不必处理，因为处理不了</li><li>RuntimeException：主要是由编程导致的异常，如数组越界，一般情况下是由于代码导致的，也就是其实可以通过良好的代码避免的，所以<strong>不要求强制处理</strong></li></ul><p>因此：Java把Error和RuntimeException划分为 <strong>非检查型异常，</strong>不一定要处理。但是其他的<strong>检查性异常则必须处理</strong>，一般都是处理IOException。</p><blockquote><p>异常方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span>     <span class="comment">// 返回关于发生的异常的详细信息。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Throwable <span class="title">getCause</span><span class="params">()</span>    <span class="comment">// 返回一个Throwable 对象代表异常原因。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span>  <span class="comment">// 打印toString()结果和栈层次到System.err，即错误输出流。</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StackTraceElement [] <span class="title">getStackTrace</span><span class="params">()</span>          </span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</span></span></span><br></pre></td></tr></table></figure><h2 id="3、异常处理"><a href="#3、异常处理" class="headerlink" title="3、异常处理"></a>3、异常处理</h2><h3 id="2-1、try-catch-finally处理"><a href="#2-1、try-catch-finally处理" class="headerlink" title="2.1、try-catch-finally处理"></a>2.1、try-catch-finally处理</h3><p>try中的代码发生异常时，若发生的异常包含在catch块中(catch块的参数),会转到catch代码块执行，执行完catch后，<code>跳过try剩余的代码，继续往后执行</code>，finally 无论是否发生异常，都会被执行。</p><p><strong>注意：</strong>当 try 语句和 finally 语句中都有 return 语句时，在⽅法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;Access element three :&quot;</span> + a[<span class="number">3</span>]);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 很明显数组越界，出现异常</span></span><br><span class="line">输出结果：java.lang.ArrayIndexOutOfBoundsException: <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>在try/catch 后面添加 finally 块并非强制性要求的。</li><li>try, catch, finally 块之间不能添加任何代码。</li><li>程序发生异常时，会生成异常对象，捕获得是异常对象（此例中的e）</li><li>catch捕获的异常对象，可以是具体的们<code>也可以是其父类</code>，所以Exception e万能</li><li><strong>重写方法不能抛出比被重写方法范围更大的异常类型</strong>。</li></ol><blockquote><p>finally不会被执行的情况</p></blockquote><ul><li>线程死亡</li><li>外部原因：如CPU出问题等等</li><li>在 try 或 finally 块中⽤了 System.exit(int) 退出程序。但是，如果 System.exit(int) 在异常语句之后， finally 还是会被执⾏</li></ul><p><strong>多重捕获异常</strong>：一个 try 代码块后面跟随多个 catch 代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、throws-把异常向上抛出"><a href="#2-2、throws-把异常向上抛出" class="headerlink" title="2.2、throws 把异常向上抛出"></a>2.2、throws 把异常向上抛出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把异常用throws抛出</span></span><br><span class="line"><span class="comment">// 格式：throws + 异常类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>抛出并不能从根本解决问题，如本例中eat方法被调用时，调用者必须<code>捕获异常</code>，或者继续抛出。</li><li>如果一直到main方法里，还继续抛出的话，发生异常就会由JVM处理，导致程序中断</li></ol><h2 id="4、自定义异常"><a href="#4、自定义异常" class="headerlink" title="4、自定义异常"></a>4、自定义异常</h2><p><strong>throws 是把异常向上抛出</strong></p><p><strong>throw   是人为抛出异常</strong>：使用throw关键字人为的抛出一个异常，程序执行到throw语句时立即停止，抛出时直接抛出<strong>异常类的实例化对象</strong>即可</p><p><strong>案例1：抛出异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 人为抛出的异常也需要捕获</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line">输出结果：java.lang.Exception: 抛出异常</span><br></pre></td></tr></table></figure><p><strong>案例2：自定义异常</strong></p><ul><li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li><li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类</li></ul><p><strong>自定义异常类：</strong>该类含有money的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常类必须继承现有的异常类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line">    <span class="comment">// 初始化，给money赋初始值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取剩余的钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义银行类：</strong>定义抛出异常的规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="comment">// 模拟取钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getmoney</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果余额笔要去的大，就可以取出，不然抛出自定义异常</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.balance&gt;balance)&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = <span class="keyword">this</span>.balance - balance;</span><br><span class="line">            System.out.println(<span class="string">&quot;取了&quot;</span>+balance);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;钱不够&quot;</span>);</span><br><span class="line">            <span class="comment">// 此处也要捕获异常</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 并抛出 自定义异常类的对象</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MyException(balance - <span class="keyword">this</span>.balance);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">                <span class="comment">// 根据捕获的对象，我们可以获取money信息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;缺少&quot;</span>+e.getMoney()+<span class="string">&quot;元钱&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟存钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmoney</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = <span class="keyword">this</span>.balance + balance;</span><br><span class="line">        System.out.println(<span class="string">&quot;存了&quot;</span> + balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bank bank = <span class="keyword">new</span> Bank(<span class="number">1</span>);</span><br><span class="line">bank.setmoney(<span class="number">3000</span>);   <span class="comment">// 存钱</span></span><br><span class="line">bank.getmoney(<span class="number">3001</span>);   <span class="comment">// 取钱超过存钱，触发抛出异常</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>注意抛出的是对象，所以可以通过<code>e.getMoney获取</code>到money的值</li><li>同理抛出异常对象的时候，由于自定义异常类只有有参构造，所以必须传参</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(四):泛型</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E5%9B%9B%20)%20%E6%B3%9B%E5%9E%8B/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E5%9B%9B%20)%20%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1、泛型简介"><a href="#1、泛型简介" class="headerlink" title="1、泛型简介"></a>1、泛型简介</h2><p>泛型程序设计，意味着编写的代码可以对多种不同的类型的对象重用，例如ArrayList不仅可以存String，还可以存Integer等等多种类型。</p><p><strong>泛型之前：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义，没有指定数据类型</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p>ArrayList维护了一个Object类型的数组，再这个数组上进行操作，但是存在问题</p><ul><li>获取值必须要转换类型</li><li>没有类型检查，可以向 Object[] 数组添加任何数据，但是这样取数据就会出错</li></ul><p><strong>泛型之后</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定数据类型</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>编译器通过泛型知道了数据的类型，就无须进行类型转换了，并且可以检查加入数据的类型是否正确</li><li>让程序更加易读，更加安全</li></ul><p><strong>通配符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个员工类</span></span><br><span class="line">ArrayList&lt;Employee&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 定义一个经理类，经理继承子员工</span></span><br><span class="line">ArrayList&lt;Manage&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>很显然，如果要把 list2 的数据添加到 list1 中，是可以的，Manage可以向上转型成 Employee，但是反过来则不行，泛型通配符就可以解决这一问题</p><h2 id="1-2、简单泛型类"><a href="#1-2、简单泛型类" class="headerlink" title="1.2、简单泛型类"></a>1.2、简单泛型类</h2><ul><li>Java内置库使用E表示集合的元素类型，K、V表示键、值，T表示任意类型</li><li>泛型类相当于普通类的工厂</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样就不必为了存储什么类型而担忧了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.second = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo1</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 省略get、set方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化需要指定类型</span></span><br><span class="line">Demo1&lt;String&gt; demo1 = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="1-3、泛型方法"><a href="#1-3、泛型方法" class="headerlink" title="1.3、泛型方法"></a>1.3、泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T...a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(Demo1.&lt;Integer&gt;getMiddle(a)); <span class="comment">// 实际可以把&lt;Integer&gt;省略</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Demo1.getMiddle(<span class="number">1.4</span>,<span class="number">1.3</span>,<span class="number">2</span>) <span class="keyword">instanceof</span> Double);</span><br></pre></td></tr></table></figure><ul><li>若为这种形式，编译器会自动装箱成Double，Double，Integer，然后转成Double</li></ul><h2 id="1-4、类型变量的限定"><a href="#1-4、类型变量的限定" class="headerlink" title="1.4、类型变量的限定"></a>1.4、类型变量的限定</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限定只有实现了Comparable接口的才能排序,注意这里使用extends并不代表一定是继承</span></span><br><span class="line"><span class="comment">// T extends A &amp; B      多个限定这种形式，注意继承的话要放第一个</span></span><br><span class="line"><span class="comment">// T extends Comparable,R extends String   多个用这种形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">compare</span><span class="params">(T...a)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;进行比较&quot;</span>);</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    <span class="keyword">for</span> (T num: a) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">9</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Demo1.compare(a);</span><br></pre></td></tr></table></figure><h2 id="1-5、泛型原理"><a href="#1-5、泛型原理" class="headerlink" title="1.5、泛型原理"></a>1.5、泛型原理</h2><blockquote><p>类型擦除</p></blockquote><p>无论何时定义一个泛型类型，都会自动提供一个相应的原始类型，原始类型就是去掉泛型参数后的泛型类型名，<strong>类型变量会被擦除</strong>，并替换为其限定类型</p><p><strong>原理：</strong></p><ul><li>编译器会检查 数据类型的一致性，若不一致，则编译不通过，无法编译</li><li>若编译通过，代表类型一致，进行泛型擦除</li></ul><p><strong>1.2中的Demo1类在擦除后</strong>：</p><ul><li>Demo1 底层会把 T <strong>全部转换成Object</strong></li><li>添加数据时，编译器会做数据类型校验，若指定的是 Demo1<String>，只有String类型才能通过编译。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为T是一个没有限定的变量，所以直接用Object替代</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.second = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo1</span><span class="params">(Object first, Object second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 省略get、set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.4中如下</p><ul><li>底层会把 T <strong>全部转换成Comparable</strong></li><li>添加数据时，编译器会做数据类型校验，<ul><li>首先指定的类型必须实现Comparable接口，</li><li>接着若指定的是 Demo1<String>，只有String类型才能通过编译。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来限定必须实现Comparable接口，擦除后直接把T替换成Comparable</span></span><br><span class="line"><span class="comment">// 编译器判断数据是不是 Comparable 的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(Comparable...a)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;进行比较&quot;</span>);</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    <span class="keyword">for</span> (Comparable num: a) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>转换泛型表达式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原本这么定义</span></span><br><span class="line">Demo1&lt;String&gt; demo1 = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br><span class="line">String name = demo.getFirst(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实getFirst()返回的是Object类型，但是编译器会帮我们转换</span></span><br><span class="line">String name = (String) demo.getFirst();</span><br></pre></td></tr></table></figure><blockquote><p>泛型方法多态性保证</p></blockquote><p><strong>方法类型擦除后会造成一些问题，如下所示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo2继承了Demo1类，并且泛型为Date类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">Demo1</span>&lt;<span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 因为指定父类了父类类型Date才能这么做，不然会报错</span></span><br><span class="line">        Date date = getFirst();</span><br><span class="line">        System.out.println(date +<span class="string">&quot; &quot;</span> + second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 擦除类型后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显然Demo2除了自己的方法，还有继承而来的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很明显是两个不同的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">Demo1</span>&lt;<span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 子类本身方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从父类继承的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试成功通过，输出子类方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo1&lt;Date&gt; demo1 = <span class="keyword">new</span> Demo2();</span><br><span class="line">        demo1.setSecond(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式在普通代码能实现多态，<strong>但是泛型类里要考虑一个问题</strong>，就是父子类的参数不同，不构成重写，这样本来应该两个类冲突的，但是为什么没有冲突，又是如何保持多态的？<strong>桥方法解决</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会在Demo2里面生成一个新的桥方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setSecond((Date) second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 Demo2 的方法 嵌套进 Demo1 的方法 里面，这样调用的是实际是Dmeo 2 的方法</p><blockquote><p>泛型擦除后的方法重复问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入定义的是这样</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子类方法&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 很显然，类型擦除后Demo2 会有两个方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子类方法&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 来自父类Demo1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，由于返回值不构成重载，这被认为是一个方法，但是为什么不报错？</p><p><strong>原因：</strong>JVM虚拟机<strong>会根据返回值判断</strong>是不是同一个方法</p><blockquote><p>桥方法解决协变问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 桥方法适用广泛</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CLone........</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Employee会有两个clone类,称为有协变的返回类型</span></span></span><br><span class="line"><span class="function">Employee <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 这种情况，桥方法会使用新的方法</span></span><br></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><ul><li>虚拟机没有泛型，只有普通类和方法</li><li>所有泛型参数会被替换成限定类型，若没有则替换成Object</li><li><strong>会合成桥方法来保证多态</strong></li><li>保证类安全，必要时会插入强制类型转换</li></ul><h2 id="1-6、局限性"><a href="#1-6、局限性" class="headerlink" title="1.6、局限性"></a>1.6、局限性</h2><h3 id="1、不能使用基本类型实例化参数"><a href="#1、不能使用基本类型实例化参数" class="headerlink" title="1、不能使用基本类型实例化参数"></a>1、不能使用基本类型实例化参数</h3><p><strong>原因：</strong>Object不能存储基本类型的值，而泛型擦除后都是Object或者限定类存储</p><h3 id="2、无法使用instanceof判断泛型类型"><a href="#2、无法使用instanceof判断泛型类型" class="headerlink" title="2、无法使用instanceof判断泛型类型"></a>2、无法使用instanceof判断泛型类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于泛型擦除，所以String变为Object，永远成立,无法缺点a的泛型类型</span></span><br><span class="line"><span class="keyword">if</span>(<span class="function">a <span class="keyword">instanceof</span> <span class="title">Demo1</span><span class="params">(String)</span>)</span></span><br><span class="line"><span class="function">    </span></span><br></pre></td></tr></table></figure><h3 id="3、不能创建参数化类型的数组"><a href="#3、不能创建参数化类型的数组" class="headerlink" title="3、不能创建参数化类型的数组"></a>3、不能创建参数化类型的数组</h3><ul><li>由于数组的劣势，任何数组都可以转换成 Object[] 数组，然而转换之后，由于泛型擦除，object只能知道要加入 Demo1 类型，不知道要加入 Demo1&lt; String &gt; 类型，从而报错</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数化类型的数组</span></span><br><span class="line">Demo1&lt;String&gt;[] demo1 = <span class="keyword">new</span> Demo1&lt;String&gt;[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 泛型擦除之后，可以转换成object</span></span><br><span class="line">Demo1[] demo1 = <span class="keyword">new</span> Demo1[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把demo1赋值给Object数组</span></span><br><span class="line">Object[] object = demo1;   <span class="comment">// 相当于Object[] object = new Demo1[5];</span></span><br><span class="line"><span class="comment">// 数组记录了类型为demo1,但是因为泛型擦除，不知道应该为Demo1&lt;String&gt;，所以下面编译通过</span></span><br><span class="line">object[<span class="number">0</span>] = <span class="keyword">new</span> Demo1&lt;String&gt;();</span><br><span class="line">object[<span class="number">1</span>] = <span class="keyword">new</span> Demo1&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于object和demo1的引用指向一个对象，所以等效为,于是编译通过，但是报错</span></span><br><span class="line">demo1[<span class="number">0</span>] = <span class="keyword">new</span> Demo1&lt;String&gt;();</span><br><span class="line">demo1[<span class="number">1</span>] = <span class="keyword">new</span> Demo1&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常情况</span></span><br><span class="line">Demo1&lt;String&gt; demo1 = <span class="keyword">new</span> Demo1();</span><br><span class="line">Object object = demo1; <span class="comment">// 转换成Object类型之后，会丢失方法</span></span><br><span class="line">demo1.setSecond(<span class="string">&quot;1&quot;</span>);  <span class="comment">// 由于不存在该方法，编译器会检查出错误，从而避免类型不一致</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>数组强转Object[] ，原来数组存储的对象的方法还在</li><li>对象强转Object类型，会丢失方法</li></ul><h3 id="4、Varargs警告"><a href="#4、Varargs警告" class="headerlink" title="4、Varargs警告"></a>4、Varargs警告</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义如下方法，注意参数实际是一个数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(ArrayList&lt;T&gt; coll, T...ts)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (T t:ts) &#123;</span><br><span class="line">coll.add(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Demo1&lt;String&gt;&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Demo1&lt;String&gt; demo1 = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br><span class="line">Demo1&lt;String&gt; demo2 = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br><span class="line"><span class="comment">// 注意到，这里建立了Demo1&lt;String&gt;数组，这种情况规则会放松，不会报错，但是会警告</span></span><br><span class="line">Demo2.addAll(collection,demo1,demo2);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用其中之一的注解注释在方法上，可以取消警告</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@SafeVarargs</span>  <span class="comment">//该注解只能使用再static、final或Java9中private的构造器和方法</span></span><br></pre></td></tr></table></figure><h3 id="5、不能-new-泛型变量"><a href="#5、不能-new-泛型变量" class="headerlink" title="5、不能 new 泛型变量"></a>5、不能 new 泛型变量</h3><p><strong>原因：</strong></p><ul><li>new T()是必须要有运行时类型信息的，否则运行时不知道实例的类型，而泛型擦除后，一律创建的是Object类型或者限定类型，<strong>无法获得类的信息</strong></li><li>T t 表示的只是某个实例，所以可以运行时自动推测类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把Demo1的构造方法更改成如下，会报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.first = <span class="keyword">new</span> T();</span><br><span class="line">    <span class="keyword">this</span>.second = <span class="keyword">new</span> T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原因：泛型擦除后变为Object，创建的类型是Object</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.first = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">this</span>.second = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6、不能-new-泛型数组"><a href="#6、不能-new-泛型数组" class="headerlink" title="6、不能 new 泛型数组"></a>6、不能 new 泛型数组</h3><p><strong>原因：</strong></p><ul><li>泛型擦除后，为Comparable[] 数组</li><li>假设返回类型可能为User[] 数组 ，就必须要向下转型，不安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] create(<span class="keyword">int</span> length)&#123;</span><br><span class="line">    T[] result = <span class="keyword">new</span> T[length];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型擦除后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] create(<span class="keyword">int</span> length)&#123;</span><br><span class="line">Object[] result = <span class="keyword">new</span> Object[length];</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 若T为User实现了接口，获取结果时 (User[]) result ，不安全，因为很明显Comparable对象不含User对象的属性和方法</span></span><br></pre></td></tr></table></figure><h3 id="7、泛型类的泛型变量不能使用static"><a href="#7、泛型类的泛型变量不能使用static" class="headerlink" title="7、泛型类的泛型变量不能使用static"></a>7、泛型类的泛型变量不能使用static</h3><p><strong>原因：</strong>静态变量初始化时无法获得变量类型，所以失败</p><h3 id="8、不能捕获抛出泛型类实例"><a href="#8、不能捕获抛出泛型类实例" class="headerlink" title="8、不能捕获抛出泛型类实例"></a>8、不能捕获抛出泛型类实例</h3><p><strong>原因：</strong></p><ul><li>内部被擦除称为Object 类型，JVM不知道应该抛出哪个异常</li></ul><blockquote><p>取消对检查型异常的检查</p></blockquote><ul><li>接收收到的异常，然后转换成 RuntimeException 异常</li><li>注意这里泛型的作用仅仅表明需要转换的类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T) t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写就可以把异常转换成编译器认为的非检查型异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">Demo2.&lt;RuntimeException&gt;throwAs(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实战：</strong>让多线程不抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            Demo2.&lt;RuntimeException&gt;throwAs(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9、擦除后的冲突"><a href="#9、擦除后的冲突" class="headerlink" title="9、擦除后的冲突"></a>9、擦除后的冲突</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这个equals泛型擦除后会和Object的方法冲突，<strong>参数，名称，返回值完全一致</strong>，注意这里因为没有继承，所以不会有桥方法，所以只能改名字或者不用泛型。</p><h3 id="10、多实现的冲突"><a href="#10、多实现的冲突" class="headerlink" title="10、多实现的冲突"></a>10、多实现的冲突</h3><p>一个类定义为泛型类，则该类的因为类型不同会有多个衍生类，这些衍生类最多只能有一个作为<strong>某一个类的父类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt; ....</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Manage</span>&gt;.....</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">// 泛型擦除后，编译能通过    </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>....</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>..... </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">// 但是使用会报错,由于继承，所以会生成两个桥方法，而这两个桥方法完全一致，所以报错</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">int</span> <span class="title">compareTo</span>(<span class="title">Object</span> <span class="title">object</span>)</span>&#123;  </span><br><span class="line">    <span class="comment">// 调用Comparable&lt;Employee&gt;的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object object)</span></span>&#123;  </span><br><span class="line">    <span class="comment">// 调用Comparable&lt;Manage&gt;的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7、泛型类的继承规则"><a href="#1-7、泛型类的继承规则" class="headerlink" title="1.7、泛型类的继承规则"></a>1.7、泛型类的继承规则</h2><h4 id="1、子类问题"><a href="#1、子类问题" class="headerlink" title="1、子类问题"></a>1、子类问题</h4><ul><li>Employee  是Manage 的 父类</li><li>但是 Demo1&lt; Employee &gt; 不是 Demo1&lt; Manage &gt;的父类</li></ul><h4 id="2、数组的子类问题"><a href="#2、数组的子类问题" class="headerlink" title="2、数组的子类问题"></a>2、数组的子类问题</h4><ul><li>Employee  是Manage 的 父类</li><li>Employee[]  是Manage[] 的 父类</li></ul><p><strong>这个是为什么不能创建泛型参数化类型数组的核心原因</strong></p><h4 id="3、泛型类可以转换成原始类"><a href="#3、泛型类可以转换成原始类" class="headerlink" title="3、泛型类可以转换成原始类"></a>3、泛型类可以转换成原始类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo1&lt;User&gt; demo1 = <span class="keyword">new</span> Demo1();</span><br><span class="line">        Demo1 demo2 = demo1;</span><br><span class="line">        demo2.setSecond(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">// 原始类型，编译器会自动帮我们寻找类型</span></span><br><span class="line">        System.out.println(demo2.getSecond() <span class="keyword">instanceof</span> String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、通配符"><a href="#8、通配符" class="headerlink" title="8、通配符"></a>8、通配符</h2><h3 id="8-1、概念"><a href="#8-1、概念" class="headerlink" title="8.1、概念"></a>8.1、概念</h3><p><strong>通配符类型中，允许类型参数发生变化，如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Demo1&lt;? extends Employee&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用通配符如下定义之后    </span></span><br><span class="line">Demo1&lt;?&gt; demo1 = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br><span class="line"><span class="comment">// 里面的方法也会变成?</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.first = first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? first)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.first = first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于无法获得具体的类型，setFirst会拒绝接收任何参数</span></span><br><span class="line"><span class="comment">// 该方法是设置里面的属性Second</span></span><br><span class="line">demo1.setSecond(demo1.getFirst());  <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><h3 id="8-2、解决泛型继承规则带来的局限"><a href="#8-2、解决泛型继承规则带来的局限" class="headerlink" title="8.2、解决泛型继承规则带来的局限"></a>8.2、解决泛型继承规则带来的局限</h3><p><strong>继承规则引起的局限</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Demo1&lt;Employee&gt; demo)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Manage 为 Employee 的子类，根据泛型继承规则</span></span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Employee&gt;());  <span class="comment">// 编译通过</span></span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Manage&gt;()); </span><br><span class="line"><span class="comment">// 报错，因为Demo1&lt;Manage&gt; 不是 Demo1&lt;Employee&gt;的子类</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>通配符解决问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样限定范围之后，就可以解决上述问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Demo1&lt;? extends Employee&gt; demo)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型 ArrayList&lt;Demo2&gt; 是ArrayList&lt;? extends Demo1&gt;的子类</span></span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Employee&gt;()); </span><br><span class="line">print(<span class="keyword">new</span> Demo1&lt;Manage&gt;());</span><br></pre></td></tr></table></figure><p><strong>并且不会带来安全隐患</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo1&lt;Manage&gt; m = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br><span class="line">        Demo1&lt;? extends Employee&gt; e = m;</span><br><span class="line">        e.setFirst(<span class="keyword">new</span> Manage());    <span class="comment">// 编译不通过</span></span><br><span class="line">        e.setFirst(<span class="keyword">new</span> Employee());  <span class="comment">// 编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// setFirst方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.first = first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// setFirst需要的参数为 capture of ? extends Employee ,因为只知道是需要子类，但是不清楚具体类型，所以拒绝接收任何类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，也可以不使用通配符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Employee&gt; <span class="function">Demo1&lt;T&gt; <span class="title">print</span><span class="params">(Demo1&lt;T&gt; demo)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> demo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3、超类型限定"><a href="#8-3、超类型限定" class="headerlink" title="8.3、超类型限定"></a>8.3、超类型限定</h3><p>限定参数必须是超类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo1&lt;? <span class="keyword">super</span> Manage&gt;</span><br></pre></td></tr></table></figure><h3 id="8-4、无限定通配符"><a href="#8-4、无限定通配符" class="headerlink" title="8.4、无限定通配符"></a>8.4、无限定通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Demo1&lt;?&gt; demo1)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> demo1.getFirst() == <span class="keyword">null</span> || demo1.getSecond()==<span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Demo1&lt;String&gt; demo1 = <span class="keyword">new</span> Demo1&lt;&gt;();</span><br><span class="line">       demo1.setSecond(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">       System.out.println(check(demo1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-5、通配符捕获"><a href="#8-5、通配符捕获" class="headerlink" title="8.5、通配符捕获"></a>8.5、通配符捕获</h3><p><strong>概念：</strong>泛型参数 如T捕获通配符</p><p>定义一个方法，实现交换值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">swap</span><span class="params">(Demo1&lt;?&gt; demo1)</span></span>&#123;</span><br><span class="line">   <span class="comment">// 然而这种写法是错误的</span></span><br><span class="line">   ? t = demo1.getFirst();</span><br><span class="line">    <span class="comment">// 这种方式也不能通过编译</span></span><br><span class="line">   demo1.setFirst(demo1.getSecond());</span><br><span class="line">   demo1.setSecond(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用泛型方法中转，这种情况下参数T捕获通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Demo1&lt;?&gt; demo1)</span></span>&#123;</span><br><span class="line">   swapHelper(demo1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Demo1&lt;T&gt; demo1)</span></span>&#123;</span><br><span class="line">T t = demo1.getFirst();</span><br><span class="line">demo1.setFirst(demo1.getSecond());</span><br><span class="line">demo1.setSecond(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通配符捕获只有在非常限定的情况下成立，<strong>编译器必须保证通配符表示单个能确定的类型，</strong>如ArrayList&lt;Demo1<T>&gt;就永远不能捕获ArrayList&lt;Demo1<T>&gt;的通配符，列表可以保存两个Demo1&lt;?&gt;，其中 ？ 分别具有不同的类型</p><h2 id="9、泛型和反射"><a href="#9、泛型和反射" class="headerlink" title="9、泛型和反射"></a>9、泛型和反射</h2><h3 id="9-1、泛型Class类型"><a href="#9-1、泛型Class类型" class="headerlink" title="9.1、泛型Class类型"></a>9.1、泛型Class类型</h3><p>Class类是泛型类，String.class 就是Class<String>类的唯一对象</p><p>API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">()</span>     <span class="comment">// 返回无参构造的一个新实例</span></span></span><br><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">(Object... parameters)</span>   </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">T <span class="title">cast</span><span class="params">(Object obj)</span>  <span class="comment">// 若obj为null或能转换成T类型，返回T，否则抛出异常</span></span></span><br><span class="line"><span class="function">T[] <span class="title">getEnumConstants</span><span class="params">()</span> <span class="comment">// 若T为枚举类型，则返回所有值组成的数组，否则null</span></span></span><br><span class="line"><span class="function">Class&lt;? <span class="keyword">super</span> T&gt; <span class="title">getSuperClass</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 返回这个类的超类，若T不是一个类或者Object类，返回null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class... parameterTypes)</span> <span class="comment">// </span></span></span><br></pre></td></tr></table></figure><h3 id="9-2、使用Class-参数进行类型匹配"><a href="#9-2、使用Class-参数进行类型匹配" class="headerlink" title="9.2、使用Class 参数进行类型匹配"></a>9.2、使用Class<T> 参数进行类型匹配</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Person&lt;T&gt; <span class="title">makeUser</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将T同Employee匹配，编译器推断返回Person&lt;Employee&gt;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person&lt;T&gt;(c.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        Person person = makeUser(Employee.class);</span><br><span class="line">        Employee employee = (Employee) person.getT();</span><br><span class="line">        employee.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;员工&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3、虚拟机的泛型信息"><a href="#9-3、虚拟机的泛型信息" class="headerlink" title="9.3、虚拟机的泛型信息"></a>9.3、虚拟机的泛型信息</h3><p>Java泛型会进行擦除，但是仍然保留关于泛型的信息，比如Demo1 直到它来自于泛型类 Demo1<T> ，尽管虚拟机不会直到它来自Demo1<String> 还是 其他</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; min(T[] a)</span><br><span class="line"><span class="comment">// 泛型擦除后    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">min</span><span class="params">(Cimparale[] a)</span></span></span><br></pre></td></tr></table></figure><p><strong>通过反射API可以确定</strong></p><ul><li>泛型方法有一个名为T的参数</li><li>这个类型参数有一个子限定类型，其自身又是一个泛型类型</li><li>这个限定类型有一个通配符参数</li><li>这个通配符参数有一个超类型限定</li><li>这个泛型方法有一个泛型数组参数</li></ul><p><strong>Java.lang.reflect 包中的接口Type，含有以下子类</strong></p><ul><li>Class类，描述具体类型</li><li>TypeVarible 接口 ： 描述类型变量</li><li>WildcardTyepe接口：描述通配符</li><li>ParameterizedType：描述泛型类或接口类型，比如collection<String></li><li>GenericArrayTye接口：描述泛型数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class方法</span></span><br><span class="line">TypeVariable[] getTypeParameters() </span><br><span class="line"><span class="comment">// 如果类型被声明为泛型类型，则获得泛型类型变量，否则获得长度为0的数组  </span></span><br><span class="line">Type[] getGenericSuperClass();   <span class="comment">// 获得声明超类的泛型类型</span></span><br><span class="line">Type[] getGenericInterfaces();   <span class="comment">// 获得这个类型所声明接口的泛型类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// method方法</span></span><br><span class="line">TypeVariable[] getTypeParameters() </span><br><span class="line">Type[] getGenericParameterTypes()  <span class="comment">// 获得泛型参数，</span></span><br><span class="line"><span class="function">Type <span class="title">getGenericReturnType</span><span class="params">()</span>        <span class="comment">// 获得泛型返回值类型。 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// TypeVariable方法</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Type[] <span class="title">getBounds</span><span class="params">()</span>   <span class="comment">// 获得变量的子类限定</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// wildcardType方法     </span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getUpperBounds</span><span class="params">()</span>    <span class="comment">// 获得这个类型变量的子类限定</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getLowerBounds</span><span class="params">()</span>   <span class="comment">// 超类限定</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ParameterizedType</span></span></span><br><span class="line"><span class="function">Type <span class="title">getRawType</span><span class="params">()</span>    <span class="comment">//获得原始类型</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getActualTypeArguments</span><span class="params">()</span>    <span class="comment">// 获得这个参数化类型声明的类型参数</span></span></span><br><span class="line"><span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span>     <span class="comment">//  返回外部类型，是顶层则返回null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// GenericArrayType</span></span></span><br><span class="line"><span class="function">Type <span class="title">getGenericComponentType</span><span class="params">()</span> <span class="comment">// 获得这个数组类型声明的泛型元素类型 </span></span></span><br></pre></td></tr></table></figure><h3 id="9-4、类型字面量"><a href="#9-4、类型字面量" class="headerlink" title="9.4、类型字面量"></a>9.4、类型字面量</h3><p>有时，希望通过值来决定程序的行为，不过，如果有泛型类，擦除会带来问题，比如ArrayList<String>、ArrayList<Integer> 擦除后都为ArrayList。</p><ul><li>可以通过反射捕获类型，然后根据类型执行不同的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="keyword">new</span> TypeLiteral&lt;ArrayList&lt;Integer&gt;&gt;()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeLiteral 构造器会捕获泛型超类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeLiteral</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TypeLiteral&#123;</span><br><span class="line">        Type parentType = getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span>(parentType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(三):集合框架</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%89%20)%20%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%89%20)%20%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1、集合框架概述"><a href="#1、集合框架概述" class="headerlink" title="1、集合框架概述"></a>1、集合框架概述</h2><h3 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h3><p>在学习Java的集合框架之前，都是通过数组来存放数组，但是数组有一些弊端</p><ul><li>数组初始化以后，长度就确定了</li><li>数组中提供的属性和方法少，不便于进行添加、删除、插入等操作</li><li>存储数据的特点单一，即都是有序可重复的</li></ul><p><strong>Java集合类可以弥补数组在存储数据方面的不足</strong></p><h3 id="1-2、分类"><a href="#1-2、分类" class="headerlink" title="1.2、分类"></a>1.2、分类</h3><p>Java 集合可分为 Collection 和 Map 两种体系</p><p>Collection接口：单列数据，定义了存取一组对象的方法的集合</p><ul><li><strong>List</strong>：元素有序、可重复的集合</li><li><strong>Set</strong>：元素无序、不可重复的集合</li></ul><p>Map接口：双列数据，保存具有映射关系“key-value对”的集合</p><p><img src="/img/JavaSE/1.jpg"></p><p><img src="/img/JavaSE/2.jpg"></p><h2 id="2、Collection-接口"><a href="#2、Collection-接口" class="headerlink" title="2、Collection 接口"></a>2、<strong>Collection</strong> 接口</h2><h3 id="2-1、简介"><a href="#2-1、简介" class="headerlink" title="2.1、简介"></a>2.1、简介</h3><p>1、Collection 接口是 List、Set 和 Queue 接口的父接口</p><p>2、该接口方法<strong>可以用于List、set、Queue集合</strong></p><p>3、JDK不提供此接口的任何<strong>直接实现</strong>，而是提供更具体的子接口实现</p><h3 id="2-2、主要方法"><a href="#2-2、主要方法" class="headerlink" title="2.2、主要方法"></a>2.2、主要方法</h3><p>由于List、Set 和 Queue 都是collection的子类，所以都可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add(Object obj)、addAll(Collection coll)                         <span class="comment">// 添加</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span>、<span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection coll)</span>： <span class="comment">// 删除</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span>：       <span class="comment">// 判断是否包含某个元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection c)</span>：  <span class="comment">// 通过元素的equals方法比较</span></span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span>                   <span class="comment">// 转换成数组</span></span></span><br><span class="line"><span class="function"><span class="title">iterator</span><span class="params">()</span>                           <span class="comment">// 返回迭代器对象，用于集合遍历</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>          <span class="comment">// 清空集合</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>     <span class="comment">// 判断是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>            <span class="comment">// 获取有效元素个数</span></span></span><br><span class="line"><span class="function"><span class="title">hashCode</span><span class="params">()</span>            <span class="comment">// 获取集合哈希值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>        <span class="comment">// 是否相等</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection c)</span>： <span class="comment">// 获取交集，结果放在当前集合</span></span></span><br></pre></td></tr></table></figure><h3 id="2-3、Iterator迭代器接口"><a href="#2-3、Iterator迭代器接口" class="headerlink" title="2.3、Iterator迭代器接口"></a>2.3、Iterator迭代器接口</h3><p>概述：</p><ul><li>Collection接口实现了迭代器接口</li><li>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素</li><li>Iterator 仅用于<code>遍历集合</code>，集合对象每次调用iterator()方法都得到<code>全新</code>的迭代器对象</li><li>集合添加，插入数据都是靠迭代器来遍历到指定的位置的</li><li><strong>迭代器的位置是位于两个元素之间的</strong></li></ul><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hasNext()     <span class="comment">// 判断是否还有元素</span></span><br><span class="line">next()        <span class="comment">// 返回当前值，同时执行后一位</span></span><br><span class="line">remove()      <span class="comment">// 调用集合对象本身的remove方法</span></span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator(); <span class="comment">// 获取迭代器</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">        <span class="comment">// 指向下一个元素的同时返回值</span></span><br><span class="line">System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了迭代器遍历，还有其他遍理方式，如foreach</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通方法</span></span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8特性</span></span><br><span class="line">list.forEach(System.out::println);  </span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line">list.forEach((str)-&gt;&#123;System.out.println(str);&#125;);</span><br></pre></td></tr></table></figure><h2 id="3、Collection的子接口：list"><a href="#3、Collection的子接口：list" class="headerlink" title="3、Collection的子接口：list"></a>3、Collection的子接口：list</h2><p><strong>概述：</strong></p><ul><li>我们通常使用List替代数组，list集合的长度是<code>动态</code>的，与数组不同</li><li>list集合中的元素都是<code>有序，可重复的</code>，每个元素都有其对应的顺序索引</li><li>中List接口的实现类常用的有：ArrayList、LinkedList和Vector</li></ul><p><strong>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加。更改、移除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span>:             <span class="comment">// 在index位置插入ele元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection eles)</span>:  <span class="comment">// 从index位置开始将插入集合</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span>:                       <span class="comment">// 移除index位置的元素，返回此元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Function)</span>               <span class="comment">// 函数返回true，就删除</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection c1,Collection c2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection c1,Collection c2)</span>  <span class="comment">// 两个相反</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span>:           <span class="comment">// 更改指定index位置的元素为ele</span></span></span><br><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span>:    <span class="comment">// 截断list</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取信息</span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>:        <span class="comment">// 获取指定index位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span>:      <span class="comment">// 返回obj在集合中首次出现的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object obj)</span>:  <span class="comment">// 返回obj在当前集合中末次出现的位置</span></span></span><br></pre></td></tr></table></figure><h3 id="3-1、List接口的迭代器：ListIterator"><a href="#3-1、List接口的迭代器：ListIterator" class="headerlink" title="3.1、List接口的迭代器：ListIterator"></a>3.1、List接口的迭代器：ListIterator</h3><p><strong>迭代器：</strong>若迭代器A、B同时操作一个集合，但是A改变了结构，这样B就会混乱</p><p><strong>List规定：</strong>若一个迭代器发现他的集合被修改了，就会抛出异常。因此，建议给一个集合关联多个迭代器时，建议限定这些迭代器只能读；或者只使用一个迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it1 = list.iterator(); <span class="comment">// 获取迭代器</span></span><br><span class="line">Iterator&lt;String&gt; it2 = list.iterator();</span><br><span class="line">it1.next();</span><br><span class="line">it1.remove();</span><br><span class="line">it2.next();  <span class="comment">//  java.util.ConcurrentModificationException</span></span><br></pre></td></tr></table></figure><p><strong>方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it2 = list.iterator(n); <span class="comment">// 获得位置在n处的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;      <span class="comment">// 在当前位置前插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(E element)</span></span>;      <span class="comment">// 在当前位置更改插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hashPrevious</span><span class="params">()</span></span>;   <span class="comment">// 判断前面是否有元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hashNext</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function">E <span class="title">previous</span><span class="params">()</span></span>;             <span class="comment">// 返回前面的一个集合</span></span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span></span>;          <span class="comment">// 返回下一次调用next方法时将返回的元素所有</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2、List实现类之一：ArrayList"><a href="#3-2、List实现类之一：ArrayList" class="headerlink" title="3.2、List实现类之一：ArrayList"></a>3.2、List实现类之一：ArrayList</h3><p><strong>本质：</strong></p><p>ArrayList是对象引用的一个”变长”数组</p><ul><li>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组</li><li>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</li></ul><p>Arrays.asList(…) 返回值是一个<code>固定长度</code>的 List 集合，不能增加数据</p><p><strong>特点：</strong>从数据中间删除、增添元素开销很大，但是访问速度快</p><h3 id="3-3、List实现类之一：LinkedList"><a href="#3-3、List实现类之一：LinkedList" class="headerlink" title="3.3、List实现类之一：LinkedList"></a>3.3、List实现类之一：LinkedList</h3><p><strong>本质：</strong></p><ul><li>是一个双向链表，内部没有声明数组。</li><li>因为是链表结构，所以<code>频繁的插入或删除元素</code>的操作，会比ArrayList更快</li><li>可以当成栈、队列来使用</li><li>get方法做了优化，会自动选择从尾部或者头部遍历，不过</li></ul><p><strong>结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">E item;</span><br><span class="line">Node&lt;E&gt; next;  </span><br><span class="line">Node&lt;E&gt; prev;</span><br><span class="line">Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line"><span class="keyword">this</span>.item = element;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line"><span class="keyword">this</span>.prev = prev;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新增方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Object obj)</span>  <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function">Object <span class="title">getFirst</span><span class="params">()</span>          Object <span class="title">getLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">removeFirst</span><span class="params">()</span>       Object <span class="title">removeLast</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="3-4、List-实现类之三：Vector"><a href="#3-4、List-实现类之三：Vector" class="headerlink" title="3.4、List 实现类之三：Vector"></a>3.4、List 实现类之三：Vector</h3><p><strong>特点：</strong></p><p>​        大多数操作与ArrayList相同，区别之处在于Vector是<code>线程安全</code>的。</p><p><strong>新增方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(Object obj)</span>     <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(Object obj,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(Object obj,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(Object obj)</span>  <span class="keyword">void</span> <span class="title">removeAllElements</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="4、Collection子接口：Set"><a href="#4、Collection子接口：Set" class="headerlink" title="4、Collection子接口：Set"></a>4、Collection子接口：Set</h2><ul><li>Set接口是Collection的子接口，set接口没有提供额外的方法</li><li>Set 集合<code>不允许包含相同</code>的元素，如果试把两个相同的元素加入同一个，会失败</li></ul><h3 id="4-1、Set实现类之一：HashSet"><a href="#4-1、Set实现类之一：HashSet" class="headerlink" title="4.1、Set实现类之一：HashSet"></a>4.1、Set实现类之一：HashSet</h3><p><strong>特点：</strong></p><ol><li>按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能</li><li><code>无序</code>、<code>线程不安全</code>、集合元素可以为<code>null</code></li><li>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类</li><li>底层是<strong>数组+散列算法</strong>，也就是说Hashset是通过数组存放数据的</li></ol><p><strong>注意点：</strong></p><p>​    若是在Set容器中存放对象，则对象的那个类必须要重写  equals 方法和 hashcode 方法，即保证equals相等的对象，hashcode也必须相等，以实现对象相等规则。<strong>相等的对象必须具有相等的散列码。</strong></p><p><strong>添加元素的过程</strong></p><ol><li>调用 方法获取哈希值，并根据哈希值判断通过<strong>散列函数</strong>判断在底层数组的存储位置。</li><li>判断 hashcode 值是否已经存在，若已经存在，则再通过 equals 方式判断</li><li>若 equals 返回 true ，则添加失败；若为false ，则<code>通过链表的方式继续链接</code>，保证唯一性</li></ol><p><strong>底层结构</strong>：</p><p>​        底层是数组，初始容量为16，当如果使用率超过0.75，就会扩大容量为原来的2倍</p><p><strong>创建方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;&gt;(list);</span><br><span class="line">HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> HashSet&lt;String&gt;(<span class="number">16</span>,<span class="number">0.8f</span>);</span><br></pre></td></tr></table></figure><blockquote><p>HashSet扩展:LinkedHashSet</p></blockquote><p><strong>特点：</strong></p><ol><li>LinkedHashSet 是 HashSet 的子类，不允许元素重复，</li><li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表按照插入顺序<strong>维护元素的次序</strong></li><li>LinkedHashSet插入性能略低于 HashSet，但是迭代访问性能好一些</li></ol><h3 id="4-2、Set实现类之二：TreeSet"><a href="#4-2、Set实现类之二：TreeSet" class="headerlink" title="4.2、Set实现类之二：TreeSet"></a>4.2、Set实现类之二：TreeSet</h3><p><strong>特点</strong>：</p><p>1、TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素<code>处于排序状态。</code></p><p>2、TreeSet底层使用<code>红黑树结构</code>存储数据，正常情况不能存null</p><p>3、有序的，查询速度比List快</p><p>4、通过compare判断重复与否，只要返回的不是0，就可以增添，<strong>不再通过hashcode</strong></p><p><strong>新增方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Comparator <span class="title">comparator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">E <span class="title">first</span><span class="params">()</span> E <span class="title">pollFirst</span><span class="params">()</span></span>;            </span><br><span class="line"><span class="function">E <span class="title">last</span><span class="params">()</span>  E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function">E <span class="title">lower</span><span class="params">(E e)</span>     E <span class="title">higher</span><span class="params">(E e)</span> <span class="comment">// 比e更大的值中的最小值</span></span></span><br><span class="line"><span class="function">SortedSet <span class="title">subSet</span><span class="params">(fromElement, toElement)</span></span></span><br><span class="line"><span class="function">SortedSet <span class="title">headSet</span><span class="params">(toElement)</span></span></span><br><span class="line"><span class="function">SortedSet <span class="title">tailSet</span><span class="params">(fromElement)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span>  <span class="comment">// 递减的迭代器    </span></span></span><br></pre></td></tr></table></figure><h4 id="1、排序方法一：自然排序"><a href="#1、排序方法一：自然排序" class="headerlink" title="1、排序方法一：自然排序"></a>1、排序方法一：自然排序</h4><p><strong>概念：</strong></p><p>​        通过继承Comparable 接口，实现compareTo方法，来比较对象的顺序。</p><p><strong>实例：</strong></p><ul><li>实体类实现接口，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        User user = (User) o;</span><br><span class="line">        <span class="keyword">if</span>(user.getId()==<span class="keyword">this</span>.id)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 相等返回0</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(user.getId()&gt;<span class="keyword">this</span>.id)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果参数对象想排到后面，就返回 -1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里省略 get 、set方法和tostring 、构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Set&lt;User&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">User user1 = <span class="keyword">new</span> User(<span class="number">1</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User(<span class="number">2</span>);</span><br><span class="line">User user3 = <span class="keyword">new</span> User(<span class="number">3</span>);</span><br><span class="line">set.add(user2);</span><br><span class="line">set.add(user1);</span><br><span class="line">set.add(user3);</span><br><span class="line">set.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、排序方法二：定制排序"><a href="#2、排序方法二：定制排序" class="headerlink" title="2、排序方法二：定制排序"></a>2、排序方法二：定制排序</h4><p><strong>概念：</strong></p><ol><li>通过Comparator接口来实现。需要重写compare(T o1,T o2)方法</li><li>实现定制排序需要把实现接口的类的对象放到Tree的形参里、</li><li><strong>目的是为了不改变实体类的结构</strong></li></ol><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">// 这里省略 get 、set方法和tostring 、构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建set对象时需要把实现Comparator接口到的类传入其中这里使用匿名内部类对象</span></span><br><span class="line">        Set&lt;User&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User u1, User u2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(u1.getId()== u2.getId())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(u1.getId()&gt; u2.getId())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="number">1</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">2</span>);</span><br><span class="line">        User user3 = <span class="keyword">new</span> User(<span class="number">3</span>);</span><br><span class="line">        set.add(user2);</span><br><span class="line">        set.add(user1);</span><br><span class="line">        set.add(user3);</span><br><span class="line">        set.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>既然使用了匿名内部类，那么自然可以使用lambda表达式替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;User&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;((u1,u2)-&gt;&#123; </span><br><span class="line">    <span class="keyword">if</span>(u1.getId()== u2.getId())&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(u1.getId()&gt; u2.getId())&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-3、Set实现类之三：EnumSet"><a href="#4-3、Set实现类之三：EnumSet" class="headerlink" title="4.3、Set实现类之三：EnumSet"></a>4.3、Set实现类之三：EnumSet</h3><p><strong>构造：</strong>只能通过静态工程方式构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Festival</span> </span>&#123;</span><br><span class="line">    Spring,Summer,Winter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EnumSet&lt;Festival&gt; enumSet1 = EnumSet.allOf(Festival.class);</span><br><span class="line"><span class="comment">// 初始为全部</span></span><br><span class="line">EnumSet&lt;Festival&gt; enumSet2 = EnumSet.noneOf(Festival.class);</span><br><span class="line"><span class="comment">// 初始为空</span></span><br><span class="line">EnumSet&lt;Festival&gt; enumSet3 = EnumSet.range(Festival.Spring,Festival.Summer);</span><br><span class="line"><span class="comment">// 两个值之前的所有值(包括两边)</span></span><br><span class="line">EnumSet&lt;Festival&gt; enumSet4 = EnumSet.of(Festival.Winter);</span><br><span class="line"><span class="comment">// 调用set集合的方法操作数据</span></span><br><span class="line">enumSet4.add(Festival.Summer);</span><br></pre></td></tr></table></figure><h2 id="5、Map接口"><a href="#5、Map接口" class="headerlink" title="5、Map接口"></a>5、Map接口</h2><p><strong>概述：</strong></p><ol><li>Map与Collection并列存在。用于保存具有映射关系的数据:key-value</li><li>Map 中的 key 和 value 都可以是<code>任何引用类型</code>的数据</li><li>Map 中的 <code>key 用Set来存放</code>，不允许重复（重复则会覆盖值），value可以重复</li></ol><p><strong>常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增添,已存在则替换</span></span><br><span class="line"><span class="function">Object <span class="title">put</span><span class="params">(Object key,Object value)</span></span></span><br><span class="line"><span class="function">    Object <span class="title">putAbsent</span><span class="params">(Object key,Object value)</span> <span class="comment">// 已存在，则不覆盖 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map m)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 删除</span></span></span><br><span class="line"><span class="function">    <span class="title">remove</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询：</span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object key)</span>：            <span class="comment">// 获取指定key对应的value</span></span></span><br><span class="line"><span class="function">    Object <span class="title">get</span><span class="params">(Object key,Object value)</span> <span class="comment">// 设置取不到的默认值    </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 元视图操作的方法：</span></span></span><br><span class="line"><span class="function">Set <span class="title">keySet</span><span class="params">()</span>        <span class="comment">// 返回所有key构成的Set集合</span></span></span><br><span class="line"><span class="function">Collection <span class="title">values</span><span class="params">()</span> <span class="comment">// 返回所有value构成的Collection集合</span></span></span><br><span class="line"><span class="function">Set <span class="title">entrySet</span><span class="params">()</span>      <span class="comment">// 返回所有key-value对构成的Set集合</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function"><span class="comment">// 初始化，通用可以选择大小，负载因子的参数               </span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射关系改变</span></span><br><span class="line"><span class="function">Object <span class="title">merge</span><span class="params">(Object key,Object value,Function)</span> </span></span><br><span class="line"><span class="function">    <span class="comment">// 若键值在集合中，则值更新为函数返回值</span></span></span><br><span class="line"><span class="function">Object <span class="title">compute</span><span class="params">(key,Function)</span> </span></span><br><span class="line"><span class="function">    <span class="comment">// 若key对应的值与函数的返回值相等，或者函数结果为null，则删除键值对</span></span></span><br><span class="line"><span class="function">Object <span class="title">computeIfPresent</span><span class="params">(key,Function)</span>  <span class="comment">// 要求map里的值不能为null</span></span></span><br><span class="line"><span class="function">Object <span class="title">computeIfAbsent</span><span class="params">(key,Function)</span>   <span class="comment">// 已存在则不覆盖  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(Function)</span> <span class="comment">// 符合映射规则的都删除</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Test </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      HashMap&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      hashMap.put(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        Integer merge = hashMap.merge(<span class="number">1</span>, <span class="number">2</span>, (k, v) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> v + <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(merge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代Map集合</strong></p><ul><li>通过Map.keySet()遍历key和value</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keySet获取map集合key的集合 然后在foreach遍历key即可</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">String value = map.get(key).toString();</span><br><span class="line">System.out.println(<span class="string">&quot;key:&quot;</span> + key + <span class="string">&quot;  value:&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">map.keySet().forEach((key)-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;key:&quot;</span> + key + <span class="string">&quot;  value:&quot;</span> + map.get(key));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Map.keySet()使用iterator遍历key和value</span></span><br><span class="line">Iterator&lt;String&gt; iter = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">String key = iter.next();</span><br><span class="line">Object value = map.get(key);</span><br><span class="line">System.out.println(<span class="string">&quot;key:&quot;</span> + key + <span class="string">&quot;  value:&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过Map.entrySet()遍历集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过foreach方式</span></span><br><span class="line">map.entrySet().forEach((m)-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;key:&quot;</span> + m.getKey() + <span class="string">&quot;  value:&quot;</span> + m.getValue());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry e : hashMap.entrySet()) &#123;</span><br><span class="line">System.out.println(e.getKey()+<span class="string">&quot;&quot;</span> +e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Map.keyentry()使用iterator遍历key和value</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">System.out.println(<span class="string">&quot;key:&quot;</span> + entry.getKey() + <span class="string">&quot;  value:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1、Map实现类之一：HashMap"><a href="#5-1、Map实现类之一：HashMap" class="headerlink" title="5.1、Map实现类之一：HashMap"></a>5.1、Map实现类之一：HashMap</h3><p><strong>特点：</strong></p><ol><li><p>允许使用<code>null键和null值</code>，与HashSet一样，不保证映射的顺序。</p></li><li><p>key构成的集合是Set:无序的、不可重复的，重写：equals()和hashCode()</p></li><li><p>判断Key相等：equals和hashcode    value只通过equals判断</p></li><li><p>哈希表的大小为 2 的次方，会根据传来的参数调整，但是无论如何都是2的次方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组下标的计算⽅法是“ (n - <span class="number">1</span>) &amp; hash ”</span><br><span class="line">为<span class="number">2</span>的次方,这样n -<span class="number">1</span> 就是 <span class="number">1</span> <span class="number">3</span> <span class="number">7</span> 转换成二进制依次 <span class="number">1</span> <span class="number">11</span> <span class="number">111</span> 这样进行位运算更合适</span><br></pre></td></tr></table></figure></li></ol><p><strong>底层结构：</strong></p><ol><li>JDK 7及以前版本：HashMap是<code>数组+链表</code>结构(即为链地址法)</li><li>JDK 8版本发布以后：HashMap是<code>数组+链表+红黑树</code>实现。</li></ol><p><strong>原理探究(JDK1.8)：</strong></p><ol><li>实例化一个HashMap时，会初始化initialCapacity（默认容量）和<code>loadFactor（填充因子）</code></li><li><strong>put数据时，才会</strong>根据默认容量（JDK8为16）创建Node数组，数组存放数据的地方成为bucket（桶），每个bucket都有自己的<code>索引</code>，所以查找速度非常快</li><li>每个bucket存一个Node对象，里面含有指向下一个元素的next引用变量，所以一个bucket可能形成<code>Node链</code>，或者是<code>TreeNode树</code>，而新添加的元素作为链表的last，或树的叶子结点</li></ol><p><strong>哈希函数：</strong></p><ul><li>JDK7：通过<strong>扰动函数处理</strong>过后得到 hash值，然后通过 (n - 1) &amp; hash判断当前元素存放的位置</li><li>JDK8：优化了代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK7</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK8</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line"> <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line"> <span class="comment">// ^ ：按位异或</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;:⽆符号右移，忽略符号位，空位都以0补⻬</span></span><br><span class="line"> <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩容情况</strong>：</p><ol><li><p>HashMap的元素个数大于 initialCapacity（默认容量）*  loadFactor（填充因子）时，就会扩大一倍。</p></li><li><p>扩容时会重新计算每个元素的位置，消耗资源，所以可以预设大小，减少资源消耗</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap(<span class="number">15</span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>树形化</strong>：</p><p>​        若是一个 Node 链 里面的元素超过了8个（容量小于64则会优先先尝试扩大容量减少哈希冲突），就会尝试树形化，然后数节点<code>由Node类型变为TreeNode类型</code>，当然，映射关系移除后，若小于6个，重新变回Node链</p><p>​        <strong>也就是说，桶里的Node链  &gt;  8 ，hashMap 容量 &gt; 64时，实际上才会发生树形化</strong></p><p><strong>loadFactor（填充因子）的理解</strong></p><ol><li>负载因子越大，数据密度越大，发生碰撞的几率越高，数组中的链表越容易长，查询或插入时的比较次数多，性能下降</li><li>负载因子越小越容易扩容，容易浪费空间</li><li>最好设置为0.7~0.75</li></ol><h4 id="5-1-1、HashMap扩展：LinkedHashMap"><a href="#5-1-1、HashMap扩展：LinkedHashMap" class="headerlink" title="5.1.1、HashMap扩展：LinkedHashMap"></a>5.1.1、HashMap扩展：LinkedHashMap</h4><ul><li>LinkedHashMap 是 HashMap 的子类</li><li>在HashMap基础上使用了一对<code>双向链表</code>来记录添加元素的顺序</li><li>LinkedHashMap 可以维护 Map 的迭代顺序：与迭代顺序插入顺序一致</li></ul><p><strong>HashMap中的内部类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Node&lt;K,V&gt; next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedHashMap中的内部类：Entry</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">Entry&lt;K,V&gt; before, after;</span><br><span class="line">Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2、HashMap扩展：IdentityHashMap"><a href="#5-1-2、HashMap扩展：IdentityHashMap" class="headerlink" title="5.1.2、HashMap扩展：IdentityHashMap"></a>5.1.2、HashMap扩展：IdentityHashMap</h4><p>重新定义了hashcode的取值方法：System.identityHashCode(Object obj)</p><ul><li>实际调用的是Object的 hashcode方法，比较地址</li><li>两个对象比较相等是不再使用 equals 而是使用 == </li><li>也是就说，只要是两个对象，永远不会相等</li></ul><h4 id="5-1-3、HashMap扩展：WeakHashMap"><a href="#5-1-3、HashMap扩展：WeakHashMap" class="headerlink" title="5.1.3、HashMap扩展：WeakHashMap"></a>5.1.3、HashMap扩展：WeakHashMap</h4><ul><li><p>使用的是弱引用，随时可能被回收</p></li><li><p>用途：缓存等</p></li></ul><h3 id="5-2、Map实现类之二：TreeMap"><a href="#5-2、Map实现类之二：TreeMap" class="headerlink" title="5.2、Map实现类之二：TreeMap"></a>5.2、Map实现类之二：TreeMap</h3><ul><li><code>同hashset</code>，实现了自动排序，红黑树底层</li><li>实现了SortedMap集合</li></ul><h3 id="5-3、Map实现类之三：EnumMap"><a href="#5-3、Map实现类之三：EnumMap" class="headerlink" title="5.3、Map实现类之三：EnumMap"></a>5.3、Map实现类之三：EnumMap</h3><p>键的值为枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Festival为枚举类，括号内一定要指定类型</span></span><br><span class="line">EnumMap&lt;Festival,String&gt; enumMap = <span class="keyword">new</span> EnumMap&lt;Festival, String&gt;(Festival.class);</span><br></pre></td></tr></table></figure><h3 id="5-4、Map实现类之四：Hashtable"><a href="#5-4、Map实现类之四：Hashtable" class="headerlink" title="5.4、Map实现类之四：Hashtable"></a>5.4、Map实现类之四：Hashtable</h3><ul><li>线程<code>安全</code>，不允许使用 null 作为 key 和 value，其他和HashMap基本一致</li><li>默认大小为11，每次扩大为 2n + 1</li></ul><h3 id="5-5、Map实现类之五：Properties"><a href="#5-5、Map实现类之五：Properties" class="headerlink" title="5.5、Map实现类之五：Properties"></a>5.5、Map实现类之五：Properties</h3><p><strong>特点：</strong></p><ol><li>Properties 类是 Hashtable 的子类，该对象用于<code>处理属性文件</code></li><li>Key和value都是<code>字符串类型</code></li><li>setProperty(String key,String value)方法和getProperty(String key)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key,String <span class="keyword">default</span>)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">setProperty</span><span class="params">(String key,String value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException  <span class="comment">// 从输入流加载属性映射</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(OutputStream out,String header)</span>  <span class="comment">// 将属性映射保存到输出流    </span></span></span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties pros = <span class="keyword">new</span> Properties();      <span class="comment">// 创建对象</span></span><br><span class="line">pros.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdbc.properties&quot;</span>));  <span class="comment">// 加载文件</span></span><br><span class="line">String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);   <span class="comment">// 获取user的值</span></span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure><h2 id="6、队列"><a href="#6、队列" class="headerlink" title="6、队列"></a>6、队列</h2><ul><li>队列允许在头部删除元素，在尾部添加数据，双端队列允许在头尾自由添加和删除数据</li><li>Java6引入了双端队列（Deque接口），ArrayDeque和LinkedList都实现了这个接口</li></ul><blockquote><p>队列API</p></blockquote><p>Queue是一个队列接口，需要自己去实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>; <span class="comment">// 若队列没满，则添加到队尾，不然抛出异常，返回false</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>; <span class="comment">// 若队列没空，则从队首取出，不然抛出异常，返回false</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">peak</span><span class="params">()</span></span>; <span class="comment">// 获取队首的元素,失败抛出异常</span></span><br></pre></td></tr></table></figure><blockquote><p>双端队列API</p></blockquote><p>Deque是一个双端队列接口，需要自己去实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Object obj)</span>       <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(Object obj)</span>  <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 移除数据</span></span></span><br><span class="line"><span class="function">Object <span class="title">removeFirst</span><span class="params">()</span>           Object <span class="title">removeLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">pollFirst</span><span class="params">(Object obj)</span>   Object <span class="title">pollLast</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 获得数据</span></span></span><br><span class="line"><span class="function">Object <span class="title">getFirst</span><span class="params">()</span>               Object <span class="title">getLast</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">Object <span class="title">peekFirst</span><span class="params">()</span>              Object <span class="title">peekLast</span><span class="params">()</span>   </span></span><br></pre></td></tr></table></figure><blockquote><p>ArrayDeque<E></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayDeque()</span><br><span class="line">ArrayDeque(<span class="keyword">int</span> size)</span><br></pre></td></tr></table></figure><blockquote><p>优先队列</p></blockquote><p><strong>使用了堆进行存储</strong>，堆进行添加和删除会让最小的元素移动到根，这样就不必进行排序了，默认实现了Comparator接口，当然也可以自己重写覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue()</span><br><span class="line">PriorityQueue(<span class="keyword">int</span> size)</span><br><span class="line">PriorityQueue(<span class="keyword">int</span> size,Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span><br></pre></td></tr></table></figure><h2 id="7、Collections工具类：增强集合"><a href="#7、Collections工具类：增强集合" class="headerlink" title="7、Collections工具类：增强集合"></a>7、Collections工具类：增强集合</h2><h3 id="7-1、同步集合"><a href="#7-1、同步集合" class="headerlink" title="7.1、同步集合"></a>7.1、同步集合</h3><p>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合<code>包装成线程同步的集合</code>，从而可以解决多线程并发访问集合时的线程安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection()</span><br><span class="line"><span class="comment">// 把Collection替换成下面的即可</span></span><br><span class="line">List/Map/Set/SortedSet/SortedMap/NavigableSet/NavigableMap</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 示例    </span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();        </span><br><span class="line">List&lt;String&gt; sy = Collections.synchronizedList(list);   </span><br></pre></td></tr></table></figure><h3 id="7-2、小集合"><a href="#7-2、小集合" class="headerlink" title="7.2、小集合"></a>7.2、小集合</h3><p>Java9引入静态方法，可以生成给定元素的集或者列表，<strong>在Java8相当于Arrays.asList</strong></p><ul><li>注意这些也是固定大小，而且不能增添、删除、修改内容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能有null值</span></span><br><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">Set&lt;Integer&gt; set = Set.of(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">Map&lt;String,Integer&gt; map = Map.of(<span class="string">&quot;wzh&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">// map也可以传入entry</span></span><br><span class="line">map = Map.ofEntries(Map.entry(<span class="string">&quot;Tom&quot;</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure><h3 id="7-3、子集合"><a href="#7-3、子集合" class="headerlink" title="7.3、子集合"></a>7.3、子集合</h3><ul><li>可以把集合分解成子集合</li><li>注意子集合并没有和父集合分离，子集合上的操作会在父集合上同步执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arrays类</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; List &lt;E&gt; asList(E...array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// List类的静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> firstIncluded,<span class="keyword">int</span> firstExcluded)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SortedSet、SortedMap(Map方法把set换成Map即可)</span></span><br><span class="line">subset(E firstIncluded,E firstExcluded);</span><br><span class="line">headSet(E firstExcluded);</span><br><span class="line">tailSet(E firstExcluded); </span><br><span class="line"></span><br><span class="line"><span class="comment">// NavigableSet、Map</span></span><br><span class="line">subset(E from, <span class="keyword">boolean</span> f,E to,<span class="keyword">boolean</span> t);</span><br><span class="line">headSet(E to,<span class="keyword">boolean</span> t);       <span class="comment">// boolean参数是表示是否包括边界</span></span><br><span class="line">tailSet(E to,<span class="keyword">boolean</span> t); </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">30</span>);</span><br><span class="line">        list.add(<span class="number">15</span>);</span><br><span class="line">        list.add(<span class="number">10</span>);</span><br><span class="line">        List&lt;Integer&gt; son = list.subList(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        son.add(<span class="number">3</span>);</span><br><span class="line">        list.forEach((v)-&gt;&#123;System.out.println(v);&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4、不可修改的视图"><a href="#7-4、不可修改的视图" class="headerlink" title="7.4、不可修改的视图"></a>7.4、不可修改的视图</h3><p>这些视图对现有集合增加了一个运行时检查，如果发现修改了，就抛出一个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.unmodifiableCollection()  <span class="comment">// 用法</span></span><br><span class="line"><span class="comment">// 把Collection替换成下面的即可</span></span><br><span class="line">List/Map/Set/SortedSet/SortedMap/NavigableSet/NavigableMap</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; l = (ArrayList&lt;Integer&gt;) Collections.unmodifiableList(list);</span><br><span class="line">l.add(<span class="number">3</span>);  <span class="comment">// 会抛出异常</span></span><br></pre></td></tr></table></figure><h3 id="7-5、严格检查集合"><a href="#7-5、严格检查集合" class="headerlink" title="7.5、严格检查集合"></a>7.5、严格检查集合</h3><ul><li>编译器有时候对于集合中添加错误的情况，没能指示出来</li><li>这样定义之后就会进行严格的检查</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collections.checkedCollection()</span><br><span class="line">List/Map/Set/SortedSet/SortedMap/NavigableSet/NavigableMap</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 示例    </span></span><br><span class="line">List&lt;String&gt; safe = Collections.checkedList(list,String.class);    </span><br></pre></td></tr></table></figure><h2 id="8、Collections工具类：计算属性"><a href="#8、Collections工具类：计算属性" class="headerlink" title="8、Collections工具类：计算属性"></a>8、Collections工具类：计算属性</h2><h3 id="8-1、排序"><a href="#8-1、排序" class="headerlink" title="8.1、排序"></a>8.1、排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List)</span>          <span class="comment">// 反转 List 中元素的顺序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List)</span>          <span class="comment">// 对 List 集合元素进行随机排序</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List)</span>             <span class="comment">// 根据元素的自然顺序对按升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List，Comparator)</span> <span class="comment">// </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List，<span class="keyword">int</span>， <span class="keyword">int</span>)</span>  <span class="comment">// 将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span></span><br></pre></td></tr></table></figure><h3 id="8-2、查找和替换"><a href="#8-2、查找和替换" class="headerlink" title="8.2、查找和替换"></a>8.2、查找和替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最值</span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection)</span>             <span class="comment">// 自然排序，或者自己实现接口</span></span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection,Comparator)</span>  <span class="comment">// 传入一个实现排序接口的对象</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection)</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection，Comparator)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置值    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span>      <span class="comment">// 将src中的内容复制到dest中 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List dest,Object value)</span>  <span class="comment">// 所有值变为value </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c,T...values)</span> <span class="comment">// 把所有值添加到集合里面    </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list,Object old,Object new)</span>  <span class="comment">// 替换</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">// 查询    </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection，Object o)</span>        <span class="comment">// 返回指定集合中指定元素的出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">disjoint</span><span class="params">(Collection c1,Collection c2)</span>   <span class="comment">// 没有公共元素，返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List father,List son)</span>  <span class="comment">// 返回子集合在父集合的索引索引 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfSubList</span><span class="params">(List father,List son)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 批操作    </span></span></span><br></pre></td></tr></table></figure><h2 id="9、其他集合"><a href="#9、其他集合" class="headerlink" title="9、其他集合"></a>9、其他集合</h2><h3 id="9-1、遗留的集合"><a href="#9-1、遗留的集合" class="headerlink" title="9.1、遗留的集合"></a>9.1、遗留的集合</h3><p><strong>Hashtable</strong></p><p><strong>枚举</strong></p><p>遗留的集合使用Enumeration遍历集合，有两个方法</p><ul><li>hasMoreElements</li><li>hasNextElement</li></ul><h3 id="9-2、栈Stack"><a href="#9-2、栈Stack" class="headerlink" title="9.2、栈Stack"></a>9.2、栈Stack</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E push(E item)</span><br><span class="line">E pop()</span><br><span class="line">E peek()</span><br></pre></td></tr></table></figure><h3 id="9-3、位集"><a href="#9-3、位集" class="headerlink" title="9.3、位集"></a>9.3、位集</h3><ul><li>用来存储位序列，把位包装在字节里，比Boolean对象的ArrayList更加高效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BistSet(<span class="keyword">int</span> size)  <span class="comment">// 定义size位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> bit)</span>   <span class="comment">// 看第bit位是1还是0  </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bit)</span>   <span class="comment">// 设置第bit位为1</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> bit)</span> <span class="comment">// 清除第bit位</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">and</span><span class="params">(BitSet set)</span>    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">or</span><span class="params">(BitSet set)</span>    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xor</span><span class="params">(BitSet set)</span>   <span class="comment">// 异或</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">andNot</span><span class="params">(BitSet set)</span>    <span class="comment">// 清0</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BitSet bitSet1 = new BitSet(4);</span><br><span class="line">        BitSet bitSet2 = new BitSet(4);</span><br><span class="line">        bitSet1.set(1);</span><br><span class="line">        bitSet1.set(2);</span><br><span class="line">        bitSet2.set(3);</span><br><span class="line">        bitSet1.or(bitSet2);</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            System.out.println(bitSet1.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE(二):类和对象</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%BA%8C%20)%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E4%BA%8C%20)%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="1、类和对象概念"><a href="#1、类和对象概念" class="headerlink" title="1、类和对象概念"></a>1、类和对象概念</h2><h3 id="1-1、面向对象与面向过程"><a href="#1-1、面向对象与面向过程" class="headerlink" title="1.1、面向对象与面向过程"></a>1.1、面向对象与面向过程</h3><p><strong>面向对象与面向过程</strong></p><ul><li>面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。</li><li>面向对象，<code>将功能封装进对象</code>，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li></ul><p>面向过程性能高，但是面向对象<strong>易维护、易复用、易扩展。</strong></p><p><strong>Java 性能差</strong>：主要原因并不是因为它是⾯向对象语言，而是 Java 是半编译语⾔，最终的执行代码并不是可以直接被 CPU 执⾏的⼆进制机械码。而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它⼀些面向过程的脚本语⾔性能也并不⼀定比 Java 好</p><p><strong>面向对象三大特征：</strong></p><ul><li>封装</li><li>继承</li><li>多态</li></ul><p><strong>面向对象思想：</strong>程序员从面向过程的执行者转化成了面向对象的指挥者</p><h3 id="1-2、类"><a href="#1-2、类" class="headerlink" title="1.2、类"></a>1.2、类</h3><p><strong>概念：</strong>构造对象的模板和蓝图，由类构造对象的过程成为<strong>创建类的实例</strong></p><p><strong>封装：</strong>又成为<strong>数据隐藏</strong>，是处理对象的一个重要概念。就是把数据和行为组合在一起，并对对象的使用者隐藏起来，只提供一个接口让使用者操作。对象的数据称为实例字段，操作数据的过程称为方法。、</p><h3 id="1-3、对象"><a href="#1-3、对象" class="headerlink" title="1.3、对象"></a>1.3、对象</h3><ul><li>对象的行为：对象的各种方法</li><li>对象的状态：每个对象的字段的得集合就是<strong>对象的状态</strong></li><li>对象的标识：</li></ul><h3 id="1-4、类之间的关系"><a href="#1-4、类之间的关系" class="headerlink" title="1.4、类之间的关系"></a>1.4、类之间的关系</h3><ul><li>依赖：类A对象需要调用类B对象的方法</li><li>聚合：类A对象包含一些类B的对象</li><li>继承：继承让多态得以提醒</li></ul><h3 id="1-5、分析对象与对象变量"><a href="#1-5、分析对象与对象变量" class="headerlink" title="1.5、分析对象与对象变量"></a>1.5、分析对象与对象变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date deadline;                     <span class="comment">// 此时deadline不是一个对象</span></span><br><span class="line">Date birthday = <span class="keyword">new</span> Date();        <span class="comment">// 通过new构造对象</span></span><br><span class="line">deadline = birthday;               <span class="comment">// 通过引用构造对象</span></span><br><span class="line"><span class="comment">// 此时二者是一个对象，hashcode相同</span></span><br><span class="line">System.out.println(deadline.hashCode());</span><br><span class="line">System.out.println(birthday.hashCode());</span><br></pre></td></tr></table></figure><ul><li>通过上面可以认识到，<strong>对象变量只是引用了一个对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deadline = <span class="keyword">null</span>;            <span class="comment">// 此时没有引用任何对象</span></span><br><span class="line">System.out.println(deadline.hashCode());   <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure><h2 id="2、类和对象的使用"><a href="#2、类和对象的使用" class="headerlink" title="2、类和对象的使用"></a>2、类和对象的使用</h2><h3 id="2-1、构造器"><a href="#2-1、构造器" class="headerlink" title="2.1、构造器"></a>2.1、构造器</h3><ul><li>构造对象需要<strong>调用构造器</strong>（默认有一个无参构造）</li><li>构造器必须配合new来使用，与类同名</li><li>构造器没有参数限制，没有返回值</li></ul><h3 id="2-2、属性"><a href="#2-2、属性" class="headerlink" title="2.2、属性"></a>2.2、属性</h3><ul><li><strong>属性分为成员变量和局部变量</strong></li></ul><table><thead><tr><th></th><th><strong>成员变量</strong></th><th><strong>局部变量</strong></th></tr></thead><tbody><tr><td>声明的位置</td><td>直接声明在类中</td><td>方法形参或内部、代码块内、构造器内等</td></tr><tr><td>修饰符</td><td>用权限修饰符修饰</td><td>只能使用final</td></tr><tr><td>初始化值</td><td>有默认值</td><td>没有默认值</td></tr><tr><td>内存加载位置</td><td><strong>堆空间或静态域内</strong></td><td><strong>栈空间</strong></td></tr></tbody></table><blockquote><p>用Var定义局部变量</p></blockquote><ul><li>Java10中，若可以从初始值推断类型，则可以使用var来修饰</li><li>var只能使用于<strong>方法中的局部变量</strong></li></ul><blockquote><p>使用Null引用</p></blockquote><ul><li>使用Null表示没有引用对象，如果调用类方法就会<strong>产生NullPointerException异常</strong></li><li>上述的name为String对象，若传进来的值为null，则会触发异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee employee = <span class="keyword">new</span> Employee(<span class="keyword">null</span>,<span class="number">75000</span>,<span class="number">1987</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">System.out.println(employee.getName().length());</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、构造器加入判断</span></span><br><span class="line"><span class="keyword">if</span>(name==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、拒绝创建null</span></span><br><span class="line"><span class="keyword">this</span>.name = Objects.requireNonNull(name,<span class="string">&quot;不允许null&quot;</span>);</span><br><span class="line"><span class="comment">// 3、类似1</span></span><br><span class="line"><span class="keyword">this</span>.name = Objects.requireNonNullElse(name,<span class="string">&quot;unknown&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-3、方法"><a href="#2-3、方法" class="headerlink" title="2.3、方法"></a>2.3、方法</h3><blockquote><p>定义</p></blockquote><ul><li>方法是类或对象<strong>行为特征的抽象</strong>，用来完成某个功能操作。</li><li>方法中只能调用方法或属性，不可以在方法内部定义方法。</li></ul><blockquote><p>参数传递机制</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> raise = salary * byPercent /<span class="number">100</span>;</span><br><span class="line">    salary = salary + raise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>显式参数：byPercent 即括号里的参数</li><li>隐式参数：调用这个方法的对象，salary 等于 employee.salary</li></ul><blockquote><p>参数传递机制</p></blockquote><p>Java里方法的<strong>参数传递</strong>方式只有一种：值传递。 </p><p><strong>将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。</strong> </p><blockquote><p>方法重载</p></blockquote><ul><li>概念：允许存在一个以上的<strong>同名方法</strong>，只要它们的参数个数或者参数类型不同即可，static和非static之间不能构成重载</li><li>特点：<strong>与返回值类型无关</strong>，仅仅返回值类型不同算一个方法。</li><li><strong>所以，参数和方法名构成了一个方法的签名</strong></li></ul><blockquote><p>可变参数</p></blockquote><ul><li>Java1.5之后，支持传递同类型的可变参数给一个方法</li><li>在方法声明中，在指定参数类型后加一个省略号(…)</li><li>一个方法只能指定一个可变参数，且必须放在最后</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>...nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>访问器方法和更改器方法</p></blockquote><ul><li>更改器方法：改变</li><li>访问器方法：不改变原来类的结构</li></ul><h3 id="2-4、this关键字"><a href="#2-4、this关键字" class="headerlink" title="2.4、this关键字"></a>2.4、this关键字</h3><ol><li>方法内部使用，即这个方法所属对象的引用</li><li>构造器内部使用，表示该构造器<code>正在初始化</code>的对象</li><li>可以用this来区分<code>属性和局部变量</code></li></ol><p><strong>注意：</strong></p><ol><li>在构造器里面使用this关键字调用<strong>其他构造器</strong>，但只能声明一个，参考上面的内容</li><li>this调用其他构造器的代码，必须声明在<strong>类的构造器的首行</strong></li></ol><h3 id="2-5、final"><a href="#2-5、final" class="headerlink" title="2.5、final"></a>2.5、final</h3><ul><li>成员变量定义为final之后，可以通过构造器赋予值，之后不能再修改</li><li><strong>final方法可以被重载</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6、static"><a href="#2-6、static" class="headerlink" title="2.6、static"></a>2.6、static</h3><p><strong>静态字段：</strong>被static修饰的静态字段，将不再属于某个对象，而是属于类被共享，<strong>可以同时被类和对象调用</strong></p><p>注意：Java叫做类字段，静态字段只是沿用了C++的叫法</p><p><strong>静态常量：</strong></p><p><strong>静态方法：</strong>同上，静态方法常用于工厂方法的实现，main方法也是一个静态方法，可以被类调用，由于独立于类，所以不能使用this和super，除此之外，静态方法不能调用非静态字段。</p><h3 id="2-7、代码块"><a href="#2-7、代码块" class="headerlink" title="2.7、代码块"></a>2.7、代码块</h3><p>三种初始化数据字段的方法</p><ul><li>构造器设置值</li><li>声明中赋值</li><li>初始化块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Block</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Block block = <span class="keyword">new</span> Block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">初始化块</span><br><span class="line">构造器方法</span><br></pre></td></tr></table></figure><p>构造器被调用后，会先判断是否调用了其他构造器</p><ul><li>若调用了，则转到另一个构造器执行</li><li>若没调用，<strong>先调用初始化块，在调用构造器剩下的部分</strong></li></ul><p><strong>静态代码块：</strong>优先于类的构造，<strong>只能对静态成员变量初始化</strong>，从上而下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//static代码块通常用于初始化static的属性</span><br><span class="line">static &#123;</span><br><span class="line">total = 100;//为total赋初值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化顺序</p></blockquote><ol><li>声明成员变量的默认初始化</li><li>显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）</li><li>构造器再对成员进行初始化操作</li><li>通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值</li></ol><h3 id="2-8、对象析构和finalize方法"><a href="#2-8、对象析构和finalize方法" class="headerlink" title="2.8、对象析构和finalize方法"></a>2.8、对象析构和finalize方法</h3><ul><li>Java会自动垃圾回收，所以Java不支持析构（构造器内放清理代码）</li><li>finalize方法用于释放资源，已经废弃，应该使用Java提供的各种类的close方法</li></ul><h2 id="3、类的继承"><a href="#3、类的继承" class="headerlink" title="3、类的继承"></a>3、类的继承</h2><h3 id="3-1、子类"><a href="#3-1、子类" class="headerlink" title="3.1、子类"></a>3.1、子类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Manage类继承了Employee类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>extends表明正在构造的新类派生于一个已经存在的类</li><li>已存在的类称为超类（基类或者父类），新类称为子类</li></ul><p>注意点：</p><ul><li>子类继承了父类的私有属性和方法，但是<strong>不能直接调用，可以间接调用</strong>（父类公有方法调用到了父类的私有属性和方法），也继承了父类的父类</li><li>子类可以通过 super() 调用父类方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类私有，只提供一个公有的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类调用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试，成功输出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Manage manage = <span class="keyword">new</span> Manage(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    manage.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、重写方法"><a href="#3-2、重写方法" class="headerlink" title="3.2、重写方法"></a>3.2、重写方法</h3><p>可以看到，上面例子中子类父类的print方法名一致，这样就是重写方法</p><p><strong>重写规则</strong></p><ul><li>方法必须具有相同的<strong>名称和参数</strong></li><li>返回值类型、异常类型要和父类一致，或为父类的子类</li><li><strong>访问权限要比父类的高或者相等</strong></li><li>无法重写static、final、private方法，因为static方法是类方法，不是成员方法</li></ul><p><strong>注意：</strong>重写发生在发生在运行期间</p><h3 id="3-3、子类构造器"><a href="#3-3、子类构造器" class="headerlink" title="3.3、子类构造器"></a>3.3、子类构造器</h3><p><strong>注意：子类初始化，必须提供父类构造的实现</strong>，几种调用方式如下</p><ul><li>父类含有无参构造时：会自动调用父类构造方法</li><li>父类不含无参构造时，子类必须调用super() 来调用父类构造方法</li><li>调用本类的其他构造方法，但是最终一定也要调用到父类构造方法</li></ul><p><strong>注意点：</strong></p><ul><li><strong>子类对象实例化时不会实例化父类对象</strong></li><li>构造器只能被调用，不能被继承</li><li>Java不支持多重继承，只支持多实现接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用其他构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4、多态与类型转换"><a href="#3-4、多态与类型转换" class="headerlink" title="3.4、多态与类型转换"></a>3.4、多态与类型转换</h3><p><strong>概念：</strong>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即⼀个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p><strong>对象类型转换</strong></p><ol><li>向上转型：父类的引用指向子类的对象</li><li>向下转型：子类的引用指向父类的对象（必须强制转换）</li></ol><p><strong>多态原理：</strong>父类的引用指向子类的对象（向上转型）</p><p><strong>引用变量类型分类：</strong></p><ul><li>编译时类型：编译时类型由声明该变量时使用的类型决定</li><li>运行时类型：运行时类型由实际赋给该变量的对象决定</li><li>编译型和运行型和不一致就导致了多态</li></ul><p><strong>注意：</strong></p><ol><li>向上转型后的父类对象 调用的是<strong>子类重载的方法</strong></li><li>向上转型后的父类对象 的其他方法和属性<strong>都是父类的</strong></li><li>本质上还是父类对象，只是方法替换成子类的</li><li><strong>向上转型是允许的、安全的，因为子类必定包含父类的所有属性和方法</strong></li><li><strong>向下转型是不安全的，因为子类含有父类不包含的属性和方法</strong>，所以需要强制转换，而且转型前需要使用instanceof进行判断</li></ol><p><strong>instanceof操作符</strong>：</p><ul><li>x instanceof A：检验x是否是A的对象或者是A<code>后代</code>的对象</li><li>向下转型时先判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据传进来的参数判断是猫还是狗</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;猫&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;狗&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat cat = <span class="keyword">new</span> Cat(<span class="string">&quot;猫&quot;</span>);</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">&quot;狗&quot;</span>);</span><br><span class="line">        Animal animal= <span class="keyword">new</span> Cat(<span class="string">&quot;动物&quot;</span>);</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.check(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组对象</p></blockquote><ul><li>数组对象向上转型可以会出现一些问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee[] employees = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">        Manage[] manages = <span class="keyword">new</span> Manage[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 父类引用指向子类对象，向上转型</span></span><br><span class="line">        employees = manages;</span><br><span class="line">        <span class="comment">// 注意此时父类子类引用同一个，相当于父类对象指向子类而没有强转，报错</span></span><br><span class="line">        employees[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        manages[<span class="number">0</span>].print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5、方法"><a href="#3-5、方法" class="headerlink" title="3.5、方法"></a>3.5、方法</h3><p><strong>通过子类的对象调用 a 方法，</strong></p><ol><li>编译器会列举所有 方法名为a，且可以访问的方法（不包括父类私有方法，注意修饰符不同的方法也不构成重载）</li><li>编译器重载解析：寻找一个与<strong>所提供的参数的类型完全匹配</strong>的方法</li><li>若发现找不到或者找到多个方法，就会报错</li></ol><p><strong>方法的签名：</strong>方法的名字和参数构成方法的签名，与返回值无关</p><ul><li>子类定义与父类签名一致的方法，则会覆盖父类的方法</li><li>签名一致的方法必须保证方法<strong>相容</strong>，不然就是语法错误</li><li>同一个类的方法签名一致，则会报错</li></ul><p><strong>方法的重写：</strong>子类覆盖父类的方法，注意<strong>无法覆盖static方法</strong></p><p><strong>方法相容规则</strong>：</p><ul><li>子类覆盖的方法返回值必须为父类的<strong>返回值或返回值的子类型</strong></li><li>子类的方法的访问权限不能小于父类的，不能重写private方法</li><li>子类方法抛出的异常不能大于父类被重写方法的异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法重载，这种写法报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Manage <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Manage(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Employee(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写方法，这种写法可以，因为Manage是Employee的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Manage(<span class="string">&quot;父类&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Manage <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Manage(<span class="string">&quot;子类&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态绑定与静态绑定</strong></p><ul><li>静态绑定：private、final、static方法，编译器会准确知道是什么方法</li><li>动态绑定：一般方法，虚拟机每次从子类寻找，找不到再从超类找，</li></ul><blockquote><p>虚拟机方法表</p></blockquote><p>虚拟机每次从子类寻找，找不到再从超类找，这样资源消耗过大</p><p>因此虚拟机定义了一个方法表，列出来<strong>所有方法的签名和要调用的实际方法</strong></p><h3 id="3-6、final"><a href="#3-6、final" class="headerlink" title="3.6、final"></a>3.6、final</h3><ul><li>final属性通过构造器赋值后就不能修改了</li><li>final类不能被继承</li><li>final方法不能被重写</li><li>final方法可以被重载</li></ul><h3 id="3-7、抽象类"><a href="#3-7、抽象类" class="headerlink" title="3.7、抽象类"></a>3.7、抽象类</h3><ul><li>抽象类：用abstract关键字来修饰一个类，这个类叫做抽象类。 </li><li>抽象方法：用abstract来修饰一个方法，该方法叫做抽象方法。</li></ul><p><strong>注意点：</strong></p><ul><li>抽象类可以不含抽象方法，含抽象方法的一定是抽象类</li><li>抽象类不能用new来实例化，只能被单继承，<strong>继承的类必须实现所有方法，不然只能继续定义为抽象类</strong></li><li>抽象类可以<strong>通过子类</strong>向上转型的方式<strong>实例化</strong></li><li><strong>抽象类相比于正常的类只是可能含有抽象方法</strong>，其他完全一致</li></ul><h3 id="3-8、访问权限修饰符"><a href="#3-8、访问权限修饰符" class="headerlink" title="3.8、访问权限修饰符"></a>3.8、访问权限修饰符</h3><table><thead><tr><th>修饰符</th><th>作用</th><th>范围</th></tr></thead><tbody><tr><td>default(即什么也不写）</td><td>在同一包内可见</td><td>类、接口、变量、方法</td></tr><tr><td>private</td><td>在同一类内可见</td><td>变量、方法</td></tr><tr><td>public</td><td>对所有类可见</td><td>类、接口、变量、方法</td></tr><tr><td>protected</td><td>对同一包内的类和所有子类可见</td><td>变量、方法</td></tr></tbody></table><h2 id="4、Object类"><a href="#4、Object类" class="headerlink" title="4、Object类"></a>4、Object类</h2><p><strong>Object类：</strong></p><ul><li><p>Object类是所有Java类的根父类</p></li><li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为Object类</p></li><li><p>Object类可以引用任何对象</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object object = new Employee(&quot;Tom&quot;);</span><br></pre></td></tr></table></figure><p><strong>Object变量只能作为各种值的泛型容器</strong>，而且必须强制类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee employee = (Employee) object;</span><br></pre></td></tr></table></figure><p><strong>Object类API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Object</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;  <span class="comment">// 唤醒线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span>;    <span class="comment">// 进入等待状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>; <span class="comment">// 设置最大等待时间并等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">getClass</span><span class="params">()</span></span>;     <span class="comment">// 获得类对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">getSuperClass</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;     <span class="comment">// 返回类名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Objects类API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title">requireNonNull</span><span class="params">(T obj)</span>     <span class="comment">// 查看指定对象是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">(Object a)</span>          <span class="comment">// null返回0，否则返回hashcode</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">(Object... objects)</span> <span class="comment">// 返回hascode组合      </span></span></span><br></pre></td></tr></table></figure><p>== ：</p><ul><li>基本数据类型比较值</li><li>引用数据类型比较地址（即是否指向同一个对象）</li></ul><p>equals：</p><ul><li>只比较引用数据类型，比较地址</li><li>String类的equals 重写了，比较的是值</li></ul><h2 id="5、包装类与自动装箱"><a href="#5、包装类与自动装箱" class="headerlink" title="5、包装类与自动装箱"></a>5、包装类与自动装箱</h2><p><strong>包装类：</strong>对八种基本数据类型定义相应的引用类型—包装类（封装类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装类对象的属性是不可以变化的</span></span><br><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">3</span>); <span class="comment">// 这种形式在Java9废弃了</span></span><br><span class="line">System.out.println(integer.hashCode());</span><br><span class="line">integer = <span class="number">5</span>;</span><br><span class="line">System.out.println(integer.hashCode());</span><br></pre></td></tr></table></figure><p><strong>装箱：</strong>基本数据类型包装成包装类的实例，<strong>如上述就是自动把5装箱</strong></p><p><strong>拆箱：</strong>包装类变成基本数据类型</p><p>注意：</p><ul><li>JDK1.5之后，支持自动装箱和自动拆箱，只要类型匹配</li><li>由于包装类是对象，所以可以为null，因此可能会出现异常</li><li>条件表示式里面混用Integer和Double类型，Integer会拆箱成int，然后转换成double，再装箱成Double</li><li><strong>自动装箱和自动拆箱是编译器优化的结果，而非虚拟机做的事情</strong></li></ul><blockquote><p>Integer类API</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;     <span class="comment">// 转换成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> radix)</span></span>;  <span class="comment">// 以radix进制显示的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span></span>;          </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s,<span class="keyword">int</span> radix)</span></span>; <span class="comment">// radix进制字符串转换成int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">ValueOf</span><span class="params">(String s)</span></span>;        <span class="comment">// 字符串转换成Integer</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">ValueOf</span><span class="params">(String s,<span class="keyword">int</span> radix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">ValueOf</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>面试题</p></blockquote><p>1、一个表达式里面，结果会变成精度最大的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">    System.out.println(o1);    <span class="comment">// 输出1.0</span></span><br><span class="line">    Object o2;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>)</span><br><span class="line">        o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">    System.out.println(o2);     <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、128以内的对象都是缓存在一个IntegerCache里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);   <span class="comment">// 不同对象</span></span><br><span class="line">    Integer m = <span class="number">1</span>;</span><br><span class="line">    Integer n = <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n);   </span><br><span class="line">    <span class="comment">// 创建的是同一个对象，这些对象已经缓存在IntegerCache里面了，因此相等</span></span><br><span class="line">    Integer x = <span class="number">128</span>;</span><br><span class="line">    Integer y = <span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y);   <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、枚举类"><a href="#6、枚举类" class="headerlink" title="6、枚举类"></a>6、枚举类</h2><ul><li>Java 枚举是一个<code>特殊的类</code>，一般表示一组常量，参数默认用<strong>public static final</strong> 修饰</li><li>枚举跟普通类一样可以有自己的变量、方法和构造函数，<strong>构造函数只能用private修饰</strong></li></ul><h3 id="6-1、简单定义和使用"><a href="#6-1、简单定义和使用" class="headerlink" title="6.1、简单定义和使用"></a>6.1、简单定义和使用</h3><ul><li>枚举类是static修饰的，所以可以通过类或者对象获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123; </span><br><span class="line">    RED, GREEN, BLUE; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Color.RED;               <span class="comment">// 直接获取</span></span><br><span class="line">Color c1 = Color.RED;    <span class="comment">// 赋给Color对象</span></span><br></pre></td></tr></table></figure><p><strong>以上的枚举类底层实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color RED = <span class="keyword">new</span> Color();  <span class="comment">// 枚举成员实际是一个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLUE = <span class="keyword">new</span> Color();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color GREEN = <span class="keyword">new</span> Color();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举类同样可以定义在一个类的内部：</strong></p><ul><li><p>本类访问：Color.BLUE;</p></li><li><p>其他类访问：外部类类名.Color.Blue</p></li></ul><h3 id="6-2、操作枚举元素"><a href="#6-2、操作枚举元素" class="headerlink" title="6.2、操作枚举元素"></a>6.2、操作枚举元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代枚举元素</span></span><br><span class="line"><span class="keyword">for</span> (Color myVar : Color.values()) &#123;</span><br><span class="line">System.out.println(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在switch中使用枚举类</span></span><br><span class="line">Color myVar = Color.BLUE;</span><br><span class="line"><span class="keyword">switch</span>(myVar) &#123;</span><br><span class="line"><span class="keyword">case</span> RED:</span><br><span class="line">System.out.println(<span class="string">&quot;红色&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>API：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">values();    <span class="comment">// 把枚举类型的成员变量实例以数组形式返回  Color[] arr = Color.values(); </span></span><br><span class="line">valueof();   <span class="comment">// 普通字符串转换为枚举实例    Color.valueOf(&quot;Blue&quot;) == Color.Blue</span></span><br><span class="line">compareTo(); <span class="comment">// 比较两个枚举对象定义的顺序，参数里面在前返回1，后面返回0</span></span><br><span class="line">ordinal();   <span class="comment">// 获取某个对象位置的索引值，从0开始</span></span><br></pre></td></tr></table></figure><h3 id="6-3、带参的枚举类成员"><a href="#6-3、带参的枚举类成员" class="headerlink" title="6.3、带参的枚举类成员"></a>6.3、带参的枚举类成员</h3><p><strong>由于枚举类成员实际上是static final 修饰的类对象，所以可以带参数</strong>，但是</p><ul><li>构造函数只能用private修饰</li><li>由于是静态的，如下有四个枚举成员，当使用Season时，会初始化这四个对象，也就是<strong>调用四次私有构造方法</strong>，同理如Season含有抽象方法，四个对象都必须实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Season</span> </span>&#123;</span><br><span class="line"><span class="comment">// 实际上等于public static final Season SPRING = new Season(&quot;春天&quot;, &quot;春暖花开&quot;);</span></span><br><span class="line"><span class="comment">// 创建了Season的一个对象，并且调用private构造器</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line"><span class="comment">// 私有变量，也是枚举成员的参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有构造方法，有四个枚举成员，所以实例化 Season时，该方法调用四次</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为是私有的变量，所以需要get方法获取参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化Season时候，会调用 n 次构造方法，n为成员数</span></span><br><span class="line">        Season season = Season.AUTUMN;</span><br><span class="line">        season.getSeasonDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、反射"><a href="#7、反射" class="headerlink" title="7、反射"></a>7、反射</h2><h3 id="7-1、概述"><a href="#7-1、概述" class="headerlink" title="7.1、概述"></a>7.1、概述</h3><p><strong>反射：</strong>类加载器加载完类之后，堆里面就会生成<strong>一个Class类型的对象</strong>（一个类只有一个Class对象），这个对象包含类的<strong>完整信息</strong>，通过这个对象来访问类的过程就是反射</p><ul><li>正常方式： 引入包名—-&gt;new实例化——&gt;取得实例化对象</li><li>反射方式： 实例化对象—–&gt;getClass()方法——-&gt;得到完整的”包类”名称</li></ul><p><strong>反射用途：</strong></p><ul><li>运行时取得类的<strong>内部信息</strong>，</li><li>运行时检查对象，直接操作对象的内部属性和方法。</li><li>实现泛型数组操作代码</li></ul><h3 id="7-2、获取Class对象"><a href="#7-2、获取Class对象" class="headerlink" title="7.2、获取Class对象"></a>7.2、获取Class对象</h3><ul><li>在程序运行期间，Java运行时系统始终为所有对象维护一个<strong>运行时类型标识</strong>，这个信息会跟踪每个对象所属的类。虚拟机利用<strong>运行时类型信息</strong>选择要执行的正确的方法。</li><li><strong>保存这些信息</strong>的类名为Class，可以通过Class对象访问这些信息。</li></ul><p><strong>注意：</strong></p><ul><li>Class 对象只能由<strong>虚拟机建立对象</strong>，一个类只有一个Class对象，所以可以用==比较</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li><li>通过Class可以完整地得到一个类中的所有被加载的结构</li></ul><p><strong>获取Class对象四种方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = User.class;           <span class="comment">// 通过类名,可以为基本数据类型 int.class</span></span><br><span class="line">Class c = user.getClass();      <span class="comment">// 通过对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">&quot;com.xxx.reflection.User&quot;</span>);   <span class="comment">//通过类的全限定名</span></span><br><span class="line">Class c = <span class="keyword">int</span>.TYPE;             <span class="comment">// 通过包装类</span></span><br></pre></td></tr></table></figure><ul><li>Class类实际上是一个<strong>泛型类</strong>，可以是类，也可以不是类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际使用都是省略类型</span></span><br><span class="line">Class&lt;User&gt; userClass = User.class;</span><br><span class="line">Class&lt;Integer&gt; integerClass = <span class="keyword">int</span>.class;</span><br></pre></td></tr></table></figure><ul><li>由于历史原因，数组输出获取名字会很奇怪</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(User[].class.getName());</span><br><span class="line">System.out.println(Integer.class.getName());</span><br><span class="line"></span><br><span class="line">[Lcom.wzh.反射.User;</span><br><span class="line">java.lang.Integer</span><br></pre></td></tr></table></figure><h3 id="7-3、获取资源"><a href="#7-3、获取资源" class="headerlink" title="7.3、获取资源"></a>7.3、获取资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">URL <span class="title">getResourceAsStream</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function">InputStream <span class="title">getResourceAsStream</span><span class="params">(String name)</span></span>;  <span class="comment">// 获取和类同一级的资源</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类对象</span></span><br><span class="line">Class c1 = Test.class;</span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// 获取输入流</span></span><br><span class="line">InputStream in = c1.getClassLoader().getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line"><span class="comment">// 读取数据信息</span></span><br><span class="line">properties.load(in);</span><br><span class="line"><span class="comment">// 获取信息</span></span><br><span class="line">String name = properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure><h3 id="7-4、操作类"><a href="#7-4、操作类" class="headerlink" title="7.4、操作类"></a>7.4、操作类</h3><p>Java.lang.reflect 包有3个类 Field、method、Constructor 分别获取属性、方法、构造器（不含父类的方法）</p><ul><li>获取类名，包名（Class对象方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>;              <span class="comment">// 获取包名 + 类名</span></span><br><span class="line"><span class="function">String <span class="title">getSimpleName</span><span class="params">()</span></span>;        <span class="comment">// 只获得类名</span></span><br><span class="line"><span class="function">String <span class="title">getPackageName</span><span class="params">()</span></span>;</span><br><span class="line">Class[] getInterfaces();       <span class="comment">// 获得接口</span></span><br></pre></td></tr></table></figure><ul><li> 获取Feild对象及FeildAPI</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Field对象</span></span><br><span class="line">Field[] getFields();               <span class="comment">// 获取public的类变量，返回数组</span></span><br><span class="line">Field[] getDeclaredFields();       <span class="comment">// 获取全部类变量，包括private</span></span><br><span class="line"></span><br><span class="line">Field[] getField(Strning name);</span><br><span class="line">Field[] getDeclaredField(Strning name);    <span class="comment">// 获取指定名称的 </span></span><br></pre></td></tr></table></figure><ul><li>获取method对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method[] getMethods();              <span class="comment">// 获取public的method</span></span><br><span class="line">Method[] getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">Method[] getMethod(String name,String.class...);  <span class="comment">// 要指定方法名和参数的类型</span></span><br><span class="line">Method[] getDeclaredMethod(String name,<span class="keyword">null</span>);     <span class="comment">// 无参可以使用null或者不填</span></span><br></pre></td></tr></table></figure><ul><li>获取Constructor对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] getConstructors();</span><br><span class="line">Constructor[] getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">Constructor[] getDeclaredConstructor(String.class...); <span class="comment">// 需要指定参数类型</span></span><br><span class="line">Constructor[] getConstructor();             <span class="comment">// 无参则不填</span></span><br></pre></td></tr></table></figure><p>三个类对象常用API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>                   <span class="comment">// 返回的 Field对象表示的字段的名称。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>         <span class="comment">// 比较这 Field与指定对象。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span>                 <span class="comment">// 返回的 对构造器、方法、字段的修饰符的描述</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>;     <span class="comment">// 操作私有的必须设置为true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field  </span></span><br><span class="line"><span class="function">Class <span class="title">getType</span><span class="params">()</span>                    <span class="comment">// 返回类型  </span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object obj)</span>             <span class="comment">// 传入对象，获取该对象的属性  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span> <span class="comment">// 传入对象，把该字段设置为该值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// Method 和 Constructor通用</span></span></span><br><span class="line"><span class="function">Class <span class="title">getReturnType</span><span class="params">()</span>      <span class="comment">// 返回类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParameterCount</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">Class[] <span class="title">getParameterTypes</span><span class="params">()</span>  <span class="comment">// 返回参数类型</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// Method</span></span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span>  <span class="comment">// 调用方法,需要传入对象和参数</span></span></span><br><span class="line"><span class="function"><span class="comment">// Constructor </span></span></span><br><span class="line"><span class="function"><span class="title">newInstance</span><span class="params">(Object... initargs)</span>  <span class="comment">// 调用构造器创建对象,需要传入参数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//扩展 通过Class对象调用newInstance是调用无参构造    </span></span></span><br></pre></td></tr></table></figure><p><strong>Modifier类API</strong></p><blockquote><p>示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">// 获得User的Class类对象</span></span><br><span class="line">        Class c = User.class;</span><br><span class="line">        <span class="comment">// 调用构造器创建对象</span></span><br><span class="line">        User user1 = (User) c.getConstructor().newInstance();</span><br><span class="line">        <span class="comment">// 调用无参构造</span></span><br><span class="line">        User user2 = (User) c.newInstance();</span><br><span class="line">        <span class="comment">// 获取私有字段</span></span><br><span class="line">        Field field = c.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="comment">// 给id设置值</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(user1,<span class="number">1</span>);</span><br><span class="line">        field.set(user2,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        Method method = c.getMethods()[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        method.invoke(user1,<span class="number">11</span>);</span><br><span class="line">        method.invoke(user2,<span class="number">88</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5、操作注解"><a href="#7-5、操作注解" class="headerlink" title="7.5、操作注解"></a>7.5、操作注解</h3><p>API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] getAnnotations();  <span class="comment">// 获取注解</span></span><br><span class="line">Annotation[] getAnnotation(Annotation annotation);  <span class="comment">// 根据注解类型获取</span></span><br><span class="line">Annotation[] getDeclaredAnnotation();</span><br></pre></td></tr></table></figure><blockquote><p>实战</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类上的注解，</span></span><br><span class="line">Annotation[] annotations = c.getAnnotations();</span><br><span class="line"><span class="keyword">for</span>(Annotation annotation:annotations)&#123;            <span class="comment">//循环注解信息</span></span><br><span class="line">    System.out.println(annotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类上的注解</span></span><br><span class="line">MyAnnotation m1 = (MyAnnotation) c.getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(m1.value());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段注解</span></span><br><span class="line">Field[] fields = c.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field f:fields) &#123;</span><br><span class="line">    MyAnnotation m2 = f.getAnnotation(MyAnnotation.class);</span><br><span class="line">    System.out.println(m2.value()); <span class="comment">// 注解定义的字段名是什么，就xxx()获取</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取方法的注解</span></span><br><span class="line">MyAnnotation m3 = c.getMethods()[<span class="number">0</span>].getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(m3.value());</span><br></pre></td></tr></table></figure><p><strong>特殊注意：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为数组时反射调用方法需要强制转换</span></span><br><span class="line">method.invoke(user,(Object) strings);</span><br></pre></td></tr></table></figure><h3 id="7-6、操作泛型"><a href="#7-6、操作泛型" class="headerlink" title="7.6、操作泛型"></a>7.6、操作泛型</h3><p>​    上述反射API获取的参数若是HashMap，则只能得到参数类型为HashMap，而无法得到HashMap里面的键和值的类型，为了通过反射操作这些类型，java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType<strong>几种类型</strong>来代表不能被归一到class类中的类型但是又和原始类型齐名的类型</p><ul><li>ParameterizedType：表示参数化类型，比如collection<String></li><li>GenericArrayType：表示一种元素类型是参数化类型或者类型变量的<strong>数组类型</strong></li><li>TypeVariable：各种类型变量的公共父接口</li><li>WinldcardType：代表一种通配符类型表达式</li></ul><p><strong>API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class方法</span></span><br><span class="line">TypeVariable[] getTypeParameters() </span><br><span class="line"><span class="comment">// 如果类型被声明为泛型类型，则获得泛型类型变量，否则获得长度为0的数组  </span></span><br><span class="line">Type[] getGenericSuperClass();   <span class="comment">// 获得声明超类的泛型类型</span></span><br><span class="line">Type[] getGenericInterfaces();   <span class="comment">// 获得这个类型所声明接口的泛型类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// method方法</span></span><br><span class="line">TypeVariable[] getTypeParameters() </span><br><span class="line">Type[] getGenericParameterTypes()  <span class="comment">// 获得泛型参数，</span></span><br><span class="line"><span class="function">Type <span class="title">getGenericReturnType</span><span class="params">()</span>        <span class="comment">// 获得泛型返回值类型。 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// TypeVariable方法</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Type[] <span class="title">getBounds</span><span class="params">()</span>   <span class="comment">// 获得变量的子类限定</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// wildcardType方法     </span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getUpperBounds</span><span class="params">()</span>    <span class="comment">// 获得这个类型变量的子类限定</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getLowerBounds</span><span class="params">()</span>   <span class="comment">// 超类限定</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ParameterizedType</span></span></span><br><span class="line"><span class="function">Type <span class="title">getRawType</span><span class="params">()</span>    <span class="comment">//获得原始类型</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getActualTypeArguments</span><span class="params">()</span>    <span class="comment">// 获得这个参数化类型声明的类型参数</span></span></span><br><span class="line"><span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span>     <span class="comment">//  返回外部类型，是顶层则返回null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// GenericArrayType</span></span></span><br><span class="line"><span class="function">Type <span class="title">getGenericComponentType</span><span class="params">()</span> <span class="comment">// 获得这个数组类型声明的泛型元素类型    </span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Map&lt;String,Integer&gt; map, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Integer&gt; <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取test1方法</span></span><br><span class="line">        Method method1 = Test.class.getMethod(<span class="string">&quot;test1&quot;</span>, Map.class,List.class);</span><br><span class="line">        <span class="comment">// 获得 所有的参数数组</span></span><br><span class="line">        Type[] genericParameterTypes = method1.getGenericParameterTypes();</span><br><span class="line">        <span class="comment">// 变量参数数组</span></span><br><span class="line">        <span class="keyword">for</span>(Type type:genericParameterTypes)&#123;</span><br><span class="line">            <span class="comment">// 输出map的所有参数和list的所有参数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;1:&quot;</span>+type);</span><br><span class="line">            <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            <span class="comment">// 把map和list整体的参数细化为String,Integer这种</span></span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class="line">                <span class="comment">// 输出具体的全部参数，如输出map里面的所有参数</span></span><br><span class="line">                <span class="keyword">for</span>(Type type1:actualTypeArguments)&#123;</span><br><span class="line">                    System.out.println(type1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取返回值参数</span></span><br><span class="line">        Method method2 = Test.class.getMethod(<span class="string">&quot;test2&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 获取返回值类型</span></span><br><span class="line">        Type genericReturnType = method2.getGenericReturnType();</span><br><span class="line">        System.out.println(genericReturnType);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type type:actualTypeArguments)&#123;</span><br><span class="line">                System.out.println(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-7、反射编写泛型数组"><a href="#7-7、反射编写泛型数组" class="headerlink" title="7.7、反射编写泛型数组"></a>7.7、反射编写泛型数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; E[] printArray( E[] inputArray )&#123;</span><br><span class="line">    Class c2 = inputArray.getClass().getComponentType();</span><br><span class="line"><span class="comment">// 调用反射方法创建数组，因为无法通过E去创建数组</span></span><br><span class="line">    E[] newArray = (E[]) Array.newInstance(c2,inputArray.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputArray.length; i++) &#123;</span><br><span class="line">        newArray[i] = inputArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、接口"><a href="#8、接口" class="headerlink" title="8、接口"></a>8、接口</h2><h3 id="8-1、简介"><a href="#8-1、简介" class="headerlink" title="8.1、简介"></a>8.1、简介</h3><ul><li><strong>只含常量值、抽象方法</strong>，变量：public static final，方法：public abstract</li><li>接口并不是类，类描述对象的属性和方法。接口则包含类要实现的方法。</li><li>接口无法被实例化，一个类可以<strong>实现多个接口</strong>，一个接口可以多继承其他接口</li><li>实现接口的类中必须提供接口中所有方法的实现，方可实例化。否则仍为抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">18</span>;              <span class="comment">// 定义成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAge</span><span class="params">()</span></span>;      <span class="comment">// 定义抽象方法</span></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购物&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现方法，使用定义的常量</span></span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以重写也可以不重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买鞋子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PersonImpl person = <span class="keyword">new</span> PersonImpl();</span><br><span class="line">        person.buy(<span class="string">&quot;衣服&quot;</span>);</span><br><span class="line">        person.buy();</span><br><span class="line">        Person.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">买衣服</span><br><span class="line">买鞋子</span><br><span class="line">吃</span><br></pre></td></tr></table></figure><p><strong>Java8新特性：</strong>可以为接口添加静态方法和默认方法（包含方法体）</p><ol><li>静态方法：使用 static 关键字修饰。可以<strong>通过接口直接调用</strong>静态方法。</li><li>默认方法：默认方法使用 default 关键字修饰。可以通过<strong>实现类对象</strong>来调用。<ul><li><strong>父类的默认方法之间可能造成冲突</strong>：类C实现了接口A和接口B，而接口A和接口B有一样的默认方法，就会造成冲突，此类C必需重写该方法。</li><li><strong>子类默认方法和父类的方法不会冲突</strong>，会调用父类方法</li></ul></li><li>私有方法：JDK9允许，私有方法必需是静态方法或者实例方法</li></ol><p>不过一般不推荐这么做，如Java就是Collection接口和CollectionS工具类提供静态方法</p><h3 id="8-2、接口和抽象"><a href="#8-2、接口和抽象" class="headerlink" title="8.2、接口和抽象"></a>8.2、接口和抽象</h3><table><thead><tr><th>区别</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>定义</td><td>可能包含抽象方法的类</td><td>主要是抽象方法和全局常量的集合</td></tr><tr><td>组成</td><td>构造方法、抽象方法、普通方法、常量、变量</td><td>常量、抽象方法、(jdk8.0:默认方法、静态方法)</td></tr><tr><td>使用</td><td>子类继承抽象类(extends)</td><td>子类实现接口(implements)</td></tr><tr><td>关系</td><td>抽象类可以实现多个接口</td><td>接口不能继承抽象类，但允许继承多个接口</td></tr><tr><td>局限</td><td>抽象类有单继承的局限</td><td>接口没有此局限</td></tr><tr><td>实际</td><td>作为一个模板</td><td>是作为一个标准或是表示一种能力</td></tr><tr><td>常见设计模式</td><td>模板方法</td><td>工厂模式、代理模式</td></tr></tbody></table><h3 id="8-3、Comparable接口"><a href="#8-3、Comparable接口" class="headerlink" title="8.3、Comparable接口"></a>8.3、Comparable接口</h3><ul><li>实现了 Comparable 接口的类，调用数组或者集合的 sort 方法·就行实现排序了</li><li>返回0表示相等，返回1表示当前类更大，返回 - 1 表示当前类更小</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4、Compator接口"><a href="#8-4、Compator接口" class="headerlink" title="8.4、Compator接口"></a>8.4、Compator接口</h3><ul><li>实现了 Comparable 接口的类，表明这是一个比较器</li><li>数组或者集合的 sort 方法 ，传入比较器的对象也能实现比较，并且不需要改动原本的类</li><li>返回0表示相等，返回1表示当前类更大，返回 - 1 表示当前类更小</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o, Object t1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如想自己定义String类的比较顺序，就只能通过传入比较器对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种方式de比较器</span></span><br><span class="line">Comparator.comparing(User::getId).thenComparing(User::getName);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入功能，比较null</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.*;</span><br><span class="line">Arrays.sort(users,comparing((User::getId),nullsFirst(naturalOrder())));</span><br><span class="line"><span class="comment">// 逆序后面加reversed()或者reverseOrder()</span></span><br></pre></td></tr></table></figure><h3 id="8-5、对象克隆"><a href="#8-5、对象克隆" class="headerlink" title="8.5、对象克隆"></a>8.5、对象克隆</h3><p><strong>问题：</strong>众所周知，把A对象赋给B对象，只是传递了引用，二者实际还是指向同一个地址，此时B对象的改变会引起A对象的改变</p><p><strong>解决</strong>：通过克隆（实现cloneable接口）可以产生一个新的对象，并且完全脱离旧对象而存在</p><ul><li>浅拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型进⾏引⽤传递般的拷⻉，此为浅拷</li><li>深拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型，创建⼀个新的对象，并复制其内容</li></ul><blockquote><p>浅克隆</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Son son = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">// Object类的clone方法是受保护的，main方法不能调用</span></span><br><span class="line">        User newUser = (User) user.clone();</span><br><span class="line">        System.out.println(user.hashCode());</span><br><span class="line">        System.out.println(newUser.hashCode());</span><br><span class="line"></span><br><span class="line">        System.out.println(user.son.hashCode());</span><br><span class="line">        System.out.println(newUser.son.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里出现了一个问题，新对象和旧对象的hashcode不同，但是他们内部属性son类却还是同一个，<strong>新对象和旧对象直接还存在联系</strong></p><ul><li>浅克隆：可能还存在一些关联</li><li>深克隆：完全不同</li></ul><blockquote><p>深克隆</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Son 实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重新编写clone方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    User user = (User) <span class="keyword">super</span>.clone();</span><br><span class="line">    user.son = (Son) <span class="keyword">this</span>.son.clone();</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><p>cloneable是一个标记接口，实际上没有任何作用，因为我们需要的clone方法是从Object类继承而来，如果一个对象克隆但是有没有实现该接口，就会生成一个检查型异常</p><h2 id="9、lambda表达式"><a href="#9、lambda表达式" class="headerlink" title="9、lambda表达式"></a>9、lambda表达式</h2><h3 id="9-1、函数式接口"><a href="#9-1、函数式接口" class="headerlink" title="9.1、函数式接口"></a>9.1、函数式接口</h3><ol><li><code>只包含一个抽象方法</code>的接口，称为函数式接口。</li><li>我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检 查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个 接口是一个函数式接口。</li><li><strong>Lambda表达式就是一个函数式接口的实例。</strong></li></ol><h3 id="9-2、Java内置四大核心函数式接口"><a href="#9-2、Java内置四大核心函数式接口" class="headerlink" title="9.2、Java内置四大核心函数式接口"></a>9.2、Java内置四大核心函数式接口</h3><p><img src="C:\Users\admin\Desktop\JavaSE\img\JavaSE\3.jpg"></p><table><thead><tr><th></th><th>参数类型</th><th>返回类型</th></tr></thead><tbody><tr><td>消费型接口</td><td>T</td><td>void</td></tr><tr><td>供给型接口</td><td>无</td><td>T</td></tr><tr><td>函数型接口</td><td>T</td><td>R</td></tr><tr><td>断定型接口</td><td>T</td><td>boolean</td></tr></tbody></table><h3 id="9-3、lambda表达式"><a href="#9-3、lambda表达式" class="headerlink" title="9.3、lambda表达式"></a>9.3、lambda表达式</h3><ol><li>Lambda 是一个匿名函数，可以把 Lambda 表达式理解为是<strong>一段可以 传递的代码</strong></li><li>Lambda表达式可以替代<strong>只有一个方法的匿名内部类</strong></li><li>本质上还是一个匿名类，所以不能引用前后的非static数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Ilike</span></span>&#123; </span><br><span class="line"><span class="function">String <span class="title">Lamada</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 匿名内部类实现</span></span><br><span class="line">        A a = <span class="keyword">new</span> A() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.index(<span class="number">5</span>);</span><br><span class="line">     <span class="comment">// lambda表达式实现   </span></span><br><span class="line">        A a1 = ((i) -&gt; &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;);</span><br><span class="line">        a1.index(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果为单个参数可以删去()，单条执行语句可以删去&#123;&#125;</span></span><br><span class="line"><span class="comment">// 简化版本</span></span><br><span class="line">A a1 = (i -&gt; System.out.println(i));</span><br><span class="line">a1.index(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><blockquote><p>变量作用域问题</p></blockquote><ul><li>lambda表达式只能获取外部的变量的值，而<strong>不能修改</strong></li><li>lambda表达式获取的外部变量，在整个作用域内<strong>不能发生改变</strong>，如下面 i 不能变化。即必须为事实最终变量</li><li>lambda表达式使用的 this 指向的是外部方法，而不是内部匿名类，并且使用this就不能定义为静态方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> j =<span class="number">0</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果定义了i++;会报错</span></span><br><span class="line">        Factory factory = ()-&gt;&#123;</span><br><span class="line">            j--;         <span class="comment">// i--会报错,因为不安全</span></span><br><span class="line">            <span class="keyword">int</span> m = j+i; <span class="comment">// 可以使用i的值，但是不能改变i</span></span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;;</span><br><span class="line">        factory.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test.fun1(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4、方法引用"><a href="#9-4、方法引用" class="headerlink" title="9.4、方法引用"></a>9.4、方法引用</h3><ul><li>当要传递给Lambda体的操作，<code>已经有实现的方法了</code>，可以使用方法引用！</li><li>简单理解：<strong>使用其他方法当做lambda表达式的方法</strong>，无须自己写方法</li></ul><p><strong>要求：</strong>实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！</p><p><strong>格式：</strong></p><ul><li><p>使用操作符 “::” 将类(或对象) 与 方法名分隔开来。</p></li><li><p>对象::实例方法名、类::静态方法名、类::实例方法名</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口：</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">big</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法调用实现,Test02类的big方法参数和返回值都和Test01的eat方法一致，所以可以调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test02 test02 = <span class="keyword">new</span> Test02();</span><br><span class="line">Test01 test01 = test02::big;   <span class="comment">//调用了方法</span></span><br><span class="line">test01.eat(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-5、构造器引用"><a href="#9-5、构造器引用" class="headerlink" title="9.5、构造器引用"></a>9.5、构造器引用</h3><p><strong>要求：</strong>构造器参数列表要与接口中抽象 方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</p><p><strong>格式：</strong>类名::new</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">createUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器引用</span></span><br><span class="line">Factory factory = User::<span class="keyword">new</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line">Test01 test01 = (()-&gt;&#123;  <span class="keyword">return</span> <span class="keyword">new</span> Bank();&#125;);</span><br></pre></td></tr></table></figure><h3 id="9-6、数组引用"><a href="#9-6、数组引用" class="headerlink" title="9.6、数组引用"></a>9.6、数组引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须要有参数指定长度</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] createArr(<span class="keyword">int</span> length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = factory.createArr(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、内部类"><a href="#10、内部类" class="headerlink" title="10、内部类"></a>10、内部类</h2><p>分类：</p><ol><li>成员内部类（static和非static，可以为public和private和protected）</li><li>局部内部类（不谈修饰符）</li><li>匿名内部类</li></ol><h3 id="9-1、成员内部类"><a href="#9-1、成员内部类" class="headerlink" title="9.1、成员内部类"></a>9.1、成员内部类</h3><ul><li>可以把内部类看做外部类的一个<strong>属性</strong>，同样有public和private和protected修饰符，<ul><li>public能在外部通过外部类创建对象，protected能在本包下创建对象，</li><li>private则只能通过<strong>外部类封装内部类的方法</strong>让外界能访问到内部类的方法</li></ul></li><li>内部类具有自己的属性和方法，但是<strong>不能定义成静态</strong>的</li><li>内部类可以获得外部类<strong>所有的</strong>方法和属性（包括私有、静态等）</li><li>内部类和外部类的属性或者方法相同时，内部类的会<strong>覆盖外部类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(String name, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String name = <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 内部类可以访问外部的所有方法和属性(包括私有的)</span></span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                System.out.println( <span class="string">&quot;访问了外部类私有数据&quot;</span>+name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// private内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner2</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String name = <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 内部类可以访问外部的所有方法和属性(包括私有的)</span></span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="comment">// 覆盖外部的name</span></span><br><span class="line">                System.out.println( <span class="string">&quot;访问了外部类私有数据&quot;</span>+name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把内部类方法封装出来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">funByInner2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner2 inner2 = <span class="keyword">new</span> Inner2();</span><br><span class="line">        inner2.fun();</span><br><span class="line">        System.out.println(inner2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public内部类对象必须通过外部类对象创建</span></span><br><span class="line">    Outer outer = <span class="keyword">new</span> Outer(<span class="string">&quot;张三&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">    Outer.Inner1 inner1 = outer.<span class="function">new <span class="title">Inner1</span><span class="params">()</span></span>;</span><br><span class="line">    inner1.fun();</span><br><span class="line">    <span class="comment">// private内部类无法在外部直接创建，只能通过外部类的方法封装内部类方法</span></span><br><span class="line">    outer.funByInner2();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2、静态内部类"><a href="#9-2、静态内部类" class="headerlink" title="9.2、静态内部类"></a>9.2、静态内部类</h3><ul><li>静态成员内部类可以定义静态属性和方法，但是有使用限制<ul><li>静态属性使用无限制，获取可以直接通过类获取，而不必new对象</li><li>静态方法只能获取静态内部类或外部类的<strong>静态属性</strong>，获取可以直接通过类获取，而不必new对象</li></ul></li><li>静态成员内部类的非静态属性和方法<ul><li>非静态属性：只能被非静态方法调用</li><li>非静态方法：只能调用外部类的静态属性和方法，内部类的所有属性和方法</li></ul></li><li>静态内部类同样有3种修饰符，</li></ul><p>总之，最大的不同就是因为是静态，所以只能获取外部的静态资源。</p><h3 id="9-3、局部内部类"><a href="#9-3、局部内部类" class="headerlink" title="9.3、局部内部类"></a>9.3、局部内部类</h3><p><strong>定义：</strong>在<strong>方法中定义</strong>，然后使用</p><p><strong>范围：</strong>只能在该方法中使用，而且必须先声明，在使用</p><p><strong>特点：</strong></p><ul><li>不能使用任何修饰符</li><li>可以访问局部变量（<strong>在方法内改变了必须从未修改过</strong>），但是不能修改</li><li>this指向的是本身</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">// this指向自己，</span></span><br><span class="line">                System.out.println(i+name+<span class="keyword">this</span>.hashCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.show();</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4、匿名内部类"><a href="#9-4、匿名内部类" class="headerlink" title="9.4、匿名内部类"></a>9.4、匿名内部类</h3><p><strong>概念：</strong>不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。</p><p><strong>特点：</strong></p><ul><li>匿名内部类必须<strong>继承父类或实现接口</strong></li><li>可以访问局部变量（<strong>在方法内改变了必须从未修改过</strong>），但是不能修改</li><li>this指向的是外部方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.eat();</span><br></pre></td></tr></table></figure><p>匿名内部类继承或者实现一个类或接口，然后调用里面的方法。</p><blockquote><p>注意</p></blockquote><p>局部和匿名内部类访问外部局部变量的原因是编译器<strong>会做变量拷贝</strong>，这也是为什么不能访问在外部发生过值变化的局部变量的原因</p><h2 id="11、代理"><a href="#11、代理" class="headerlink" title="11、代理"></a>11、代理</h2><h3 id="11-1、静态代理"><a href="#11-1、静态代理" class="headerlink" title="11.1、静态代理"></a>11.1、静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Marry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;等了这么久，终于等到你。。。 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarryCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Marry marry;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarryCompany</span><span class="params">(Marry marry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.marry = marry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        marry.toMarry();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;婚礼现场布置中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜您结婚，迈入人生第二阶段&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代理类和目标类实现同一个接口</li><li>代理类构造方法需要传入目标类</li><li>代理类的方法依次实现before方法，目标类方法，after方法</li></ul><p><strong>优点</strong></p><ul><li>真实的对象更加纯粹，不用去关注一些公共的业务</li><li>广告业务交给代理类，实现业务分工</li><li>公共业务发生拓展的时候，方便集中管理</li></ul><p><strong>缺点</strong></p><ul><li>一个真实对象会产生一个代理角色：代码量翻倍——&gt;效率低</li></ul><h3 id="11-2、动态代理（反射）"><a href="#11-2、动态代理（反射）" class="headerlink" title="11.2、动态代理（反射）"></a>11.2、动态代理（反射）</h3><ul><li>动态代理和静态代理角色一样</li><li>动态代理的代理类是动态生成的，不是直接写好的</li><li>动态代理分为两大类：基于接口和基于类<ul><li>基于接口——-JDK代理</li><li>基于类：cglib</li><li>Java字节码实现：JavaAssist</li></ul></li></ul><blockquote><p>InvocationHandler：反射包下的类，是一个接口，只有invoke方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy,方法 method,Object[] args)</span><span class="keyword">throws</span> Throwable</span></span><br></pre></td></tr></table></figure><p>定义一个动作，所有接口的方法执行都会替换成动作执行</p><blockquote><p>Proxy：</p></blockquote><p>Proxy为创建动态代理类的实例提供了静态方法，也是所有动态代理类的父类的方法创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, </span></span></span><br><span class="line"><span class="params"><span class="function">              类&lt;?&gt;[] interfaces, InvocationHandler h)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序</span></span></span><br><span class="line"><span class="function"><span class="comment">//即根据传入的父接口的子实现类，返回该父接口的对象（向上转型），通过该父接口调用子类方法</span></span></span><br></pre></td></tr></table></figure><ul><li>参数一为Loader的类加载器</li><li>参数二为代理实现的接口，Class对象数组</li><li>参数三为调用处理器，即代理类</li></ul><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Rent rent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRent</span><span class="params">(Rent rent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成得到代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),rent.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// invoke相当于执行接口的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">// 反射调用了方法，rent为对象，objects为参数</span></span><br><span class="line">        Object result = method.invoke(rent,objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真实角色</span></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        <span class="comment">//代理角色:现在没有</span></span><br><span class="line">        ProxyInvocationHandler proxyInvocationHandler = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">        <span class="comment">//传入真实角色</span></span><br><span class="line">        proxyInvocationHandler.setRent(host);</span><br><span class="line">        <span class="comment">// 获得代理类</span></span><br><span class="line">        Rent proxy = (Rent) proxyInvocationHandler.getProxy();</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE(一):基本语法</title>
      <link href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%80%20)%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%80%20)%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h2><p><strong>按照数据类型分类：</strong></p><ul><li>基本类型：整型、浮点型、字符型、布尔型</li><li>引用类型：类、接口、数组、枚举、注解等</li></ul><p><strong>按声明的位置的不同</strong></p><ul><li>成员变量：方法体外，类体内声明的变量称为（其中被static修饰的称为<strong>类变量</strong>，其他为实例变量）</li><li>局部变量：在方法体内部声明（形参、方法内局部变量、代码块局部变量）</li></ul><p><strong>同：</strong>都有生命周期 </p><p><strong>异：</strong>局部变量除形参外，需显式初始化。</p><h3 id="1-1、整型"><a href="#1-1、整型" class="headerlink" title="1.1、整型"></a>1.1、整型</h3><p>整型表示没有小数部分的数值</p><table><thead><tr><th align="center">类型</th><th align="center">存储需求</th><th>范围</th><th>表示</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">4字节</td><td>-2 ^31 ~2^31-1(约21亿)</td><td>正常表示</td></tr><tr><td align="center">short</td><td align="center">2字节</td><td>-2 ^15 ~2^15 -1</td><td></td></tr><tr><td align="center">long</td><td align="center">8字节</td><td>-2 ^63 ~2^63-1(约21亿)</td><td>后缀有L或者l</td></tr><tr><td align="center">byte</td><td align="center">1字节</td><td>-128~127</td><td></td></tr></tbody></table><p>需要注意的是，</p><ul><li>Java的整型范围与平台无关（C/C++会自动选择最优的）</li><li>Java没有任何无符号形式的整形</li></ul><h3 id="1-2、浮点类型"><a href="#1-2、浮点类型" class="headerlink" title="1.2、浮点类型"></a>1.2、浮点类型</h3><table><thead><tr><th>类型</th><th>存储需求</th><th>范围</th><th>表示</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>-3.403E38 ~ 3.403E38</td><td>后缀有F或者f</td></tr><tr><td>double</td><td>8字节</td><td>-1.798E308 ~ 1.798E308</td><td>后缀有D或者d</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li><p>没有后缀默认为double类型</p></li><li><p>两种表示方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.1</span>   <span class="number">6.34F</span>   <span class="number">.512</span>   <span class="comment">// 十进制计数法 </span></span><br><span class="line"><span class="number">5.12e2</span> <span class="number">512E2</span> <span class="number">100E-2</span>  <span class="comment">// 科学计数法</span></span><br></pre></td></tr></table></figure></li><li><p>特殊的三个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Double.POSITIVE_INFINITY;  <span class="comment">// 表示正无穷大</span></span><br><span class="line">Double.NEGATIVE_INFINITY;  <span class="comment">// 表示负无穷大</span></span><br><span class="line">Double.NaN;                <span class="comment">// 表示不是一个数字，0/0 或者 负数平方根</span></span><br></pre></td></tr></table></figure></li><li><p>所有的浮点数直接不能比较，因为浮点数底层还是用<strong>二进制</strong>表示的，二进制无法准确的表示小数</p></li></ul><h3 id="1-3、char类型"><a href="#1-3、char类型" class="headerlink" title="1.3、char类型"></a>1.3、char类型</h3><table><thead><tr><th>类型</th><th>存储需求</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>2字节，16位</td><td>\u0000~\uFFFF</td></tr></tbody></table><ul><li>char类型用于表示<strong>单个字符</strong>，一些Unicode编码<strong>需要两个char</strong>表示</li><li>Java中的所有字符都使用Unicode编码，通常字符用一个char存储，特殊的用两个存储，如emoji表情🍺</li><li>字符型变量的三种表现形式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;       <span class="comment">// 字面量表示</span></span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">&#x27;\n&#x27;</span>;      <span class="comment">// 用转义字符‘\’来将其后的字符转变为特殊字符型常量</span></span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">&#x27;\uXXXX&#x27;</span>;  <span class="comment">// 直接使用 Unicode 值来表示字符型常量</span></span><br></pre></td></tr></table></figure><ul><li>特殊的：\u是一种<strong>转义序列</strong>，可以出现在<strong>加引号的字符常量</strong>或者<strong>字符串之外</strong>（其他转义序列不行）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String\u005B\u005D args)</span>  <span class="comment">// 可以运行</span></span></span><br></pre></td></tr></table></figure><ul><li>Unicode转义序列会在<strong>解析代码</strong>之前处理，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \u000A a        会报错,因为\u000A会转换成一个换行符 \n</span></span><br></pre></td></tr></table></figure><ul><li>char也是用二进制存储的，可以和int相互转换，但int的范围不能太大</li></ul><blockquote><p>Unicode和char类型</p></blockquote><p>​    Unicode统一了同一了世界上所有字符，每个字符都为其分配一个数字来表示，当时认为16位（65536）已经足够表示了，所以Java设计char类型时也使用16位的Uicode字符集，但是后来随着汉字和日韩语言等的加入，16位得char已经不够使用了。</p><p>​    新标准：U+0000~U+FFFF表示经典Unicode编码，其他在最前面加入一位表示<strong>代码平面</strong>，例如U+10000就表示第一个代码平面。</p><p><strong>注意：Unicode只是一种标准，一般传输数据多用UTF-8或UTF-16</strong></p><p><strong>UTF-8（Unicode的一种实现）：</strong></p><ul><li>变长字节的设计，一个字符最长4字节，最少1字节，大部分汉字3字节</li><li>用一个字节表示的字符，第一位设为0，后面七位对应字符的Unicode码点，由于128个字符的Unicode完全对照ASCII码，所以ASCII编码的文件可以用UTF-8打开不乱码</li><li>用n个字节以上表示的，则第一个字节的前n位都为1，第N+1位为0，剩下的n-1个字节前两位都设置为10，多余的位置使用该字符的Unicode二进制代码填充，不够用0填充</li></ul><p><strong>UTF-16（Java使用的编码方式）</strong>：</p><ul><li>用2个字节或者4个字节表示</li><li>4字节表示的使用两个char，2字节的使用一个char表示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">U+1D546 使用UTF-16需要两个代码单元，也就是使用两个char表示</span><br><span class="line">此时如果调用charAt(1) 获取的是第二个代码单元</span><br></pre></td></tr></table></figure><h3 id="1-4、boolean类型"><a href="#1-4、boolean类型" class="headerlink" title="1.4、boolean类型"></a>1.4、boolean类型</h3><ul><li>大小1bit（位），判断逻辑条件，不能和整形相互转换</li><li>不允许取null值</li></ul><h3 id="1-5、数值类型之间的转换"><a href="#1-5、数值类型之间的转换" class="headerlink" title="1.5、数值类型之间的转换"></a>1.5、数值类型之间的转换</h3><ul><li>自动类型转换：多数据混合运算时，会<strong>自动转换</strong>成容量最大的那种。</li><li>强制类型转换：可以把<strong>大的数据类型强制转换(casting)成小的</strong>数据类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">char</span>、<span class="keyword">byte</span>、<span class="keyword">short</span>)<span class="keyword">int</span> -&gt; <span class="keyword">long</span> -&gt; <span class="keyword">float</span> -&gt; <span class="keyword">double</span> -&gt; String</span><br><span class="line"><span class="comment">// char、byte、short运算时会自动转换成int类型   </span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>布尔类型不能转换</li><li>String类型转回基本类型需要通过基本类型的包装类</li></ul><h3 id="1-6、进制"><a href="#1-6、进制" class="headerlink" title="1.6、进制"></a>1.6、进制</h3><ul><li>Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位，即最高位</li><li>前缀0X或者0x表示十六进制，前缀0表示八进制，前缀0b或者0B表示二进制</li><li>计算机以二进制<strong>补码</strong>的形式保存所有的整数</li></ul><p><strong>三种形式：</strong>负数情况下：反码  = 127 - 原码 、  补码 = 128 - 原码</p><ul><li>原码：最高位为符号位，负数为1。</li><li>反码：正数与原码相等，负数除了最高位，其他取反</li><li>补码：正数与原码相等，负数等于反码加1。</li></ul><p><strong>特点：</strong></p><ul><li>正数的原码、反码、补码都相同</li><li>负数的补码是其反码+1</li></ul><p><strong>原因：</strong></p><p>让计算机<strong>计算符号位</strong>比较麻烦，于是人们想出了将符号位也参与运算的方法。</p><p>根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了。</p><p>1-1=1+(-1)=0000 0001(原) + 1000 0001(原) = 0000 0001(补) + 1111 1111(补) = 0000 0000(原) = 0</p><ul><li>即让 1-1  = 1 + (-1) = (1 + (128-1))%128 =  128 % 128 = 0</li></ul><h2 id="2、变量和常量"><a href="#2、变量和常量" class="headerlink" title="2、变量和常量"></a>2、变量和常量</h2><h3 id="2-1、变量"><a href="#2-1、变量" class="headerlink" title="2.1、变量"></a>2.1、变量</h3><p><strong>概念：</strong></p><ul><li>内存中的一个存储区域（保存数据），该区域的值在不断变化，</li><li>程序中最基本的存储单元，</li></ul><p><strong>声明变量：</strong>每个变量都有一个类型，声明时需要指定类型，然后是变量名，以分号结尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量名: 合法的标志符</span><br><span class="line">标识符: 以字母开头并由字母(包括下划线)或者数字构成的序列，注意不能与关键字和保留字重名</span><br><span class="line">关键字: 被Java语言赋予了特殊含义，用做专门用途的字符串（单词），都为小写</span><br><span class="line">保留字: 现在Java没用到，但是以后可能用到</span><br></pre></td></tr></table></figure><p><strong>初始化：</strong>变量必须初始化后才能使用（类的成员变量会有默认值）</p><p><strong>作用域：</strong>其定义所在的一对{ }内 </p><p><strong>分类：</strong></p><ul><li>类变量：独立于方法之外的变量，用 static 修饰。</li><li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li><li>局部变量：方法里面</li></ul><h3 id="2-2、常量"><a href="#2-2、常量" class="headerlink" title="2.2、常量"></a>2.2、常量</h3><ul><li>使用关键字 final 修饰的变量，不能被修改，</li><li>通常使用大写字母作为变量名</li></ul><h3 id="2-3、枚举对象"><a href="#2-3、枚举对象" class="headerlink" title="2.3、枚举对象"></a>2.3、枚举对象</h3><p>Java 枚举是一个<code>特殊的类</code>，一般表示一组常量，参数默认用public static final 修饰</p><h3 id="2-4、修饰符"><a href="#2-4、修饰符" class="headerlink" title="2.4、修饰符"></a>2.4、修饰符</h3><p>访问权限：</p><table><thead><tr><th>修饰符</th><th>作用</th><th>范围</th></tr></thead><tbody><tr><td><strong>default</strong></td><td>同一包内可见，不使用任何修饰符</td><td>类、接口、变量、方法</td></tr><tr><td><strong>private</strong></td><td>在同一类内可见</td><td>变量、方法、内部类</td></tr><tr><td><strong>public</strong></td><td>对所有类可见</td><td>类、接口、变量、方法</td></tr><tr><td><strong>protected</strong></td><td>对同一包内的类和所有子类可见</td><td>变量、方法、内部类</td></tr></tbody></table><p>非访问权限：</p><table><thead><tr><th><strong>修饰符</strong></th><th><strong>作用</strong></th><th><strong>范围</strong></th></tr></thead><tbody><tr><td><strong>static</strong></td><td></td><td>变量、方法</td></tr><tr><td>final</td><td>变量：赋值后，不能修改    方法：不能继承</td><td>变量、方法</td></tr><tr><td>abstract</td><td></td><td>类、方法</td></tr><tr><td>synchronized</td><td>标记为同步</td><td>方法、代码块</td></tr><tr><td>volatile</td><td>保持可见性、禁止指令重排</td><td>变量</td></tr><tr><td>transient</td><td>java 虚拟机(JVM)跳过该特定的变量不序列化</td><td>变量</td></tr></tbody></table><h2 id="3、数字计算"><a href="#3、数字计算" class="headerlink" title="3、数字计算"></a>3、数字计算</h2><h3 id="3-1、算术运算符"><a href="#3-1、算术运算符" class="headerlink" title="3.1、算术运算符"></a>3.1、算术运算符</h3><ul><li>当两个操作数含浮点数时：表示浮动除法，</li><li>全为整数时：为整数除法（自动舍弃小数点后的数）</li></ul><h3 id="3-2、数学函数与变量"><a href="#3-2、数学函数与变量" class="headerlink" title="3.2、数学函数与变量"></a>3.2、数学函数与变量</h3><ul><li>Math 类提供很多方法，提供数学计算</li><li>StrictMath 类可以保证所有平台的计算结果一致</li><li>Math.PI    Math.E  表示π</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abs  <span class="comment">// 绝对值</span></span><br><span class="line">acos,asin,atan,cos,sin,tan  <span class="comment">// 三角函数</span></span><br><span class="line">sqrt  <span class="comment">// 平方根</span></span><br><span class="line">pow(<span class="keyword">double</span> a,doble b) <span class="comment">//  a的b次幂</span></span><br><span class="line">log  <span class="comment">// 自然对数</span></span><br><span class="line">exp <span class="comment">//  e为底指数</span></span><br><span class="line">max(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span><br><span class="line">min(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span><br><span class="line">random()                  <span class="comment">// 返回0.0到1.0的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> a)</span>      <span class="comment">// double型数据a转换为long型（四舍五入）</span></span></span><br><span class="line"><span class="function"><span class="title">toDegrees</span><span class="params">(<span class="keyword">double</span> angrad)</span>  <span class="comment">// 弧度—&gt;角度</span></span></span><br><span class="line"><span class="function"><span class="title">toRadians</span><span class="params">(<span class="keyword">double</span> angdeg)</span>  <span class="comment">// 角度—&gt;弧度</span></span></span><br></pre></td></tr></table></figure><h3 id="3-4、结合赋值运算符"><a href="#3-4、结合赋值运算符" class="headerlink" title="3.4、结合赋值运算符"></a>3.4、结合赋值运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+=  *= /= %=</span><br></pre></td></tr></table></figure><h3 id="3-5、自增和自减"><a href="#3-5、自增和自减" class="headerlink" title="3.5、自增和自减"></a>3.5、自增和自减</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x++  <span class="comment">// 先使用x，再++   </span></span><br><span class="line">++x  <span class="comment">// 先++，在使用x </span></span><br><span class="line">x-- </span><br></pre></td></tr></table></figure><h3 id="3-6、位运算"><a href="#3-6、位运算" class="headerlink" title="3.6、位运算"></a>3.6、位运算</h3><p>位运算是对整形的操作，若为布尔值，则为逻辑操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;    <span class="comment">// 与：全1则1，否则0</span></span><br><span class="line">|    <span class="comment">// 或：含1则1</span></span><br><span class="line">^    <span class="comment">// 异或：不同为1，相同为0</span></span><br><span class="line">~    <span class="comment">// 非：取反</span></span><br><span class="line">&gt;&gt;   <span class="comment">// 右移：</span></span><br><span class="line">&lt;&lt;   <span class="comment">// 左移</span></span><br><span class="line">&gt;&gt;&gt;  <span class="comment">// 右移并且用0填充高位</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">System.out.println(a&lt;&lt;<span class="number">1</span>);  <span class="comment">// 6</span></span><br><span class="line">System.out.println(a&gt;&gt;<span class="number">1</span>);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="3-7、逻辑运算"><a href="#3-7、逻辑运算" class="headerlink" title="3.7、逻辑运算"></a>3.7、逻辑运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;  逻辑短路与  &amp;</span><br><span class="line">||  逻辑短路或  |</span><br><span class="line">!   取反</span><br></pre></td></tr></table></figure><h2 id="4、字符串String类型"><a href="#4、字符串String类型" class="headerlink" title="4、字符串String类型"></a>4、字符串String类型</h2><h3 id="4-1、String类"><a href="#4-1、String类" class="headerlink" title="4.1、String类"></a>4.1、String类</h3><p><strong>概念：</strong></p><ul><li>String属于引用类型</li><li>String是一个<strong>final类</strong>，代表不可变的<strong>字符序列</strong>。</li><li>String对象的字符内容是存储在一个**字符数组value[]**中的，但是不能把字符串和字符数组划上等号，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;   <span class="comment">// String 内部是一个用final定义的char[]数组</span></span><br><span class="line"><span class="comment">// JDK9 之后使用 byte数组</span></span><br></pre></td></tr></table></figure><p><strong>定义：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一，使用字面量</span></span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// 方法二，使用字符串创建</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">// 方法三，使用字符数组创建</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><ul><li>字面量形式创建的字符串是放在<code>字符串常量池</code>的</li><li>new出来的是放在<code>堆</code>中的，在常量池创建一个对象（存在即不用创建），然后引用</li></ul><p><strong>子串：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String s2 = s1.substring(<span class="number">0</span>,<span class="number">3</span>);  <span class="comment">// s2 为 s1的一个子串</span></span><br></pre></td></tr></table></figure><p><strong>拼接：</strong></p><ul><li>两个字符串拼接，只要一个不为字面量，结果就在堆中产生</li><li>拼接结果调用intern()方法，把结果放到常量池中<ul><li>JDK1.8，无论结果失败成功，都返回常量池中的对象</li><li>JDK1.6，只有成功返回常量池的对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s4 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;   <span class="comment">// 字符串常量拼接的原理是编译器优化</span></span><br><span class="line"></span><br><span class="line">String s5 = s1 + <span class="string">&quot;b&quot;</span>;   <span class="comment">// 字符串变量拼接的原理是StringBuilder，返回新对象</span></span><br><span class="line"><span class="comment">// String s5 = new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString();</span></span><br><span class="line"><span class="comment">// 并且这种情况如果在循环体内不断进行，会很浪费资源</span></span><br></pre></td></tr></table></figure><p><strong>不可变的优劣：</strong></p><p><strong>劣：</strong></p><ul><li>由于不可变，所以String每次想要改变时，只能通过定义新的字符串，这样效率低</li></ul><p><strong>优：</strong></p><ul><li>编译器可以让字符串共享（放在字符串常量池中）</li></ul><p>Java开发者认为共享更加高效，大多数情况下字符串都是比较等而很少修改</p><p><strong>空串与Null串：</strong></p><ul><li>空串：长度为0的字符串，””，本质上是一个Java对象，只是没有内容</li><li>Null串：没有和任何对象关联</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str != <span class="keyword">null</span> &amp;&amp; str.length()!=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>码点与代码单元：</strong></p><ul><li>码点：每一个char</li><li>代码单元：每个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;🍺 很牛逼&quot;</span>;</span><br><span class="line"><span class="comment">// 输出char[]数组的长度 6</span></span><br><span class="line">System.out.println(str.length()); </span><br><span class="line"><span class="comment">// 输出实际字符个数 5</span></span><br><span class="line">System.out.println(str.codePointCount(<span class="number">0</span>,str.length()));</span><br><span class="line"><span class="comment">// 输出？，而不是空格 </span></span><br><span class="line">System.out.println(str.charAt(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 输出 57210，转换成int</span></span><br><span class="line">System.out.println(str.codePointAt(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 遍历每一个码点，然后转换回字符串 🍺 很牛逼     </span></span><br><span class="line"><span class="keyword">int</span>[] codes = str.codePoints().toArray();</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(codes,<span class="number">0</span>,codes.length));</span><br></pre></td></tr></table></figure><p>常用API：</p><p><strong>转换成基本类型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = “<span class="number">43</span>”; </span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(a);</span><br></pre></td></tr></table></figure><h3 id="4-2、StringBuilder"><a href="#4-2、StringBuilder" class="headerlink" title="4.2、StringBuilder"></a>4.2、StringBuilder</h3><ul><li>StringBuilder继承了AbstractStringBuilder类</li><li>AbstractStringBuilder类定义了char数组，但是没有指定为final，这意味着可变</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(str.hashCode());</span><br><span class="line">str.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">System.out.println(str.hashCode());</span><br><span class="line"><span class="comment">// 两次的结果一致</span></span><br></pre></td></tr></table></figure><p><strong>常用API：</strong></p><ul><li>创建对象，注意<strong>只能通过new创建</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder()           <span class="comment">// 初始容量16的字符串缓冲区</span></span><br><span class="line">StringBuilder(<span class="keyword">int</span> size)   <span class="comment">// 构造指定容量的字符串缓冲区</span></span><br><span class="line">StringBuilder(String str) <span class="comment">// 将内容初始化为指定字符串内容</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBuilder <span class="title">append</span><span class="params">(xxx)</span>：               <span class="comment">// 字符串拼接</span></span></span><br><span class="line"><span class="function">StringBuilder <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>   <span class="comment">// 删除指定位置的内容</span></span></span><br><span class="line"><span class="function">StringBuilder <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span>   <span class="comment">// 替换</span></span></span><br><span class="line"><span class="function">StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, xxx)</span>     <span class="comment">// 在指定位置插入xxx</span></span></span><br><span class="line"><span class="function">StringBuilder <span class="title">reverse</span><span class="params">()</span>                   <span class="comment">// 把当前字符序列逆转</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>            <span class="comment">// 返回str出现的位置           </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> n)</span>                 <span class="comment">// 获得指定位置的字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch)</span></span></span><br></pre></td></tr></table></figure><h3 id="4-3、StringBuffer"><a href="#4-3、StringBuffer" class="headerlink" title="4.3、StringBuffer"></a>4.3、StringBuffer</h3><ul><li>线程安全</li><li>同样的继承了AbstractStringBuilder类，</li><li>大部分方法使用synchronized修饰</li></ul><blockquote><p>总结</p></blockquote><p>每次对 String 类型进⾏改变的时候，都会⽣成⼀个新的 String 对象，然后将指针指向新的 String</p><p>对象，StringBuffer 每次都会对 StringBuffer 对象本身进⾏操作，⽽不是⽣成新的对象并改变对象</p><p>引⽤。</p><ul><li>操作少量的数据: 适⽤ String</li><li>单线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder</li><li>多线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer</li></ul><h2 id="5、输入与输出"><a href="#5、输入与输出" class="headerlink" title="5、输入与输出"></a>5、输入与输出</h2><h3 id="5-1、输入"><a href="#5-1、输入" class="headerlink" title="5.1、输入"></a>5.1、输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取密码可以通过Console,这样输入不可见。并且一次只能读一行</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">// 获取一行的输入 输入 124 d 读取 124 d</span></span><br><span class="line">String str1 = in.nextLine();</span><br><span class="line">System.out.println(str1);</span><br><span class="line"><span class="comment">// 读取到空格 输入 124 d 读取 124</span></span><br><span class="line">String str2 = in.next();</span><br><span class="line">System.out.println(str2);</span><br><span class="line"><span class="comment">// 判断数据是否还有其他词 true</span></span><br><span class="line">System.out.println(in.hasNext());</span><br><span class="line"><span class="comment">// 直接获取下一个</span></span><br><span class="line">System.out.println(in.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 BufferedReader</span></span><br><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2、输出"><a href="#5-2、输出" class="headerlink" title="5.2、输出"></a>5.2、输出</h3><p><strong>格式化输出</strong>：Java沿用了C语言的printf方法</p><h2 id="6、控制流程"><a href="#6、控制流程" class="headerlink" title="6、控制流程"></a>6、控制流程</h2><h3 id="6-1、块作用域"><a href="#6-1、块作用域" class="headerlink" title="6.1、块作用域"></a>6.1、块作用域</h3><ul><li>块是指由若干条Java语句组成的语句，并且用一对大括号括起来</li><li>块定义了变量的作用域，一个块中（或者是块1中的块2）的变量<strong>不能同名</strong></li></ul><h3 id="6-2、条件语句"><a href="#6-2、条件语句" class="headerlink" title="6.2、条件语句"></a>6.2、条件语句</h3><h3 id="6-3、循环"><a href="#6-3、循环" class="headerlink" title="6.3、循环"></a>6.3、循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while()&#123;</span><br><span class="line"> 程序体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4、确定循环"><a href="#6-4、确定循环" class="headerlink" title="6.4、确定循环"></a>6.4、确定循环</h3><p>for循环等</p><h3 id="6-5、多重选择"><a href="#6-5、多重选择" class="headerlink" title="6.5、多重选择"></a>6.5、多重选择</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> choice = in.nextInt();</span><br><span class="line"><span class="keyword">switch</span> (choice)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Not in&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><ul><li>如果没有break会一直往下执行</li><li>case标签可以是如下（常量）<ul><li>char、byte、short、int的常量表达式</li><li>枚举常量</li><li>字符串<strong>字面量</strong></li></ul></li></ul><h3 id="6-6、中断控制"><a href="#6-6、中断控制" class="headerlink" title="6.6、中断控制"></a>6.6、中断控制</h3><ul><li>break</li><li>continue</li><li>goto（不建议使用）</li></ul><h2 id="7、大数"><a href="#7、大数" class="headerlink" title="7、大数"></a>7、大数</h2><p>有时候，基本的整数和浮点数不能满足需求，可以使用math包里的<strong>BigInteger</strong>和<strong>BigDecimal</strong></p><h3 id="7-1、BigInteger"><a href="#7-1、BigInteger" class="headerlink" title="7.1、BigInteger"></a>7.1、BigInteger</h3><p><strong>获取大数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bigInteger1 = BigInteger.valueOf(<span class="number">100</span>);   <span class="comment">// 通过数值</span></span><br><span class="line">BigInteger bigInteger2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;100&quot;</span>);     <span class="comment">// 通过构造方法</span></span><br></pre></td></tr></table></figure><p><strong>运算：</strong>大数运算并不能和普通的数一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">abs</span><span class="params">()</span>              <span class="comment">// 绝对值的 BigInteger。 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span>       <span class="comment">// this + val </span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span>  <span class="comment">// this - val</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span>  <span class="comment">// this * val</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span>    <span class="comment">// 除，只保留整数</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">BigInteger <span class="title">sqrt</span><span class="params">(BigInteger val)</span>      <span class="comment">// 平方根</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BigInteger</span><span class="params">(BigInteger val)</span>       <span class="comment">// 比较大小</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">BigInteger <span class="title">remainder</span><span class="params">(BigInteger val)</span>            <span class="comment">// 求余</span></span></span><br><span class="line"><span class="function">BigInteger[] <span class="title">divideAndRemainder</span><span class="params">(BigInteger val)</span> <span class="comment">// 返回数组 </span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">pow</span><span class="params">(<span class="keyword">int</span> exponent)</span>    <span class="comment">// 返回其值为 (thisexponent) 的 BigInteger。    </span></span></span><br></pre></td></tr></table></figure><h3 id="7-2、BigDecimal"><a href="#7-2、BigDecimal" class="headerlink" title="7.2、BigDecimal"></a>7.2、BigDecimal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BigDecimal</span><span class="params">(<span class="keyword">double</span> val)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BigDecimal</span><span class="params">(String val)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> val)</span>           <span class="comment">// 根据long获得</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> val,<span class="keyword">int</span> scale)</span> <span class="comment">// 参数依次为3,1  则结果 3.0    </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BigDecimal <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> val)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 加减乘除    </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">add</span><span class="params">(BigDecimal augend)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">subtract</span><span class="params">(BigDecimal subtrahend)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">multiply</span><span class="params">(BigDecimal multiplicand)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">divide</span><span class="params">(BigDecimal divisor, <span class="keyword">int</span> scale, <span class="keyword">int</span> roundingMode)</span></span></span><br></pre></td></tr></table></figure><h2 id="8、数组"><a href="#8、数组" class="headerlink" title="8、数组"></a>8、数组</h2><h3 id="8-1、概念"><a href="#8-1、概念" class="headerlink" title="8.1、概念"></a>8.1、概念</h3><ol><li>数组(Array)，是多个<strong>相同类型数据</strong>按一定顺序排列 的集合，并使用一个名字命名，并通过<strong>编号的方式管理</strong></li><li>数组本身是引用数据类型，而数组中的元素可以是任何数据类型</li><li>数据占用连续的空间地址，长度一旦确定，就<strong>不能修改</strong></li></ol><h3 id="8-2、创建数组"><a href="#8-2、创建数组" class="headerlink" title="8.2、创建数组"></a>8.2、创建数组</h3><p><strong>声明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[];  <span class="comment">// 注意：声明数组时不能指定其长度</span></span><br><span class="line"><span class="keyword">int</span>[] a;  <span class="comment">// 这两种方式都可以</span></span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><ul><li><p><strong>动态初始化：</strong>初始化完毕再赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; arr[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">String names[];   names = <span class="keyword">new</span> String[<span class="number">3</span>];  names[<span class="number">0</span>] = “钱学森”;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态初始化：</strong>初始化时就赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;  </span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li>Java允许有长度为0的数组，与null不同</li><li>定义并<strong>用运算符new为之分配空间</strong>后，才可以引用数组中的每个元素</li><li>数组是引用类型，<strong>它的元素相当于类的成员变量</strong>，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化，初始化默认值不尽相同。<strong>默认值 基本类型大部分为0，引用类型为null</strong></li></ul><h3 id="8-3、访问数组"><a href="#8-3、访问数组" class="headerlink" title="8.3、访问数组"></a>8.3、访问数组</h3><ul><li>for循环</li><li>for each循环</li><li>Arrays.toString(a) 方法把数组转换成 [1,2,3] 这种形式的字符串</li></ul><h3 id="8-4、数组拷贝"><a href="#8-4、数组拷贝" class="headerlink" title="8.4、数组拷贝"></a>8.4、数组拷贝</h3><ul><li>调用 Arrays.copyOf ，这样新数组与原数组就没有关系了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a = Arrays.copyOf(b,<span class="number">3</span>);  <span class="comment">// 参数2为新数组长度</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">System.out.println(a[<span class="number">0</span>]);</span><br><span class="line">System.out.println(b[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h3 id="8-5、数组排序"><a href="#8-5、数组排序" class="headerlink" title="8.5、数组排序"></a>8.5、数组排序</h3><p>对应数值型的数组，可以使用 Arrays.sort() 进行排序，算法为<strong>优化的快排</strong></p><h3 id="8-6、多维数组"><a href="#8-6、多维数组" class="headerlink" title="8.6、多维数组"></a>8.6、多维数组</h3><ul><li><p>从数组底层的运行机制来看，其实<strong>没有</strong>多维数组。</p></li><li><p>二维数组[][]：数组中的数组</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态初始化：规则数组</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 动态初始化：不规则数组</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>][]; arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-7、Arrays工具类"><a href="#8-7、Arrays工具类" class="headerlink" title="8.7、Arrays工具类"></a>8.7、Arrays工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)</span>   <span class="comment">//  判断相等</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span>          </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> val)</span>        <span class="comment">// 指定值添加到数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span>                <span class="comment">// 排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> key)</span> <span class="comment">// 对排序后的数组进行二分法检索指定的值</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyOf</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> end)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyOf</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"/>
      <url>/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1、发展历史"><a href="#1、发展历史" class="headerlink" title="1、发展历史"></a>1、发展历史</h1><blockquote><p>1、单机MySQL的美好年代</p></blockquote><ul><li><p>在90年代，一个网站的访问量一般不大，用单个数据库完全可以轻松应付！</p></li><li><p>在那个时候，更多的都是静态网页，动态交互类型的网站不多。</p></li></ul><p><strong>当时数据存储的瓶颈：</strong></p><ol><li><p>数据量的总大小，一个机器放不下时</p></li><li><p>数据的索引（B+ Tree）一个机器的内存放不下时</p></li><li><p>访问量（读写混合）一个实例不能承受</p></li></ol><blockquote><p>2、Memcached（缓存）+ MySQL + 垂直拆分</p></blockquote><ul><li>访问量上升，大部分使用MySQL架构的网站在数据库上都出现性能问题</li><li>程序开始追求性能，使用缓存缓解数据库压力，优化数据库的结构和索引，</li><li>开始比较流行的是通过文件缓存，但是多台web机器通过文件缓存不能共享，大量的小文件缓存也带了比较高的IO压力，在这个时候，Memcached就自然的成为一个非常时尚的技术产品。</li></ul><blockquote><p>3、MySQL主从读写分离</p></blockquote><ul><li>Memcached只能缓解数据库的读取压力，读写集中在一个数据库上让数据库不堪重负，</li><li>使用<strong>主从复制技术</strong>来达到读写分离，提高读写性能和读库的可扩展性</li><li>MySQL的master-slave模式成为标配了。</li></ul><blockquote><p>4、分表分库 + 水平拆分 + Mysql 集群</p></blockquote><ul><li>MyISAM使用表锁，高并发下出现严重的锁问题，开始使用InnoDB引擎代替MyISAM。</li><li>流行使用分表分库来缓解写压力和数据增长的扩展问题。</li><li>MySQL推出了还不太稳定的表分区，在高可靠性上提供了非常大的保证。</li></ul><p>MyISAM：表锁，查一个数据，整个表都加锁，高并发下出现问题</p><p>INNODB：行锁</p><blockquote><p>5、MySQL 的扩展性瓶颈</p></blockquote><ul><li>MySQL数据库经常存储一些大文本的字段，使数据库表非常的大，影响速度。</li><li>把这些数据从MySQL省去，MySQL将变的非常的小，速度提升、</li><li>MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。</li></ul><blockquote><p>6、如今</p></blockquote><ul><li>今天我们可以通过第三方平台（如：Google，FaceBook等）可以很容易的访问和抓取数据。</li><li>用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加、</li><li>我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了，而NoSQL数据库的发展却能很好的处理这些大的数据！</li></ul><h1 id="2、NoSQL"><a href="#2、NoSQL" class="headerlink" title="2、NoSQL"></a>2、NoSQL</h1><h2 id="2-1、概念"><a href="#2-1、概念" class="headerlink" title="2.1、概念"></a>2.1、概念</h2><ul><li>NoSQL = Not Only SQL，意思：<strong>不仅仅是SQL；</strong></li><li>不遵循SQL标准</li><li>不支持ACID原则</li><li>性能远超SQL</li></ul><p>关系型：表格，行，列</p><p>非关系型：键值对存储，列存储，文档存储，图形数据库</p><h2 id="2-2、特点"><a href="#2-2、特点" class="headerlink" title="2.2、特点"></a>2.2、特点</h2><ul><li>易扩展，数据之间没有耦合性</li><li>细粒度的缓存，高性能    官方记录：Redis 一秒可以写8万次，读11万次！</li><li>类型多（不需要事先设计数据库，随取随用）</li></ul><p>对比：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">传统关系型数据库RDBMS </span><br><span class="line">- 高度组织化结构化数据 </span><br><span class="line">- 结构化查询语言（SQL） </span><br><span class="line">- 数据和关系都存储在单独的表中 </span><br><span class="line">- 数据操纵语言，数据定义语言 </span><br><span class="line">- 严格的一致性 </span><br><span class="line">- 基础事务 </span><br><span class="line">NoSQL </span><br><span class="line">- 代表着不仅仅是SQL </span><br><span class="line">- 没有声明性查询语言 </span><br><span class="line">- 没有预定义的模式 </span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库 </span><br><span class="line">- 最终一致性，而非ACID属性 </span><br><span class="line">- 非结构化和不可预知的数据 </span><br><span class="line">- CAP定理 （一致性、可用性、分区容忍性最多满足2个）</span><br><span class="line">- 高性能，高可用性 和 可伸缩性</span><br></pre></td></tr></table></figure><h2 id="2-3、拓展"><a href="#2-3、拓展" class="headerlink" title="2.3、拓展"></a>2.3、拓展</h2><p>大数据时代的3V ： 主要是对问题的描述</p><ul><li>海量 Volume</li><li>多样 Variety</li><li>实时 Velocity</li></ul><p>互联网需求的<strong>3高</strong> ： 主要是对程序的要求</p><ul><li>高并发</li><li>高可用</li><li>高性能</li></ul><p>当下的应用是 SQL 和 NoSQL 一起使用，技术没有高低之分，就看怎么用</p><h2 id="2-4、经典应用分析"><a href="#2-4、经典应用分析" class="headerlink" title="2.4、经典应用分析"></a>2.4、经典应用分析</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、商品基本信息</span></span><br><span class="line"><span class="string">名称、价格、出厂日期、生产厂商等</span> </span><br><span class="line"><span class="string">关系型数据库：mysql、oracle</span></span><br><span class="line"><span class="string">注意，淘宝内部用的MySQL是里面的大牛自己改造过的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、商品描述、详情、评价信息（多文字类）</span></span><br><span class="line"><span class="string">多文字信息描述类，IO读写性能变差</span> </span><br><span class="line"><span class="string">-存在文档数据库MongDB中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、商品的图片</span></span><br><span class="line"><span class="string">商品图片展现类</span> </span><br><span class="line"><span class="string">分布式文件系统中</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">淘宝自己的</span> <span class="string">TFS</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Google的</span> <span class="string">GFS</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Hadoop的</span> <span class="string">HDFS</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">阿里云的</span>  <span class="string">OSS</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、商品的关键</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">搜索引擎</span> <span class="string">solr</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">搜索引擎，淘宝内用</span> </span><br><span class="line"><span class="string">ISearch：多隆一高兴一个人开发的</span> <span class="string">所有牛逼的人在牛逼之前,肯定有一段苦逼的岁月,但只要像傻逼一样的坚持,一定终将牛逼</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、商品的波段性的热点高频信息</span></span><br><span class="line"><span class="string">内存数据库</span> </span><br><span class="line"><span class="string">Tair、Redis、Memcache等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、商品的交易，价格计算，积分累计！</span></span><br><span class="line"><span class="string">外部系统，外部第三方支付接口</span> <span class="string">支付宝</span></span><br></pre></td></tr></table></figure><p>大型互联网应用问题：</p><ul><li>数据类型的多样性</li><li>数据源多样性和变化重构</li><li>数据源改造而数据服务平台不需要大面积重构</li></ul><p>解决办法：</p><ul><li>统一数据服务层（加一层）</li></ul><h2 id="2-5、NoSQL数据模型简介"><a href="#2-5、NoSQL数据模型简介" class="headerlink" title="2.5、NoSQL数据模型简介"></a>2.5、NoSQL数据模型简介</h2><h5 id="1、KV键值对"><a href="#1、KV键值对" class="headerlink" title="1、KV键值对"></a>1、KV键值对</h5><ul><li>新浪：BerkeleyDB+redis</li><li>美团：redis+tair</li><li>阿里、百度：memcache+redis</li></ul><h5 id="2、文档型数据库（Bson比较多）"><a href="#2、文档型数据库（Bson比较多）" class="headerlink" title="2、文档型数据库（Bson比较多）"></a>2、文档型数据库（Bson比较多）</h5><ul><li>CouchDB</li><li>MongoDB<ul><li>MongoDB 是一个<strong>基于分布式文件存储的数据库</strong>。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</li><li>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</li></ul></li></ul><h5 id="3、列存储数据库："><a href="#3、列存储数据库：" class="headerlink" title="3、列存储数据库："></a>3、列存储数据库：</h5><ul><li>Cassandra, HBase</li><li>分布式文件系统</li></ul><p><strong>4、图关系数据库</strong></p><ul><li>它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统</li><li>社交网络，推荐系统等。专注于构建关系图谱</li><li>Neo4J, InfoGrid</li></ul><h2 id="2-6、CAP-BASE"><a href="#2-6、CAP-BASE" class="headerlink" title="2.6、CAP + BASE"></a>2.6、CAP + BASE</h2><blockquote><p>ACID</p></blockquote><ul><li>A：原子性</li><li>C：一致性</li><li>I：隔离性</li><li>D：持久性</li></ul><blockquote><p>CAP（分布式系统中）</p></blockquote><ul><li>C : Consistency（强一致性，在分布式系统中的所有数据备份，在同一时刻值是否相等）</li><li>A : Availability（可用性，部分节点故障后，集群整体是否还能响应请求，即每次请求都能被响应）</li><li>P : Partition tolerance（分区容错性，允许分区之间由于原因没能正确同步）</li></ul><p><strong>在分布式系统中，最多实现其中的2个</strong>：分区数量越多，分区容错性越大，但是会降低数据的一致性，为了保持一致性，就需要花更多时间去等待数据同步，就不能立即返回数据，可用性降低。</p><p> <strong>所以NoSQL 数据库分成了满足 CA 原则、满足 CP原则和满足 AP 原则三 大类：</strong></p><ul><li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li><li>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</li><li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li></ul><p><strong>大多数web应用，其实并不需要强一致性，牺牲C换取P是分布式数据库产品主流</strong></p><blockquote><p>Base理论</p></blockquote><ul><li>无法实现强一致性，就结合业务特点等达到最终一致性。</li></ul><p><strong>概念</strong></p><ul><li>基本可用(Basically Available)： 允许损失部分可用性，保证核心可用。如电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。</li><li>软状态(Soft State)： 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状的体现。MySQL Replication 的异步复制也是一种体现</li><li>最终一致性(Eventual Consistency)： 最终一致性是指系统中的所有数据最终达到一致的状态，最终一致性是<strong>弱一致性的一种特殊情况</strong>。</li></ul><p><strong>思想</strong></p><ul><li>通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观</li></ul><h1 id="3、Redis简介"><a href="#3、Redis简介" class="headerlink" title="3、Redis简介"></a>3、Redis简介</h1><h2 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h2><blockquote><p>Redis是什么</p></blockquote><p>Redis：<code>RE</code>mote <code>DI</code>ctionary <code>S</code>erver（远程字典服务器）</p><p>是完全开源免费的，用<strong>C语言编写</strong>的，遵守BSD协议，是一个高性能<strong>分布式内存数据库</strong>，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为数据结构服务器</p><blockquote><p>相对于其他key-value缓存产品</p></blockquote><ul><li>Redis<strong>支持持久化</strong>，可以将数据存在磁盘中，重启的时候可以再次加载使用。</li><li>Redis不仅仅支持简单的 key-value 类型的数据，<strong>还支持list、set、zset、hash等数据结构</strong>的存储。</li><li>Redis支持数据的备份，即<strong>master-slave模式的数据备份</strong>。</li></ul><blockquote><p>特性</p></blockquote><ul><li>数据类型、基本操作和配置</li><li>持久化和复制，RDB、AOF</li><li>事务的控制，但是不支持ACID原则</li><li>集群</li><li>做分布式锁，甚⾄是消息队列</li></ul><h2 id="3-2、linux安装"><a href="#3-2、linux安装" class="headerlink" title="3.2、linux安装"></a>3.2、linux安装</h2><p>宝塔面板傻瓜式安装</p><p><strong>daemonize设置yes或者no区别</strong></p><ul><li><p>yes（宝塔默认）</p><p>redis采用的是<strong>单线程+多路IO复用</strong>的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfifile设置的文件中，此时redis将一直运行，除非手动kill该进程。</p></li><li><p>no（linux命令安装默认）</p><p>当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。</p></li></ul><p><strong>测试</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-cli -p 6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ping</span> </span><br><span class="line"><span class="string">PONG</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">helloworld</span> </span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k1</span> </span><br><span class="line"><span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">del</span> <span class="string">k1</span> </span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-cli -p 6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">shutdown</span></span><br><span class="line"><span class="string">not</span> <span class="string">connected&gt;</span> <span class="string">exit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示系统当前进程信息</span></span><br><span class="line"><span class="comment"># ps -ef|grep redis</span></span><br></pre></td></tr></table></figure><ul><li>6739为默认端口号</li></ul><p>6379在是手机按键上MERZ对应的号码，而MERZ取自意大利歌女<a href="http://it.wikipedia.org/wiki/Alessia_Merz">Alessia Merz</a>的名字。MERZ长期以来被antirez及其朋友当作愚蠢的代名词</p><h2 id="3-3、选择数据库"><a href="#3-3、选择数据库" class="headerlink" title="3.3、选择数据库"></a>3.3、选择数据库</h2><p>默认16个数据库，类似数组下标从零开始，初始默认使用零号库</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换数据库</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">select</span> <span class="number">0</span></span><br><span class="line"><span class="string">Ok</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379[7]&gt;</span> <span class="string">DBSIZE</span> </span><br><span class="line"><span class="string">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># 清空当前库 </span></span><br><span class="line"><span class="comment"># Flushall：清空全部的库</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">FLUSHDB</span> </span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">DBSIZE</span> </span><br><span class="line"><span class="string">(integer)</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="4、五大数据类型"><a href="#4、五大数据类型" class="headerlink" title="4、五大数据类型"></a>4、五大数据类型</h1><h2 id="4-1、简介"><a href="#4-1、简介" class="headerlink" title="4.1、简介"></a>4.1、简介</h2><blockquote><p>String （字符串类型）</p></blockquote><p><strong>结构：</strong>一个key对应一个value，即单键单值</p><p><strong>底层：</strong>为简单动态字符串（与C语言不同），可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用<code>预分配冗余空间</code>的方式来减少内存的频繁分配，最大512M。</p><p><strong>特点：</strong>可以存二进制字符串（意味着可以存任何数据），同时线程安全。</p><p><strong>应用：</strong>需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">value</span>    <span class="comment"># 设置值    mset 批量操作         </span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span>          <span class="comment"># 获得key   mget 批量操作           </span></span><br><span class="line"><span class="string">del</span> <span class="string">key</span>          <span class="comment"># 删除key       </span></span><br><span class="line"></span><br><span class="line"><span class="string">exists</span> <span class="string">key</span>       <span class="comment"># 判断 key 是否存在</span></span><br><span class="line"><span class="string">strlen</span> <span class="string">key</span>       <span class="comment"># 返回 key 所储存的字符串值的⻓度。</span></span><br><span class="line"></span><br><span class="line"><span class="string">incr</span> <span class="string">views</span>       <span class="comment"># 数字形式的值加1,incrby views 10</span></span><br><span class="line"><span class="string">decr</span> <span class="string">views</span>       <span class="comment">#  - 1          decrby views 10 </span></span><br><span class="line"></span><br><span class="line"><span class="string">setex</span> <span class="string">key</span> <span class="number">10</span> <span class="string">value</span>     <span class="comment"># 原子设置过期时间 或者设置键值对后再 expire key 10</span></span><br><span class="line"><span class="string">ttl</span> <span class="string">key</span>                <span class="comment"># 查看剩余的时间，-1 表示永不过期，-2 表示已过期</span></span><br></pre></td></tr></table></figure><blockquote><p>List（列表）</p></blockquote><p><strong>结构：</strong>一个key对应多个value，即单键多值</p><p><strong>底层：</strong>字符串双向链表，使用一块连续内存；元素少为<strong>ZipList</strong>，多为快速链表quickList</p><p><strong>特点：</strong>可以在两端操作，因此可以作为栈和队列（如消息队列）</p><p><strong>应用：</strong>发布与订阅或者说消息队列、慢查询。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Lpush/Rpush</span> <span class="string">list</span> <span class="string">&quot;one&quot;</span><span class="comment"># 将一个或多个值插入到列表头部（左）/尾部(右)</span></span><br><span class="line"><span class="string">Lpop/Rpop</span> <span class="string">list</span>          <span class="comment"># 返回并移除第一个元素。</span></span><br><span class="line"><span class="string">lset</span> <span class="string">list</span> <span class="number">1</span> <span class="string">&quot;world&quot;</span>    <span class="comment"># 更改list位置1的值</span></span><br><span class="line"><span class="string">Lrange</span> <span class="string">list</span> <span class="number">0</span> <span class="number">-1</span>        <span class="comment"># 返回指定区间内的元素，0表示第一个元素，-1表示最后一个</span></span><br><span class="line"><span class="string">Lindex</span> <span class="string">list</span> <span class="number">1</span>           <span class="comment"># 按照索引下标获得元素</span></span><br><span class="line"><span class="string">llen</span> <span class="string">list</span>               <span class="comment"># 长度</span></span><br></pre></td></tr></table></figure><blockquote><p>Hash（哈希，类似 Java里的Map）</p></blockquote><p><strong>结构：</strong>一个key对应多个 内部key，一个内部key对应一个值</p><p><strong>底层：</strong>String类型的field和value的映射表，类似Java里面的Map&lt;String,Object&gt;</p><p><strong>应用：</strong>hash特别适合用于存储对象。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hset</span> <span class="string">myhash</span> <span class="string">key1</span> <span class="string">&quot;wzh&quot;</span>   <span class="comment"># 设置myhash的键值对为key1和&quot;wzh&quot;</span></span><br><span class="line"><span class="string">hget</span> <span class="string">myhash</span> <span class="string">key1</span>         <span class="comment"># 获得myhash的key1的值</span></span><br><span class="line"><span class="string">hdel</span> <span class="string">myhash</span> <span class="string">field1</span>       <span class="comment"># 删除键</span></span><br><span class="line"><span class="string">hexists</span> <span class="string">myhash</span> <span class="string">field1</span>    <span class="comment"># 是否存在</span></span><br></pre></td></tr></table></figure><blockquote><p>Set（集合）</p></blockquote><p><strong>结构：</strong>一个 key 对应一个 value</p><p><strong>底层：</strong>value为null的hash表，</p><p><strong>特点：</strong>无序、不允许重复，添加，删除，查找的复杂度都是O(1)，可以集合关系</p><p><strong>应用：</strong>交集、并集、差集非常方便的实现如共同关注、共同喜好、二度好友等功能，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sadd</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span>          <span class="comment"># 将一个或多个成员元素加入</span></span><br><span class="line"><span class="string">sismember</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span>     <span class="comment"># 判断是否在集合里面</span></span><br><span class="line"><span class="string">srem</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span> <span class="string">&quot;xuexi&quot;</span><span class="comment"># 移除集合中的一个或多个成员</span></span><br><span class="line"><span class="string">SDIFF</span> <span class="string">key1</span> <span class="string">key2</span>    <span class="comment"># 差集 </span></span><br><span class="line"><span class="string">SINTER</span> <span class="string">key1</span> <span class="string">key2</span>   <span class="comment"># 交集 </span></span><br><span class="line"><span class="string">SUNION</span> <span class="string">key1</span> <span class="string">key2</span>   <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure><blockquote><p>Zset（sorted set：有序集合）</p></blockquote><p><strong>结构：</strong>一个 key 对应一个 value，同时每个key 关联一个 double类型的分数</p><p><strong>底层：</strong>value为null的hash表，跳跃表（排序）</p><p><strong>特点：</strong></p><ol><li>与Set基本相同；不同之处 set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2</li><li>会根据 double 类型的分数 自动排序。</li></ol><p><strong>应用：</strong>带权重的队列、排行榜取 Top、礼物、用户按权重排名</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zadd</span> <span class="string">salary</span> <span class="number">1</span> <span class="string">&quot;one&quot;</span><span class="comment"># 加入1个或者多个</span></span><br><span class="line"><span class="string">zrem</span> <span class="string">salaryt</span> <span class="string">&quot;one&quot;</span>    <span class="comment"># zrem 删除集合成员</span></span><br><span class="line"></span><br><span class="line"><span class="string">zcard</span> <span class="string">myZset</span>            <span class="comment"># 查看 sorted set 中的元素数量</span></span><br><span class="line"><span class="string">zscore</span> <span class="string">myZset</span> <span class="string">value1</span>    <span class="comment"># 查看某个 value 的权重</span></span><br><span class="line"></span><br><span class="line"><span class="string">zrange</span> <span class="string">salary</span> <span class="number">0</span> <span class="number">-1</span><span class="comment"># 顺序返回指定区间的成员</span></span><br><span class="line"><span class="string">zrevrange</span> <span class="string">myZset</span> <span class="number">0</span> <span class="number">1</span>    <span class="comment"># 逆序输出某个范围区间的元素，0 为 start 1</span></span><br></pre></td></tr></table></figure><h2 id="4-2、Redis的键"><a href="#4-2、Redis的键" class="headerlink" title="4.2、Redis的键"></a>4.2、Redis的键</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">redis-cli</span> <span class="string">-p</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="string">keys</span> <span class="string">*</span> <span class="comment"># 查看所有的key </span></span><br><span class="line"><span class="string">EXISTS</span> <span class="string">name</span>  <span class="comment"># 判断是否存在键name</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">name</span> <span class="string">wzh</span>    <span class="comment"># 设置键值对</span></span><br><span class="line"><span class="string">move</span> <span class="string">name</span> <span class="number">1</span> <span class="comment"># move key db ---&gt; 移动到其他库</span></span><br><span class="line"><span class="string">del</span> <span class="string">name</span> <span class="comment"># 删除键</span></span><br><span class="line"><span class="string">unlink</span> <span class="string">key</span>   <span class="comment"># 根据value选择非阻塞删除仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">name</span> <span class="string">wzh</span>       <span class="comment"># 设置键 name 值为 wzh</span></span><br><span class="line"><span class="string">EXPIRE</span> <span class="string">name</span> <span class="number">10</span>     <span class="comment"># 给key 设置生存时间，过期时被自动删除。</span></span><br><span class="line"><span class="string">persist</span> <span class="string">key</span>        <span class="comment"># 移除过期时间</span></span><br><span class="line"><span class="string">ttl</span> <span class="string">name</span>           <span class="comment"># 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type key 查看你的key是什么类型 </span></span><br><span class="line"><span class="string">type</span> <span class="string">name</span> </span><br></pre></td></tr></table></figure><h2 id="4-3、字符串String"><a href="#4-3、字符串String" class="headerlink" title="4.3、字符串String"></a>4.3、字符串String</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本操作</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">-p</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">value</span>    <span class="comment"># 设置值             OK</span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span>          <span class="comment"># 获得key            &quot;value1&quot; </span></span><br><span class="line"><span class="string">del</span> <span class="string">key</span>          <span class="comment"># 删除key            (integer) 1 </span></span><br><span class="line"><span class="string">keys</span> <span class="string">*</span>           <span class="comment"># 查看全部的key       (empty list or set) </span></span><br><span class="line"><span class="string">exists</span> <span class="string">key</span>       <span class="comment"># 判断 key 是否存在   (integer) 0 </span></span><br><span class="line"></span><br><span class="line"><span class="string">append</span> <span class="string">key</span> <span class="string">&quot;hello&quot;</span>    <span class="comment"># 若对不存在的 key 进行 APPEND ，等同于 SET  </span></span><br><span class="line"><span class="string">append</span> <span class="string">key</span> <span class="string">&quot;-2333&quot;</span>    <span class="comment"># 对已存在的字符串进行 APPEND，等于增加内容</span></span><br><span class="line"><span class="string">strlen</span> <span class="string">key</span>        <span class="comment"># 获取字符串的长度   </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数字进行加减操作一定要是数字</span></span><br><span class="line"><span class="string">set</span> <span class="string">views</span> <span class="number">0</span>       <span class="comment"># 设置为0     OK</span></span><br><span class="line"><span class="string">incr</span> <span class="string">views</span>        <span class="comment">#  + 1    (integer) 1 </span></span><br><span class="line"><span class="string">decr</span> <span class="string">views</span>        <span class="comment">#  - 1    (integer) 0 </span></span><br><span class="line"><span class="string">incrby</span> <span class="string">views</span> <span class="number">10</span>   <span class="comment"># +10     (integer) 10 </span></span><br><span class="line"><span class="string">decrby</span> <span class="string">views</span> <span class="number">10</span>   <span class="comment"># -10     (integer) 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范围:getrange 获取指定区间范围内的值</span></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">abcd123456</span>  <span class="comment"># 设置key2的值 </span></span><br><span class="line"><span class="string">getrange</span> <span class="string">key</span> <span class="number">0</span> <span class="number">-1</span>   <span class="comment"># 获得全部的值           &quot;abcd123456&quot;</span></span><br><span class="line"><span class="string">getrange</span> <span class="string">key</span> <span class="number">0</span> <span class="number">2</span>    <span class="comment"># 截取部分字符串 &quot;abc&quot;    &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setrange 从指定位置开始替换值</span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span>             <span class="comment">#         &quot;abcd123456&quot;</span></span><br><span class="line"><span class="string">SETRANGE</span> <span class="string">key</span> <span class="number">1</span> <span class="string">xx</span>   <span class="comment"># 替换值   (integer) 10 </span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span>             <span class="comment">#         &quot;axxd123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置过期时间</span></span><br><span class="line"><span class="string">setex</span> <span class="string">key</span> <span class="number">10</span> <span class="string">value</span>     <span class="comment"># 原子设置过期时间 或者设置键值对后再 expire key 10</span></span><br><span class="line"><span class="string">ttl</span> <span class="string">key</span>                <span class="comment"># 查看剩余的时间，-1 表示永不过期，-2 表示已过期</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件设置</span></span><br><span class="line"><span class="string">setnx</span> <span class="string">mykey</span> <span class="string">&quot;redis&quot;</span>   <span class="comment"># 如果不存在就设置，成功返回1    </span></span><br><span class="line"><span class="string">setex</span> <span class="string">mykey</span> <span class="string">&quot;mongodb&quot;</span>  <span class="comment"># 如果存在就设置，失败返回0       </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量操作</span></span><br><span class="line"><span class="string">mset</span> <span class="string">k10</span> <span class="string">v10</span> <span class="string">k11</span> <span class="string">v11</span> <span class="string">k12</span> <span class="string">v12</span> <span class="comment"># 创建多个键值对</span></span><br><span class="line"><span class="string">mget</span> <span class="string">k10</span> <span class="string">k11</span> <span class="string">k12</span> <span class="string">k13</span>         <span class="comment"># 获得多个键的值</span></span><br><span class="line"><span class="string">msetnx</span> <span class="string">k10</span> <span class="string">v10</span> <span class="string">k15</span> <span class="string">v15</span>       <span class="comment"># 原子操作，都成功返回1，否则都失败，返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统缓存对象(不是真正的缓存对象)</span></span><br><span class="line"><span class="string">mset</span> <span class="string">user:1:name</span> <span class="string">zhangsan</span> <span class="string">user:1:age</span> <span class="number">2</span> </span><br><span class="line"><span class="string">mget</span> <span class="string">user:1:name</span> <span class="string">user:1:age</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># getset（先get再set）</span></span><br><span class="line"><span class="string">getset</span> <span class="string">db</span> <span class="string">mongodb</span></span><br></pre></td></tr></table></figure><h2 id="4-4、列表List"><a href="#4-4、列表List" class="headerlink" title="4.4、列表List"></a>4.4、列表List</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">LPUSH</span> <span class="string">list</span> <span class="string">&quot;one&quot;</span><span class="comment"># 将一个或多个值插入到列表头部。（左）</span></span><br><span class="line"><span class="string">LPUSH</span> <span class="string">list</span> <span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="string">RPUSH</span> <span class="string">list</span> <span class="string">&quot;right&quot;</span><span class="comment"># rpush：将一个或多个值插入到列表尾部。（右）</span></span><br><span class="line"><span class="comment"># lrange：返回指定区间内的元素，0表示第一个元素，-1表示最后一个元素</span></span><br><span class="line"><span class="string">Lrange</span> <span class="string">list</span> <span class="number">0</span> <span class="number">-1</span>     <span class="comment">#  1) &quot;two&quot;、2) &quot;one&quot;、3) &quot;right&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">Lpop</span> <span class="string">list</span>          <span class="comment"># 返回并移除第一个元素。不存在时，返回 nil 。 </span></span><br><span class="line"><span class="string">Rpop</span> <span class="string">list</span>          <span class="comment"># 最后一个元素 </span></span><br><span class="line"></span><br><span class="line"><span class="string">Lindex</span> <span class="string">list</span> <span class="number">1</span>      <span class="comment"># 按照索引下标获得元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">Llen</span> <span class="string">list</span>          <span class="comment"># 返回列表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="string">lrem</span> <span class="string">list</span> <span class="number">1</span> <span class="string">&quot;two&quot;</span>  <span class="comment"># 移除列表里的two元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">ltrim</span> <span class="string">mylist</span> <span class="number">1</span> <span class="number">2</span><span class="comment"># 保留指定区间内的元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">rpoplpush</span> <span class="string">list</span> <span class="string">mylist</span>   <span class="comment"># 把list最后一个移到mylist里面</span></span><br><span class="line"></span><br><span class="line"><span class="string">lset</span> <span class="string">list</span> <span class="number">1</span> <span class="string">&quot;world&quot;</span><span class="comment"># 更改list的值</span></span><br><span class="line"></span><br><span class="line"><span class="string">linsert</span> <span class="string">list</span> <span class="string">before</span> <span class="string">&quot;world&quot;</span> <span class="string">&quot;hello&quot;</span>   <span class="comment"># hello 插到world前面</span></span><br></pre></td></tr></table></figure><h2 id="4-5、哈希Hash"><a href="#4-5、哈希Hash" class="headerlink" title="4.5、哈希Hash"></a>4.5、哈希Hash</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hset</span> <span class="string">myhash</span> <span class="string">key1</span> <span class="string">&quot;wzh&quot;</span>  <span class="comment"># 设置myhash的键值对为key1和&quot;wzh&quot;</span></span><br><span class="line"><span class="string">hget</span> <span class="string">myhash</span> <span class="string">key1</span>        <span class="comment"># 获得myhash的key1的值</span></span><br><span class="line"><span class="string">HMSET</span> <span class="string">myhash</span> <span class="string">field1</span> <span class="string">&quot;Hello&quot;</span> <span class="string">field2</span> <span class="string">&quot;World&quot;</span>  <span class="comment"># 设置多个</span></span><br><span class="line"><span class="string">hgetall</span> <span class="string">myhash</span>          <span class="comment"># 展示所有值，格式为键一行，值在键下一行</span></span><br><span class="line"><span class="string">hdel</span> <span class="string">myhash</span> <span class="string">field1</span>      <span class="comment"># 删除键</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">hlen</span> <span class="string">myhash</span><span class="comment"># hlen 获取哈希表长度</span></span><br><span class="line"><span class="string">hexists</span> <span class="string">myhash</span> <span class="string">field1</span>    <span class="comment"># 是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="string">hkeys</span> <span class="string">myhash</span> <span class="comment"># 获得所有域（field），键</span></span><br><span class="line"><span class="string">hvals</span> <span class="string">myhash</span><span class="comment"># 获得所有域（field）的值</span></span><br><span class="line"></span><br><span class="line"><span class="string">hincrby</span> <span class="string">myhash</span> <span class="string">nums</span> <span class="number">1</span>   <span class="comment"># myhash表的nums的值增1</span></span><br><span class="line"></span><br><span class="line"><span class="string">hsetnx</span> <span class="string">myhash</span> <span class="string">happy</span> <span class="string">&quot;hello&quot;</span> <span class="comment"># 未不存在的字段复制，存在返回0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-6、集合Set"><a href="#4-6、集合Set" class="headerlink" title="4.6、集合Set"></a>4.6、集合Set</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sadd</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span>   <span class="comment"># 将一个或多个成员元素加入</span></span><br><span class="line"><span class="string">SMEMBERS</span> <span class="string">myset</span> <span class="comment"># 返回集合中的所有的成员。</span></span><br><span class="line"><span class="string">SISMEMBER</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span> <span class="comment"># 判断是否在集合里面</span></span><br><span class="line"></span><br><span class="line"><span class="string">scard</span> <span class="string">myset</span><span class="comment"># scard，获取集合里面的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="string">srem</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span> <span class="string">&quot;xuexi&quot;</span><span class="comment"># 移除集合中的一个或多个成员</span></span><br><span class="line"></span><br><span class="line"><span class="string">srandmember</span> <span class="string">myset</span> <span class="number">2</span>  <span class="comment"># 返回2个随机元素</span></span><br><span class="line"><span class="string">spop</span> <span class="string">myset</span> <span class="number">2</span> <span class="comment"># 移除2个随机元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">smove</span> <span class="string">myset</span> <span class="string">set</span> <span class="string">&quot;hello&quot;</span> <span class="comment"># hello移到set集合李阿敏里面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合</span></span><br><span class="line"><span class="string">SDIFF</span> <span class="string">key1</span> <span class="string">key2</span>    <span class="comment"># 差集 </span></span><br><span class="line"><span class="string">SINTER</span> <span class="string">key1</span> <span class="string">key2</span>   <span class="comment"># 交集 </span></span><br><span class="line"><span class="string">SUNION</span> <span class="string">key1</span> <span class="string">key2</span>   <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure><h2 id="4-7、有序集合Zset"><a href="#4-7、有序集合Zset" class="headerlink" title="4.7、有序集合Zset"></a>4.7、有序集合Zset</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zadd</span> <span class="string">salary</span> <span class="number">1</span> <span class="string">&quot;one&quot;</span><span class="comment"># 加入1个或者多个</span></span><br><span class="line"><span class="string">zadd</span> <span class="string">salary</span> <span class="number">2</span> <span class="string">&quot;two&quot;</span> <span class="number">3</span> <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="string">zrange</span> <span class="string">salary</span> <span class="number">0</span> <span class="number">-1</span><span class="comment"># 返回指定区间的成员</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">zrangebyscore</span> <span class="string">salary</span> <span class="string">-inf</span> <span class="string">+inf</span>     <span class="comment"># 从负无穷大到正无穷大，递增显示</span></span><br><span class="line"><span class="string">zrevrange</span> <span class="string">salary</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span>   <span class="comment"># 递减排列   </span></span><br><span class="line"><span class="string">zrangebyscore</span> <span class="string">salary</span> <span class="string">-inf</span> <span class="number">2500 </span><span class="string">WITHSCORES</span>     <span class="comment"># 工资小于2500,递增</span></span><br><span class="line"></span><br><span class="line"><span class="string">zrem</span> <span class="string">salaryt</span> <span class="string">&quot;one&quot;</span><span class="comment"># zrem 删除集合成员</span></span><br><span class="line"></span><br><span class="line"><span class="string">zcard</span> <span class="string">salary</span><span class="comment"># 返回长度</span></span><br><span class="line"><span class="string">zcount</span> <span class="string">salary</span> <span class="number">10</span> <span class="number">3000</span><span class="comment"># 返回指定区间成员数量。</span></span><br><span class="line"></span><br><span class="line"><span class="string">zrank</span> <span class="string">salary</span> <span class="string">wzh</span>  <span class="comment"># 从0开始，由小到大，显示排名，即第几个</span></span><br><span class="line"><span class="string">zrevrank</span> <span class="string">salary</span> <span class="string">zk</span> <span class="comment"># 即倒数第几个</span></span><br></pre></td></tr></table></figure><h1 id="5、三种特殊数据类型"><a href="#5、三种特殊数据类型" class="headerlink" title="5、三种特殊数据类型"></a>5、三种特殊数据类型</h1><h2 id="5-1、GEO地理位置"><a href="#5-1、GEO地理位置" class="headerlink" title="5.1、GEO地理位置"></a>5.1、GEO地理位置</h2><p>Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。</p><p><strong>geo的数据类型为zset。</strong></p><p>GEO 共有六个常用命令：geoadd、geopos、geodist、georadius、georadiusbymember、gethash</p><blockquote><p>geoadd：设置地点</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">geoadd</span> <span class="string">key</span> <span class="string">longitude</span> <span class="string">latitude</span> <span class="string">member</span></span><br><span class="line"><span class="string">geoadd</span> <span class="string">china:city</span> <span class="number">116.23</span> <span class="number">40.22</span> <span class="string">北京</span></span><br><span class="line"><span class="string">geoadd</span> <span class="string">china:city</span> <span class="number">121.48</span> <span class="number">31.40</span> <span class="string">上海</span> <span class="number">113.88</span> <span class="number">22.55</span> <span class="string">深圳</span> <span class="number">120.21</span> <span class="number">30.20</span> <span class="string">杭州</span></span><br><span class="line"><span class="comment"># 将给定的空间元素(纬度、经度、名字)添加到指定的键里面。 </span></span><br><span class="line"><span class="comment"># 这些数据会以有序集he的形式被储存在键里面，从而使得georadius和georadiusbymember这样的 命令可以在之后通过位置查询取得这些元素。 </span></span><br><span class="line"><span class="comment"># geoadd命令以标准的x,y格式接受参数,所以用户必须先输入经度,然后再输入纬度。 </span></span><br><span class="line"><span class="comment"># geoadd能够记录的坐标是有限的:非常接近两极的区域无法被索引。 </span></span><br><span class="line"><span class="comment"># 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间。， 当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。</span></span><br></pre></td></tr></table></figure><blockquote><p>geopos：查找经纬度</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">geopos</span> <span class="string">key</span> <span class="string">member</span> [<span class="string">member...</span>]</span><br><span class="line"><span class="comment">#从key里返回所有给定位置元素的位置（经度和纬度）</span></span><br><span class="line"><span class="string">geopos</span> <span class="string">china:city</span> <span class="string">北京</span></span><br></pre></td></tr></table></figure><blockquote><p>geodist：查找城市间距离</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法 </span></span><br><span class="line"><span class="string">geodist</span> <span class="string">key</span> <span class="string">member1</span> <span class="string">member2</span> [<span class="string">unit</span>]</span><br><span class="line"><span class="string">geodist</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="string">上海</span></span><br><span class="line"><span class="string">geodist</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="string">上海</span> <span class="string">km</span></span><br><span class="line"><span class="comment"># 返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在,那么命令返回空值。</span></span><br><span class="line"><span class="comment"># 指定单位的参数unit必须是以下单位的其中一个： </span></span><br><span class="line"><span class="comment"># m表示单位为米 # km表示单位为千米 # mi表示单位为英里 # ft表示单位为英尺 </span></span><br><span class="line"><span class="comment"># 如果用户没有显式地指定单位参数,那么geodist默认使用米作为单位。 </span></span><br><span class="line"><span class="comment">#geodist命令在计算距离时会假设地球为完美的球形,在极限情况下,这一假设最大会造成0.5%的误 差。</span></span><br></pre></td></tr></table></figure><blockquote><p>georadius：以一点为中心查找附近城市</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">georadius</span> <span class="string">key</span> <span class="string">longitude</span> <span class="string">latitude</span> <span class="string">radius</span> <span class="string">m|km|ft|mi</span> [<span class="string">withcoord</span>][<span class="string">withdist</span>] [<span class="string">withhash</span>][<span class="string">asc|desc</span>][<span class="string">count</span> <span class="string">count</span>]</span><br><span class="line"><span class="comment"># 以给定的经纬度为中心， 找出某一半径内的元素</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cli --raw -p 6379  # 强制输出中文，不然乱码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市</span></span><br><span class="line"><span class="string">georadius</span> <span class="string">china:city</span> <span class="number">100</span> <span class="number">30</span> <span class="number">1000 </span><span class="string">km</span></span><br><span class="line"><span class="comment"># withdist 返回位置名称和中心距离</span></span><br><span class="line"><span class="string">georadius</span> <span class="string">china:city</span> <span class="number">100</span> <span class="number">30</span> <span class="number">1000 </span><span class="string">km</span> <span class="string">withdist</span></span><br><span class="line"><span class="comment"># withcoord 返回位置名称和经纬度 </span></span><br><span class="line"><span class="string">georadius</span> <span class="string">china:city</span> <span class="number">100</span> <span class="number">30</span> <span class="number">1000 </span><span class="string">km</span> <span class="string">withcoord</span></span><br><span class="line"><span class="comment"># withdist withcoord 返回位置名称 距离 和经纬度 count 限定寻找个数 </span></span><br><span class="line"><span class="string">georadius</span> <span class="string">china:city</span> <span class="number">100</span> <span class="number">30</span> <span class="number">1000 </span><span class="string">km</span> <span class="string">withcoord</span> <span class="string">withdist</span> <span class="string">count</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>georadiusbymember：以城市为中心查找附近城市</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法 </span></span><br><span class="line"><span class="string">georadiusbymember</span> <span class="string">key</span> <span class="string">member</span> <span class="string">radius</span> <span class="string">m|km|ft|mi</span> [<span class="string">withcoord</span>][<span class="string">withdist</span>] [<span class="string">withhash</span>][<span class="string">asc|desc</span>][<span class="string">count</span> <span class="string">count</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">GEORADIUSBYMEMBER</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="number">1000 </span><span class="string">km</span></span><br></pre></td></tr></table></figure><blockquote><p>geohash：经纬度转换为字符串</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法 </span></span><br><span class="line"><span class="string">geohash</span> <span class="string">key</span> <span class="string">member</span> [<span class="string">member...</span>] </span><br><span class="line"><span class="comment"># Redis使用geohash将二维经纬度转换为一维字符串，</span></span><br><span class="line"><span class="comment">#字符串越长表示位置更精确,两个字符串越相似 表示距离越近。</span></span><br><span class="line"></span><br><span class="line"><span class="string">geohash</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="string">重庆</span></span><br></pre></td></tr></table></figure><blockquote><p>zrem：删除</p></blockquote><p>GEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zrem</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="comment"># 移除元素</span></span><br></pre></td></tr></table></figure><h2 id="5-2、HyperLogLog"><a href="#5-2、HyperLogLog" class="headerlink" title="5.2、HyperLogLog"></a>5.2、HyperLogLog</h2><ul><li>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</li><li>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li><li>HyperLogLog则是一种算法，它提供了不精确的去重计数方案。</li><li>假如我要统计网页的UV（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的解决方案是使用Set来保存用户id，然后统计Set中的元素数量来获取页面UV。但这种方案只能承载少量用户，一旦用户数量大起来就需要消耗大量的空间来存储用户id。我的目的是统计用户数量而不是保存用户，这简直是个吃力不讨好的方案！而使用Redis的HyperLogLog最多需要12k就可以统计大量的用户数，尽管它大概有0.81%的错误率，但对于统计UV这种不需要很精确的数据是可以忽略不计的。</li></ul><blockquote><p>基数</p></blockquote><ul><li>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。基数估计就是在误差可接受的范围内，快速计算基数。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PFADD</span> <span class="string">mykey</span> <span class="string">a</span> <span class="string">b</span> <span class="string">c</span> <span class="string">d</span> <span class="string">e</span> <span class="string">f</span> <span class="string">g</span> <span class="string">h</span> <span class="string">i</span> <span class="string">j</span>  <span class="comment"># 添加指定元素到 HyperLogLog 中。 </span></span><br><span class="line"><span class="string">PFCOUNT</span> <span class="string">mykey</span>                    <span class="comment"># 返回给定 HyperLogLog 的基数估算值。</span></span><br><span class="line"><span class="string">PFADD</span> <span class="string">mykey2</span> <span class="string">i</span> <span class="string">j</span> <span class="string">z</span> <span class="string">x</span> <span class="string">c</span> <span class="string">v</span> <span class="string">b</span> <span class="string">n</span> <span class="string">m</span> </span><br><span class="line"><span class="string">PFMERGE</span> <span class="string">mykey3</span> <span class="string">mykey</span> <span class="string">mykey2</span>      <span class="comment"># 将多个 合并为并集计算</span></span><br><span class="line"><span class="string">PFCOUNT</span> <span class="string">mykey3</span></span><br></pre></td></tr></table></figure><h2 id="5-3、BitMap"><a href="#5-3、BitMap" class="headerlink" title="5.3、BitMap"></a>5.3、BitMap</h2><ul><li> Redis 提供了 Bitmap ，Bitmap 通过操作二进制位来进行记录，即为 0 和 1；如果要记录 365 天的打卡情况，使用 Bitmap表示的形式大概如下0101000111000111………………………，节约内存了，365 天相当于 365 bit，又 1 字节 = 8 bit , 所以相当于使用 46 个字节即可。</li><li>Bitmaps实际上它就是字符串（key-value），但是可以对字符串位操作</li></ul><blockquote><p>setbit 设置操作</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SETBIT key offset value :</span> <span class="string">设置</span> <span class="string">key</span> <span class="string">的第</span> <span class="string">offset</span> <span class="string">位为value</span> <span class="string">(1或0)</span></span><br><span class="line"><span class="comment"># value只能为0或者1</span></span><br><span class="line"><span class="comment"># 使用 bitmap 来记录上述事例中一周的打卡记录如下所示： </span></span><br><span class="line"><span class="comment"># 周一：1，周二：0，周三：0，周四：1，周五：1，周六：0，周天：0 （1 为打卡，0 为不打卡）</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">2</span> <span class="number">0</span> </span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">5</span> <span class="number">0</span> </span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">6</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><blockquote><p>getbit 获取操作</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">GETBIT</span> <span class="string">key</span> <span class="string">offset</span>  <span class="comment"># 获取offset设置的值，未设置过默认返回0</span></span><br><span class="line"></span><br><span class="line"><span class="string">getbit</span> <span class="string">sign</span> <span class="number">3</span>      <span class="comment"># 查看周四是否打卡</span></span><br></pre></td></tr></table></figure><blockquote><p>bitcount 统计操作</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计value为1的值得次数 </span></span><br><span class="line"><span class="string">bitcount</span> <span class="string">sign</span></span><br></pre></td></tr></table></figure><ul><li>僵尸粉大多，其实还不如用set集合</li></ul><h1 id="6、Redis-conf"><a href="#6、Redis-conf" class="headerlink" title="6、Redis.conf"></a>6、Redis.conf</h1><ul><li>Redis 的配置文件位于 Redis 安装目录下，文件名为 <strong>redis.conf</strong></li></ul><blockquote><p>Units 单位</p></blockquote><p><img src="/img/Redis/2.jpg"></p><ul><li>配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit</li><li>对 大小写 不敏感</li></ul><blockquote><p>INCLUDES 包含</p></blockquote><p><img src="/img/Redis/3.jpg"></p><blockquote><p>NETWORK 网络配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bind</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>     <span class="comment"># 绑定的ip,只接受本机的访问请求</span></span><br><span class="line"><span class="string">protected-mode</span> <span class="literal">yes</span> <span class="comment"># 保护模式,没密码时，只接受本机响应 </span></span><br><span class="line"><span class="string">port</span> <span class="number">6379</span>          <span class="comment"># 默认端口</span></span><br><span class="line"><span class="string">tcp-backlog</span> <span class="number">511</span>    <span class="comment"># backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列</span></span><br><span class="line"><span class="string">timeout</span> <span class="number">0</span>   <span class="comment"># 空闲的客户端维持多少秒关闭</span></span><br><span class="line"><span class="string">tcp-keepalive</span> <span class="number">300</span>  <span class="comment"># 对访问客户端的一种心跳检测，,0不检测</span></span><br></pre></td></tr></table></figure><blockquote><p>GENERAL 通用</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span> <span class="comment"># yes 开启作为守护线程</span></span><br><span class="line"><span class="string">supervised</span> <span class="literal">no</span> <span class="comment"># 可通过upstart和systemd管理Redis守护进程 </span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/var/run/redis_6379.pid</span> <span class="comment"># pid文件位置</span></span><br><span class="line"><span class="string">loglevel</span> <span class="string">notice</span> <span class="comment"># 日志级别。可选项有： </span></span><br><span class="line"><span class="comment"># debug（记录大量日志信息，适用于开发、测试阶段）；</span></span><br><span class="line">                <span class="comment"># verbose（较多日志信息）；</span></span><br><span class="line">                <span class="comment"># notice（适量日志信息，使用于生产环境）； </span></span><br><span class="line">                <span class="comment"># warning（仅有部分重要、关键信息才会被记录）。 </span></span><br><span class="line"><span class="string">logfile</span> <span class="string">&quot;&quot;</span><span class="comment"># 日志文件的位置，当指定为空字符串时，为标准输出 </span></span><br><span class="line"><span class="string">databases</span> <span class="number">16</span> <span class="comment"># 设置数据库的数目。默认的数据库是DB 0 </span></span><br><span class="line"><span class="string">always-show-logo</span> <span class="literal">yes</span> <span class="comment"># 是否总是显示logo</span></span><br></pre></td></tr></table></figure><blockquote><p>SNAPSHOPTING 快照</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） </span></span><br><span class="line"><span class="string">save</span> <span class="number">900</span> <span class="number">1</span> </span><br><span class="line"><span class="comment"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） </span></span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">10</span> </span><br><span class="line"><span class="comment"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化） </span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span> </span><br><span class="line"><span class="comment"># 持久化出现错误后，是否依然进行继续进行工作 </span></span><br><span class="line"><span class="string">stop-writes-on-bgsave-error</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 使用压缩rdb文件 yes：压缩，cpu消耗。no：不压缩，消耗磁盘空间</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 是否校验rdb文件，保存rdb文件的时 候，会有大概10%的性能损耗</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span> </span><br><span class="line"><span class="comment"># dbfilenamerdb的文件名称</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump.rdb</span> </span><br><span class="line"><span class="comment"># dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span></span><br><span class="line"><span class="string">dir</span> <span class="string">./</span> </span><br></pre></td></tr></table></figure><blockquote><p>REPLICATION 复制 </p></blockquote><ul><li>看后面的主从复制</li></ul><blockquote><p>SECURITY安全</p></blockquote><ul><li>访问密码的查看，设置和取消</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动redis </span></span><br><span class="line"><span class="comment"># 连接客户端 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得和设置密码 </span></span><br><span class="line"><span class="string">config</span> <span class="string">get</span> <span class="string">requirepass</span> </span><br><span class="line"><span class="string">config</span> <span class="string">set</span> <span class="string">requirepass</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="comment">#测试ping，发现需要验证 </span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ping</span> </span><br><span class="line"><span class="string">NOAUTH</span> <span class="string">Authentication</span> <span class="string">required.</span> </span><br><span class="line"><span class="comment"># 验证 </span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">auth</span> <span class="number">123456</span> </span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ping</span> </span><br><span class="line"><span class="string">PONG</span></span><br></pre></td></tr></table></figure><blockquote><p>LIMITS限制</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">maxclients</span> <span class="number">10000</span>   <span class="comment"># 设置能连上redis的最大客户端连接数量 </span></span><br><span class="line"><span class="string">maxmemory</span> <span class="string">&lt;bytes&gt;</span>  <span class="comment"># redis配置的最大内存容量 </span></span><br><span class="line"></span><br><span class="line"><span class="string">maxmemory-policy</span> <span class="string">noeviction</span></span><br><span class="line"><span class="comment"># maxmemory-policy 内存达到上限的处理策略 </span></span><br><span class="line"><span class="comment">#volatile-lru：利用LRU算法移除设置过过期时间的key。 </span></span><br><span class="line"><span class="comment">#volatile-random：随机移除设置过过期时间的key。 </span></span><br><span class="line"><span class="comment">#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL） </span></span><br><span class="line"><span class="comment">#allkeys-lru：利用LRU算法移除任何key。 </span></span><br><span class="line"><span class="comment">#allkeys-random：随机移除任何key。</span></span><br><span class="line">    <span class="comment">#noeviction：不移除任何key，只是返回一个写错误。</span></span><br></pre></td></tr></table></figure><blockquote><p>append only模式</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appendonly</span> <span class="literal">no</span> </span><br><span class="line"><span class="comment"># 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这种 方式在许多应用中已经足够用了</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># appendfilename AOF 文件名称 </span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span> <span class="comment"># appendfsync aof持久化策略的配置 </span></span><br><span class="line"><span class="comment"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。 </span></span><br><span class="line"><span class="comment"># always表示每次写入都执行fsync，以保证数据同步到磁盘。</span></span><br><span class="line">        <span class="comment"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br></pre></td></tr></table></figure><h1 id="7、Redis的持久化"><a href="#7、Redis的持久化" class="headerlink" title="7、Redis的持久化"></a>7、Redis的持久化</h1><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。</p><h2 id="7-1、RDB（默认）"><a href="#7-1、RDB（默认）" class="headerlink" title="7.1、RDB（默认）"></a>7.1、RDB（默认）</h2><p><strong>概念：</strong>指定的时间间隔内将内存的数据集写入<strong>dump.rdb</strong> <strong>文件</strong>（快照），恢复时读取文件</p><p><strong>执行过程：</strong>Redis单独创建（Fork）一个子进程进行持久化，先把数据写入临时文件中，结束后用临时文件替换上次的文件。</p><p><strong>优点：</strong>持久化不进行IO操作，效率高；性能比AOF更好，适合大规模、数据不敏感的情况</p><p><strong>缺点：</strong>最后一次快照后的修改易丢失；Fork的时候，克隆大致2倍的膨胀性需要考虑</p><p><strong>Fork：</strong>复制一个与当前进程完全一致一样的进程，并作为原进程的子进程</p><blockquote><p>配置位置及SNAPSHOTTING解析</p></blockquote><ul><li>默认配置</li></ul><p><img src="/img/Redis/1.jpg"></p><ul><li>可以修改触发条件机制</li><li>不设置任何save，即可禁用RDB</li><li>若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效 !</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">save</span> <span class="number">120</span> <span class="number">10</span> <span class="comment"># 120秒内修改10次则触发RDB</span></span><br><span class="line"></span><br><span class="line"><span class="string">flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</span></span><br></pre></td></tr></table></figure><ul><li>使用 bgsave 会在后台异步进行快照</li><li>lastsave 命令获取最后一次成功执行快照的时间</li></ul><blockquote><p>配置文件</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span> <span class="comment"># 存储快照后，进行压缩</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span>   <span class="comment"># 存储快照后，会开启数据检验，但会多消耗10%性能</span></span><br></pre></td></tr></table></figure><blockquote><p>恢复</p></blockquote><p>将备份文件（dump.rdb）移动到redis安装目录并启动服务即可</p><h2 id="7-2、AOF"><a href="#7-2、AOF" class="headerlink" title="7.2、AOF"></a>7.2、AOF</h2><p><strong>概念：</strong>用日志的形式， 把指令（读除外）记录下来，每次重启需要<code>重新执行指令</code>。</p><p><strong>执行过程：</strong></p><ol><li>客户端请求的命令追加到 AOF缓存区，</li><li>根据持久化策略异步的把缓存区 同步到 appendonly.aof 文件</li><li>同步后如果文件大小超过阈值（大了64M），会对appendonly.aof 文件进行重写。</li></ol><p><strong>特点：</strong>可以追加指令到文件，但是不可以改写文件</p><p><strong>同步规则：</strong>1、不设置规则让操作系统决定   2、每次修改同步    3、每秒同步（建议）   </p><p><strong>重写 rewrite</strong>：fork处一条新进程，通过读取缓存的数据，实现指令的压缩。</p><p><strong>缺点：</strong>同样容量文件AOF远大于RDB，恢复速度因此更慢</p><p><strong>优点：</strong>每次修改就保存策略可以<code>不丢失数据</code>，每秒的形式兼顾性能和效果。</p><p><strong>注意点：</strong>不同步效率和rdb相同。</p><blockquote><p>配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appendonly</span> <span class="literal">no</span> <span class="comment"># 持久化方式，</span></span><br><span class="line"><span class="comment"># 默认使用的是rdb方式持久化，这种方式在许多应用中已经足够用了 </span></span><br><span class="line"><span class="comment"># 设置成yes，开启AOF方式</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># appendfilename AOF 生成文件名称</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span> <span class="comment"># appendfsync aof持久化策略的配置 </span></span><br><span class="line"><span class="comment"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。 </span></span><br><span class="line"><span class="comment"># always表示每次写入都执行fsync，以保证数据同步到磁盘。 </span></span><br><span class="line"><span class="comment"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br><span class="line"></span><br><span class="line"><span class="literal">no</span><span class="string">-appendfsync-on-rewrite</span> <span class="literal">no</span> </span><br><span class="line"><span class="comment"># 重写时是否可以运用Appendfsync，用默认no即可保证数据安全性</span></span><br><span class="line"><span class="comment"># yes：不写入aof文件只写入缓存，用户请求不会阻塞</span></span><br><span class="line"><span class="comment"># no，会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="string">Auto-aof-rewrite-min-size</span>        <span class="comment"># 设置重写的基准值 </span></span><br><span class="line"><span class="string">Auto-aof-rewrite-percentage</span>      <span class="comment"># 设置重写的基准值</span></span><br></pre></td></tr></table></figure><blockquote><p>数据恢复</p></blockquote><p><strong>正常恢复：</strong></p><ul><li>启动：修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录</li><li>恢复：重启redis然后重新加载</li></ul><p><strong>异常恢复：</strong></p><ul><li>启动：修改默认的appendonly no，改为yes</li><li>故意破坏 appendonly.aof 文件！</li><li>修复： redis-check-aof –fix appendonly.aof 进行修复</li><li>恢复：重启 redis 然后重新加载</li></ul><h2 id="7-3、总结"><a href="#7-3、总结" class="headerlink" title="7.3、总结"></a>7.3、总结</h2><p><strong>RDB：</strong>性能高，但是容易丢失修改的操作。</p><p><strong>AOF：</strong>性能低，但是对文件的修改保存的更好。</p><p><strong>使用建议：</strong>同时开启 RDB 和 AOF</p><ol><li>Redis 重启 优先加载 AOF，因为AOF往往记录更加完整。</li><li>RDB 作为后备用途，更适合用于备份数据库（AOF在不断变化不好备份）。</li></ol><p><strong>性能建议</strong></p><ul><li>RDB文件只用作后备用途，建议只在Slave（从机）上持久化RDB文件，而且只要15分钟备份一次就够了，保留 save 900 1 这条规则。</li><li>如果开启AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li><li>如果不开启 AOF ，仅靠 Master-Slave Repllcation （主从复制）实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li></ul><h1 id="8、Redis事务"><a href="#8、Redis事务" class="headerlink" title="8、Redis事务"></a>8、Redis事务</h1><p><strong>本质</strong>：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令</p><p><strong>特点：</strong>不存在隔离级别，ACID原则，回滚</p><ol><li>事务开启并不会执行命令，而是放入缓存；命令会被序列化，等提交后依次执行。</li><li>在执行事务之前，事务支持被打断（类似<code>乐观锁机制</code>）</li></ol><p><strong>原子性：</strong>可以使用Lua语言来实现原子性。</p><p><strong>Redis事务的三个阶段</strong>：1、开始事务  2、命令入队  3、执行事务</p><p><strong>Redis事务相关命令</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">watch</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">...</span> <span class="comment">#监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则 事务被打断(类似乐观锁)</span></span><br><span class="line"><span class="string">multi</span>    <span class="comment"># 标记一个事务块的开始(queued) 标记之后，结束之前指令会加入队列但不执行。</span></span><br><span class="line"><span class="string">exec</span>     <span class="comment"># 执行所有事务块的命令(一旦执行exec后，之前加的监控锁都会被取消掉) </span></span><br><span class="line"></span><br><span class="line"><span class="string">discard</span>  <span class="comment"># 取消事务，放弃事务块中的所有命令 </span></span><br><span class="line"><span class="string">unwatch</span>  <span class="comment"># 取消watch对所有key的监控</span></span><br></pre></td></tr></table></figure><blockquote><p>正常执行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">multi       # 开始事务</span><br><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">get k2</span><br><span class="line">set k3 v3</span><br><span class="line">exec        # 执行事务</span><br></pre></td></tr></table></figure><blockquote><p>放弃事务</p></blockquote><ul><li>全部都不执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multi       # 开始事务</span><br><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">discard     # 放弃事务</span><br><span class="line">exec        # 执行事务</span><br></pre></td></tr></table></figure><blockquote><p>事务出现命令错误，语法对</p></blockquote><ul><li>执行阶段发生错误，错误的不执行，其他都执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multi       # 开始事务</span><br><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">get k3 v3   # 错误命令</span><br><span class="line">exec        # 执行事务</span><br></pre></td></tr></table></figure><blockquote><p>事务出现语法错误</p></blockquote><ul><li>执行阶段前发生错误，全部都不执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multi       # 开始事务</span><br><span class="line">set k1      # 语法错误</span><br><span class="line">set k2 v2</span><br><span class="line">exec        # 执行事务</span><br></pre></td></tr></table></figure><blockquote><p>Watch监控：实现乐观锁</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现乐观锁机制</span></span><br><span class="line"><span class="string">set</span> <span class="string">balance</span> <span class="number">100</span>  <span class="comment"># 余额100</span></span><br><span class="line"><span class="string">set</span> <span class="string">debt</span> <span class="number">0</span>       <span class="comment"># 欠款0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用watch检测balance，事务期间balance数据未变动，事务执行成功</span></span><br><span class="line"><span class="string">watch</span> <span class="string">balance</span>          <span class="comment"># 开启监控</span></span><br><span class="line"><span class="string">MULTI</span>                  <span class="comment"># 开始事务</span></span><br><span class="line"><span class="string">decrby</span> <span class="string">balance</span> <span class="number">20</span>      <span class="comment"># 减少余额20</span></span><br><span class="line"><span class="string">incrby</span> <span class="string">debt</span> <span class="number">20</span>         <span class="comment"># 增加欠款20</span></span><br><span class="line"><span class="string">exec</span>                   <span class="comment"># 执行事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若中途balance有变化，就会执行失败</span></span><br></pre></td></tr></table></figure><ul><li>一但执行 EXEC 开启事务的执行后， WARCH 对变量的监控就会被取消。</li><li>所以事务失败后，需要重新使用watch变量监视</li></ul><h1 id="9、发布订阅"><a href="#9、发布订阅" class="headerlink" title="9、发布订阅"></a>9、发布订阅</h1><p><strong>概念：</strong></p><ul><li>Redis 发布订阅(pub/sub)是一种消息通信模式：</li><li>发送者(pub)发送消息，订阅者(sub)接收消息。</li><li>Redis 客户端可以订阅任意数量的频道。</li><li>每当有新消息通过publish命令发送给频道时，消息就会发送给所有客户端</li></ul><blockquote><p>命令</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅一个或多个符合给定模式的频道。</span></span><br><span class="line"><span class="string">PSUBSCRIBE</span> <span class="string">pattern</span> [<span class="string">pattern</span> <span class="string">...</span>] </span><br><span class="line"><span class="comment"># 查看订阅与发布系统状态。</span></span><br><span class="line"><span class="string">PUBSUB</span> <span class="string">subcommand</span> [<span class="string">argument</span> [<span class="string">argument</span> <span class="string">...</span>]] </span><br><span class="line"><span class="string">PUBSUB</span> <span class="string">Channels</span> <span class="string">myChat</span></span><br><span class="line"><span class="comment"># 将信息发送到指定的频道。</span></span><br><span class="line"><span class="string">PUBLISH</span> <span class="string">channel</span> <span class="string">message</span> </span><br><span class="line"><span class="comment"># 退订所有给定模式的频道。</span></span><br><span class="line"><span class="string">PUNSUBSCRIBE</span> [<span class="string">pattern</span> [<span class="string">pattern</span> <span class="string">...</span>]] </span><br><span class="line"><span class="comment"># 订阅给定的一个或多个频道的信息。</span></span><br><span class="line"><span class="string">SUBSCRIBE</span> <span class="string">channel</span> [<span class="string">channel</span> <span class="string">...</span>] </span><br><span class="line"><span class="comment"># 指退订给定的频道。</span></span><br><span class="line"><span class="string">UNSUBSCRIBE</span> [<span class="string">channel</span> [<span class="string">channel</span> <span class="string">...</span>]] </span><br></pre></td></tr></table></figure><blockquote><p>实战</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建订阅频道名字为myChat</span></span><br><span class="line"><span class="string">SUBSCRIBE</span> <span class="string">myChat</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 新开一个客户端连接redis，同一个频道myChat发布消息</span></span><br><span class="line"><span class="string">publish</span> <span class="string">myChat</span> <span class="string">&quot;hello,redis&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个客户端就能收到信息</span></span><br></pre></td></tr></table></figure><blockquote><p>原理</p></blockquote><p><strong>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能</strong></p><ul><li> SUBSCRIBE 命令订阅某频道后，redis-server 里会维护了一个字典，字典的键就是一个个 channel（频道），而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中</li><li>PUBLISH 命令向订阅者发送消息，根据链表发送给所有客户端</li></ul><blockquote><p>使用场景</p></blockquote><ul><li>Pub/Sub构建实时消息系统</li></ul><h1 id="10、主从复制"><a href="#10、主从复制" class="headerlink" title="10、主从复制"></a>10、主从复制</h1><h2 id="10-1、概念"><a href="#10-1、概念" class="headerlink" title="10.1、概念"></a>10.1、概念</h2><ul><li>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。</li><li>前者称为主节点(master/leader)，后者称为从节点(slave/follower)；</li><li>数据的复制是<strong>单向的，只能由主到从</strong>。Master以写为主，Slave 以读为主。</li><li>默认情况下，每台Redis服务器都是主节点，一个从节点只能有一个主节点。</li></ul><h2 id="10-2、-优点"><a href="#10-2、-优点" class="headerlink" title="10.2、 优点"></a>10.2、 优点</h2><ul><li>数据冗余：主从复制实现了数据的<strong>热备份</strong>，是持久化外的一种数据冗余方式</li><li>故障恢复：当主节点出现问题时，可以由从节点故障恢复；服务的冗余。</li><li>负载均衡：配合读写分离，可以由主节点提供写服务，由从节点提供读服务分担服务器负载；大大提高Redis服务器的并发量。</li><li>高可用基石：主从复制是<strong>哨兵</strong>和<strong>集群</strong>能够实施的基础。</li></ul><h2 id="10-3、环境配置"><a href="#10-3、环境配置" class="headerlink" title="10.3、环境配置"></a>10.3、环境配置</h2><ul><li>准备</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前库的信息</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">info</span> <span class="string">replication</span></span><br><span class="line"><span class="string">role:master</span>            <span class="comment"># 角色，主机</span></span><br><span class="line"><span class="string">connected_slaves:0</span>     <span class="comment"># 从机  0 个</span></span><br></pre></td></tr></table></figure><h3 id="1、启动三个redis"><a href="#1、启动三个redis" class="headerlink" title="1、启动三个redis"></a>1、启动三个redis</h3><ul><li>复制启动文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cp</span> <span class="string">redis.conf</span> <span class="string">redis79.conf</span>  <span class="comment"># 依次复制三份</span></span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">vim</span> <span class="string">redis79.conf</span>   <span class="comment"># 先进入配置文件</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/www/server/redis/redis6379.pid</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">&quot;/www/server/redis/redis6379.log&quot;</span>  <span class="comment">#日志文件修改</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump6379.rdb</span>   <span class="comment"># 默认持久化文件名修改</span></span><br><span class="line"></span><br><span class="line"><span class="string">vim</span> <span class="string">redis80.conf</span>   <span class="comment"># 先进入配置文件</span></span><br><span class="line"><span class="string">port</span> <span class="number">6380</span>          <span class="comment"># 修改端口号</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/www/server/redis/redis6380.pid</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">&quot;/www/server/redis/redis6380.log&quot;</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump6380.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次配置81</span></span><br></pre></td></tr></table></figure><ul><li>启动redis</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/www/server/redis/src/redis-server /www/server/redis/redis.conf</span><br><span class="line"></span><br><span class="line">/www/server/redis/src/redis-server /www/server/redis/redis79.conf</span><br><span class="line">redis-cli -p 6379</span><br><span class="line"></span><br><span class="line">/www/server/redis/src/redis-server /www/server/redis/redis80.conf</span><br><span class="line">/www/server/redis/src/redis-server /www/server/redis/redis81.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>查看进程信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure><h3 id="2、暂时配置主从"><a href="#2、暂时配置主从" class="headerlink" title="2、暂时配置主从"></a>2、暂时配置主从</h3><ul><li>开始配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">info</span> <span class="string">replication</span>  <span class="comment"># 默认都是主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置79 为主机 80 81为从机</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6380&gt;</span> <span class="string">slaveof</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span>  <span class="comment"># 设置认 6379 当做主机</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6380&gt;</span> <span class="string">info</span> <span class="string">replication</span>        <span class="comment"># 此时信息显示该为从机</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6381&gt;</span> <span class="string">slaveof</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span>  <span class="comment"># 设置认 6379 当做主机</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6381&gt;</span> <span class="string">info</span> <span class="string">replication</span>        <span class="comment"># 此时信息显示该为从机</span></span><br></pre></td></tr></table></figure><h3 id="3、永久配置主从"><a href="#3、永久配置主从" class="headerlink" title="3、永久配置主从"></a>3、永久配置主从</h3><ul><li>再配置文件中找到replication修改</li></ul><p><img src="/img/Redis/4.jpg"></p><ul><li>去掉注释 &lt;&gt; 里面写入内容即可</li><li>地址 主机IP      replicaof 127.0.0.1 6379</li><li>主机密码</li></ul><h3 id="4、关闭服务"><a href="#4、关闭服务" class="headerlink" title="4、关闭服务"></a>4、关闭服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown save</span><br></pre></td></tr></table></figure><h3 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h3><ul><li>在主机设置值，在从机都可以取到！从机不能写值</li></ul><h2 id="10-4、测试"><a href="#10-4、测试" class="headerlink" title="10.4、测试"></a>10.4、测试</h2><h3 id="1、正常读写"><a href="#1、正常读写" class="headerlink" title="1、正常读写"></a>1、正常读写</h3><ul><li>在主机设置值，在从机都可以取到（增量复制）！从机不能写值</li></ul><h3 id="2、宕机"><a href="#2、宕机" class="headerlink" title="2、宕机"></a>2、宕机</h3><ul><li><p>主机宕机后，从机还是从机，不会变为主机</p></li><li><p>主机宕机恢复后，从机会自动重新连接，获取主机新操作</p></li><li><p>从机宕机恢复后，会自动同步主机的信息（全量复制）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Slave 启动成功连接到 master 后会发送一个sync命令</span><br><span class="line">Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行</span><br><span class="line">完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</span><br><span class="line">全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内中。</span><br><span class="line">增量复制：Master继续将新的所有收集到的修改命令依次传给slave完成同步、</span><br><span class="line"></span><br><span class="line">但是只要是重新连接master，一次完全同步（全量复制）将被自动执行</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、谋权篡位"><a href="#3、谋权篡位" class="headerlink" title="3、谋权篡位"></a>3、谋权篡位</h3><ul><li>一主二从的情况下，主机长时间宕机了怎么办？</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用命令将自己改为主机,原来同步所得的数据集不会被丢弃</span></span><br><span class="line"><span class="string">SLAVEOF</span> <span class="literal">NO</span> <span class="string">ONE</span> </span><br></pre></td></tr></table></figure><ul><li>若此时原主机再恢复，会成为一个独立的机</li></ul><h3 id="4、薪火相传"><a href="#4、薪火相传" class="headerlink" title="4、薪火相传"></a>4、薪火相传</h3><ul><li>B从机在当A的从机时还充当C的主机，可以减少主机压力</li><li>不过B主机作为从机仍然是不能写入的</li></ul><h2 id="10-5、哨兵模式"><a href="#10-5、哨兵模式" class="headerlink" title="10.5、哨兵模式"></a>10.5、哨兵模式</h2><ul><li><strong>谋权篡位</strong>的自动版</li><li>后台监控主机，主机故障了就<strong>根据投票数</strong>自动将从库转换为主库。</li><li>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，</li><li>哨兵是一个独立的进程，作为进程，它会独立运行。</li></ul><h3 id="1、原理："><a href="#1、原理：" class="headerlink" title="1、原理："></a>1、原理：</h3><ul><li>哨兵通过发送命令，等待Redis服务器响应，监控运行的多个Redis实例。</li><li>哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改<strong>配置文件</strong>（永久更改），让它们切换主机</li><li>原主机回来之后<code>自动变为从机</code></li></ul><h3 id="2、多哨兵模式："><a href="#2、多哨兵模式：" class="headerlink" title="2、多哨兵模式："></a>2、多哨兵模式：</h3><ul><li>一个哨兵可能会出现问题，所以可以使用多个哨兵互相监控。</li><li>哨兵1检测到主机宕机，不会立即选取新主机，这个现象成为<strong>主观下线</strong></li><li>后面的哨兵也检测到主服务器不可用，且达到一定数量时，会进行投票</li><li>投票的结果由一个哨兵发起，进行failover[故障转移]操作，选择新主机，并且通过发布订阅模式，让哨兵通知监视的从机修改配置切换成新主机，该过程成为<strong>客观下线</strong></li></ul><h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><ul><li><p>设置一主二从，79主机，80、81从机</p></li><li><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cd</span> <span class="string">/www/server/redis/</span>  <span class="comment"># 进入目录</span></span><br><span class="line"><span class="string">vim</span> <span class="string">sentinel.conf</span>      <span class="comment"># 进入文件</span></span><br><span class="line"></span><br><span class="line"><span class="string">port</span> <span class="number">26379</span>   <span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line"><span class="string">dir</span> <span class="string">/tmp</span>     <span class="comment"># 哨兵sentinel的工作目录 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line"><span class="comment"># 哨兵sentinel      主机名(自己取) 地址  主机端口号</span></span><br><span class="line"><span class="comment"># 1个哨兵认为宕机就宕机</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379 </span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line"><span class="comment"># 哨兵sentinel   监控 mymaster     连接主机的密码</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">auth-pass</span> <span class="string">mymaster</span> <span class="string">MySUPER--secret-0123passw0rd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; </span></span><br><span class="line"><span class="comment"># 30毫秒之后 主节点没有应答哨兵sentinel ，哨兵就主观上认为主节点下线 </span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">30000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发生failover主备切换时同时只能有1个从机可以对新的主机同步</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; sentinel </span></span><br><span class="line"><span class="string">parallel-syncs</span> <span class="string">mymaster</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间设置为 3分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">180000</span></span><br></pre></td></tr></table></figure></li><li><p>启动哨兵</p><p>/www/server/redis/src/redis-sentinel /www/server/redis/sentinel.conf</p></li><li><p>关闭主机</p></li><li><p>新主机被自动选举出来</p></li><li><p>原主机重新回来后，只能当从机（永久性的改变）</p></li></ul><h3 id="4、优缺点"><a href="#4、优缺点" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点</strong></p><ol><li><p>哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。</p></li><li><p>主从可以切换，故障可以转移，系统可用性更好。</p></li><li><p>哨兵模式是主从模式的升级，系统更健壮，可用性更高。</p></li></ol><p><strong>缺点</strong></p><ol><li><p>Redis<strong>较难支持在线扩容</strong>，在集群容量达到上限时在线扩容会变得很复杂。</p></li><li><p>实现哨兵模式的配置也不简单，甚至可以说有些繁琐</p></li></ol><h1 id="11、Redis集群"><a href="#11、Redis集群" class="headerlink" title="11、Redis集群"></a>11、Redis集群</h1><h2 id="11-1、概念"><a href="#11-1、概念" class="headerlink" title="11.1、概念"></a>11.1、概念</h2><ul><li>对Redis的水平扩容，即启动N个redis主节点，将整个数据库<code>均匀分布</code>存储在这N个主节点中，每个主节点存储总数据的1/N。</li><li>无中心节点，各个主节点之间保持联系</li><li>每个主节点可以有多个从节点</li></ul><h2 id="11-2、配置"><a href="#11-2、配置" class="headerlink" title="11.2、配置"></a>11.2、配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先复制六份配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后配置文件配置 redis.conf</span></span><br><span class="line"><span class="string">cluster-enabled</span> <span class="literal">yes</span>                  <span class="comment"># 打开集群模式</span></span><br><span class="line"><span class="string">cluster-config-file</span> <span class="string">nodes-6379.conf</span>  <span class="comment"># 设定节点配置文件名</span></span><br><span class="line"><span class="string">cluster-node-timeout</span> <span class="number">15000</span>   </span><br><span class="line"><span class="comment"># 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着配置完之后启动六个redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将六个节点合成一个集群</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">--cluster</span> <span class="string">create</span> <span class="string">--cluster-replicas</span> <span class="number">1</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6379</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6380</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6381</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6389</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6390</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6391</span></span><br><span class="line"></span><br><span class="line"><span class="string">不要用127.0.0.1，</span> <span class="string">请用真实IP地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-3、登录"><a href="#11-3、登录" class="headerlink" title="11.3、登录"></a>11.3、登录</h2><p><strong>普通方式登陆</strong></p><ul><li>可能直接进入<strong>读主机</strong>，存储数据时，会出现MOVED重定向操作</li><li>所以，应该以集群方式登录。</li></ul><p><strong>集群方式登录：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 6379</span><br></pre></td></tr></table></figure><ul><li>-c 采用集群策略连接，设置数据会自动切换到相应的写主机</li></ul><p><strong>查看集群信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure><h2 id="11-4、节点分配问题"><a href="#11-4、节点分配问题" class="headerlink" title="11.4、节点分配问题"></a>11.4、节点分配问题</h2><ul><li>一个集群至少要有三个主节点</li><li>选项 –cluster-replicas 1 表示我们希望为集群中的<code>每个主节点创建一个从节点</code></li><li>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</li></ul><h2 id="11-5、Slot插槽"><a href="#11-5、Slot插槽" class="headerlink" title="11.5、Slot插槽"></a>11.5、Slot插槽</h2><ul><li>一个 Redis 集群包含 16384 个插槽（hash slot），</li><li> 数据库中的每个键都属于这 16384 个插槽的其中一个</li><li>集群每个主节点负责一部分插槽，存取值时根据 key(插槽)去对应节点</li><li>上面使用   - c  连接后会自动根据插槽，<strong>重定向到合适的主机</strong></li></ul><p><strong>注意：</strong></p><ul><li><p>不是一个插槽下的值，不能使用<strong>mget,mset</strong>等多键操作</p></li><li><p>不过可以通过  {  } 来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset k1&#123;cust&#125; v1 k2&#123;cust&#125; v2</span><br></pre></td></tr></table></figure></li></ul><p><strong>查询值</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">CLUSTER</span> <span class="string">GETKEYSINSLOT</span> <span class="string">&lt;slot&gt;&lt;count&gt;</span></span><br><span class="line"><span class="string">cluster</span> <span class="string">keyslot</span> <span class="string">cust</span> <span class="comment"># 返回插槽cust的一个值</span></span><br><span class="line"><span class="string">cluster</span> <span class="string">keyslot</span> <span class="string">cust</span>  <span class="number">10</span> <span class="comment"># 返回插槽cust的十个值</span></span><br></pre></td></tr></table></figure><h2 id="11-6、故障"><a href="#11-6、故障" class="headerlink" title="11.6、故障"></a>11.6、故障</h2><ul><li>如果主节点下线：从节点自动升为主节点</li><li>如果主节点恢复：主节点变成了从节点</li></ul><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，只是<strong>该插槽部分不能使用</strong>，也无法存储。</p><h2 id="11-7、缺点"><a href="#11-7、缺点" class="headerlink" title="11.7、缺点"></a>11.7、缺点</h2><ul><li>多键操作是不被支持的 </li><li>多键的Redis事务是不被支持的。lua脚本不被支持</li></ul><h1 id="12、Jedis"><a href="#12、Jedis" class="headerlink" title="12、Jedis"></a>12、Jedis</h1><h3 id="1、依赖"><a href="#1、依赖" class="headerlink" title="1、依赖"></a>1、依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;121.41.4.48&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="comment">//查看服务是否运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要先修改</span></span><br><span class="line"><span class="comment">bind 182.100.29.183 </span></span><br><span class="line"><span class="comment">bind 127.0.0.1</span></span><br><span class="line"><span class="comment">protected-mode no</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3、其他代码"><a href="#3、其他代码" class="headerlink" title="3、其他代码"></a>3、其他代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>); </span><br><span class="line"><span class="comment">//验证密码，如果没有设置密码这段代码省略 </span></span><br><span class="line"><span class="comment">// jedis.auth(&quot;password&quot;);</span></span><br><span class="line"></span><br><span class="line">jedis.connect(); <span class="comment">//连接 </span></span><br><span class="line">jedis.disconnect(); <span class="comment">//断开连接 </span></span><br><span class="line">jedis.flushAll(); <span class="comment">//清空所有的key</span></span><br></pre></td></tr></table></figure><h3 id="4、操作事务"><a href="#4、操作事务" class="headerlink" title="4、操作事务"></a>4、操作事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建客户端连接服务端，redis服务端需要被开启 </span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>); </span><br><span class="line">jedis.flushDB();</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启事务 </span></span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//向redis存入一条数据 </span></span><br><span class="line">    multi.set(<span class="string">&quot;json&quot;</span>, result); </span><br><span class="line">    <span class="comment">//再存入一条数据 </span></span><br><span class="line">    multi.set(<span class="string">&quot;json2&quot;</span>, result); </span><br><span class="line">    <span class="comment">//这里引发了异常，用0作为被除数 </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>/<span class="number">0</span>; </span><br><span class="line">    <span class="comment">//如果没有引发异常，执行进入队列的命令</span></span><br><span class="line">    multi.exec(); </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">    <span class="comment">//如果出现异常，放弃 </span></span><br><span class="line">    multi.discard(); </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123; </span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json2&quot;</span>)); </span><br><span class="line">    <span class="comment">//最终关闭客户端 </span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、集群情况下"><a href="#5、集群情况下" class="headerlink" title="5、集群情况下"></a>5、集群情况下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JedisCluster jedisCluster=new JedisCluster(set);</span><br><span class="line">jedisCluster.set(&quot;k1&quot;, &quot;v1&quot;);</span><br></pre></td></tr></table></figure><h1 id="13、SpringBoot整合"><a href="#13、SpringBoot整合" class="headerlink" title="13、SpringBoot整合"></a>13、SpringBoot整合</h1><h2 id="13-1、分析"><a href="#13-1、分析" class="headerlink" title="13.1、分析"></a>13.1、分析</h2><ul><li><p>SpringBoot2之后，jedis变成了lettuce</p><ul><li>jedis采用的直连，多线程不安全，需要使用连接池</li><li>lettuce采用的netty，实例可以再多个线程中共享</li></ul></li><li><p>在SpringBoot中一般使用<strong>RedisTemplate提供的方法</strong>来操作Redis。</p></li><li><p>RedisAutoConfiguration类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>   <span class="comment">//不存在bean才生效，所以可以自定义</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认的RedisTemplate 没有过多的设置，redis对象需要序列化</span></span><br><span class="line">    <span class="comment">// 两个泛型都是object，我们后使用需要强转</span></span><br><span class="line">   RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">   template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">   <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span> <span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认的序列化配置（通过JDK序列化，使字符串转义）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer keySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer valueSerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashKeySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashValueSerializer = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="13-2、简单测试"><a href="#13-2、简单测试" class="headerlink" title="13.2、简单测试"></a>13.2、简单测试</h2><ul><li>确保有如下依赖</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>yaml（可以查看 RedisProperties 分析）</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">121.41</span><span class="number">.4</span><span class="number">.48</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    opsForValue() 操作字符串 </span></span><br><span class="line"><span class="comment">    opsForList()  操作list</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;myKey&quot;</span>,<span class="string">&quot;myValue&quot;</span>);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;myKey&quot;</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取redis连接对象</span></span><br><span class="line">     RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        connection.flushAll();</span><br></pre></td></tr></table></figure><h2 id="13-3、深入测试"><a href="#13-3、深入测试" class="headerlink" title="13.3、深入测试"></a>13.3、深入测试</h2><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">    connection.flushAll();</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;wzh&quot;</span>);</span><br><span class="line">    <span class="comment">//直接传对象会报错，转换成json字符串</span></span><br><span class="line">    <span class="comment">// 或者user对象继承serializable类序列化</span></span><br><span class="line">    String jsonUser = <span class="keyword">new</span> ObjectMapper().writeValueAsString(user);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>, jsonUser);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xac\xed\x00\x05t\x00\x04user&quot;</span>  JDK序列化会显示成这样</span><br></pre></td></tr></table></figure><ul><li>编写自定义Redistemplate，自定义序列化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemp</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">//序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer); </span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer); </span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer); </span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">     template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14、常见面试题"><a href="#14、常见面试题" class="headerlink" title="14、常见面试题"></a>14、常见面试题</h1><h2 id="14-1、-Redis-和-Memcached"><a href="#14-1、-Redis-和-Memcached" class="headerlink" title="14.1、 Redis 和 Memcached"></a>14.1、 Redis 和 Memcached</h2><p><strong>共同点</strong> ：</p><ul><li>都是基于内存的数据库，⼀般都用来来当做缓存使⽤。</li><li>都有过期策略。</li><li>两者的性能都非常⾼。</li></ul><p><strong>区别</strong> ：</p><ol><li>Redis的类型丰富，Memcached只支持最简单的 K / V</li><li>Redis 支持持久化，可以有灾难恢复机制，Memcached不支持</li><li>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。Memcached则报异常。</li><li>Redis 支持原生的集群模式，Memcached没有，需要依靠客户端实现集群中分片写入数据。</li><li>Redis 单线程，多路IO复用模型；Memcached多线程，非阻塞 的IO 复用的网络类型。</li><li>Redis 支持发布订阅模型、Lua脚本、事务；Memcached不支持</li><li>Redis 同时使用了惰性删除与定期删除；Memcached过期数据的删除策略只用了惰性删除。</li></ol><p>所以现在一般选用 Redis 作为缓存数据库。</p><h2 id="14-2、-缓存数据处理流程"><a href="#14-2、-缓存数据处理流程" class="headerlink" title="14.2、 缓存数据处理流程"></a>14.2、 缓存数据处理流程</h2><p><img src="/img/Redis/5.jpg"></p><h2 id="14-3、为什么要用Redis-缓存数据库"><a href="#14-3、为什么要用Redis-缓存数据库" class="headerlink" title="14.3、为什么要用Redis/缓存数据库"></a>14.3、为什么要用Redis/缓存数据库</h2><blockquote><p>高性能</p></blockquote><p><strong>作用：</strong>使用缓存主要是为了提升用户体验以及应对更多的用户</p><p><strong>第一次读取：</strong>从数据库取出数据较慢，然后同时更新缓存</p><p><strong>第二次读取：</strong>直接从缓存读取，很快。</p><p><strong>注意：</strong>当数据库的数据改变后，要同步改变缓存中的数据才可以。</p><blockquote><p>高并发</p></blockquote><p><strong>QPS（Query Per Second）：</strong>服务器每秒可以执行的查询次数；</p><p>⼀般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使⽤ Redis 缓存之后很容易达到 10w+，甚⾄最⾼能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p><ul><li></li></ul><h2 id="14-4、Redis单线程模型"><a href="#14-4、Redis单线程模型" class="headerlink" title="14.4、Redis单线程模型"></a>14.4、Redis单线程模型</h2><p><strong>事件处理模型：</strong>Redis基于 Reactor 模式设计开发的 <code>文件事件处理器</code>，文件事件处理器基于单线程运行，使用 IO 多路复用技术来同时监听多个套接字。</p><p><strong>IO多路复用模型</strong>：Redis 通过 IO 多路复用程序监听来自客户端的大量连接，它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生，这样 Redis 就不需要 额外创建多余的线程来监听客户端了，降低了资源的消耗。（类似 NIO 的 Selector组件）</p><p><strong>多路IO复用技术</strong>：异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</p><ul><li>文件事件处理器会同时监听多个套接字（Socket），根据套接字执行的任务来<code>匹配不同事件处理器</code></li><li>被监听的套接字<code>准备进行 IO 操作</code>时，文件事件处理器就会返回，然后调用匹配的事件处理器。如果一直，没有响应，文件事件处理器就会阻塞</li></ul><blockquote><p>Redis单线程为什么这么快？</p></blockquote><ul><li>Redis基于内存操作的，所以速度快</li><li>数据结构简单，操作节省时间</li><li>多路复用io阻塞机制</li></ul><h2 id="14-5、Redis单线程？4-0加入多线程？"><a href="#14-5、Redis单线程？4-0加入多线程？" class="headerlink" title="14.5、Redis单线程？4.0加入多线程？"></a>14.5、Redis单线程？4.0加入多线程？</h2><p><strong>单线程：</strong>指处理我们的网络请求的时候只有一个线程来处理。</p><blockquote><p>Redis6.0 之前 为什么不使⽤多线程？</p></blockquote><ol><li>单线程编程容易并且更容易维护；</li><li>Redis 基于内存处理，所以性能瓶颈不再 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol><p><strong>总结：</strong>不需要靠多线程提高CPU速度，反而多线程会带来问题。</p><blockquote><p>Redis6.0 之后 为什么 加入多线程</p></blockquote><p><strong>原因：</strong>提高网络IO 读写性能，因为这个算是 Redis 中的⼀个性能瓶颈</p><p><strong>因此：</strong>Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此不需要担心线程安全问题。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要修改 redis 配置⽂件开启多线程</span></span><br><span class="line"><span class="string">io-threads-do-reads</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">io-threads</span> <span class="number">4</span> <span class="comment">#官⽹建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure><h2 id="14-6、Redis缓存数据过期问题"><a href="#14-6、Redis缓存数据过期问题" class="headerlink" title="14.6、Redis缓存数据过期问题"></a>14.6、Redis缓存数据过期问题</h2><blockquote><p>为什么要设计过期时间？</p></blockquote><p>如果不设置过期时间，很容易内存溢出。</p><p><strong>注意：</strong>只有字符串有 setex 命令， 其他都得通过 expire设置，persist移除过期时间。</p><blockquote><p>Redis如何判断过期的</p></blockquote><p>Redis 通过⼀个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是⼀个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line"> ...</span><br><span class="line"> dict *dict; //数据库键空间,保存着数据库中所有键值对</span><br><span class="line"> dict *expires // 过期字典,保存着键的过期时间</span><br><span class="line"> ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><blockquote><p>删除策略</p></blockquote><p><strong>惰性删除</strong>：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。</p><p><strong>定期删除</strong>： 每隔⼀段时间抽取⼀批 key执行删除过期key操作。并且，Redis 底层会通过限制删除操作执行和时长和频率来减少删除操作对CPU时间的影响。</p><p><strong>Redis：</strong>两者结合使用</p><blockquote><p>内存淘汰机制</p></blockquote><p><strong>问题：</strong>如果有大量的键值对没有设置过期时间，仍然容易 out of memory，需要自动删除。</p><p>MySQL 有 2000w 数据，Redis 中只存 20w ，如何保证 Redis 中的数据都是热点数据?</p><p><strong>八种内存淘汰机制</strong></p><ol><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。  </li><li>volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。  </li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰  </li><li>allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。  </li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰  </li><li> no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。  </li></ol><p><strong>总结：</strong>这八种大体上可以分为4种，lru、lfu、random、ttl。</p><p><strong>即最近最少使用、将要过期、频率最低、任意选择 四种</strong></p><h2 id="14-7、缓存穿透"><a href="#14-7、缓存穿透" class="headerlink" title="14.7、缓存穿透"></a>14.7、缓存穿透</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><ul><li>用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，</li><li>于是向持久层数据库查询。发现也没有，于是本次查询失败。</li><li>当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了<strong>缓存穿透</strong></li></ul><h3 id="2、解决"><a href="#2、解决" class="headerlink" title="2、解决"></a>2、解决</h3><blockquote><p>布隆过滤器：</p></blockquote><p><strong>原理：</strong>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，通过它我们可以非常方便地判断⼀个给定数据是否存在于海量数据中。</p><p><strong>流程：</strong>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程</p><blockquote><p>缓存空对象：</p></blockquote><p><strong>流程：</strong>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p><p><strong>缺点：</strong>需要更大的缓存空间，可能导致缓存大量无用的key；缓存层和存储层的数据还是会有一段时间窗口的不一致，影响一致性</p><h2 id="14-8、缓存雪崩-穿透"><a href="#14-8、缓存雪崩-穿透" class="headerlink" title="14.8、缓存雪崩/ 穿透"></a>14.8、缓存雪崩/ 穿透</h2><h3 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h3><p><strong>雪崩：</strong>在某一个时间段，缓存集中过期失效，访问都落到了数据库上。</p><p><strong>穿透：</strong>单个缓存</p><h3 id="2、解决-1"><a href="#2、解决-1" class="headerlink" title="2、解决"></a>2、解决</h3><blockquote><p>针对Redis服务不可用的情况</p></blockquote><ol><li>使用Redis集群，避免某个Redis主机挂掉</li><li>限流降级：通过加锁或者队列来控制读数据库写缓存的线程数量。</li></ol><blockquote><p>针对热点缓存失效的情况</p></blockquote><ol><li>热点永不失效</li><li>不同的缓存数据设置不同的过期时间</li><li>数据预热：针对高峰访问期间，先访问一遍数据，避免失效。</li></ol><h2 id="14-9、保证缓存和数据库数据的⼀致性"><a href="#14-9、保证缓存和数据库数据的⼀致性" class="headerlink" title="14.9、保证缓存和数据库数据的⼀致性"></a>14.9、保证缓存和数据库数据的⼀致性</h2><blockquote><p>Cache Aside Pattern（旁路缓存模式）</p></blockquote><p>更新 DB，然后直接删除 cache 。如果缓存删除失败</p><ol><li><strong>缓存失效时间变短（不推荐，治标不治本） ：</strong>我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加cache更新重试机制（常⽤）：</strong> 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔⼀段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li></ol><h2 id="14-10、Redis实现分布式锁"><a href="#14-10、Redis实现分布式锁" class="headerlink" title="14.10、Redis实现分布式锁"></a>14.10、Redis实现分布式锁</h2><h3 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h3><ul><li>分布式系统中，不同的系统不能识别同一把锁</li></ul><h3 id="2、实现方式（基于Redis）"><a href="#2、实现方式（基于Redis）" class="headerlink" title="2、实现方式（基于Redis）"></a>2、实现方式（基于Redis）</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">setnx</span> <span class="string">users</span> <span class="number">10</span>  <span class="comment"># 成功</span></span><br><span class="line"><span class="string">setnx</span> <span class="string">users</span> <span class="number">20</span>  <span class="comment"># 失败,注意如果用set仍然可以设置</span></span><br><span class="line"><span class="string">del</span> <span class="string">users</span>    <span class="comment"># 只在键不存在时，才对键进行设置操作</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">sku:1:info</span> <span class="string">“OK”</span> <span class="string">NX</span> <span class="string">PX</span> <span class="number">10000</span></span><br><span class="line"><span class="comment"># EX second:设置键的过期时间为 second 秒(EX可以省略)</span></span><br><span class="line"><span class="comment"># PX millisecond ：设置键的过期时间为 毫秒(PX可以省略)</span></span><br><span class="line"><span class="comment"># 注意 px 写在key和value之间，ex写在value之后 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过expire设置过期时间，</span></span><br><span class="line"><span class="comment"># 但是如果在setnx和expire之间出现异常，锁也无法释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NX:只在键不存在时，才对键进行设置操作。（setnx也可以） </span></span><br><span class="line"><span class="comment"># XX:只在键已经存在时，才对键进行设置操作。</span></span><br></pre></td></tr></table></figure><ul><li>通过修改成功，可以判断是否被<strong>逻辑上上锁了</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1获取锁，setne</span></span><br><span class="line">    <span class="comment">// (&quot;lock&quot;, &quot;111&quot;,3，TimeUnit.SENCONDS); 设置过期时间</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(lock)&#123;</span><br><span class="line">      <span class="comment">// 2业务代码</span></span><br><span class="line">        <span class="comment">// 3释放锁，del</span></span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 4获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、优化之UUID防误删"><a href="#3、优化之UUID防误删" class="headerlink" title="3、优化之UUID防误删"></a>3、优化之UUID防误删</h3><ul><li>业务代码执行时间<strong>小于</strong>锁释放的时间，</li><li>导致业务代码执行后，删除的是其他业务的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">String uuid = UUID.randonUUID().toString();</span><br><span class="line">Boolean lock = <span class="keyword">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">if</span>(uuid.equals((String)redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>)))&#123;</span><br><span class="line">    <span class="keyword">this</span>.redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="4、LUA脚本保证原子性"><a href="#4、LUA脚本保证原子性" class="headerlink" title="4、LUA脚本保证原子性"></a>4、LUA脚本保证原子性</h3><ul><li>查询uuid相等到删除操作之间可能被其他进程插入，导致释放错锁</li><li>因为没有原子性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
      <url>/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="1、数据库基本概念"><a href="#1、数据库基本概念" class="headerlink" title="1、数据库基本概念"></a>1、数据库基本概念</h1><h2 id="1-1、数据库基本概念"><a href="#1-1、数据库基本概念" class="headerlink" title="1.1、数据库基本概念"></a>1.1、数据库基本概念</h2><ul><li><p><strong>数据库</strong>（DB，DataBase）：相关互联的数据集合</p></li><li><p><strong>数据库管理系统</strong>（DBMS）：数据库系统核心部分，位于用户和os之间</p></li><li><p><strong>数据库系统</strong>（DBS）：由DB、DBMS、应用系统、DBA（数据库管理员）组成</p></li><li><p><strong>数据库应用系统</strong>（DBAS）：实现业务逻辑的应用程序</p></li></ul><h2 id="1-2、数据库分类"><a href="#1-2、数据库分类" class="headerlink" title="1.2、数据库分类"></a>1.2、数据库分类</h2><p><strong>关系型数据库</strong>：(SQL)</p><ul><li>代表：MySQL、Oracle、SQL Server</li><li>通过表和表、行和列之间的关系进行数据库的存储</li></ul><p> <strong>非关系型数据库</strong>：(NoSQL) Not Only</p><ul><li><p>代表：Redis、MongDB</p></li><li><p>特点：对象存储</p></li></ul><h2 id="1-3、数据模型"><a href="#1-3、数据模型" class="headerlink" title="1.3、数据模型"></a>1.3、数据模型</h2><blockquote><p><strong>根据抽象级别定义4种模型</strong></p></blockquote><ul><li><p><strong>概念模型：</strong>从用户角度描述数据库整体结构，现在常用E-R图表示</p><p>实体间联系：1对1、1对多、多对多</p></li><li><p><strong>逻辑模型：</strong>表达数据库逻辑结构，包括层次模型、网状模型、关系模型</p></li><li><p><strong>外部模型：</strong>逻辑模型的一个逻辑子集，根据业务特点设计</p></li><li><p><strong>内部模型：</strong>又称物理模型，描述在磁盘的存储方式</p></li></ul><blockquote><p><strong>关系模型</strong></p></blockquote><p><strong>概念：</strong>包括 数据结构、数据操作、数据的完整性约束</p><ul><li>关系型数据模型的数据结构<ul><li>关系：一个关系就是<strong>一张规范的二维表</strong>，表中的每一列<strong>不可再分</strong>（不能有表中表）</li><li>元组：表中的一行</li><li>主键：能唯一识别元组的最小属性集合，<strong>只能有一个</strong></li><li>候选键：可以有多个，和主键一样非空唯一</li><li>属性：表中的一列即为一个属性，每个属性有一个属性名</li><li>域：列（属性）的取值范围</li><li>关系模式：关系名即表名（属性1，属性2……，属性n）</li></ul></li><li>关系数据库模型的操作：增删改查</li><li>完整性约束<ul><li>实体完整性：主键不能为null</li><li>参照完整性：外键为空或为被参照关系中主键的某个值</li><li>用户定义完整性</li></ul></li></ul><h2 id="1-4、数据库体系结构"><a href="#1-4、数据库体系结构" class="headerlink" title="1.4、数据库体系结构"></a>1.4、数据库体系结构</h2><ul><li>外模式（子模式、用户模式）：又称用户<strong>视图</strong>，用户能直接看到，可以有多个</li><li>概念模式（模式、逻辑模式）：数据库全体数据的逻辑结构和特征的描述，只能有一个</li><li>内模式（存储、物理模式）：物理结构和存储方式的描述，只能有一个</li></ul><p><strong>数据独立性</strong>：</p><ul><li>物理独立性：内模式—–概念模式实现，程序和数据的独立</li><li>逻辑独立性：外模式—–概念模式实现，程序和逻辑的独立</li></ul><h2 id="1-5、SQL语言组成"><a href="#1-5、SQL语言组成" class="headerlink" title="1.5、SQL语言组成"></a>1.5、SQL语言组成</h2><ul><li><strong>数据定义语言DDL：</strong>数据定义语句，定义、修改、删除数据库中的对象<ul><li>包括CREATE、ALTER、DROP、RENAME以及删除TRUNCATE</li></ul></li><li><strong>数据操纵语言DML：</strong>数据操纵语句，增删改查</li><li><strong>数据控制语言DCL：</strong>数据控制语句，定义用户的访问权限和安全级别<ul><li>事务：ROLLBACK、COMMIT、SAVEPOINT</li><li>权限管理：GRANT、REMOVE</li><li>锁定数据库表实现并发控制：LOCKTABLE</li></ul></li></ul><blockquote><p>DCL</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>      <span class="comment">-- 授予访问权限</span></span><br><span class="line"><span class="keyword">REVOKE</span>     <span class="comment">-- 撤销访问权限</span></span><br><span class="line"><span class="keyword">COMMIT</span>     <span class="comment">-- 提交事务处理</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>   <span class="comment">-- 事务处理回退</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span>  <span class="comment">-- 设置保存点</span></span><br><span class="line">LOCK       <span class="comment">-- 对数据库的特定部分进行锁定</span></span><br></pre></td></tr></table></figure><h1 id="2、MySQL的安装"><a href="#2、MySQL的安装" class="headerlink" title="2、MySQL的安装"></a>2、MySQL的安装</h1><h2 id="2-1、环境安装"><a href="#2-1、环境安装" class="headerlink" title="2.1、环境安装"></a>2.1、环境安装</h2><blockquote><p>Windows环境</p></blockquote><ol><li><p>配置环境变量：下载安装包解压</p></li><li><p>创建my.ini文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">basedir=D:\mysql-5.7.33\</span><br><span class="line">datadir=D:\mysql-5.7.33\data\</span><br><span class="line">port=3306</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure></li><li><p>管理员运行DOC窗口转到bin目录下</p></li><li><p>输入mysqld -install安装</p></li><li><p>输入mysqld –initialize-insecure –console</p></li><li><p>输入net start mysql启动mysql</p></li><li><p>输入mysql -uroot -p     进入mysql</p></li><li><p>输入update mysql.user set authentication_string=password(‘123456’) where user=’root’and Host=’localhost’;       修改密码</p></li><li><p>输入flush privileges; 刷新权限</p></li><li><p>net stop mysql</p></li><li><p>net start mysql</p></li></ol><p><strong>Sqlyog创建数据库：</strong>选utf-8和utf8_general_ci   创建表：引擎选InnoDB</p><blockquote><p>Linux环境：使用docker</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看Linux服务器上是否安装过MySQL</span></span><br><span class="line">rpm -qa | grep -i mysql # 查询出所有mysql依赖包</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、拉取镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、创建实例并启动</span></span><br><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /root/mysql/log:/var/log/mysql \</span><br><span class="line">-v /root/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /root/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=333 \</span><br><span class="line">-d mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、mysql配置 /root/mysql/conf/my.conf</span></span><br><span class="line">[client]</span><br><span class="line"><span class="meta">#</span><span class="bash">mysqlde utf8字符集默认为3位的，不支持emoji表情及部分不常见的汉字，故推荐使用utf8mb4</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta">#</span><span class="bash">设置client连接mysql时的字符集,防止乱码</span></span><br><span class="line">init_connect=&#x27;SET collation_connection = utf8_general_ci&#x27;</span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">数据库默认字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">数据库字符集对应一些排序等规则，注意要和character-set-server对应</span></span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 跳过mysql程序起动时的字符参数设置 ，使用服务器端字符集设置</span></span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！</span></span><br><span class="line">skip-name-resolve</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、重启mysql容器</span></span><br><span class="line">docker restart mysql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、进入到mysql容器</span></span><br><span class="line">docker exec -it mysql /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6、查看修改的配置文件</span></span><br><span class="line">cat /etc/mysql/my.conf</span><br></pre></td></tr></table></figure><p><strong>安装位置：</strong></p><p><code>Docker</code>容器就是一个小型的<code>Linux</code>环境，进入到<code>MySQL</code>容器中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p><code>Linux</code>环境下<code>MySQL</code>的安装目录。</p><table><thead><tr><th>路径</th><th>解释</th></tr></thead><tbody><tr><td><code>/var/lib/mysql</code></td><td>MySQL数据库文件存放位置</td></tr><tr><td><code>/usr/share/mysql</code></td><td>错误消息和字符集文件配置</td></tr><tr><td><code>/usr/bin</code></td><td>客户端程序和脚本</td></tr><tr><td><code>/etc/init.d/mysql</code></td><td>启停脚本相关</td></tr></tbody></table><h2 id="2-2、修改字符集"><a href="#2-2、修改字符集" class="headerlink" title="2.2、修改字符集"></a>2.2、修改字符集</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、进入到mysql数据库并查看字符集</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> show variables like <span class="string">&#x27;character%&#x27;</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> show variables like <span class="string">&#x27;%char%&#x27;</span>;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show variables like <span class="string">&#x27;character%&#x27;</span>;</span></span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show variables like <span class="string">&#x27;%char%&#x27;</span>;</span></span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p><code>MySQL5.7</code>配置文件位置是<code>/etc/my.cnf</code>或者<code>/etc/mysql/my.cnf</code>，如果字符集不是<code>utf-8</code>直接进入配置文件修改即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置client连接mysql时的字符集,防止乱码</span></span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line">init_connect=&#x27;SET collation_connection = utf8_general_ci&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据库默认字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">数据库字符集对应一些排序等规则，注意要和character-set-server对应</span></span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 跳过mysql程序起动时的字符参数设置 ，使用服务器端字符集设置</span></span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！</span></span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><p><strong>注意：安装<code>MySQL</code>完毕之后，第一件事就是修改字符集编码。</strong></p><h2 id="2-3、配置文件"><a href="#2-3、配置文件" class="headerlink" title="2.3、配置文件"></a>2.3、配置文件</h2><p><strong><code>MySQL</code>配置文件讲解：<a href="https://www.cnblogs.com/gaoyuechen/p/10273102.html">https://www.cnblogs.com/gaoyuechen/p/10273102.html</a></strong></p><p>1、二进制日志<code>log-bin</code>：主从复制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> my,cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启mysql binlog功能</span></span><br><span class="line">log-bin=mysql-bin</span><br></pre></td></tr></table></figure><p>2、错误日志<code>log-error</code>：默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> my,cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据库错误日志文件</span></span><br><span class="line">log-error = error.log</span><br></pre></td></tr></table></figure><p>3、查询日志<code>log</code>：默认关闭，记录查询的<code>sql</code>语句，如果开启会降低<code>MySQL</code>整体的性能，因为记录日志需要消耗系统资源。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> my,cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 慢查询sql日志设置</span></span><br><span class="line">slow_query_log = 1</span><br><span class="line">slow_query_log_file = slow.log</span><br></pre></td></tr></table></figure><p>4、数据文件。</p><ul><li><code>frm文件</code>：存放表结构。</li><li><code>myd</code>文件：存放表数据。</li><li><code>myi</code>文件：存放表索引。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mysql5.7 使用.frm文件来存储表结构</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 .ibd文件来存储表索引和表数据</span></span><br><span class="line">-rw-r-----  1 mysql mysql   8988 Jun 25 09:31 pms_category.frm</span><br><span class="line">-rw-r-----  1 mysql mysql 245760 Jul 21 10:01 pms_category.ibd</span><br></pre></td></tr></table></figure><p><code>MySQL5.7</code>的<code>Innodb</code>存储引擎可将所有数据存放于<code>ibdata*</code>的共享表空间，也可将每张表存放于独立的<code>.ibd</code>文件的独立表空间。<br>共享表空间以及独立表空间都是针对数据的存储方式而言的。</p><ul><li>共享表空间: 某一个数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在<code>data</code>目录下。 默认的文件名为<code>:ibdata1</code> 初始化为<code>10M</code>。</li><li>独立表空间: 每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个<code>.frm</code>表描述文件，还有一个<code>.ibd</code>文件。 其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下它的存储位置也是在表的位置之中。在配置文件<code>my.cnf</code>中设置： <code>innodb_file_per_table</code>。</li></ul><h1 id="3、MySQL的基本概念"><a href="#3、MySQL的基本概念" class="headerlink" title="3、MySQL的基本概念"></a>3、MySQL的基本概念</h1><h2 id="3-1、MySQL逻辑架构"><a href="#3-1、MySQL逻辑架构" class="headerlink" title="3.1、MySQL逻辑架构"></a>3.1、MySQL逻辑架构</h2><p><img src="/img/MySQL/1.jpg"></p><ul><li><p><code>Connectors</code>：指的是不同语言中与SQL的交互。</p></li><li><p><code>Connection Pool</code>：管理缓冲用户连接，线程处理等需要缓存的需求。<strong>MySQL数据库的连接层。</strong></p></li><li><p><code> Management Serveices &amp; Utilities</code>：系统管理和控制工具。备份、安全、复制、集群等等。。</p></li><li><p><code>SQL Interface</code>：接受用户的SQL命令，并且返回用户需要查询的结果。</p></li><li><p><code>Parser</code>：SQL语句解析器。</p></li><li><p><code>Optimizer</code>：查询优化器，SQL语句在查询之前会使用查询优化器对查询进行优化。<strong>就是优化客户端请求query</strong>，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果。<strong>For Example</strong>： <code>select uid,name from user where gender = 1;</code>这个<code>select </code>查询先根据<code>where </code>语句进行选取，而不是先将表全部查询出来以后再进行<code>gender</code>过滤；然后根据<code>uid</code>和<code>name</code>进行属性投影，而不是将属性全部取出以后再进行过滤。最后将这两个查询条件联接起来生成最终查询结果。</p></li><li><p><code>Caches &amp; Buffers</code>：查询缓存。</p></li><li><p><code>Pluggable Storage Engines</code>：<strong>存储引擎接口。MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎(注意：存储引擎是基于表的，而不是数据库)。</strong></p></li><li><p><code>File System</code>：数据落地到磁盘上，就是文件的存储。</p></li></ul><p>MySQL数据库和其他数据库相比，MySQL有点与众不同，主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需求选择合适的存储引擎。</p><blockquote><p>逻辑架构分层</p></blockquote><p><img src="/img/MySQL/2.jpg"></p><ul><li><p>连接层：最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于<code>tcp/ip</code>的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于<code>SSL</code>的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p></li><li><p>服务层：MySQL的核心服务功能层，该层是MySQL的核心，包括查询缓存，解析器，解析树，预处理器，查询优化器。主要进行查询解析、分析、查询缓存、内置函数、存储过程、触发器、视图等，select操作会先检查是否命中查询缓存，命中则直接返回缓存数据，否则解析查询并创建对应的解析树。</p></li><li><p>引擎层：存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p></li><li><p>存储层：数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p></li></ul><h2 id="3-2、MySQL的引擎"><a href="#3-2、MySQL的引擎" class="headerlink" title="3.2、MySQL的引擎"></a>3.2、MySQL的引擎</h2><p><code>show engines;</code>命令查看MySQL5.7支持的存储引擎。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show engines;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200801170442428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70" alt="存储引擎"></p><p><code>show variables like &#39;default_storage_engine%&#39;;</code>查看当前数据库正在使用的存储引擎。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show variables like <span class="string">&#x27;default_storage_engine%&#x27;</span>;</span></span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| default_storage_engine | InnoDB |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p>InnoDB和MyISAM对比</p></blockquote><table><thead><tr><th></th><th>MYISAM</th><th>INNODB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持</td><td>支持</td></tr><tr><td>数据表锁定</td><td>支持</td><td>支持</td></tr><tr><td>外键约束</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表空间大小</td><td>较小</td><td>较大，约为2倍</td></tr></tbody></table><ul><li>MYISAM：节约空间，速度较快，每次查询具有原子性</li><li>INNODB：安全性高，支持事务处理，回滚，崩溃修复能力，事务安全ACID</li></ul><blockquote><p>在物理空间的位置：</p></blockquote><p><strong>所有数据库文件都在data目录下，一个文件夹对应一个数据库，本质还是文件的存储</strong></p><p><strong>INNODB：</strong></p><ul><li>数据库表中只有一个*.frm文件，以及上级目录的ibdata1文件</li></ul><p><strong>MYISAM：</strong></p><ul><li>*.frm： 表数据库的定义文件</li><li>*.MYD：数据文件</li><li>*.MYI： 索引文件</li></ul><h2 id="3-3、数据库的字段类型"><a href="#3-3、数据库的字段类型" class="headerlink" title="3.3、数据库的字段类型"></a>3.3、数据库的字段类型</h2><blockquote><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a><strong>整型</strong></h4></blockquote><ul><li>tinyint：        很小的数据  1字节</li><li>smallint：     较小数据   2字节</li><li>mediumint：中等大小   3字节</li><li>int：              标准整数   4字节</li><li>bigint：         较大的数据  8字节</li></ul><blockquote><p><strong>小数</strong></p></blockquote><ul><li>float：           浮点数    4字节</li><li>double</li><li>decimal          字符串形式浮点数 金融计算的时候一般是使用decaimal</li></ul><blockquote><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h4></blockquote><ul><li>char         字符串固定大小   0~255</li><li>varcahr    可变字符串           0~6535</li><li>tingtext   微型文本                2^8-1</li><li>text          文本串                   2^16-1</li></ul><blockquote><p><strong>二进制字符串</strong></p></blockquote><ul><li>binary</li><li>varbinary</li></ul><blockquote><h4 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h4></blockquote><ul><li>date           YYYY-MM-DD         日期</li><li>time           HH：mm：ss       时间格式</li><li>datatime         日期时间(最常用)</li><li>timestamp      时间戳，1970.1.1到现在的毫秒数</li><li>year                 年份表示</li></ul><blockquote><h4 id="4、Null"><a href="#4、Null" class="headerlink" title="4、Null"></a>4、Null</h4></blockquote><ul><li>没有值</li></ul><h2 id="3-4、数据库的字段属性"><a href="#3-4、数据库的字段属性" class="headerlink" title="3.4、数据库的字段属性"></a>3.4、数据库的字段属性</h2><ul><li><p>Unsigned： 无符号<strong>整数</strong>，不能为负数</p></li><li><p>Zerofill：  不足的位数使用0来填充</p></li><li><p>自增：   自动在上一条记录的基础上+1，必须整数类型，可以设计起始值和步长</p></li><li><p>非空：   </p></li><li><p>默认：   默认值</p></li></ul><h2 id="3-5、MySQL常用函数"><a href="#3-5、MySQL常用函数" class="headerlink" title="3.5、MySQL常用函数"></a>3.5、MySQL常用函数</h2><h3 id="1、MySQL常量"><a href="#1、MySQL常量" class="headerlink" title="1、MySQL常量"></a>1、MySQL常量</h3><ul><li>字符串：         单引号’ ‘ 或双引号”   “</li><li>数值：             直接用</li><li>日期和时间： 单引号’ ‘ </li><li>布尔                 1表示true   0表示false</li><li>NULL                NULL参与运算，结果仍为NULL</li></ul><h3 id="2、常用函数"><a href="#2、常用函数" class="headerlink" title="2、常用函数"></a>2、常用函数</h3><blockquote><p>数学运算</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ABS</span>(<span class="number">-8</span>)            <span class="comment">-- 绝对值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEILING</span>(<span class="number">9.4</span>)       <span class="comment">-- 下上取整</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">9.4</span>)         <span class="comment">-- 向下</span></span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">45.926</span>, <span class="number">2</span>)   <span class="comment">-- 四舍五入 45.3</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">1600</span>, <span class="number">300</span>)     <span class="comment">-- 求余数 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> RAND()             <span class="comment">-- 0~1的绝对值</span></span><br><span class="line"><span class="keyword">SELECT</span> SIGN(<span class="number">10</span>)           <span class="comment">-- 判断符号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">3.14159</span>,<span class="number">2</span>)  <span class="comment">-- 截取前面2位</span></span><br></pre></td></tr></table></figure><blockquote><p>字符串</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOWER</span>()                       <span class="comment">-- 小写</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">UPPER</span>()                       <span class="comment">-- 大写</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>()                 <span class="comment">-- 长度</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;是&#x27;</span>)              <span class="comment">-- 拼接字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;HelloWorld&#x27;</span>,<span class="number">1</span>,<span class="number">5</span>)      <span class="comment">-- 截取字符串,第1个开始截取5个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INSERT</span>(<span class="string">&#x27;我爱学习&#x27;</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">&#x27;不&#x27;</span>)    <span class="comment">-- 替换字符串，返回  我不习</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;wzh&#x27;</span>,<span class="string">&#x27;h&#x27;</span>)              <span class="comment">-- 返回h第一次出现的索引</span></span><br><span class="line"><span class="keyword">SELECT</span> REPLACE(<span class="string">&#x27;坚持学习&#x27;</span>,<span class="string">&#x27;学习&#x27;</span>,<span class="string">&#x27;吃&#x27;</span>) <span class="comment">-- 替换</span></span><br></pre></td></tr></table></figure><blockquote><p>时间和日期</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span>()    <span class="comment">-- 当前日期</span></span><br><span class="line"><span class="keyword">SELECT</span> CURDATE()         <span class="comment">-- 当前日期</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW()             <span class="comment">-- 当前时间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOCALTIME</span>()       <span class="comment">-- 本地时间</span></span><br><span class="line"><span class="keyword">SELECT</span> SYSDATE()         <span class="comment">-- 系统时间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(NOW())       <span class="comment">-- 年份</span></span><br></pre></td></tr></table></figure><h3 id="3、聚合函数"><a href="#3、聚合函数" class="headerlink" title="3、聚合函数"></a>3、聚合函数</h3><ul><li>COUNT()  计数  //不会忽略null值</li><li>SUM()   求和</li><li>AVG()   p平均值</li><li>MAX()   最大值</li><li>MIN()   最小值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不能在where中使用，可以在having中使用</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(id) <span class="keyword">FROM</span> student         <span class="comment">-- 会忽略NULL值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student          <span class="comment">-- 不会忽略NULL值，本质是计算行数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> student          <span class="comment">-- 不会忽略NULL值，本质是计算行数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(age) <span class="keyword">AS</span> 年龄 <span class="keyword">FROM</span> student   <span class="comment">-- 计算总和</span></span><br></pre></td></tr></table></figure><h3 id="4、MD5加密"><a href="#4、MD5加密" class="headerlink" title="4、MD5加密"></a>4、MD5加密</h3><p>MD5加密是<strong>不可逆</strong>的过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">插入后加密：</span><br><span class="line">UPDATE student <span class="keyword">SET</span> `pwd` <span class="operator">=</span> MD5(`pwd`) <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">插入时加密：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (id,`name`,`pwd`,`sex`)<span class="keyword">VALUES</span>(<span class="number">9</span>,<span class="string">&#x27;李三啊&#x27;</span>,MD5(<span class="number">1258</span>),<span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>检验：</strong>将用户传递进来的密码，进行MD5加密然后对比加密的值</p><h2 id="3-6、SQL性能下降的原因"><a href="#3-6、SQL性能下降的原因" class="headerlink" title="3.6、SQL性能下降的原因"></a>3.6、SQL性能下降的原因</h2><ul><li>查询语句写的差。</li><li>索引失效：索引建了，但是没有用上。</li><li>关联 查询太多<code>join</code>（设计缺陷或者不得已的需求）。</li><li>服务器调优以及各个参数的设置（缓冲、线程数等）。</li></ul><h1 id="4、DDL结构化语句"><a href="#4、DDL结构化语句" class="headerlink" title="4、DDL结构化语句"></a>4、DDL结构化语句</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>   <span class="comment">-- 创建数据库表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>    <span class="comment">-- 更改表结构、添加、删除、修改列长度</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>     <span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX   <span class="comment">-- 在表上建立索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX     <span class="comment">-- 删除索引</span></span><br></pre></td></tr></table></figure><h2 id="4-1、DDL之创建数据库"><a href="#4-1、DDL之创建数据库" class="headerlink" title="4.1、DDL之创建数据库"></a>4.1、DDL之创建数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Show</span> databases;             <span class="comment">-- 展示所有数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> school;    <span class="comment">-- 创建school数据库</span></span><br><span class="line">USE school;                 <span class="comment">-- 使用school数据库</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE school;       <span class="comment">-- 删除数据库</span></span><br></pre></td></tr></table></figure><h2 id="4-2、DDL之创建表"><a href="#4-2、DDL之创建表" class="headerlink" title="4.2、DDL之创建表"></a>4.2、DDL之创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `student` (          <span class="comment">-- 创建student表</span></span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;学号&#x27;</span>,  <span class="comment">-- 自增</span></span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;张三&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">`pwd` <span class="type">VARCHAR</span>(<span class="number">20</span>),              <span class="comment">-- COMMENT  </span></span><br><span class="line">`sex` <span class="type">VARCHAR</span>(<span class="number">2</span>),               <span class="comment">-- DEFAULT 默认值</span></span><br><span class="line">`birthday` DATETIME,            <span class="comment">-- NOT NULL 非空</span></span><br><span class="line">`addrss` <span class="type">VARCHAR</span>(<span class="number">100</span>),          <span class="comment">-- AUTO_INCREMENT 自增</span></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8            <span class="comment">-- 设置引擎和编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student2 <span class="keyword">as</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student    <span class="comment">-- 子查询创建表</span></span><br><span class="line">USE student;                                      <span class="comment">-- 选择student表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 扩展</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE school    <span class="comment">-- 显示数据库的sql语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student      <span class="comment">-- 显示创建表的sql语句</span></span><br><span class="line"><span class="keyword">DESC</span> student                   <span class="comment">-- 显示表结构</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> student               <span class="comment">-- 显示表结构</span></span><br></pre></td></tr></table></figure><h2 id="4-3、DDL之表的修改"><a href="#4-3、DDL之表的修改" class="headerlink" title="4.3、DDL之表的修改"></a>4.3、DDL之表的修改</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表添加列（字段）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` <span class="keyword">ADD</span> age <span class="type">INT</span>(<span class="number">3</span>)<span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;18&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> studtnet          <span class="comment">-- 删除student表，表结构不在</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> student       <span class="comment">-- 截断student表，表结构仍在</span></span><br><span class="line">                                       <span class="comment">-- 注意截断的表不能回滚，删除的可以</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` <span class="keyword">DROP</span> age1        <span class="comment">-- 删除字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` RENAME <span class="keyword">AS</span> s               <span class="comment">-- 重命名表名 </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` <span class="keyword">to</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` CHANGE age age1 <span class="type">INT</span>(<span class="number">2</span>)    <span class="comment">-- 重命名字段名,必须指定类型和大小</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` MODIFY age <span class="type">VARCHAR</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;18&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span> </span><br></pre></td></tr></table></figure><h2 id="4-4、数据约束"><a href="#4-4、数据约束" class="headerlink" title="4.4、数据约束"></a>4.4、数据约束</h2><p><strong>注意到：</strong>创建表之后字段后面跟的一大堆就是对字段的约束</p><ul><li>为了保证数据的一致性和完整性，SQL规范以约束的方式对表数据进行额外的条件限制</li><li>约束是表级的强制规定</li><li>可以在创建表时规定约束、或者在表创建之后</li></ul><p><strong>六种约束</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NOT</span> <span class="keyword">NULL</span>       <span class="comment">-- 非空约束，规定某个字段不能为空</span></span><br><span class="line"><span class="keyword">UNIQUE</span>         <span class="comment">-- 唯一约束，规定某个字段在整个表中是唯一的</span></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY    <span class="comment">-- 主键(非空且唯一) </span></span><br><span class="line"><span class="keyword">FOREIGN</span> KEY    <span class="comment">-- 外键</span></span><br><span class="line"><span class="keyword">CHECK</span>          <span class="comment">-- 检查约束  -- 可以使用但是mysql没有效果</span></span><br><span class="line"><span class="keyword">DEFAULT</span>        <span class="comment">-- 默认值</span></span><br></pre></td></tr></table></figure><p><strong>分类：</strong></p><ul><li>列级：只能约束单个字段</li><li>表级：可以约束多个字段</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- not null 非空约束</span></span><br><span class="line">id <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>                                <span class="comment">-- 建表时添加</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp MODIFY sex <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;   <span class="comment">-- 增加约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp MODIFY sex <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span>;       <span class="comment">-- 取消约束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- UNIQUE 唯一约束默认创建唯一索引，注意不同字段直接可以重复</span></span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>;</span><br><span class="line"><span class="keyword">CONSTRAINT</span> uk_name_pwd <span class="keyword">UNIQUE</span>(NAME)                 <span class="comment">-- 建表时添加，用户名不能重复</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(NAME,PASSWORD);         <span class="comment">-- 增加约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> uk_name_pwd <span class="keyword">UNIQUE</span>(NAME,PASSWORD);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> MODIFY NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> INDEX uk_name_pwd;   <span class="comment">-- 删除约束,没自定义名字的话为字段名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 主键约束 一个表只能有一个</span></span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT        <span class="comment">-- 建表时添加主键</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> id <span class="keyword">PRIMARY</span> KEY(id,name)         <span class="comment">-- 表级才能定义多个子弹和定义别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;               <span class="comment">-- 删除约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(name,pwd);      <span class="comment">-- 添加约束，已存在就不能添加</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> MODIFY id <span class="type">INT</span>(<span class="number">2</span>) <span class="keyword">PRIMARY</span> KEY;   <span class="comment">-- 修改约束，已存在就不能修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外键约束 FOREIGN KEY </span></span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (`gradeid`) REFERNECES `grade`(`id`)   <span class="comment">-- 关联年级表(grade)的id字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` <span class="keyword">ADD</span> 加上                      <span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY emp_dept_id_fk;   <span class="comment">-- 删除外键</span></span><br></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- not null  default</span></span><br><span class="line">id <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">20</span>;                    <span class="comment">-- 建表时添加</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp MODIFY sex <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;   <span class="comment">-- MODIFY修改字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 主键 PRIMARY KEY、唯一约束 UNIQUE</span></span><br><span class="line">id <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">UNIQUE</span><span class="operator">/</span><span class="keyword">PRIMARY</span>;     <span class="comment">-- 建表时列级范围添加</span></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY<span class="operator">/</span><span class="keyword">UNIQUE</span>(name,pwd);  <span class="comment">-- 建表时标记范围添加  取别名 CONSTRAINT 名字 </span></span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (`gradeid`) REFERNECES `grade`(`id`)   <span class="comment">-- 外键关联年级表(grade)的id字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">ADD</span> 形式<span class="number">2</span><span class="operator">/</span><span class="number">3</span>;             <span class="comment">-- ADD添加约束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> INDEX 约束名称;      <span class="comment">-- DROP删除约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 约束名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Modifty 不建议使用</span></span><br></pre></td></tr></table></figure><h2 id="4-5、索引入门"><a href="#4-5、索引入门" class="headerlink" title="4.5、索引入门"></a>4.5、索引入门</h2><h3 id="1、索引的定义"><a href="#1、索引的定义" class="headerlink" title="1、索引的定义"></a>1、索引的定义</h3><p><strong>官方定义：</strong>索引（INDEX）是帮助MySQL高效获取数据的数据结果。</p><p><strong>索引的本质：</strong>索引是排好序的快速查找数据结构。</p><p><strong>举例：</strong>索引的目的在于提高查询效率，可以类比字典的目录。如果要查<code>mysql</code>这个这个单词，我们肯定要先定位到<code>m</code>字母，然后从上往下找<code>y</code>字母，再找剩下的<code>sql</code>。如果没有索引，那么可能需要<code>a---z</code>，这样全字典扫描，如果我想找<code>Java</code>开头的单词呢？如果我想找<code>Oracle</code>开头的单词呢？？？</p><p><strong>重点：</strong>索引会影响到<code>MySQL查找(WHERE的查询条件)和排序(ORDER BY)</code>两大功能！</p><p><strong>结构：</strong>数据库维护着一个满足特定查找算法的<code>数据结构</code>，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们平时所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种数据结构的索引之外，还有哈希索引（Hash Index）等。</span><br></pre></td></tr></table></figure><p><strong>位置：</strong>索引往往以索引文件的形式存储在磁盘上。</p><h3 id="2、索引的优劣"><a href="#2、索引的优劣" class="headerlink" title="2、索引的优劣"></a>2、索引的优劣</h3><p><strong>优势：</strong></p><ul><li>查找：类似大学图书馆的书目索引，提高数据检索的效率，降低数据库的IO成本。</li><li>排序：通过索引対数据进行排序，降低数据排序的成本，降低了CPU的消耗。</li></ul><p><strong>劣势：</strong></p><ul><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，也要占用空间的。</li><li>虽然索引大大提高了查询速度，但是同时会<strong>降低表的更新速度</strong>，因为表更新，索引也得更新。索引文件每次更新添加的索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li></ul><h3 id="3、索引的分类"><a href="#3、索引的分类" class="headerlink" title="3、索引的分类"></a>3、索引的分类</h3><blockquote><p>根据索引的类型</p></blockquote><ul><li><strong>主键索引 PRIMARY KEY</strong>： 自动创建，主键不可重复，只能有一个列作为主键</li><li><strong>唯一索引 UNIQUE KEY：</strong>可以有多个，索引列本列的值是唯一的，为可以空</li><li><strong>外键索引 FOREIGN KEY：</strong>MySQL会自动添加索引</li><li><strong>普通索引 KEY/INDEX ：</strong></li><li><strong>全文索引FULLTEXT ：</strong>特定的数据库引擎（MYISAM）才有</li></ul><blockquote><p>根据索引的列多少</p></blockquote><ul><li><strong>单值索引：</strong>一个索引只包含单个列，一个表可以有多个单列索引。</li><li><strong>复合索引：</strong>一个索引包含多个字段。</li></ul><blockquote><p>按照数据结构分类</p></blockquote><ul><li><code>BTree</code>索引。</li><li><code>Hash</code>索引。</li><li><code>Full-text</code>全文索引。</li><li><code>R-Tree</code>索引。</li></ul><p>B树索引的原理：</p><p><img src="/img/MySQL/4.jpg"></p><h3 id="4、约束和索引的区别"><a href="#4、约束和索引的区别" class="headerlink" title="4、约束和索引的区别"></a>4、约束和索引的区别</h3><blockquote><p>唯一约束和唯一索引</p></blockquote><ul><li>创建唯一约束 会 自动创建唯一索引；二者都能实现对数据的唯一性约束</li><li>单独创建的唯一索引可以单独删除；唯一约束自动创建的唯一索引，唯一索引不能单独删除</li><li>想作为外键必须要有唯一约束</li></ul><blockquote><p>主键和外键</p></blockquote><p>索引都是伴随约束出现的，不能单独创建。这里不确定，个人猜测。</p><h3 id="5、创建、删除索引"><a href="#5、创建、删除索引" class="headerlink" title="5、创建、删除索引"></a>5、创建、删除索引</h3><p><strong>建议：</strong>一张表建的索引最好不要超过5个！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1、创建索引 [UNIQUE]表示唯一索引 */</span></span><br><span class="line">[<span class="keyword">UNIQUE</span>] INDEX sex1(sex)                        <span class="comment">-- 建表时为sex添加索引sex1</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] INDEX indexName <span class="keyword">ON</span> tabName(columnName(length));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、删除索引 */</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX [indexName] <span class="keyword">ON</span> tabName;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、查看索引 */</span></span><br><span class="line"><span class="comment">/* 加上\G就可以以列的形式查看了 不加\G就是以表的形式查看 */</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> tabName \G;</span><br></pre></td></tr></table></figure><h3 id="6、索引使用建议"><a href="#6、索引使用建议" class="headerlink" title="6、索引使用建议"></a>6、索引使用建议</h3><blockquote><p>不要建索引的情况</p></blockquote><ul><li><p>记录太少的表。</p></li><li><p>经常增删改的表、频繁更新的字段不适合创建索引。</p></li><li><p>Where条件里用不到的字段不创建索引。</p></li><li><p>一个字段在整列中的属性值大部分都一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假如一个表有10万行记录，有一个字段A只有true和false两种值，并且每个值的分布概率大约为50%，那么对A字段建索引一般不会提高数据库的查询速度。索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>需要建索引的情况</p></blockquote><ul><li>主键自动建立主键索引（唯一 + 非空）。</li><li>频繁作为查询条件的字段应该创建索引。</li><li>查询中与其他表关联的字段，<code>外键关系</code>建立索引，（MySQL外键字段添加索引，不加索引导致死锁）</li><li>查询中排序（order by）的字段</li><li>查询中统计或者分组字段（group by也和索引有关）。</li></ul><blockquote><p>多表Join语句优化</p></blockquote><ul><li>尽可能减少<code>JOIN</code>语句中的<strong>嵌套循环</strong>的总次数：<strong>永远都是小的结果集驱动大的结果集</strong>。</li><li>左连接右边表建索引,</li><li>优先优化<code>NestedLoop</code>的内层循环。</li><li>保证<code>JOIN</code>语句中被驱动表上<code>JOIN</code>条件字段已经被索引。</li><li>当无法保证被驱动表的<code>JOIN</code>条件字段被索引且内存资源充足的前提下，不要太吝惜<code>Join Buffer</code> 的设置。</li></ul><h1 id="5、DML增删改查"><a href="#5、DML增删改查" class="headerlink" title="5、DML增删改查"></a>5、DML增删改查</h1><h2 id="5-1、DML语言之增删改"><a href="#5-1、DML语言之增删改" class="headerlink" title="5.1、DML语言之增删改"></a>5.1、DML语言之增删改</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 增</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (id,name,pwd,sex)<span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;wzh&#x27;</span>,<span class="number">123456</span>,<span class="string">&#x27;男&#x27;</span>)   </span><br><span class="line"><span class="comment">-- 增加操作，可以只增加部分值，剩下的不写，或者写NULL</span></span><br><span class="line"><span class="comment">-- 插入的值 可以用子查询的数据替代</span></span><br><span class="line"><span class="comment">-- 插入的数据可以用 NOW() 等函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改</span></span><br><span class="line">UPDATE student <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;zk&#x27;</span>,pwd<span class="operator">=</span><span class="number">234</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>                </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>                     <span class="comment">-- 清空表后自增列不变</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="number">9</span><span class="operator">+</span><span class="number">2</span>)          <span class="comment">-- 可以利用子查询删除</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> student                     <span class="comment">-- 清空表会重新设置自增列，不会影响事务</span></span><br></pre></td></tr></table></figure><p> DELETE删除后重启数据库：    </p><ul><li>INNODB：自增列从1开始(存在内存中)</li><li>MYISAM：继续从上一个自增量开始</li></ul><h2 id="5-2、DML语言之查"><a href="#5-2、DML语言之查" class="headerlink" title="5.2、DML语言之查"></a>5.2、DML语言之查</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> <span class="operator">|</span> DISTINCTROW <span class="operator">|</span> TOP ] </span><br><span class="line">&#123;<span class="operator">*</span><span class="operator">|</span>talbe.<span class="operator">*</span><span class="operator">|</span>[table.]field1[<span class="keyword">AS</span> alias1][,[table.]field2[<span class="keyword">AS</span> alias2][,…]]&#125;   <span class="comment">--- 查的字段</span></span><br><span class="line"><span class="keyword">FROM</span> 表名[<span class="keyword">as</span> 别名]    <span class="comment">-- 从哪些表中选择</span></span><br><span class="line">[<span class="keyword">left</span> <span class="operator">|</span> <span class="keyword">right</span> <span class="operator">|</span> <span class="keyword">inner</span> <span class="keyword">join</span> 表名<span class="number">2</span> ]  <span class="comment">-- 联合查询</span></span><br><span class="line">[<span class="keyword">IN</span> externaldatabase] </span><br><span class="line">[<span class="keyword">WHERE</span>…]       <span class="comment">--  结果满足的条件</span></span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span>…]    <span class="comment">-- 按照那些字段分组</span></span><br><span class="line">[<span class="keyword">HAVING</span>…]      <span class="comment">-- 过滤分组记录满足的条件</span></span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span>…]    <span class="comment">-- 结果排序</span></span><br><span class="line">[limit ]       <span class="comment">-- 分页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--注意： 必须严格按照顺序来</span></span><br></pre></td></tr></table></figure><blockquote><p>1、查询全部</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `student`</span><br></pre></td></tr></table></figure><blockquote><p>2、查询指定的字段（使用别名）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.`id` <span class="keyword">AS</span> ID <span class="keyword">FROM</span> `student` <span class="keyword">AS</span> s  <span class="comment">-- 字段使用``</span></span><br><span class="line"><span class="keyword">SELECT</span> s.`id` <span class="string">&#x27;ID&#x27;</span> <span class="keyword">FROM</span> `student` `s`    <span class="comment">-- 字段别名&#x27;&#x27;,表取别名``</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id ID <span class="keyword">FROM</span> student s            <span class="comment">-- 不用任何字符</span></span><br></pre></td></tr></table></figure><blockquote><p>3、concat函数</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;学号:&#x27;</span>,id) <span class="keyword">AS</span> ID <span class="keyword">FROM</span> student <span class="comment">-- 拼接字符串</span></span><br></pre></td></tr></table></figure><blockquote><p>4、对结果操作</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age<span class="operator">+</span><span class="number">1</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">11</span> </span><br></pre></td></tr></table></figure><blockquote><p>5、去重</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> `id` <span class="keyword">FROM</span> student    <span class="comment">-- 使用 DISTINCT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> age,id <span class="keyword">FROM</span> <span class="keyword">USER</span>     <span class="comment">-- DISTINCT作用于所有列，如这里，只有id和age均相同，才会被去重 </span></span><br></pre></td></tr></table></figure><blockquote><p>6、where筛选</p></blockquote><ul><li>算数运算判断：&lt;    &lt;    =   &gt;   &gt;=     !=    =     &lt;&gt;(name &lt;&gt; ‘张三’ 即名字不为张三)</li><li>逻辑比较判断：AND或者&amp;&amp;    OR或者||     NOT或者！</li><li>之间判断：        BETWEEN   AND</li><li>之内判断：       IN</li><li>模糊匹配：       LIKE</li><li>空值判断：       IS   [NOT]  NULL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mysql 优先计算And 其次计算 or</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">18</span> <span class="comment">-- id为6 或者 id为3且age为18</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> (id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">3</span>) <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">18</span>  <span class="comment">-- id为6或3 且 age为18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL的 NOT 支持对 BETWEEN、IN、EXISTS 搭配使用 </span></span><br></pre></td></tr></table></figure><blockquote><p>7、模糊查询：比较运算符</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">12</span> <span class="comment">-- 查询区间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;张%&#x27;</span>      <span class="comment">-- %表示任意字符,表示张....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;张_&#x27;</span>      <span class="comment">-- _表示一个字符,表示张x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="keyword">IN</span>(<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>)      <span class="comment">-- 查询id为11、12、13之内的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> addrss <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>   <span class="comment">-- 查询address不为空</span></span><br></pre></td></tr></table></figure><blockquote><p>8、使用正则表达式查询</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> NAME REGEXP <span class="string">&#x27;1000&#x27;</span>  <span class="comment">-- 使用正则表达式，匹配包含1000的字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> NAME REGEXP <span class="string">&#x27;1000|2000&#x27;</span>  <span class="comment">--  与</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> NAME REGEXP <span class="string">&#x27;[JT]&#x27;</span>       <span class="comment">-- 字符为J或者T 等于 J|T</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> NAME REGEXP <span class="string">&#x27;[^J]&#x27;</span>       <span class="comment">-- 字符不为J</span></span><br></pre></td></tr></table></figure><blockquote><p>9、相等连接（内连接）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接student表和teacher表中id相等的行</span></span><br><span class="line"><span class="keyword">SELECT</span> s.name <span class="keyword">FROM</span> student s,teacher t <span class="keyword">WHERE</span> s.id<span class="operator">=</span>t.id              <span class="comment">-- 使用where</span></span><br><span class="line"><span class="keyword">SELECT</span> s.name <span class="keyword">FROM</span> student s <span class="keyword">INNER</span> <span class="keyword">JOIN</span> teacher t <span class="keyword">ON</span> s.id<span class="operator">=</span>t.id   <span class="comment">-- 使用join连接</span></span><br><span class="line">                          <span class="comment">-- INNER可以省略</span></span><br></pre></td></tr></table></figure><blockquote><p>10、高级连接</p></blockquote><ul><li>左连接：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.name,t.pwd <span class="keyword">FROM</span> student s <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> teacher t <span class="keyword">ON</span> s.id<span class="operator">=</span>t.id</span><br><span class="line"><span class="comment">-- 把student表的所有字段和teacher表的中满足条件的连接起来</span></span><br><span class="line"><span class="comment">-- 没有的字段会显示null</span></span><br><span class="line"><span class="comment">-- 此语句中会显示所有student表中的数据，满足内连接条件的会有t.pwd的值，其他都会显示为null</span></span><br><span class="line"><span class="comment">-- 直接left join也可以</span></span><br></pre></td></tr></table></figure><ul><li>右连接：左连接反过来</li><li>全连接：MySQL目前不支持</li><li>自连接</li></ul><blockquote><p>11、子查询:where语句中嵌套select语句，最多嵌套255层</p></blockquote><ul><li>返回单值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.name <span class="keyword">FROM</span> student s <span class="keyword">WHERE</span> s.id <span class="operator">=</span> (<span class="keyword">SELECT</span> t.id <span class="keyword">FROM</span> teacher t <span class="keyword">WHERE</span> t.name<span class="operator">=</span><span class="string">&#x27;李三&#x27;</span>)</span><br><span class="line"><span class="comment">-- &lt;  &gt; 等等</span></span><br></pre></td></tr></table></figure><ul><li><p>返回多值：必须使用多值比较运算符</p><p><strong>IN</strong></p><p><strong>ALL</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.name <span class="keyword">FROM</span> student s <span class="keyword">WHERE</span> s.age <span class="operator">&gt;</span><span class="keyword">ALL</span>(<span class="keyword">SELECT</span> t.age <span class="keyword">FROM</span> teacher t <span class="keyword">WHERE</span> t.id<span class="operator">&gt;</span><span class="number">3</span>)                         <span class="comment">-- s.age必须大于所有返回的结果</span></span><br></pre></td></tr></table></figure><p><strong>ANY</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.name <span class="keyword">FROM</span> student s <span class="keyword">WHERE</span> s.age <span class="operator">&gt;</span><span class="keyword">ANY</span>(<span class="keyword">SELECT</span> t.age <span class="keyword">FROM</span> teacher t <span class="keyword">WHERE</span> t.id<span class="operator">&gt;</span><span class="number">3</span>)                         <span class="comment">-- s.age大于其中某一个即可</span></span><br></pre></td></tr></table></figure><p><strong>EXISTS</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">-- 将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则EXISTS子句返回TRUE，这一行行可作为外查询的结果行，否则不能作为结果。</span></span><br><span class="line"><span class="keyword">SELECT</span> s.age <span class="keyword">FROM</span> student s <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher t <span class="keyword">WHERE</span> s.id<span class="operator">=</span>t.id)</span><br></pre></td></tr></table></figure></li></ul><p><strong>子查询的作用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="number">3</span> <span class="keyword">AS</span> id)                  <span class="comment">-- 过滤数据 </span></span><br><span class="line"><span class="keyword">SELECT</span> id,NAME,(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> o <span class="keyword">WHERE</span> o.id <span class="operator">=</span> c.id) <span class="keyword">FROM</span> c <span class="comment">-- 作为计算字段</span></span><br></pre></td></tr></table></figure><blockquote><p>12.合并查询结果</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 语句<span class="number">1</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> 语句<span class="number">2</span></span><br><span class="line"><span class="comment">-- 语句1和语句2查询的结果必须完全一致，Union自动去重</span></span><br><span class="line"><span class="comment">-- 只能使用一条order by 语句且在最后一条语句后面</span></span><br></pre></td></tr></table></figure><blockquote><p>13、分组过滤：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,pwd <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> name,id <span class="keyword">HAVING</span> id <span class="operator">&gt;</span><span class="number">4</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br><span class="line"><span class="comment">-- 所有相同的name的分成一组，每组的结果只选第一个</span></span><br><span class="line"><span class="comment">-- 可以按照多列分组</span></span><br><span class="line"><span class="comment">-- having只能和group by 一直使用，作用是进一步筛选</span></span><br><span class="line"><span class="comment">-- 通常配合聚合函数使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配合聚合函数</span></span><br></pre></td></tr></table></figure><blockquote><p>14、排序</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span>   <span class="comment">--  升序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span>  <span class="comment">--  降序</span></span><br></pre></td></tr></table></figure><blockquote><p>15、分页</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span> LIMIT <span class="number">10</span>,<span class="number">3</span>  <span class="comment">-- 从第11行开始显示，每页3个数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span> LIMIT <span class="number">10</span>    <span class="comment">-- 前10条语句</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span> LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">3</span>; <span class="comment">-- 相当于 limit 3,10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span> LIMIT <span class="number">10</span>,<span class="number">-1</span>  <span class="comment">-- 检索到最后一条数据</span></span><br></pre></td></tr></table></figure><h2 id="4-3、七种JOIN理论总结"><a href="#4-3、七种JOIN理论总结" class="headerlink" title="4.3、七种JOIN理论总结"></a>4.3、七种JOIN理论总结</h2><p><img src="/img/MySQL/3.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A INNER JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key WHERE B.Key IS NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"><span class="comment">/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 1+2 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key</span><br><span class="line">UNION</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL OR B.Key IS NULL;</span><br><span class="line"><span class="comment">/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 4+5 */</span></span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key WHERE B.Key IS NULL;</span><br><span class="line">UNION</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL;</span><br></pre></td></tr></table></figure><h1 id="6、DCL语句"><a href="#6、DCL语句" class="headerlink" title="6、DCL语句"></a>6、DCL语句</h1><h2 id="6-1、DCL：事务"><a href="#6-1、DCL：事务" class="headerlink" title="6.1、DCL：事务"></a>6.1、DCL：事务</h2><h3 id="1、事务原则"><a href="#1、事务原则" class="headerlink" title="1、事务原则"></a>1、事务原则</h3><ul><li>原子性：要么都成功，要么都失败</li><li>一致性：事务执行前后都满足**数据库的完整性约束 **，如A、B转账前后总和不变</li><li>隔离性：多个事务互不影响</li><li>持久性：事务完成后，持久化</li></ul><h3 id="2、手动执行事务"><a href="#2、手动执行事务" class="headerlink" title="2、手动执行事务"></a>2、手动执行事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>   <span class="comment">-- 关闭事务，MySQL时默认开始事务提交的，要手动操作必须先关闭事务</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">1</span>   <span class="comment">-- 开启事务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">START</span> TRANSACTION    <span class="comment">-- 事务开始</span></span><br><span class="line"><span class="keyword">COMMIT</span>               <span class="comment">-- 事务提交，一旦提交就持久化了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名               <span class="comment">-- 记录保存点，可以回滚到改点</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> 保存点名   <span class="comment">-- 回滚</span></span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名       <span class="comment">-- 撤销保存点名</span></span><br></pre></td></tr></table></figure><h3 id="3、并发问题"><a href="#3、并发问题" class="headerlink" title="3、并发问题"></a>3、并发问题</h3><ul><li><strong>读脏数据：</strong>     事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li><strong>不可重复读：</strong> 一个事务对同一数据两次读到的<strong>值</strong>不同</li><li><strong>幻影读：</strong>        事务B对表 table 进行读取，在此过程中事务A对表 table 增加了一条数据，事务B修改完毕后发现<strong>还有一条数据没有读取</strong>，好像发生了环境</li></ul><blockquote><p>事务隔离级别</p></blockquote><table><thead><tr><th>级别</th><th>约束</th></tr></thead><tbody><tr><td>READ UNCOMMITTED（未提交读）</td><td>没有限制</td></tr><tr><td>READ COMMITTED（提交读）</td><td>不允许读未提交的数据，但是数据仍然可能在事务结束前被修改</td></tr><tr><td>REPEATABLE READ（可重复读）</td><td>保证一个事务中重复读到的数据保持同样的值，但允许其他用户将新幻影行插入数据集</td></tr><tr><td>SERIALIZABLE（可串行读）</td><td>不允许其他用户在事务完成前更新数据集或者将行插入到数据集</td></tr></tbody></table><table><thead><tr><th>隔离级别</th><th>丢失更新</th><th>读脏数据</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED（未提交读）</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>READ COMMITTED（已提交读）</td><td>否</td><td>否</td><td>是</td><td>是</td></tr><tr><td>REPEATABLE READ（可重复度）</td><td>否</td><td>否</td><td>否</td><td>是</td></tr><tr><td>SERIALIZABLE（可串行读）</td><td>否</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置MySQL连接的隔离级别</span></span><br><span class="line"><span class="keyword">set</span> transaction isolation level read committed;</span><br><span class="line"><span class="comment">-- 设置数据库系统的全局的隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE  <span class="comment">-- 设置可串行读</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION    <span class="comment">-- 事务开始</span></span><br><span class="line"><span class="keyword">COMMIT</span>               <span class="comment">-- 事务提交</span></span><br></pre></td></tr></table></figure><h3 id="4、MySQL的表级锁（偏读）"><a href="#4、MySQL的表级锁（偏读）" class="headerlink" title="4、MySQL的表级锁（偏读）"></a>4、MySQL的表级锁（偏读）</h3><blockquote><p>特点</p></blockquote><p>偏向<code>MyISAM</code>存储引擎，开销小，加锁快，<strong>无死锁</strong>，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><blockquote><p>使用</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lcok TABLES student READ;    <span class="comment">-- 上锁，读锁    WRITE为写锁</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES;            <span class="comment">-- 查看数据库表锁的命令</span></span><br><span class="line">UNLOCK <span class="keyword">TABLE</span>;                <span class="comment">-- 解锁</span></span><br></pre></td></tr></table></figure><blockquote><p>案例说明</p></blockquote><p><strong>案例说明—-读锁：</strong>打开两个会话，<code>SESSION1</code>为<code>mylock</code>表添加读锁。</p><ul><li>SESSION1 可以读mylock表、不可以修改mylock表、不可以读其他的表</li><li>SESSION2 可以读mylock表、修改mylock表会被阻塞，需要等待SESSION1释放mylock表、可以读其他表</li></ul><p><strong>案例说明—-写锁：</strong>打开两个会话，<code>SESSION1</code>为<code>mylock</code>表添加写锁。</p><ul><li>SESSION1 可以读mylock的表、可以修改mylock表、不可以读其他的表</li><li>SESSION2 可以读mylock表、修改mylock表会被阻塞，需要等待SESSION1释放mylock表、可以读其他表</li></ul><blockquote><p>结论</p></blockquote><p><strong><code>MyISAM</code>引擎在执行查询语句<code>SELECT</code>之前，会自动给涉及到的所有表加读锁，在执行增删改之前，会自动给涉及的表加写锁。</strong></p><p>MySQL的表级锁有两种模式：</p><ul><li><p>表共享读锁（Table Read Lock）。</p></li><li><p>表独占写锁（Table Write Lock）。</p></li></ul><p>対<code>MyISAM</code>表进行操作，会有以下情况：</p><ul><li>対<code>MyISAM</code>表的读操作（加读锁），不会阻塞其他线程対同一表的读操作，但是会阻塞其他线程対同一表的写操作。只有当读锁释放之后，才会执行其他线程的写操作。</li><li>対<code>MyISAM</code>表的写操作（加写锁），会阻塞其他线程対同一表的读和写操作，只有当写锁释放之后，才会执行其他线程的读写操作。</li></ul><p><strong>此外，<code>MyISAM</code>的读写锁调度是写优先，这也是<code>MyISAM</code>不适合作为主表的引擎。因为写锁后，其他线程不能进行任何操作，大量的写操作会使查询很难得到锁，从而造成永远阻塞。</strong></p><h3 id="5、MySQL的行级锁（偏写）"><a href="#5、MySQL的行级锁（偏写）" class="headerlink" title="5、MySQL的行级锁（偏写）"></a>5、MySQL的行级锁（偏写）</h3><blockquote><p>特点</p></blockquote><p>偏向<code>InnoDB</code>存储引擎，开销大，加锁慢；会出现<strong>死锁</strong>；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p><ul><li>MyISAM采用表级锁(table-level locking)。</li><li>InnoDB⽀持行级锁(row-level locking)和表级锁,默认为行级锁</li></ul><blockquote><p>使用</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION    <span class="comment">-- 事务开启</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;     <span class="comment">-- 共享锁（读锁）、允许其他会话读</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> UPDATE;             <span class="comment">-- 排他锁（写锁）、禁止其他会话读</span></span><br><span class="line"><span class="comment">-- 增删改语句MySQL会自动加上隐式排它锁、select不会加锁</span></span><br><span class="line"><span class="keyword">commit</span>               <span class="comment">---提交后自动解锁</span></span><br></pre></td></tr></table></figure><blockquote><p>案例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 案例1</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `b` <span class="operator">=</span> <span class="string">&#x27;88&#x27;</span> <span class="keyword">WHERE</span> `a` <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- SESSION1写操作，但是没有commit。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test_innodb_lock`;      <span class="comment">-- SESSION2是读不到SESSION1未提交的数据的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `b` <span class="operator">=</span> <span class="string">&#x27;99&#x27;</span> <span class="keyword">WHERE</span> `a` <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">-- SESSION1写操作，但是没有commit</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `b` <span class="operator">=</span> <span class="string">&#x27;asdasd&#x27;</span> <span class="keyword">WHERE</span> `a` <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- SESSION2写操作会阻塞到1执行完</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例3</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `b` <span class="operator">=</span> <span class="string">&#x27;8976&#x27;</span> <span class="keyword">WHERE</span> `a` <span class="operator">=</span> <span class="number">6</span>;   <span class="comment">-- SESSION1写操作，</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `b` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">WHERE</span> `a` <span class="operator">=</span> <span class="number">4</span>;  <span class="comment">-- SESSION2写操作其他行不受影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例4 索引失效行锁变表锁</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `a` <span class="operator">=</span> <span class="number">888</span> <span class="keyword">WHERE</span> `b` <span class="operator">=</span> <span class="number">8000</span>;  <span class="comment">-- `b`没有加单引号，索引失效</span></span><br><span class="line">UPDATE `test_innodb_lock` <span class="keyword">SET</span> `b` <span class="operator">=</span> <span class="string">&#x27;1314&#x27;</span> <span class="keyword">WHERE</span> `a` <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 操作不同行，但是阻塞</span></span><br></pre></td></tr></table></figure><blockquote><p>间隙锁</p></blockquote><p><strong>概念：</strong>当我们用范围条件而不是相等条件检索数据，并请求共享或者排他锁时，<code>InnoDB</code>会给符合条件的已有数据记录的索引项加锁，对于键值在条件范围内但并不存在的记录，叫做”间隙(GAP)”。</p><p><code>InnoDB</code>也会对这个”间隙”加锁，这种锁的机制就是所谓的”间隙锁”。</p><p><strong>危害：</strong>因为<code>Query</code>执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值不存在。</p><p>间隙锁有一个比较致命的缺点，就是<strong>当锁定一个范围的键值后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。</strong>在某些场景下这可能会対性能造成很大的危害。</p><blockquote><p>总结</p></blockquote><p><code>InnoDB</code>存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于<code>MyISAM</code>的表级锁定的。当系统并发量较高的时候，<code>InnoDB</code>的整体性能和<code>MyISAM</code>相比就会有比较明显的优势了。</p><p>但是，<code>InnoDB</code>的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让<code>InnoDB</code>的整体性能表现不仅不能比<code>MyISAM</code>高，甚至可能会更差。</p><h2 id="6-2、DCL：权限管理"><a href="#6-2、DCL：权限管理" class="headerlink" title="6.2、DCL：权限管理"></a>6.2、DCL：权限管理</h2><blockquote><p>用户管理</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> wzh<span class="variable">@localhost</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>    <span class="comment">-- 创建用户wzh，密码123456</span></span><br><span class="line">        <span class="comment">-- @后面是主机名，如果指定了那么创建的用户必须通过该主机连接</span></span><br><span class="line">        <span class="comment">-- 并且修改也必须带上@主机名</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;123456&#x27;</span>)                     <span class="comment">-- 修改本机密码</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> wzh<span class="variable">@localhost</span> <span class="operator">=</span> PASSWORD(<span class="string">&#x27;1234566&#x27;</span>)  <span class="comment">-- 指定用户修改密码</span></span><br><span class="line">RENAME <span class="keyword">USER</span> wzh<span class="variable">@localhost</span> <span class="keyword">TO</span> wzh                      <span class="comment">-- 更改用户名</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> wzh                                         <span class="comment">-- 删除用户</span></span><br></pre></td></tr></table></figure><blockquote><p>权限管理</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> wzh    <span class="comment">-- 授权对所有表的所有权限给wzh用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> school.student <span class="keyword">TO</span> wzh  <span class="comment">--只给school数据库的student表的所有权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> wzh                   <span class="comment">-- 显示用户wzh的权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> wzh <span class="comment">-- 撤销权限</span></span><br></pre></td></tr></table></figure><blockquote><p>角色管理：MySQL8.0新增</p></blockquote><p>如果用户被授予角色权限，则该用户拥有该角色的权限。</p><h1 id="7、数据库的备份"><a href="#7、数据库的备份" class="headerlink" title="7、数据库的备份"></a>7、数据库的备份</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导出  导出：多张表不要加逗号，用空格就行</span></span><br><span class="line"><span class="comment">--         主机名                      数据库  表          文件名      </span></span><br><span class="line">mysqldump <span class="operator">-</span>hlocalhost <span class="operator">-</span>uroot <span class="operator">-</span>p123456 school student <span class="operator">&gt;</span>D:<span class="operator">/</span>a.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导入</span></span><br><span class="line">source d:<span class="operator">/</span>a.sql                     <span class="comment">-- 已经登录</span></span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p123456 库名<span class="operator">&lt;</span>备份文件   <span class="comment">-- 未登录</span></span><br></pre></td></tr></table></figure><h1 id="8、MySQL索引失效"><a href="#8、MySQL索引失效" class="headerlink" title="8、MySQL索引失效"></a>8、MySQL索引失效</h1><blockquote><p>数据准备</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `staffs`(</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">24</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">`age` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">`pos` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;职位&#x27;</span>,</span><br><span class="line">`add_time` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;入职时间&#x27;</span></span><br><span class="line">)COMMENT <span class="string">&#x27;员工记录表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `staffs`(`name`,`age`,`pos`) <span class="keyword">VALUES</span>(<span class="string">&#x27;Ringo&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;manager&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `staffs`(`name`,`age`,`pos`) <span class="keyword">VALUES</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;dev&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `staffs`(`name`,`age`,`pos`) <span class="keyword">VALUES</span>(<span class="string">&#x27;李四&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;dev&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建索引 */</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_staffs_name_age_pos <span class="keyword">ON</span> `staffs`(`name`,`age`,`pos`);</span><br></pre></td></tr></table></figure><blockquote><p>索引失效的情况</p></blockquote><ul><li>最佳左前缀法则</li><li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换）</li><li>索引中范围条件右边的字段会全部失效。</li><li>尽量使用覆盖索引（只访问索引的查询，索引列和查询列一致），减少<code>SELECT *</code>。</li><li>MySQL在使用<code>!=</code>、<code>&lt;&gt;</code>、<code>is null</code>、<code>is not null</code>索引失效</li><li><code>like</code>以通配符开头<code>%abc</code>索引失效会变成全表扫描。</li><li>字符串不加单引号，容易导致类型转换，最终索引失效。</li><li>少用<code>or</code>，用它来连接时会索引失效。</li></ul><h2 id="8-1、最佳左前缀法则"><a href="#8-1、最佳左前缀法则" class="headerlink" title="8.1、最佳左前缀法则"></a>8.1、最佳左前缀法则</h2><p><strong>概念：</strong>复合索引（A，B，C），索引B生效的条件是必须用到A字段，C生效条件是必须用到A和B</p><p><strong>注意：</strong>order by 、group by算使用到，但是要严格按照顺序 where B group by A，C  不失效    C，A 失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name字段 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name, age字段 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name，age，pos字段 这是属于全值匹配的情况！！！*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 索引没用上，ALL全表扫描 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 索引没用上，ALL全表扫描 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name字段，pos字段索引失效 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;  <span class="comment">-- </span></span><br></pre></td></tr></table></figure><h2 id="8-2、索引列上不计算"><a href="#8-2、索引列上不计算" class="headerlink" title="8.2、索引列上不计算"></a>8.2、索引列上不计算</h2><p><strong>概念：</strong>where 语句后面的某条件上进行了计算，该索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span>;           <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(`name`, <span class="number">5</span>) <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span>;  <span class="comment">-- 失效</span></span><br></pre></td></tr></table></figure><h2 id="8-3、范围之后全失效"><a href="#8-3、范围之后全失效" class="headerlink" title="8.3、范围之后全失效"></a>8.3、范围之后全失效</h2><p><strong>概念：</strong>where 语句后面的某条件如 xx &gt; xx ，在这之后的语句索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name，age，pos字段 这是属于全值匹配的情况！！！*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name，age字段，pos字段索引失效 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">&gt;</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;dev&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="8-4、覆盖索引尽量用"><a href="#8-4、覆盖索引尽量用" class="headerlink" title="8.4、覆盖索引尽量用"></a>8.4、覆盖索引尽量用</h2><p><strong>覆盖索引：</strong>数据列只用从索引中就能够取得，不必从数据表中读取，即查询列要被所使用的索引覆盖。</p><p>所以在写SQL的不要使用<code>SELECT *</code>，用什么字段就查询什么字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 没有用到覆盖索引</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用到了覆盖索引</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `name`, `age`, `pos` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="8-5、不等有时会失效"><a href="#8-5、不等有时会失效" class="headerlink" title="8.5、不等有时会失效"></a>8.5、不等有时会失效</h2><p><strong>概念：</strong>where语句 使用  !=  索引有时候会失效 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> `name`, `age`, `pos` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">!=</span> <span class="string">&#x27;Ringo&#x27;</span>;  <span class="comment">-- 成功</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">!=</span> <span class="string">&#x27;Ringo&#x27;</span>;           <span class="comment">-- 失败</span></span><br></pre></td></tr></table></figure><h2 id="8-6、like百分加右边"><a href="#8-6、like百分加右边" class="headerlink" title="8.6、like百分加右边"></a>8.6、like百分加右边</h2><p><strong>概念</strong>： like  “%xxxxx” 这种形式索引会失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%ing%&#x27;</span>;    <span class="comment">-- 失败</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%ing&#x27;</span>;     <span class="comment">-- 失败</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;Rin%&#x27;</span>;     <span class="comment">-- 成功</span></span><br></pre></td></tr></table></figure><h2 id="8-7、字符要加单引号"><a href="#8-7、字符要加单引号" class="headerlink" title="8.7、字符要加单引号"></a>8.7、字符要加单引号</h2><p><strong>概念：</strong>字符串不加单引号容易发生强制类型转换，索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> `id`, `name` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="number">2000</span>;   <span class="comment">-- 使用覆盖索引，未失效</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="number">2000</span>;      <span class="comment">-- 失效</span></span><br></pre></td></tr></table></figure><h2 id="8-8、索引相关题目"><a href="#8-8、索引相关题目" class="headerlink" title="8.8、索引相关题目"></a>8.8、索引相关题目</h2><p><strong>假设index(a,b,c)</strong></p><table><thead><tr><th>Where语句</th><th>索引是否被使用</th></tr></thead><tbody><tr><td>where a = 3</td><td>Y，使用到a</td></tr><tr><td>where a = 3 and b = 5</td><td>Y，使用到a，b</td></tr><tr><td>where a = 3 and b = 5</td><td>Y，使用到a，b，c</td></tr><tr><td>where b = 3 或者 where b = 3 and c = 4 或者 where c = 4</td><td>N，没有用到a字段</td></tr><tr><td>where a = 3 and c = 5</td><td>使用到a，但是没有用到c，因为b断了</td></tr><tr><td>where a = 3 and b &gt; 4 and c = 5</td><td>使用到a，b，但是没有用到c，因为c在范围之后</td></tr><tr><td>where a = 3 and b like ‘kk%’ and c = 4</td><td>Y，a，b，c都用到</td></tr><tr><td>where a = 3 and b like ‘%kk’ and c = 4</td><td>只用到a</td></tr><tr><td>where a = 3 and b like ‘%kk%’ and c = 4</td><td>只用到a</td></tr><tr><td>where a = 3 and b like ‘k%kk%’ and c = 4</td><td>Y，a，b，c都用到</td></tr></tbody></table><h2 id="8-9、面试题分析"><a href="#8-9、面试题分析" class="headerlink" title="8.9、面试题分析"></a>8.9、面试题分析</h2><blockquote><p>数据准备</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建表 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test03`(</span><br><span class="line">`id` <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`c1` <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">`c2` <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">`c3` <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">`c4` <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">`c5` <span class="type">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;a1&#x27;</span>,<span class="string">&#x27;a2&#x27;</span>,<span class="string">&#x27;a3&#x27;</span>,<span class="string">&#x27;a4&#x27;</span>,<span class="string">&#x27;a5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;b1&#x27;</span>,<span class="string">&#x27;b22&#x27;</span>,<span class="string">&#x27;b3&#x27;</span>,<span class="string">&#x27;b4&#x27;</span>,<span class="string">&#x27;b5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>,<span class="string">&#x27;c4&#x27;</span>,<span class="string">&#x27;c5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;d1&#x27;</span>,<span class="string">&#x27;d2&#x27;</span>,<span class="string">&#x27;d3&#x27;</span>,<span class="string">&#x27;d4&#x27;</span>,<span class="string">&#x27;d5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;e1&#x27;</span>,<span class="string">&#x27;e2&#x27;</span>,<span class="string">&#x27;e3&#x27;</span>,<span class="string">&#x27;e4&#x27;</span>,<span class="string">&#x27;e5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建复合索引 */</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_test03_c1234 <span class="keyword">ON</span> `test03`(`c1`,`c2`,`c3`,`c4`);</span><br></pre></td></tr></table></figure><blockquote><p>题目</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最好索引怎么创建的，就怎么用，按照顺序使用，避免让MySQL再自己去翻译一次 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.全值匹配 用到索引c1 c2 c3 c4全字段 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">=</span> <span class="string">&#x27;a3&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">=</span> <span class="string">&#x27;a3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">=</span> <span class="string">&#x27;a3&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4.用到索引c1 c2 c3字段，c4字段失效，范围之后全失效 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">&gt;</span> <span class="string">&#x27;a3&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">&gt;</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">=</span> <span class="string">&#x27;a3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   6.用到了索引c1 c2 c3三个字段, c1和c2两个字段用于查找,  c3字段用于排序了但是没有统计到key_len中，c4字段失效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c3`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7.用到了索引c1 c2 c3三个字段，c1和c2两个字段用于查找, c3字段用于排序了但是没有统计到key_len中*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c3`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   8.用到了索引c1 c2两个字段，c4失效，c1和c2两个字段用于查找，c4字段排序产生了Using filesort说明排序没有用到c4字段 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c4`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 9.用到了索引c1 c2 c3三个字段，c1用于查找，c2和c3用于排序 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c5` <span class="operator">=</span> <span class="string">&#x27;a5&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c2`, `c3`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 10.用到了c1一个字段，c1用于查找，c3和c2两个字段索引失效，产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c5` <span class="operator">=</span> <span class="string">&#x27;a5&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c3`, `c2`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 11.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span>  `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c2, c3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 12.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span>  `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c5` <span class="operator">=</span> <span class="string">&#x27;a5&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c2, c3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   13.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 没有产生Using filesort </span></span><br><span class="line"><span class="comment">      因为之前c2这个字段已经确定了是&#x27;a2&#x27;了，这是一个常量，再去ORDER BY c3,c2 这时候c2已经不用排序了！</span></span><br><span class="line"><span class="comment">      所以没有产生Using filesort 和(10)进行对比学习！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c5` <span class="operator">=</span> <span class="string">&#x27;a5&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c3, c2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GROUP BY 表面上是叫做分组，但是分组之前必定排序。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 14.用到c1 c2 c3三个字段，c1用于查找，c2 c3用于排序，c4失效 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> `c2`,`c3`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 15.用到c1这一个字段，c4失效，c2和c3排序失效产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> `c3`,`c2`;</span><br></pre></td></tr></table></figure><p><code>GROUP BY</code>基本上都需要进行排序，索引优化几乎和<code>ORDER BY</code>一致，但是<code>GROUP BY</code>会有临时表的产生。</p><h2 id="8-10、总结"><a href="#8-10、总结" class="headerlink" title="8.10、总结"></a>8.10、总结</h2><p>索引优化的一般性建议：</p><ul><li>对于单值索引，尽量选择针对当前<code>query</code>过滤性更好的索引。</li><li>在选择复合索引的时候，当前<code>query</code>中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择复合索引的时候，尽量选择可以能够包含当前<code>query</code>中的<code>where</code>子句中更多字段的索引。</li><li>尽可能通过分析统计信息和调整<code>query</code>的写法来达到选择合适索引的目的。</li></ul><p>口诀：</p><ul><li>带头大哥不能死。</li><li>中间兄弟不能断。</li><li>索引列上不计算。</li><li>范围之后全失效。</li><li>覆盖索引尽量用。</li><li>不等有时会失效。</li><li>like百分加右边。</li><li>字符要加单引号。</li><li>一般SQL少用or。</li></ul><h1 id="9、MySQL查询优化"><a href="#9、MySQL查询优化" class="headerlink" title="9、MySQL查询优化"></a>9、MySQL查询优化</h1><h2 id="9-1、小表驱动大表"><a href="#9-1、小表驱动大表" class="headerlink" title="9.1、小表驱动大表"></a>9.1、小表驱动大表</h2><blockquote><p>优化原则：对于MySQL数据库而言，永远都是小表驱动大表。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 举个例子：可以使用嵌套的for循环来理解小表驱动大表。</span></span><br><span class="line"><span class="comment">* 以下两个循环结果都是一样的，但是对于MySQL来说不一样，</span></span><br><span class="line"><span class="comment">* 第一种可以理解为，和MySQL建立5次连接每次查询1000次。</span></span><br><span class="line"><span class="comment">* 第一种可以理解为，和MySQL建立1000次连接每次查询5次。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IN和EXISTS</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 优化原则：小表驱动大表，即小的数据集驱动大的数据集 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IN适合B表比A表数据小的情况*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `A` <span class="keyword">WHERE</span> `id` <span class="keyword">IN</span> (<span class="keyword">SELECT</span> `id` <span class="keyword">FROM</span> `B`)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* EXISTS适合B表比A表数据大的情况 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `A` <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> `B` <span class="keyword">WHERE</span> `B`.id <span class="operator">=</span> `A`.id);</span><br></pre></td></tr></table></figure><p><strong>EXISTS：</strong></p><ul><li>语法：<code>SELECT....FROM tab WHERE EXISTS(subquery);</code>该语法可以理解为：</li><li>该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（<code>true</code>或是<code>false</code>）来决定主查询的数据结果是否得以保留。</li></ul><p><strong>提示：</strong></p><ul><li><code>EXISTS(subquery)</code>子查询只返回<code>true</code>或者<code>false</code>，因此子查询中的<code>SELECT *</code>可以是<code>SELECT 1 OR SELECT X</code>，它们并没有区别。</li><li><code>EXISTS(subquery)</code>子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担心效率问题，可进行实际检验以确定是否有效率问题。</li><li><code>EXISTS(subquery)</code>子查询往往也可以用条件表达式，其他子查询或者<code>JOIN</code>替代，何种最优需要具体问题具体分析。</li></ul><h2 id="9-2、ORDER-BY优化"><a href="#9-2、ORDER-BY优化" class="headerlink" title="9.2、ORDER BY优化"></a>9.2、ORDER BY优化</h2><blockquote><p>数据准备</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `talA`(</span><br><span class="line">`age` <span class="type">INT</span>,</span><br><span class="line">`birth` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">18</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">19</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">21</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">22</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">23</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `talA`(`age`) <span class="keyword">VALUES</span>(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建索引 */</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_talA_age_birth <span class="keyword">ON</span> `talA`(`age`, `birth`);</span><br></pre></td></tr></table></figure><blockquote><p>案例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1.使用索引进行排序了 不会产生Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">WHERE</span> `age` <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `age`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.使用索引进行排序了 不会产生Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">WHERE</span> `age` <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `age`,`birth`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.没有使用索引进行排序 产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">WHERE</span> `age` <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `birth`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4.没有使用索引进行排序 产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">WHERE</span> `age` <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `birth`,`age`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5.没有使用索引进行排序 产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `birth`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6.没有使用索引进行排序 产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">WHERE</span> `birth` <span class="operator">&gt;</span> <span class="string">&#x27;2020-08-04 07:42:21&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `birth`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7.使用索引进行排序了 不会产生Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">WHERE</span> `birth` <span class="operator">&gt;</span> <span class="string">&#x27;2020-08-04 07:42:21&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `age`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 8.没有使用索引进行排序 产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `talA` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `age` <span class="keyword">ASC</span>, `birth` <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><code>ORDER BY</code>子句，尽量使用索引排序，避免使用<code>Using filesort</code>排序（未通过索引排序）。</p><p>MySQL支持两种方式的排序，<code>FileSort</code>和<code>Index</code>，<code>Index</code>的效率高，<code>FileSort</code>方式效率较低。</p><p><code>ORDER BY</code>满足两情况，会使用<code>Index</code>方式排序：</p><ul><li><code>ORDER BY</code>语句使用索引最左前列。</li><li>使用<code>WHERE</code>子句与<code>ORDER BY</code>子句条件列组合满足索引最左前列。</li></ul><p><strong>结论：尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀原则。</strong></p><blockquote><p>如果不在索引列上，File Sort有两种算法：MySQL就要启动双路排序算法和单路排序算法</p></blockquote><p>1、双路排序算法：MySQL4.1之前使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和<code>ORDER BY</code>列，対他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。<strong>一句话，从磁盘取排序字段，在<code>buffer</code>中进行排序，再从磁盘取其他字段。</strong></p><p>取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在MySQL4.1之后，出现了改进的算法，就是单路排序算法。</p><p>2、单路排序算法：从磁盘读取查询需要的所有列，按照<code>ORDER BY</code>列在<code>buffer</code>対它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。</p><p>由于单路排序算法是后出的，总体而言效率好过双路排序算法。</p><p>但是单路排序算法有问题：如果<code>SortBuffer</code>缓冲区太小，导致从磁盘中读取所有的列不能完全保存在<code>SortBuffer</code>缓冲区中，这时候单路复用算法就会出现问题，反而性能不如双路复用算法。</p><p><strong>单路复用算法的优化策略：</strong></p><ul><li>增大<code>sort_buffer_size</code>参数的设置。</li><li>增大<code>max_length_for_sort_data</code>参数的设置。</li></ul><p><strong>提高ORDER BY排序的速度：</strong></p><ul><li><p><code>ORDER BY</code>时使用<code>SELECT *</code>是大忌，查什么字段就写什么字段，这点非常重要。在这里的影响是：</p><ul><li>当查询的字段大小总和小于<code>max_length_for_sort_data</code>而且排序字段不是<code>TEXT|BLOB</code>类型时，会使用单路排序算法，否则使用多路排序算法。</li><li>两种排序算法的数据都有可能超出<code>sort_buffer</code>缓冲区的容量，超出之后，会创建<code>tmp</code>临时文件进行合并排序，导致多次IO，但是单路排序算法的风险会更大一些，所以要增大<code>sort_buffer_size</code>参数的设置。</li></ul></li><li><p>尝试提高<code>sort_buffer_size</code>：不管使用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。</p></li><li><p>尝试提高<code>max_length_for_sort_data</code>：提高这个参数，会增加用单路排序算法的概率。但是如果设置的太高，数据总容量<code>sort_buffer_size</code>的概率就增大，明显症状是高的磁盘IO活动和低的处理器使用率。</p></li></ul><h2 id="9-3、GORUP-BY优化"><a href="#9-3、GORUP-BY优化" class="headerlink" title="9.3、GORUP BY优化"></a>9.3、GORUP BY优化</h2><ul><li><p><code>GROUP BY</code>实质是先排序后进行分组，遵照索引建的最佳左前缀。</p></li><li><p>当无法使用索引列时，会使用<code>Using filesort</code>进行排序，增大<code>max_length_for_sort_data</code>参数的设置和增大<code>sort_buffer_size</code>参数的设置，会提高性能。</p></li><li><p><code>WHERE</code>执行顺序高于<code>HAVING</code>，能写在<code>WHERE</code>限定条件里的就不要写在<code>HAVING</code>中了。</p></li></ul><h2 id="9-4、总结"><a href="#9-4、总结" class="headerlink" title="9.4、总结"></a>9.4、总结</h2><p><strong>为排序使用索引</strong></p><ul><li>MySQL两种排序方式：<code>Using filesort</code>和<code>Index</code>扫描有序索引排序。</li><li>MySQL能为排序与查询使用相同的索引，创建的索引既可以用于排序也可以用于查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建a b c三个字段的索引 */</span></span><br><span class="line">idx_table_a_b_c(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.ORDER BY 能使用索引最左前缀 */</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b, c;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">DESC</span>, b <span class="keyword">DESC</span>, c <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.如果WHERE子句中使用索引的最左前缀定义为常量，则ORDER BY能使用索引 */</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c;</span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="string">&#x27;Tangs&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c;</span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> b <span class="operator">&gt;</span> <span class="number">2000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.不能使用索引进行排序 */</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">ASC</span>, b <span class="keyword">DESC</span>, c <span class="keyword">DESC</span>;  <span class="comment">/* 排序不一致 */</span></span><br><span class="line"><span class="keyword">WHERE</span> g <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c;   <span class="comment">/* 丢失a字段索引 */</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> c;      <span class="comment">/* 丢失b字段索引 */</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, d;   <span class="comment">/* d字段不是索引的一部分 */</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="keyword">IN</span> (...) <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c;  <span class="comment">/* 对于排序来说，多个相等条件(a=1 or a=2)也是范围查询 */</span></span><br></pre></td></tr></table></figure><h1 id="10、性能分析"><a href="#10、性能分析" class="headerlink" title="10、性能分析"></a>10、性能分析</h1><h2 id="8-1-EXPLAIN简介"><a href="#8-1-EXPLAIN简介" class="headerlink" title="8.1.EXPLAIN简介"></a>8.1.EXPLAIN简介</h2><blockquote><p>EXPLAIN是什么？</p></blockquote><p>EXPLAIN：SQL的执行计划，使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的。</p><blockquote><p>EXPLAIN怎么使用？</p></blockquote><p>语法：<code>explain</code> + <code>SQL</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select * from pms_category \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1425</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>EXPLAIN能干嘛？</p></blockquote><p>可以查看以下信息：</p><ul><li><code>id</code>：表的读取顺序。</li><li><code>select_type</code>：数据读取操作的操作类型。</li><li><code>possible_keys</code>：哪些索引可以使用。</li><li><code>key</code>：哪些索引被实际使用。</li><li><code>ref</code>：表之间的引用。</li><li><code>rows</code>：每张表有多少行被优化器查询。</li></ul><h2 id="8-2-EXPLAIN字段"><a href="#8-2-EXPLAIN字段" class="headerlink" title="8.2.EXPLAIN字段"></a>8.2.EXPLAIN字段</h2><blockquote><p>id</p></blockquote><p><code>id</code>：表的读取和加载顺序。</p><p>值有以下三种情况：</p><ul><li><code>id</code>相同，执行顺序由上至下。</li><li><code>id</code>不同，如果是子查询，id的序号会递增，<strong>id值越大优先级越高，越先被执行。</strong></li><li><code>id</code>相同不同，同时存在。<strong>永远是id大的优先级最高，id相等的时候顺序执行。</strong></li></ul><blockquote><p>select_type</p></blockquote><p><code>select_type</code>：数据查询的类型，主要是用于区别，普通查询、联合查询、子查询等的复杂查询。</p><ul><li><code>SIMPLE</code>：简单的<code>SELECT</code>查询，查询中不包含子查询或者<code>UNION </code>。</li><li><code>PRIMARY</code>：查询中如果包含任何复杂的子部分，最外层查询则被标记为<code>PRIMARY</code>。</li><li><code>SUBQUERY</code>：在<code>SELECT</code>或者<code>WHERE</code>子句中包含了子查询。</li><li><code>DERIVED</code>：在<code>FROM</code>子句中包含的子查询被标记为<code>DERIVED(衍生)</code>，MySQL会递归执行这些子查询，把结果放在临时表中。</li><li><code>UNION</code>：如果第二个<code>SELECT</code>出现在<code>UNION</code>之后，则被标记为<code>UNION</code>；若<code>UNION</code>包含在<code>FROM</code>子句的子查询中，外层<code>SELECT</code>将被标记为<code>DERIVED</code>。</li><li><code>UNION RESULT</code>：从<code>UNION</code>表获取结果的<code>SELECT</code>。</li></ul><blockquote><p>type</p></blockquote><p><code>type</code>：访问类型排列。</p><p><strong>从最好到最差依次是：</strong><code>system</code>&gt;<code>const</code>&gt;<code>eq_ref</code>&gt;<code>ref</code>&gt;<code>range</code>&gt;<code>index</code>&gt;<code>ALL</code>。除了<code>ALL</code>没有用到索引，其他级别都用到索引了。</p><p>一般来说，得保证查询至少达到<code>range</code>级别，最好达到<code>ref</code>。</p><ul><li><p><code>system</code>：表只有一行记录（等于系统表），这是<code>const</code>类型的特例，平时不会出现，这个也可以忽略不计。</p></li><li><p><code>const</code>：表示通过索引一次就找到了，<code>const</code>用于比较<code>primary key</code>或者<code>unique</code>索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>列表中，MySQL就能将该查询转化为一个常量。</p></li><li><p><code>eq_ref</code>：唯一性索引扫描，读取本表中和关联表表中的每行组合成的一行，查出来只有一条记录。除 了 <code>system</code> 和<code> const</code> 类型之外, 这是最好的联接类型。</p></li><li><p><code>ref</code>：非唯一性索引扫描，返回本表和关联表某个值匹配的所有行，查出来有多条记录。</p></li><li><p><code>range</code>：只检索给定范围的行，一般就是在<code>WHERE</code>语句中出现了<code>BETWEEN</code>、<code>&lt; &gt;</code>、<code>in</code>等的查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引树的某一点，而结束于另一点，不用扫描全部索引。</p></li><li><p><code>index</code>：<code>Full Index Scan</code>，全索引扫描，<code>index</code>和<code>ALL</code>的区别为<code>index</code>类型只遍历索引树。<strong>也就是说虽然<code>ALL</code>和<code>index</code>都是读全表，但是<code>index</code>是从索引中读的，<code>ALL</code>是从磁盘中读取的。</strong></p></li><li><p><code>ALL</code>：<code>Full Table Scan</code>，没有用到索引，全表扫描。</p></li></ul><blockquote><p>possible_keys 和 key</p></blockquote><p><code>possible_keys</code>：显示可能应用在这张表中的索引，一个或者多个。查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用。</strong></p><p><code>key</code>：实际使用的索引。如果为<code>NULL</code>，则没有使用索引。查询中如果使用了覆盖索引，则该索引仅仅出现在<code>key</code>列表中。</p><blockquote><p>key_len</p></blockquote><p><code>key_len</code>：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。<code>key_len</code>显示的值为索引字段的最大可能长度，并非实际使用长度，即<code>key_len</code>是根据表定义计算而得，不是通过表内检索出的。在不损失精度的情况下，长度越短越好。</p><p><code>key_len</code>计算规则：<strong><a href="https://blog.csdn.net/qq_34930488/article/details/102931490">https://blog.csdn.net/qq_34930488/article/details/102931490</a></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> desc pms_category;</span></span><br><span class="line">+---------------+------------+------+-----+---------+----------------+</span><br><span class="line">| Field         | Type       | Null | Key | Default | Extra          |</span><br><span class="line">+---------------+------------+------+-----+---------+----------------+</span><br><span class="line">| cat_id        | bigint(20) | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name          | char(50)   | YES  |     | NULL    |                |</span><br><span class="line">| parent_cid    | bigint(20) | YES  |     | NULL    |                |</span><br><span class="line">| cat_level     | int(11)    | YES  |     | NULL    |                |</span><br><span class="line">| show_status   | tinyint(4) | YES  |     | NULL    |                |</span><br><span class="line">| sort          | int(11)    | YES  |     | NULL    |                |</span><br><span class="line">| icon          | char(255)  | YES  |     | NULL    |                |</span><br><span class="line">| product_unit  | char(50)   | YES  |     | NULL    |                |</span><br><span class="line">| product_count | int(11)    | YES  |     | NULL    |                |</span><br><span class="line">+---------------+------------+------+-----+---------+----------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select cat_id from pms_category <span class="built_in">where</span> cat_id between 10 and 20 \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY  # 用到了主键索引，通过查看表结构知道，cat_id是bigint类型，占用8个字节</span><br><span class="line">      key_len: 8        # 这里只用到了cat_id主键索引，所以长度就是8！</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 11</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>ref</p></blockquote><p><code>ref</code>：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p><blockquote><p>rows</p></blockquote><p><code>rows</code>：根据表统计信息及索引选用情况，大致估算出找到所需的记录需要读取的行数。</p><blockquote><p>Extra</p></blockquote><p><code>Extra</code>：包含不适合在其他列中显示但十分重要的额外信息。</p><ul><li><code>Using filesort</code>：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<strong>MySQL中无法利用索引完成的排序操作成为”文件内排序”。</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 排序没有使用索引</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select name from pms_category <span class="built_in">where</span> name=<span class="string">&#x27;Tangs&#x27;</span> order by cat_level \G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_name_parentCid_catLevel</span><br><span class="line">          key: idx_name_parentCid_catLevel</span><br><span class="line">      key_len: 201</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index; Using filesort</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 排序使用到了索引</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select name from pms_category <span class="built_in">where</span> name=<span class="string">&#x27;Tangs&#x27;</span> order by parent_cid,cat_level\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_name_parentCid_catLevel</span><br><span class="line">          key: idx_name_parentCid_catLevel</span><br><span class="line">      key_len: 201</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><p><code>Using temporary</code>：使用了临时表保存中间结果，MySQL在対查询结果排序时使用了临时表。常见于排序<code>order by</code>和分组查询<code>group by</code>。<strong>临时表対系统性能损耗很大。</strong></p></li><li><p><code>Using index</code>：表示相应的<code>SELECT</code>操作中使用了覆盖索引，避免访问了表的数据行，效率不错！如果同时出现<code>Using where</code>，表示索引被用来执行索引键值的查找；如果没有同时出现<code>Using where</code>，表明索引用来读取数据而非执行查找动作。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 覆盖索引</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：如果要使用覆盖索引，一定不能写SELECT *，要写出具体的字段。</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select cat_id from pms_category \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL       </span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1425</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index   # select的数据列只用从索引中就能够取得，不必从数据表中读取   </span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><code>Using where</code>：表明使用了<code>WHERE</code>过滤。</li><li><code>Using join buffer</code>：使用了连接缓存。</li><li><code>impossible where</code>：<code>WHERE</code>子句的值总是false，不能用来获取任何元组。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select name from pms_category <span class="built_in">where</span> name = <span class="string">&#x27;zs&#x27;</span> and name = <span class="string">&#x27;ls&#x27;</span>\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: NULL</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">     filtered: NULL</span><br><span class="line">        Extra: Impossible WHERE   # 不可能字段同时查到两个名字</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="11、主从复制"><a href="#11、主从复制" class="headerlink" title="11、主从复制"></a>11、主从复制</h1><h2 id="11-1、复制基本原理"><a href="#11-1、复制基本原理" class="headerlink" title="11.1、复制基本原理"></a>11.1、复制基本原理</h2><p><img src="/img/MySQL/5.jpg"></p><p>MySQL复制过程分为三步：</p><ul><li>Master将改变记录到二进制日志(Binary Log)。这些记录过程叫做二进制日志事件，<code>Binary Log Events</code>；</li><li>Slave将Master的<code>Binary Log Events</code>拷贝到它的中继日志(Replay  Log);</li><li>Slave重做中继日志中的事件，将改变应用到自己的数据库中。MySQL复制是异步且串行化的。</li></ul><h2 id="10-2、复制基本原则"><a href="#10-2、复制基本原则" class="headerlink" title="10.2、复制基本原则"></a>10.2、复制基本原则</h2><ul><li>每个Slave只有一个Master。</li><li>每个Slave只能有一个唯一的服务器ID。</li><li>每个Master可以有多个Salve。</li></ul><h2 id="10-3、一主一从配置"><a href="#10-3、一主一从配置" class="headerlink" title="10.3、一主一从配置"></a>10.3、一主一从配置</h2><blockquote><p>1、基本要求：Master和Slave的MySQL服务器版本一致且后台以服务运行。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建mysql-slave1实例</span></span><br><span class="line">docker run -p 3307:3306 --name mysql-slave1 \</span><br><span class="line">-v /root/mysql-slave1/log:/var/log/mysql \</span><br><span class="line">-v /root/mysql-slave1/data:/var/lib/mysql \</span><br><span class="line">-v /root/mysql-slave1/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=333 \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><blockquote><p>2、主从配置都是配在[mysqld]节点下，都是小写</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Master配置</span></span><br><span class="line">[mysqld]</span><br><span class="line">server-id=1 # 必须</span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin # 必须</span><br><span class="line">read-only=0</span><br><span class="line">binlog-ignore-db=mysql</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Slave配置</span></span><br><span class="line">[mysqld]</span><br><span class="line">server-id=2 # 必须</span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin</span><br></pre></td></tr></table></figure><blockquote><p>3、Master配置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;从机IP地址&#x27;</span> IDENTIFIED BY <span class="string">&#x27;password&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;172.18.0.3&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span></span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、刷新命令</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> FLUSH PRIVILEGES;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、记录下File和Position</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每次配从机的时候都要SHOW MASTER STATUS;查看最新的File和Position</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW MASTER STATUS;</span></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |      602 |              | mysql            |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>4、Slave从机配置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;172.18.0.4&#x27;,</span><br><span class="line">MASTER_USER=&#x27;zhangsan&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;123456&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.File的编号&#x27;,</span><br><span class="line">MASTER_LOG_POS=Position的最新值;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、使用用户名密码登录进Master</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CHANGE MASTER TO MASTER_HOST=<span class="string">&#x27;172.18.0.4&#x27;</span>,</span></span><br><span class="line">    -&gt; MASTER_USER=&#x27;zhangsan&#x27;,</span><br><span class="line">    -&gt; MASTER_PASSWORD=&#x27;123456&#x27;,</span><br><span class="line">    -&gt; MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,</span><br><span class="line">    -&gt; MASTER_LOG_POS=602;</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.02 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、开启Slave从机的复制</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> START SLAVE;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、查看Slave状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Slave_IO_Running 和 Slave_SQL_Running 必须同时为Yes 说明主从复制配置成功！</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW SLAVE STATUS\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event # Slave待命状态</span><br><span class="line">                  Master_Host: 172.18.0.4</span><br><span class="line">                  Master_User: zhangsan</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 602</span><br><span class="line">               Relay_Log_File: b030ad25d5fe-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 320</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes  </span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 602</span><br><span class="line">              Relay_Log_Space: 534</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: bd047557-b20c-11ea-9961-0242ac120002</span><br><span class="line">             Master_Info_File: /var/lib/mysql/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: </span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>5、测试主从复制</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Master创建数据库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create database test_replication;</span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Slave查询数据库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show databases;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test_replication   |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>6、停止主从复制功能</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、停止Slave</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> STOP SLAVE;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、重新配置主从</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MASTER_LOG_FILE 和 MASTER_LOG_POS一定要根据最新的数据来配</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CHANGE MASTER TO MASTER_HOST=<span class="string">&#x27;172.18.0.4&#x27;</span>,</span></span><br><span class="line">    -&gt; MASTER_USER=&#x27;zhangsan&#x27;,</span><br><span class="line">    -&gt; MASTER_PASSWORD=&#x27;123456&#x27;,</span><br><span class="line">    -&gt; MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,</span><br><span class="line">    -&gt; MASTER_LOG_POS=797;</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.01 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> START SLAVE;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW SLAVE STATUS\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 172.18.0.4</span><br><span class="line">                  Master_User: zhangsan</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 797</span><br><span class="line">               Relay_Log_File: b030ad25d5fe-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 320</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 797</span><br><span class="line">              Relay_Log_Space: 534</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: bd047557-b20c-11ea-9961-0242ac120002</span><br><span class="line">             Master_Info_File: /var/lib/mysql/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: </span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="11、常见面试题"><a href="#11、常见面试题" class="headerlink" title="11、常见面试题"></a>11、常见面试题</h1><blockquote><p>SQL查询缓慢</p></blockquote><p>分析：</p><p>1、观察，至少跑1天，看看生产的慢SQL情况。</p><p>2、开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。</p><p>3、explain + 慢SQL分析。</p><p>4、show Profile。</p><p>5、运维经理 OR DBA，进行MySQL数据库服务器的参数调优。</p><p>总结（大纲）：</p><p>1、慢查询的开启并捕获。</p><p>2、explain + 慢SQL分析。</p><p>3、show Profile查询SQL在MySQL数据库中的执行细节和生命周期情况。</p><p>4、MySQL数据库服务器的参数调优。</p><blockquote><p>大表优化</p></blockquote><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，⼀些常见的优化措施如下</p><ol><li>限定范围，如删除一个月之前的记录</li><li>读写分离：主库负责写，从库负责读</li><li>垂直分区：把一张表拆分成多张表，可以简化结构，但是会带来数据冗余，引起Join操作；而且事务更加复杂。</li><li>水平分区：表的数据还是在同⼀台机器上，其实对于提升MySQL并发能⼒没有什么意义，所以<strong>水平拆分最好分库</strong> 。而且会带来逻辑、部署、运维的各种复杂度，如果实在要分片，尽量选择客户端分片架构，这样可以减少⼀次和中间件的网络 IO水平拆分难以解决分片事务，跨节点Join性能差，逻辑复杂。<ul><li><strong>客户端代理：</strong> 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的 <strong>Sharding-JDBC</strong> 、阿⾥的TDDL是两种比较常用的实现。</li><li><strong>中间件代理：</strong> 在应用和数据中间加了⼀个代理层。分片逻辑统⼀维护在中间件服务中。我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul></li></ol><blockquote><p>池化技术</p></blockquote><p>有些对象创建的代价比较大，比如线程、tcp连接、数据库连接等对象。对于这些创建耗时较长，或者资源占用较大(占据操作系统资源，比如说线程，网络连接等)的对象；同时这些资源又是经常使用的，为了避免频繁的创建、销毁这些对象，就使用池化技术，把这些资源放入池中，实现资源的重复使用。</p><p><strong>总结：</strong>获取资源直接从池中获取，实现复用，避免每次都需要重写创建对象。</p><blockquote><p>分库分表之后,id主键如何处理</p></blockquote><p>分成多个表之后，需要⼀个全局唯⼀的id 来⽀持。</p><ul><li>UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。</li><li>数据库自增ID : 两台数据库分别设置不同步长，⽣成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li><li>利用 redis 生成ID：性能高，不依赖数据库，但是加入 redis 组件，系统更复杂，可用性降低。</li><li>Twitter的snowflake（雪花）算法：</li><li>美团的Leaf分布式ID生成系统：</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/19/hello-world/"/>
      <url>/2021/06/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate asfffaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">s</span><br><span class="line">s</span><br><span class="line">s</span><br><span class="line">sss</span><br><span class="line">s</span><br><span class="line"></span><br><span class="line">s</span><br><span class="line">s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
