<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis | Notes</title><meta name="keywords" content="Redis数据库"><meta name="author" content="Bug"><meta name="copyright" content="Bug"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis数据库的基本使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/index.html">
<meta property="og:site_name" content="Notes">
<meta property="og:description" content="Redis数据库的基本使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2021-06-20T03:53:05.000Z">
<meta property="article:modified_time" content="2021-06-21T03:53:05.000Z">
<meta property="article:author" content="Bug">
<meta property="article:tag" content="Redis数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Bug","link":"链接: ","source":"来源: Notes","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-21 11:53:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/18.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Notes</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-20T03:53:05.000Z" title="发表于 2021-06-20 11:53:05">2021-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-06-21T03:53:05.000Z" title="更新于 2021-06-21 11:53:05">2021-06-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1、发展历史"><a href="#1、发展历史" class="headerlink" title="1、发展历史"></a>1、发展历史</h1><blockquote>
<p>1、单机MySQL的美好年代</p>
</blockquote>
<ul>
<li><p>在90年代，一个网站的访问量一般不大，用单个数据库完全可以轻松应付！</p>
</li>
<li><p>在那个时候，更多的都是静态网页，动态交互类型的网站不多。</p>
</li>
</ul>
<p><strong>当时数据存储的瓶颈：</strong></p>
<ol>
<li><p>数据量的总大小，一个机器放不下时</p>
</li>
<li><p>数据的索引（B+ Tree）一个机器的内存放不下时</p>
</li>
<li><p>访问量（读写混合）一个实例不能承受</p>
</li>
</ol>
<blockquote>
<p>2、Memcached（缓存）+ MySQL + 垂直拆分</p>
</blockquote>
<ul>
<li>访问量上升，大部分使用MySQL架构的网站在数据库上都出现性能问题</li>
<li>程序开始追求性能，使用缓存缓解数据库压力，优化数据库的结构和索引，</li>
<li>开始比较流行的是通过文件缓存，但是多台web机器通过文件缓存不能共享，大量的小文件缓存也带了比较高的IO压力，在这个时候，Memcached就自然的成为一个非常时尚的技术产品。</li>
</ul>
<blockquote>
<p>3、MySQL主从读写分离</p>
</blockquote>
<ul>
<li>Memcached只能缓解数据库的读取压力，读写集中在一个数据库上让数据库不堪重负，</li>
<li>使用<strong>主从复制技术</strong>来达到读写分离，提高读写性能和读库的可扩展性</li>
<li>MySQL的master-slave模式成为标配了。</li>
</ul>
<blockquote>
<p>4、分表分库 + 水平拆分 + Mysql 集群</p>
</blockquote>
<ul>
<li>MyISAM使用表锁，高并发下出现严重的锁问题，开始使用InnoDB引擎代替MyISAM。</li>
<li>流行使用分表分库来缓解写压力和数据增长的扩展问题。</li>
<li>MySQL推出了还不太稳定的表分区，在高可靠性上提供了非常大的保证。</li>
</ul>
<p>MyISAM：表锁，查一个数据，整个表都加锁，高并发下出现问题</p>
<p>INNODB：行锁</p>
<blockquote>
<p>5、MySQL 的扩展性瓶颈</p>
</blockquote>
<ul>
<li>MySQL数据库经常存储一些大文本的字段，使数据库表非常的大，影响速度。</li>
<li>把这些数据从MySQL省去，MySQL将变的非常的小，速度提升、</li>
<li>MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。</li>
</ul>
<blockquote>
<p>6、如今</p>
</blockquote>
<ul>
<li>今天我们可以通过第三方平台（如：Google，FaceBook等）可以很容易的访问和抓取数据。</li>
<li>用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加、</li>
<li>我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了，而NoSQL数据库的发展却能很好的处理这些大的数据！</li>
</ul>
<h1 id="2、NoSQL"><a href="#2、NoSQL" class="headerlink" title="2、NoSQL"></a>2、NoSQL</h1><h2 id="2-1、概念"><a href="#2-1、概念" class="headerlink" title="2.1、概念"></a>2.1、概念</h2><ul>
<li>NoSQL = Not Only SQL，意思：<strong>不仅仅是SQL；</strong></li>
<li>不遵循SQL标准</li>
<li>不支持ACID原则</li>
<li>性能远超SQL</li>
</ul>
<p>关系型：表格，行，列</p>
<p>非关系型：键值对存储，列存储，文档存储，图形数据库</p>
<h2 id="2-2、特点"><a href="#2-2、特点" class="headerlink" title="2.2、特点"></a>2.2、特点</h2><ul>
<li>易扩展，数据之间没有耦合性</li>
<li>细粒度的缓存，高性能    官方记录：Redis 一秒可以写8万次，读11万次！</li>
<li>类型多（不需要事先设计数据库，随取随用）</li>
</ul>
<p>对比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">传统关系型数据库RDBMS </span><br><span class="line">- 高度组织化结构化数据 </span><br><span class="line">- 结构化查询语言（SQL） </span><br><span class="line">- 数据和关系都存储在单独的表中 </span><br><span class="line">- 数据操纵语言，数据定义语言 </span><br><span class="line">- 严格的一致性 </span><br><span class="line">- 基础事务 </span><br><span class="line">NoSQL </span><br><span class="line">- 代表着不仅仅是SQL </span><br><span class="line">- 没有声明性查询语言 </span><br><span class="line">- 没有预定义的模式 </span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库 </span><br><span class="line">- 最终一致性，而非ACID属性 </span><br><span class="line">- 非结构化和不可预知的数据 </span><br><span class="line">- CAP定理 （一致性、可用性、分区容忍性最多满足2个）</span><br><span class="line">- 高性能，高可用性 和 可伸缩性</span><br></pre></td></tr></table></figure>

<h2 id="2-3、拓展"><a href="#2-3、拓展" class="headerlink" title="2.3、拓展"></a>2.3、拓展</h2><p>大数据时代的3V ： 主要是对问题的描述</p>
<ul>
<li>海量 Volume</li>
<li>多样 Variety</li>
<li>实时 Velocity</li>
</ul>
<p>互联网需求的<strong>3高</strong> ： 主要是对程序的要求</p>
<ul>
<li>高并发</li>
<li>高可用</li>
<li>高性能</li>
</ul>
<p>当下的应用是 SQL 和 NoSQL 一起使用，技术没有高低之分，就看怎么用</p>
<h2 id="2-4、经典应用分析"><a href="#2-4、经典应用分析" class="headerlink" title="2.4、经典应用分析"></a>2.4、经典应用分析</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、商品基本信息</span></span><br><span class="line"><span class="string">名称、价格、出厂日期、生产厂商等</span> </span><br><span class="line"><span class="string">关系型数据库：mysql、oracle</span></span><br><span class="line"><span class="string">注意，淘宝内部用的MySQL是里面的大牛自己改造过的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、商品描述、详情、评价信息（多文字类）</span></span><br><span class="line"><span class="string">多文字信息描述类，IO读写性能变差</span> </span><br><span class="line"><span class="string">-存在文档数据库MongDB中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、商品的图片</span></span><br><span class="line"><span class="string">商品图片展现类</span> </span><br><span class="line"><span class="string">分布式文件系统中</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">淘宝自己的</span> <span class="string">TFS</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Google的</span> <span class="string">GFS</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Hadoop的</span> <span class="string">HDFS</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">阿里云的</span>  <span class="string">OSS</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、商品的关键</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">搜索引擎</span> <span class="string">solr</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">搜索引擎，淘宝内用</span> </span><br><span class="line"><span class="string">ISearch：多隆一高兴一个人开发的</span> <span class="string">所有牛逼的人在牛逼之前,肯定有一段苦逼的岁月,但只要像傻逼一样的坚持,一定终将牛逼</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、商品的波段性的热点高频信息</span></span><br><span class="line"><span class="string">内存数据库</span> </span><br><span class="line"><span class="string">Tair、Redis、Memcache等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、商品的交易，价格计算，积分累计！</span></span><br><span class="line"><span class="string">外部系统，外部第三方支付接口</span> <span class="string">支付宝</span></span><br></pre></td></tr></table></figure>

<p>大型互联网应用问题：</p>
<ul>
<li>数据类型的多样性</li>
<li>数据源多样性和变化重构</li>
<li>数据源改造而数据服务平台不需要大面积重构</li>
</ul>
<p>解决办法：</p>
<ul>
<li>统一数据服务层（加一层）</li>
</ul>
<h2 id="2-5、NoSQL数据模型简介"><a href="#2-5、NoSQL数据模型简介" class="headerlink" title="2.5、NoSQL数据模型简介"></a>2.5、NoSQL数据模型简介</h2><h5 id="1、KV键值对"><a href="#1、KV键值对" class="headerlink" title="1、KV键值对"></a>1、KV键值对</h5><ul>
<li>新浪：BerkeleyDB+redis</li>
<li>美团：redis+tair</li>
<li>阿里、百度：memcache+redis</li>
</ul>
<h5 id="2、文档型数据库（Bson比较多）"><a href="#2、文档型数据库（Bson比较多）" class="headerlink" title="2、文档型数据库（Bson比较多）"></a>2、文档型数据库（Bson比较多）</h5><ul>
<li>CouchDB</li>
<li>MongoDB<ul>
<li>MongoDB 是一个<strong>基于分布式文件存储的数据库</strong>。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</li>
<li>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</li>
</ul>
</li>
</ul>
<h5 id="3、列存储数据库："><a href="#3、列存储数据库：" class="headerlink" title="3、列存储数据库："></a>3、列存储数据库：</h5><ul>
<li>Cassandra, HBase</li>
<li>分布式文件系统</li>
</ul>
<p><strong>4、图关系数据库</strong></p>
<ul>
<li>它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统</li>
<li>社交网络，推荐系统等。专注于构建关系图谱</li>
<li>Neo4J, InfoGrid</li>
</ul>
<h2 id="2-6、CAP-BASE"><a href="#2-6、CAP-BASE" class="headerlink" title="2.6、CAP + BASE"></a>2.6、CAP + BASE</h2><blockquote>
<p>ACID</p>
</blockquote>
<ul>
<li>A：原子性</li>
<li>C：一致性</li>
<li>I：隔离性</li>
<li>D：持久性</li>
</ul>
<blockquote>
<p>CAP（分布式系统中）</p>
</blockquote>
<ul>
<li>C : Consistency（强一致性，在分布式系统中的所有数据备份，在同一时刻值是否相等）</li>
<li>A : Availability（可用性，部分节点故障后，集群整体是否还能响应请求，即每次请求都能被响应）</li>
<li>P : Partition tolerance（分区容错性，允许分区之间由于原因没能正确同步）</li>
</ul>
<p><strong>在分布式系统中，最多实现其中的2个</strong>：分区数量越多，分区容错性越大，但是会降低数据的一致性，为了保持一致性，就需要花更多时间去等待数据同步，就不能立即返回数据，可用性降低。</p>
<p> <strong>所以NoSQL 数据库分成了满足 CA 原则、满足 CP原则和满足 AP 原则三 大类：</strong></p>
<ul>
<li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</li>
<li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>
</ul>
<p><strong>大多数web应用，其实并不需要强一致性，牺牲C换取P是分布式数据库产品主流</strong></p>
<blockquote>
<p>Base理论</p>
</blockquote>
<ul>
<li>无法实现强一致性，就结合业务特点等达到最终一致性。</li>
</ul>
<p><strong>概念</strong></p>
<ul>
<li>基本可用(Basically Available)： 允许损失部分可用性，保证核心可用。如电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。</li>
<li>软状态(Soft State)： 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状的体现。MySQL Replication 的异步复制也是一种体现</li>
<li>最终一致性(Eventual Consistency)： 最终一致性是指系统中的所有数据最终达到一致的状态，最终一致性是<strong>弱一致性的一种特殊情况</strong>。</li>
</ul>
<p><strong>思想</strong></p>
<ul>
<li>通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观</li>
</ul>
<h1 id="3、Redis简介"><a href="#3、Redis简介" class="headerlink" title="3、Redis简介"></a>3、Redis简介</h1><h2 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h2><blockquote>
<p>Redis是什么</p>
</blockquote>
<p>Redis：<code>RE</code>mote <code>DI</code>ctionary <code>S</code>erver（远程字典服务器）</p>
<p>是完全开源免费的，用<strong>C语言编写</strong>的，遵守BSD协议，是一个高性能<strong>分布式内存数据库</strong>，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为数据结构服务器</p>
<blockquote>
<p>相对于其他key-value缓存产品</p>
</blockquote>
<ul>
<li>Redis<strong>支持持久化</strong>，可以将数据存在磁盘中，重启的时候可以再次加载使用。</li>
<li>Redis不仅仅支持简单的 key-value 类型的数据，<strong>还支持list、set、zset、hash等数据结构</strong>的存储。</li>
<li>Redis支持数据的备份，即<strong>master-slave模式的数据备份</strong>。</li>
</ul>
<blockquote>
<p>特性</p>
</blockquote>
<ul>
<li>数据类型、基本操作和配置</li>
<li>持久化和复制，RDB、AOF</li>
<li>事务的控制，但是不支持ACID原则</li>
<li>集群</li>
<li>做分布式锁，甚⾄是消息队列</li>
</ul>
<h2 id="3-2、linux安装"><a href="#3-2、linux安装" class="headerlink" title="3.2、linux安装"></a>3.2、linux安装</h2><p>宝塔面板傻瓜式安装</p>
<p><strong>daemonize设置yes或者no区别</strong></p>
<ul>
<li><p>yes（宝塔默认）</p>
<p>redis采用的是<strong>单线程+多路IO复用</strong>的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfifile设置的文件中，此时redis将一直运行，除非手动kill该进程。</p>
</li>
<li><p>no（linux命令安装默认）</p>
<p>当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。</p>
</li>
</ul>
<p><strong>测试</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-cli -p 6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ping</span> </span><br><span class="line"><span class="string">PONG</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">helloworld</span> </span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k1</span> </span><br><span class="line"><span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">del</span> <span class="string">k1</span> </span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-cli -p 6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">shutdown</span></span><br><span class="line"><span class="string">not</span> <span class="string">connected&gt;</span> <span class="string">exit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示系统当前进程信息</span></span><br><span class="line"><span class="comment"># ps -ef|grep redis</span></span><br></pre></td></tr></table></figure>

<ul>
<li>6739为默认端口号</li>
</ul>
<p>6379在是手机按键上MERZ对应的号码，而MERZ取自意大利歌女<a target="_blank" rel="noopener" href="http://it.wikipedia.org/wiki/Alessia_Merz">Alessia Merz</a>的名字。MERZ长期以来被antirez及其朋友当作愚蠢的代名词</p>
<h2 id="3-3、选择数据库"><a href="#3-3、选择数据库" class="headerlink" title="3.3、选择数据库"></a>3.3、选择数据库</h2><p>默认16个数据库，类似数组下标从零开始，初始默认使用零号库</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换数据库</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">select</span> <span class="number">0</span></span><br><span class="line"><span class="string">Ok</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379[7]&gt;</span> <span class="string">DBSIZE</span> </span><br><span class="line"><span class="string">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># 清空当前库 </span></span><br><span class="line"><span class="comment"># Flushall：清空全部的库</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">FLUSHDB</span> </span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">DBSIZE</span> </span><br><span class="line"><span class="string">(integer)</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h1 id="4、五大数据类型"><a href="#4、五大数据类型" class="headerlink" title="4、五大数据类型"></a>4、五大数据类型</h1><h2 id="4-1、简介"><a href="#4-1、简介" class="headerlink" title="4.1、简介"></a>4.1、简介</h2><blockquote>
<p>String （字符串类型）</p>
</blockquote>
<p><strong>结构：</strong>一个key对应一个value，即单键单值</p>
<p><strong>底层：</strong>为简单动态字符串（与C语言不同），可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用<code>预分配冗余空间</code>的方式来减少内存的频繁分配，最大512M。</p>
<p><strong>特点：</strong>可以存二进制字符串（意味着可以存任何数据），同时线程安全。</p>
<p><strong>应用：</strong>需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">value</span>    <span class="comment"># 设置值    mset 批量操作         </span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span>          <span class="comment"># 获得key   mget 批量操作           </span></span><br><span class="line"><span class="string">del</span> <span class="string">key</span>          <span class="comment"># 删除key       </span></span><br><span class="line"></span><br><span class="line"><span class="string">exists</span> <span class="string">key</span>       <span class="comment"># 判断 key 是否存在</span></span><br><span class="line"><span class="string">strlen</span> <span class="string">key</span>       <span class="comment"># 返回 key 所储存的字符串值的⻓度。</span></span><br><span class="line"></span><br><span class="line"><span class="string">incr</span> <span class="string">views</span>       <span class="comment"># 数字形式的值加1,incrby views 10</span></span><br><span class="line"><span class="string">decr</span> <span class="string">views</span>       <span class="comment">#  - 1          decrby views 10 </span></span><br><span class="line"></span><br><span class="line"><span class="string">setex</span> <span class="string">key</span> <span class="number">10</span> <span class="string">value</span>     <span class="comment"># 原子设置过期时间 或者设置键值对后再 expire key 10</span></span><br><span class="line"><span class="string">ttl</span> <span class="string">key</span>                <span class="comment"># 查看剩余的时间，-1 表示永不过期，-2 表示已过期</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>List（列表）</p>
</blockquote>
<p><strong>结构：</strong>一个key对应多个value，即单键多值</p>
<p><strong>底层：</strong>字符串双向链表，使用一块连续内存；元素少为<strong>ZipList</strong>，多为快速链表quickList</p>
<p><strong>特点：</strong>可以在两端操作，因此可以作为栈和队列（如消息队列）</p>
<p><strong>应用：</strong>发布与订阅或者说消息队列、慢查询。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Lpush/Rpush</span> <span class="string">list</span> <span class="string">&quot;one&quot;</span>	<span class="comment"># 将一个或多个值插入到列表头部（左）/尾部(右)</span></span><br><span class="line"><span class="string">Lpop/Rpop</span> <span class="string">list</span>          <span class="comment"># 返回并移除第一个元素。</span></span><br><span class="line"><span class="string">lset</span> <span class="string">list</span> <span class="number">1</span> <span class="string">&quot;world&quot;</span>	    <span class="comment"># 更改list位置1的值</span></span><br><span class="line"><span class="string">Lrange</span> <span class="string">list</span> <span class="number">0</span> <span class="number">-1</span>        <span class="comment"># 返回指定区间内的元素，0表示第一个元素，-1表示最后一个</span></span><br><span class="line"><span class="string">Lindex</span> <span class="string">list</span> <span class="number">1</span>           <span class="comment"># 按照索引下标获得元素</span></span><br><span class="line"><span class="string">llen</span> <span class="string">list</span>               <span class="comment"># 长度</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Hash（哈希，类似 Java里的Map）</p>
</blockquote>
<p><strong>结构：</strong>一个key对应多个 内部key，一个内部key对应一个值</p>
<p><strong>底层：</strong>String类型的field和value的映射表，类似Java里面的Map&lt;String,Object&gt;</p>
<p><strong>应用：</strong>hash特别适合用于存储对象。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hset</span> <span class="string">myhash</span> <span class="string">key1</span> <span class="string">&quot;wzh&quot;</span>   <span class="comment"># 设置myhash的键值对为key1和&quot;wzh&quot;</span></span><br><span class="line"><span class="string">hget</span> <span class="string">myhash</span> <span class="string">key1</span>         <span class="comment"># 获得myhash的key1的值</span></span><br><span class="line"><span class="string">hdel</span> <span class="string">myhash</span> <span class="string">field1</span>       <span class="comment"># 删除键</span></span><br><span class="line"><span class="string">hexists</span> <span class="string">myhash</span> <span class="string">field1</span>    <span class="comment"># 是否存在</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Set（集合）</p>
</blockquote>
<p><strong>结构：</strong>一个 key 对应一个 value</p>
<p><strong>底层：</strong>value为null的hash表，</p>
<p><strong>特点：</strong>无序、不允许重复，添加，删除，查找的复杂度都是O(1)，可以集合关系</p>
<p><strong>应用：</strong>交集、并集、差集非常方便的实现如共同关注、共同喜好、二度好友等功能，</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sadd</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span>          <span class="comment"># 将一个或多个成员元素加入</span></span><br><span class="line"><span class="string">sismember</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span>     <span class="comment"># 判断是否在集合里面</span></span><br><span class="line"><span class="string">srem</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span> <span class="string">&quot;xuexi&quot;</span>	<span class="comment"># 移除集合中的一个或多个成员</span></span><br><span class="line"><span class="string">SDIFF</span> <span class="string">key1</span> <span class="string">key2</span>    <span class="comment"># 差集 </span></span><br><span class="line"><span class="string">SINTER</span> <span class="string">key1</span> <span class="string">key2</span>   <span class="comment"># 交集 </span></span><br><span class="line"><span class="string">SUNION</span> <span class="string">key1</span> <span class="string">key2</span>   <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Zset（sorted set：有序集合）</p>
</blockquote>
<p><strong>结构：</strong>一个 key 对应一个 value，同时每个key 关联一个 double类型的分数</p>
<p><strong>底层：</strong>value为null的hash表，跳跃表（排序）</p>
<p><strong>特点：</strong></p>
<ol>
<li>与Set基本相同；不同之处 set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2</li>
<li>会根据 double 类型的分数 自动排序。</li>
</ol>
<p><strong>应用：</strong>带权重的队列、排行榜取 Top、礼物、用户按权重排名</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zadd</span> <span class="string">salary</span> <span class="number">1</span> <span class="string">&quot;one&quot;</span>		<span class="comment"># 加入1个或者多个</span></span><br><span class="line"><span class="string">zrem</span> <span class="string">salaryt</span> <span class="string">&quot;one&quot;</span>	    <span class="comment"># zrem 删除集合成员</span></span><br><span class="line"></span><br><span class="line"><span class="string">zcard</span> <span class="string">myZset</span>            <span class="comment"># 查看 sorted set 中的元素数量</span></span><br><span class="line"><span class="string">zscore</span> <span class="string">myZset</span> <span class="string">value1</span>    <span class="comment"># 查看某个 value 的权重</span></span><br><span class="line"></span><br><span class="line"><span class="string">zrange</span> <span class="string">salary</span> <span class="number">0</span> <span class="number">-1</span>		<span class="comment"># 顺序返回指定区间的成员</span></span><br><span class="line"><span class="string">zrevrange</span> <span class="string">myZset</span> <span class="number">0</span> <span class="number">1</span>    <span class="comment"># 逆序输出某个范围区间的元素，0 为 start 1</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2、Redis的键"><a href="#4-2、Redis的键" class="headerlink" title="4.2、Redis的键"></a>4.2、Redis的键</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">redis-cli</span> <span class="string">-p</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="string">keys</span> <span class="string">*</span> 			<span class="comment"># 查看所有的key </span></span><br><span class="line"><span class="string">EXISTS</span> <span class="string">name</span>  	<span class="comment"># 判断是否存在键name</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">name</span> <span class="string">wzh</span>    <span class="comment"># 设置键值对</span></span><br><span class="line"><span class="string">move</span> <span class="string">name</span> <span class="number">1</span> 	<span class="comment"># move key db ---&gt; 移动到其他库</span></span><br><span class="line"><span class="string">del</span> <span class="string">name</span> 		<span class="comment"># 删除键</span></span><br><span class="line"><span class="string">unlink</span> <span class="string">key</span>   	<span class="comment"># 根据value选择非阻塞删除仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">name</span> <span class="string">wzh</span>       <span class="comment"># 设置键 name 值为 wzh</span></span><br><span class="line"><span class="string">EXPIRE</span> <span class="string">name</span> <span class="number">10</span>     <span class="comment"># 给key 设置生存时间，过期时被自动删除。</span></span><br><span class="line"><span class="string">persist</span> <span class="string">key</span>        <span class="comment"># 移除过期时间</span></span><br><span class="line"><span class="string">ttl</span> <span class="string">name</span>           <span class="comment"># 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type key 查看你的key是什么类型 </span></span><br><span class="line"><span class="string">type</span> <span class="string">name</span> </span><br></pre></td></tr></table></figure>

<h2 id="4-3、字符串String"><a href="#4-3、字符串String" class="headerlink" title="4.3、字符串String"></a>4.3、字符串String</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本操作</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">-p</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">value</span>    <span class="comment"># 设置值             OK</span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span>          <span class="comment"># 获得key            &quot;value1&quot; </span></span><br><span class="line"><span class="string">del</span> <span class="string">key</span>          <span class="comment"># 删除key            (integer) 1 </span></span><br><span class="line"><span class="string">keys</span> <span class="string">*</span>           <span class="comment"># 查看全部的key       (empty list or set) </span></span><br><span class="line"><span class="string">exists</span> <span class="string">key</span>       <span class="comment"># 判断 key 是否存在   (integer) 0 </span></span><br><span class="line"></span><br><span class="line"><span class="string">append</span> <span class="string">key</span> <span class="string">&quot;hello&quot;</span>    <span class="comment"># 若对不存在的 key 进行 APPEND ，等同于 SET  </span></span><br><span class="line"><span class="string">append</span> <span class="string">key</span> <span class="string">&quot;-2333&quot;</span>    <span class="comment"># 对已存在的字符串进行 APPEND，等于增加内容</span></span><br><span class="line"><span class="string">strlen</span> <span class="string">key</span>      	  <span class="comment"># 获取字符串的长度   </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数字进行加减操作一定要是数字</span></span><br><span class="line"><span class="string">set</span> <span class="string">views</span> <span class="number">0</span>       <span class="comment"># 设置为0     OK</span></span><br><span class="line"><span class="string">incr</span> <span class="string">views</span>        <span class="comment">#  + 1    (integer) 1 </span></span><br><span class="line"><span class="string">decr</span> <span class="string">views</span>        <span class="comment">#  - 1    (integer) 0 </span></span><br><span class="line"><span class="string">incrby</span> <span class="string">views</span> <span class="number">10</span>   <span class="comment"># +10     (integer) 10 </span></span><br><span class="line"><span class="string">decrby</span> <span class="string">views</span> <span class="number">10</span>   <span class="comment"># -10     (integer) 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范围:getrange 获取指定区间范围内的值</span></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">abcd123456</span>  <span class="comment"># 设置key2的值 </span></span><br><span class="line"><span class="string">getrange</span> <span class="string">key</span> <span class="number">0</span> <span class="number">-1</span>   <span class="comment"># 获得全部的值           &quot;abcd123456&quot;</span></span><br><span class="line"><span class="string">getrange</span> <span class="string">key</span> <span class="number">0</span> <span class="number">2</span>    <span class="comment"># 截取部分字符串 &quot;abc&quot;    &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setrange 从指定位置开始替换值</span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span>             <span class="comment">#         &quot;abcd123456&quot;</span></span><br><span class="line"><span class="string">SETRANGE</span> <span class="string">key</span> <span class="number">1</span> <span class="string">xx</span>   <span class="comment"># 替换值   (integer) 10 </span></span><br><span class="line"><span class="string">get</span> <span class="string">key</span>             <span class="comment">#         &quot;axxd123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置过期时间</span></span><br><span class="line"><span class="string">setex</span> <span class="string">key</span> <span class="number">10</span> <span class="string">value</span>     <span class="comment"># 原子设置过期时间 或者设置键值对后再 expire key 10</span></span><br><span class="line"><span class="string">ttl</span> <span class="string">key</span>                <span class="comment"># 查看剩余的时间，-1 表示永不过期，-2 表示已过期</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件设置</span></span><br><span class="line"><span class="string">setnx</span> <span class="string">mykey</span> <span class="string">&quot;redis&quot;</span>   <span class="comment"># 如果不存在就设置，成功返回1    </span></span><br><span class="line"><span class="string">setex</span> <span class="string">mykey</span> <span class="string">&quot;mongodb&quot;</span>  <span class="comment"># 如果存在就设置，失败返回0       </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量操作</span></span><br><span class="line"><span class="string">mset</span> <span class="string">k10</span> <span class="string">v10</span> <span class="string">k11</span> <span class="string">v11</span> <span class="string">k12</span> <span class="string">v12</span> <span class="comment"># 创建多个键值对</span></span><br><span class="line"><span class="string">mget</span> <span class="string">k10</span> <span class="string">k11</span> <span class="string">k12</span> <span class="string">k13</span>         <span class="comment"># 获得多个键的值</span></span><br><span class="line"><span class="string">msetnx</span> <span class="string">k10</span> <span class="string">v10</span> <span class="string">k15</span> <span class="string">v15</span>       <span class="comment"># 原子操作，都成功返回1，否则都失败，返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统缓存对象(不是真正的缓存对象)</span></span><br><span class="line"><span class="string">mset</span> <span class="string">user:1:name</span> <span class="string">zhangsan</span> <span class="string">user:1:age</span> <span class="number">2</span> </span><br><span class="line"><span class="string">mget</span> <span class="string">user:1:name</span> <span class="string">user:1:age</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># getset（先get再set）</span></span><br><span class="line"><span class="string">getset</span> <span class="string">db</span> <span class="string">mongodb</span></span><br></pre></td></tr></table></figure>

<h2 id="4-4、列表List"><a href="#4-4、列表List" class="headerlink" title="4.4、列表List"></a>4.4、列表List</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">LPUSH</span> <span class="string">list</span> <span class="string">&quot;one&quot;</span>	<span class="comment"># 将一个或多个值插入到列表头部。（左）</span></span><br><span class="line"><span class="string">LPUSH</span> <span class="string">list</span> <span class="string">&quot;two&quot;</span>	</span><br><span class="line"><span class="string">RPUSH</span> <span class="string">list</span> <span class="string">&quot;right&quot;</span>	<span class="comment"># rpush：将一个或多个值插入到列表尾部。（右）</span></span><br><span class="line"><span class="comment"># lrange：返回指定区间内的元素，0表示第一个元素，-1表示最后一个元素</span></span><br><span class="line"><span class="string">Lrange</span> <span class="string">list</span> <span class="number">0</span> <span class="number">-1</span>     <span class="comment">#  1) &quot;two&quot;、2) &quot;one&quot;、3) &quot;right&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">Lpop</span> <span class="string">list</span>          <span class="comment"># 返回并移除第一个元素。不存在时，返回 nil 。 </span></span><br><span class="line"><span class="string">Rpop</span> <span class="string">list</span>          <span class="comment"># 最后一个元素 </span></span><br><span class="line"></span><br><span class="line"><span class="string">Lindex</span> <span class="string">list</span> <span class="number">1</span>      <span class="comment"># 按照索引下标获得元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">Llen</span> <span class="string">list</span>          <span class="comment"># 返回列表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="string">lrem</span> <span class="string">list</span> <span class="number">1</span> <span class="string">&quot;two&quot;</span>  <span class="comment"># 移除列表里的two元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">ltrim</span> <span class="string">mylist</span> <span class="number">1</span> <span class="number">2</span>	<span class="comment"># 保留指定区间内的元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">rpoplpush</span> <span class="string">list</span> <span class="string">mylist</span>   <span class="comment"># 把list最后一个移到mylist里面</span></span><br><span class="line"></span><br><span class="line"><span class="string">lset</span> <span class="string">list</span> <span class="number">1</span> <span class="string">&quot;world&quot;</span>	<span class="comment"># 更改list的值</span></span><br><span class="line"></span><br><span class="line"><span class="string">linsert</span> <span class="string">list</span> <span class="string">before</span> <span class="string">&quot;world&quot;</span> <span class="string">&quot;hello&quot;</span>   <span class="comment"># hello 插到world前面</span></span><br></pre></td></tr></table></figure>

<h2 id="4-5、哈希Hash"><a href="#4-5、哈希Hash" class="headerlink" title="4.5、哈希Hash"></a>4.5、哈希Hash</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hset</span> <span class="string">myhash</span> <span class="string">key1</span> <span class="string">&quot;wzh&quot;</span>  <span class="comment"># 设置myhash的键值对为key1和&quot;wzh&quot;</span></span><br><span class="line"><span class="string">hget</span> <span class="string">myhash</span> <span class="string">key1</span>        <span class="comment"># 获得myhash的key1的值</span></span><br><span class="line"><span class="string">HMSET</span> <span class="string">myhash</span> <span class="string">field1</span> <span class="string">&quot;Hello&quot;</span> <span class="string">field2</span> <span class="string">&quot;World&quot;</span>  <span class="comment"># 设置多个</span></span><br><span class="line"><span class="string">hgetall</span> <span class="string">myhash</span>          <span class="comment"># 展示所有值，格式为键一行，值在键下一行</span></span><br><span class="line"><span class="string">hdel</span> <span class="string">myhash</span> <span class="string">field1</span>      <span class="comment"># 删除键</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">hlen</span> <span class="string">myhash</span>		<span class="comment"># hlen 获取哈希表长度</span></span><br><span class="line"><span class="string">hexists</span> <span class="string">myhash</span> <span class="string">field1</span>    <span class="comment"># 是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="string">hkeys</span> <span class="string">myhash</span> 	<span class="comment"># 获得所有域（field），键</span></span><br><span class="line"><span class="string">hvals</span> <span class="string">myhash</span>	<span class="comment"># 获得所有域（field）的值</span></span><br><span class="line"></span><br><span class="line"><span class="string">hincrby</span> <span class="string">myhash</span> <span class="string">nums</span> <span class="number">1</span>   <span class="comment"># myhash表的nums的值增1</span></span><br><span class="line"></span><br><span class="line"><span class="string">hsetnx</span> <span class="string">myhash</span> <span class="string">happy</span> <span class="string">&quot;hello&quot;</span> <span class="comment"># 未不存在的字段复制，存在返回0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-6、集合Set"><a href="#4-6、集合Set" class="headerlink" title="4.6、集合Set"></a>4.6、集合Set</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sadd</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span>   <span class="comment"># 将一个或多个成员元素加入</span></span><br><span class="line"><span class="string">SMEMBERS</span> <span class="string">myset</span>		 <span class="comment"># 返回集合中的所有的成员。</span></span><br><span class="line"><span class="string">SISMEMBER</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span> <span class="comment"># 判断是否在集合里面</span></span><br><span class="line"></span><br><span class="line"><span class="string">scard</span> <span class="string">myset</span>	<span class="comment"># scard，获取集合里面的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="string">srem</span> <span class="string">myset</span> <span class="string">&quot;hello&quot;</span> <span class="string">&quot;xuexi&quot;</span>	<span class="comment"># 移除集合中的一个或多个成员</span></span><br><span class="line"></span><br><span class="line"><span class="string">srandmember</span> <span class="string">myset</span> <span class="number">2</span>  <span class="comment"># 返回2个随机元素</span></span><br><span class="line"><span class="string">spop</span> <span class="string">myset</span> <span class="number">2</span>		 <span class="comment"># 移除2个随机元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">smove</span> <span class="string">myset</span> <span class="string">set</span> <span class="string">&quot;hello&quot;</span> <span class="comment"># hello移到set集合李阿敏里面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合</span></span><br><span class="line"><span class="string">SDIFF</span> <span class="string">key1</span> <span class="string">key2</span>    <span class="comment"># 差集 </span></span><br><span class="line"><span class="string">SINTER</span> <span class="string">key1</span> <span class="string">key2</span>   <span class="comment"># 交集 </span></span><br><span class="line"><span class="string">SUNION</span> <span class="string">key1</span> <span class="string">key2</span>   <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure>

<h2 id="4-7、有序集合Zset"><a href="#4-7、有序集合Zset" class="headerlink" title="4.7、有序集合Zset"></a>4.7、有序集合Zset</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zadd</span> <span class="string">salary</span> <span class="number">1</span> <span class="string">&quot;one&quot;</span>		<span class="comment"># 加入1个或者多个</span></span><br><span class="line"><span class="string">zadd</span> <span class="string">salary</span> <span class="number">2</span> <span class="string">&quot;two&quot;</span> <span class="number">3</span> <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="string">zrange</span> <span class="string">salary</span> <span class="number">0</span> <span class="number">-1</span>		<span class="comment"># 返回指定区间的成员</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">zrangebyscore</span> <span class="string">salary</span> <span class="string">-inf</span> <span class="string">+inf</span>     <span class="comment"># 从负无穷大到正无穷大，递增显示</span></span><br><span class="line"><span class="string">zrevrange</span> <span class="string">salary</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span>   <span class="comment"># 递减排列   </span></span><br><span class="line"><span class="string">zrangebyscore</span> <span class="string">salary</span> <span class="string">-inf</span> <span class="number">2500 </span><span class="string">WITHSCORES</span>     <span class="comment"># 工资小于2500,递增</span></span><br><span class="line"></span><br><span class="line"><span class="string">zrem</span> <span class="string">salaryt</span> <span class="string">&quot;one&quot;</span>	<span class="comment"># zrem 删除集合成员</span></span><br><span class="line"></span><br><span class="line"><span class="string">zcard</span> <span class="string">salary</span>			<span class="comment"># 返回长度</span></span><br><span class="line"><span class="string">zcount</span> <span class="string">salary</span> <span class="number">10</span> <span class="number">3000</span>	<span class="comment"># 返回指定区间成员数量。</span></span><br><span class="line"></span><br><span class="line"><span class="string">zrank</span> <span class="string">salary</span> <span class="string">wzh</span>  	<span class="comment"># 从0开始，由小到大，显示排名，即第几个</span></span><br><span class="line"><span class="string">zrevrank</span> <span class="string">salary</span> <span class="string">zk</span> 	<span class="comment"># 即倒数第几个</span></span><br></pre></td></tr></table></figure>

<h1 id="5、三种特殊数据类型"><a href="#5、三种特殊数据类型" class="headerlink" title="5、三种特殊数据类型"></a>5、三种特殊数据类型</h1><h2 id="5-1、GEO地理位置"><a href="#5-1、GEO地理位置" class="headerlink" title="5.1、GEO地理位置"></a>5.1、GEO地理位置</h2><p>Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。</p>
<p><strong>geo的数据类型为zset。</strong></p>
<p>GEO 共有六个常用命令：geoadd、geopos、geodist、georadius、georadiusbymember、gethash</p>
<blockquote>
<p>geoadd：设置地点</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">geoadd</span> <span class="string">key</span> <span class="string">longitude</span> <span class="string">latitude</span> <span class="string">member</span></span><br><span class="line"><span class="string">geoadd</span> <span class="string">china:city</span> <span class="number">116.23</span> <span class="number">40.22</span> <span class="string">北京</span></span><br><span class="line"><span class="string">geoadd</span> <span class="string">china:city</span> <span class="number">121.48</span> <span class="number">31.40</span> <span class="string">上海</span> <span class="number">113.88</span> <span class="number">22.55</span> <span class="string">深圳</span> <span class="number">120.21</span> <span class="number">30.20</span> <span class="string">杭州</span></span><br><span class="line"><span class="comment"># 将给定的空间元素(纬度、经度、名字)添加到指定的键里面。 </span></span><br><span class="line"><span class="comment"># 这些数据会以有序集he的形式被储存在键里面，从而使得georadius和georadiusbymember这样的 命令可以在之后通过位置查询取得这些元素。 </span></span><br><span class="line"><span class="comment"># geoadd命令以标准的x,y格式接受参数,所以用户必须先输入经度,然后再输入纬度。 </span></span><br><span class="line"><span class="comment"># geoadd能够记录的坐标是有限的:非常接近两极的区域无法被索引。 </span></span><br><span class="line"><span class="comment"># 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间。， 当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>geopos：查找经纬度</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">geopos</span> <span class="string">key</span> <span class="string">member</span> [<span class="string">member...</span>]</span><br><span class="line"><span class="comment">#从key里返回所有给定位置元素的位置（经度和纬度）</span></span><br><span class="line"><span class="string">geopos</span> <span class="string">china:city</span> <span class="string">北京</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>geodist：查找城市间距离</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法 </span></span><br><span class="line"><span class="string">geodist</span> <span class="string">key</span> <span class="string">member1</span> <span class="string">member2</span> [<span class="string">unit</span>]</span><br><span class="line"><span class="string">geodist</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="string">上海</span></span><br><span class="line"><span class="string">geodist</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="string">上海</span> <span class="string">km</span></span><br><span class="line"><span class="comment"># 返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在,那么命令返回空值。</span></span><br><span class="line"><span class="comment"># 指定单位的参数unit必须是以下单位的其中一个： </span></span><br><span class="line"><span class="comment"># m表示单位为米 # km表示单位为千米 # mi表示单位为英里 # ft表示单位为英尺 </span></span><br><span class="line"><span class="comment"># 如果用户没有显式地指定单位参数,那么geodist默认使用米作为单位。 </span></span><br><span class="line"><span class="comment">#geodist命令在计算距离时会假设地球为完美的球形,在极限情况下,这一假设最大会造成0.5%的误 差。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>georadius：以一点为中心查找附近城市</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">georadius</span> <span class="string">key</span> <span class="string">longitude</span> <span class="string">latitude</span> <span class="string">radius</span> <span class="string">m|km|ft|mi</span> [<span class="string">withcoord</span>][<span class="string">withdist</span>] [<span class="string">withhash</span>][<span class="string">asc|desc</span>][<span class="string">count</span> <span class="string">count</span>]</span><br><span class="line"><span class="comment"># 以给定的经纬度为中心， 找出某一半径内的元素</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cli --raw -p 6379  # 强制输出中文，不然乱码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市</span></span><br><span class="line"><span class="string">georadius</span> <span class="string">china:city</span> <span class="number">100</span> <span class="number">30</span> <span class="number">1000 </span><span class="string">km</span></span><br><span class="line"><span class="comment"># withdist 返回位置名称和中心距离</span></span><br><span class="line"><span class="string">georadius</span> <span class="string">china:city</span> <span class="number">100</span> <span class="number">30</span> <span class="number">1000 </span><span class="string">km</span> <span class="string">withdist</span></span><br><span class="line"><span class="comment"># withcoord 返回位置名称和经纬度 </span></span><br><span class="line"><span class="string">georadius</span> <span class="string">china:city</span> <span class="number">100</span> <span class="number">30</span> <span class="number">1000 </span><span class="string">km</span> <span class="string">withcoord</span></span><br><span class="line"><span class="comment"># withdist withcoord 返回位置名称 距离 和经纬度 count 限定寻找个数 </span></span><br><span class="line"><span class="string">georadius</span> <span class="string">china:city</span> <span class="number">100</span> <span class="number">30</span> <span class="number">1000 </span><span class="string">km</span> <span class="string">withcoord</span> <span class="string">withdist</span> <span class="string">count</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>georadiusbymember：以城市为中心查找附近城市</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法 </span></span><br><span class="line"><span class="string">georadiusbymember</span> <span class="string">key</span> <span class="string">member</span> <span class="string">radius</span> <span class="string">m|km|ft|mi</span> [<span class="string">withcoord</span>][<span class="string">withdist</span>] [<span class="string">withhash</span>][<span class="string">asc|desc</span>][<span class="string">count</span> <span class="string">count</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">GEORADIUSBYMEMBER</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="number">1000 </span><span class="string">km</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>geohash：经纬度转换为字符串</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法 </span></span><br><span class="line"><span class="string">geohash</span> <span class="string">key</span> <span class="string">member</span> [<span class="string">member...</span>] </span><br><span class="line"><span class="comment"># Redis使用geohash将二维经纬度转换为一维字符串，</span></span><br><span class="line"><span class="comment">#字符串越长表示位置更精确,两个字符串越相似 表示距离越近。</span></span><br><span class="line"></span><br><span class="line"><span class="string">geohash</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="string">重庆</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>zrem：删除</p>
</blockquote>
<p>GEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除. </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">zrem</span> <span class="string">china:city</span> <span class="string">北京</span> <span class="comment"># 移除元素</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2、HyperLogLog"><a href="#5-2、HyperLogLog" class="headerlink" title="5.2、HyperLogLog"></a>5.2、HyperLogLog</h2><ul>
<li>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</li>
<li>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li>
<li>HyperLogLog则是一种算法，它提供了不精确的去重计数方案。</li>
<li>假如我要统计网页的UV（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的解决方案是使用Set来保存用户id，然后统计Set中的元素数量来获取页面UV。但这种方案只能承载少量用户，一旦用户数量大起来就需要消耗大量的空间来存储用户id。我的目的是统计用户数量而不是保存用户，这简直是个吃力不讨好的方案！而使用Redis的HyperLogLog最多需要12k就可以统计大量的用户数，尽管它大概有0.81%的错误率，但对于统计UV这种不需要很精确的数据是可以忽略不计的。</li>
</ul>
<blockquote>
<p>基数</p>
</blockquote>
<ul>
<li>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。基数估计就是在误差可接受的范围内，快速计算基数。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PFADD</span> <span class="string">mykey</span> <span class="string">a</span> <span class="string">b</span> <span class="string">c</span> <span class="string">d</span> <span class="string">e</span> <span class="string">f</span> <span class="string">g</span> <span class="string">h</span> <span class="string">i</span> <span class="string">j</span>  <span class="comment"># 添加指定元素到 HyperLogLog 中。 </span></span><br><span class="line"><span class="string">PFCOUNT</span> <span class="string">mykey</span>                    <span class="comment"># 返回给定 HyperLogLog 的基数估算值。</span></span><br><span class="line"><span class="string">PFADD</span> <span class="string">mykey2</span> <span class="string">i</span> <span class="string">j</span> <span class="string">z</span> <span class="string">x</span> <span class="string">c</span> <span class="string">v</span> <span class="string">b</span> <span class="string">n</span> <span class="string">m</span> </span><br><span class="line"><span class="string">PFMERGE</span> <span class="string">mykey3</span> <span class="string">mykey</span> <span class="string">mykey2</span>      <span class="comment"># 将多个 合并为并集计算</span></span><br><span class="line"><span class="string">PFCOUNT</span> <span class="string">mykey3</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3、BitMap"><a href="#5-3、BitMap" class="headerlink" title="5.3、BitMap"></a>5.3、BitMap</h2><ul>
<li> Redis 提供了 Bitmap ，Bitmap 通过操作二进制位来进行记录，即为 0 和 1；如果要记录 365 天的打卡情况，使用 Bitmap表示的形式大概如下0101000111000111………………………，节约内存了，365 天相当于 365 bit，又 1 字节 = 8 bit , 所以相当于使用 46 个字节即可。</li>
<li>Bitmaps实际上它就是字符串（key-value），但是可以对字符串位操作</li>
</ul>
<blockquote>
<p>setbit 设置操作</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SETBIT key offset value :</span> <span class="string">设置</span> <span class="string">key</span> <span class="string">的第</span> <span class="string">offset</span> <span class="string">位为value</span> <span class="string">(1或0)</span></span><br><span class="line"><span class="comment"># value只能为0或者1</span></span><br><span class="line"><span class="comment"># 使用 bitmap 来记录上述事例中一周的打卡记录如下所示： </span></span><br><span class="line"><span class="comment"># 周一：1，周二：0，周三：0，周四：1，周五：1，周六：0，周天：0 （1 为打卡，0 为不打卡）</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">2</span> <span class="number">0</span> </span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">5</span> <span class="number">0</span> </span><br><span class="line"><span class="string">setbit</span> <span class="string">sign</span> <span class="number">6</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>getbit 获取操作</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">GETBIT</span> <span class="string">key</span> <span class="string">offset</span>  <span class="comment"># 获取offset设置的值，未设置过默认返回0</span></span><br><span class="line"></span><br><span class="line"><span class="string">getbit</span> <span class="string">sign</span> <span class="number">3</span>      <span class="comment"># 查看周四是否打卡</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>bitcount 统计操作</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计value为1的值得次数 </span></span><br><span class="line"><span class="string">bitcount</span> <span class="string">sign</span></span><br></pre></td></tr></table></figure>

<ul>
<li>僵尸粉大多，其实还不如用set集合</li>
</ul>
<h1 id="6、Redis-conf"><a href="#6、Redis-conf" class="headerlink" title="6、Redis.conf"></a>6、Redis.conf</h1><ul>
<li>Redis 的配置文件位于 Redis 安装目录下，文件名为 <strong>redis.conf</strong></li>
</ul>
<blockquote>
<p>Units 单位</p>
</blockquote>
<p><img src="/img/Redis/2.jpg"></p>
<ul>
<li>配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit</li>
<li>对 大小写 不敏感</li>
</ul>
<blockquote>
<p>INCLUDES 包含</p>
</blockquote>
<p><img src="/img/Redis/3.jpg"></p>
<blockquote>
<p>NETWORK 网络配置</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bind</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>     <span class="comment"># 绑定的ip,只接受本机的访问请求</span></span><br><span class="line"><span class="string">protected-mode</span> <span class="literal">yes</span> <span class="comment"># 保护模式,没密码时，只接受本机响应 </span></span><br><span class="line"><span class="string">port</span> <span class="number">6379</span>          <span class="comment"># 默认端口</span></span><br><span class="line"><span class="string">tcp-backlog</span> <span class="number">511</span>    <span class="comment"># backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列</span></span><br><span class="line"><span class="string">timeout</span> <span class="number">0</span>		   <span class="comment"># 空闲的客户端维持多少秒关闭</span></span><br><span class="line"><span class="string">tcp-keepalive</span> <span class="number">300</span>  <span class="comment"># 对访问客户端的一种心跳检测，,0不检测</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>GENERAL 通用</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span> <span class="comment"># yes 开启作为守护线程</span></span><br><span class="line"><span class="string">supervised</span> <span class="literal">no</span> <span class="comment"># 可通过upstart和systemd管理Redis守护进程 </span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/var/run/redis_6379.pid</span> <span class="comment"># pid文件位置</span></span><br><span class="line"><span class="string">loglevel</span> <span class="string">notice</span> <span class="comment"># 日志级别。可选项有： </span></span><br><span class="line">				<span class="comment"># debug（记录大量日志信息，适用于开发、测试阶段）；</span></span><br><span class="line">                <span class="comment"># verbose（较多日志信息）；</span></span><br><span class="line">                <span class="comment"># notice（适量日志信息，使用于生产环境）； </span></span><br><span class="line">                <span class="comment"># warning（仅有部分重要、关键信息才会被记录）。 </span></span><br><span class="line"><span class="string">logfile</span> <span class="string">&quot;&quot;</span>		<span class="comment"># 日志文件的位置，当指定为空字符串时，为标准输出 </span></span><br><span class="line"><span class="string">databases</span> <span class="number">16</span> 	<span class="comment"># 设置数据库的数目。默认的数据库是DB 0 </span></span><br><span class="line"><span class="string">always-show-logo</span> <span class="literal">yes</span> <span class="comment"># 是否总是显示logo</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>SNAPSHOPTING 快照</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） </span></span><br><span class="line"><span class="string">save</span> <span class="number">900</span> <span class="number">1</span> </span><br><span class="line"><span class="comment"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） </span></span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">10</span> </span><br><span class="line"><span class="comment"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化） </span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span> </span><br><span class="line"><span class="comment"># 持久化出现错误后，是否依然进行继续进行工作 </span></span><br><span class="line"><span class="string">stop-writes-on-bgsave-error</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 使用压缩rdb文件 yes：压缩，cpu消耗。no：不压缩，消耗磁盘空间</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 是否校验rdb文件，保存rdb文件的时 候，会有大概10%的性能损耗</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span> </span><br><span class="line"><span class="comment"># dbfilenamerdb的文件名称</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump.rdb</span> </span><br><span class="line"><span class="comment"># dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span></span><br><span class="line"><span class="string">dir</span> <span class="string">./</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>REPLICATION 复制 </p>
</blockquote>
<ul>
<li>看后面的主从复制</li>
</ul>
<blockquote>
<p>SECURITY安全</p>
</blockquote>
<ul>
<li>访问密码的查看，设置和取消</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动redis </span></span><br><span class="line"><span class="comment"># 连接客户端 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得和设置密码 </span></span><br><span class="line"><span class="string">config</span> <span class="string">get</span> <span class="string">requirepass</span> </span><br><span class="line"><span class="string">config</span> <span class="string">set</span> <span class="string">requirepass</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="comment">#测试ping，发现需要验证 </span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ping</span> </span><br><span class="line"><span class="string">NOAUTH</span> <span class="string">Authentication</span> <span class="string">required.</span> </span><br><span class="line"><span class="comment"># 验证 </span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">auth</span> <span class="number">123456</span> </span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ping</span> </span><br><span class="line"><span class="string">PONG</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>LIMITS限制</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">maxclients</span> <span class="number">10000</span>   <span class="comment"># 设置能连上redis的最大客户端连接数量 </span></span><br><span class="line"><span class="string">maxmemory</span> <span class="string">&lt;bytes&gt;</span>  <span class="comment"># redis配置的最大内存容量 </span></span><br><span class="line"></span><br><span class="line"><span class="string">maxmemory-policy</span> <span class="string">noeviction</span></span><br><span class="line"><span class="comment"># maxmemory-policy 内存达到上限的处理策略 </span></span><br><span class="line">	<span class="comment">#volatile-lru：利用LRU算法移除设置过过期时间的key。 </span></span><br><span class="line">	<span class="comment">#volatile-random：随机移除设置过过期时间的key。 </span></span><br><span class="line">	<span class="comment">#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL） </span></span><br><span class="line">	<span class="comment">#allkeys-lru：利用LRU算法移除任何key。 </span></span><br><span class="line">	<span class="comment">#allkeys-random：随机移除任何key。</span></span><br><span class="line">    <span class="comment">#noeviction：不移除任何key，只是返回一个写错误。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>append only模式</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appendonly</span> <span class="literal">no</span> </span><br><span class="line"><span class="comment"># 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这种 方式在许多应用中已经足够用了</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># appendfilename AOF 文件名称 </span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span> 			<span class="comment"># appendfsync aof持久化策略的配置 </span></span><br><span class="line">		<span class="comment"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。 </span></span><br><span class="line">		<span class="comment"># always表示每次写入都执行fsync，以保证数据同步到磁盘。</span></span><br><span class="line">        <span class="comment"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br></pre></td></tr></table></figure>



<h1 id="7、Redis的持久化"><a href="#7、Redis的持久化" class="headerlink" title="7、Redis的持久化"></a>7、Redis的持久化</h1><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。</p>
<h2 id="7-1、RDB（默认）"><a href="#7-1、RDB（默认）" class="headerlink" title="7.1、RDB（默认）"></a>7.1、RDB（默认）</h2><p><strong>概念：</strong>指定的时间间隔内将内存的数据集写入<strong>dump.rdb</strong> <strong>文件</strong>（快照），恢复时读取文件</p>
<p><strong>执行过程：</strong>Redis单独创建（Fork）一个子进程进行持久化，先把数据写入临时文件中，结束后用临时文件替换上次的文件。</p>
<p><strong>优点：</strong>持久化不进行IO操作，效率高；性能比AOF更好，适合大规模、数据不敏感的情况</p>
<p><strong>缺点：</strong>最后一次快照后的修改易丢失；Fork的时候，克隆大致2倍的膨胀性需要考虑</p>
<p><strong>Fork：</strong>复制一个与当前进程完全一致一样的进程，并作为原进程的子进程</p>
<blockquote>
<p>配置位置及SNAPSHOTTING解析</p>
</blockquote>
<ul>
<li>默认配置</li>
</ul>
<p><img src="/img/Redis/1.jpg"></p>
<ul>
<li>可以修改触发条件机制</li>
<li>不设置任何save，即可禁用RDB</li>
<li>若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效 !</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">save</span> <span class="number">120</span> <span class="number">10</span> <span class="comment"># 120秒内修改10次则触发RDB</span></span><br><span class="line"></span><br><span class="line"><span class="string">flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 bgsave 会在后台异步进行快照</li>
<li>lastsave 命令获取最后一次成功执行快照的时间</li>
</ul>
<blockquote>
<p>配置文件</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span> <span class="comment"># 存储快照后，进行压缩</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span>	   <span class="comment"># 存储快照后，会开启数据检验，但会多消耗10%性能</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>恢复</p>
</blockquote>
<p>将备份文件（dump.rdb）移动到redis安装目录并启动服务即可</p>
<h2 id="7-2、AOF"><a href="#7-2、AOF" class="headerlink" title="7.2、AOF"></a>7.2、AOF</h2><p><strong>概念：</strong>用日志的形式， 把指令（读除外）记录下来，每次重启需要<code>重新执行指令</code>。</p>
<p><strong>执行过程：</strong></p>
<ol>
<li>客户端请求的命令追加到 AOF缓存区，</li>
<li>根据持久化策略异步的把缓存区 同步到 appendonly.aof 文件</li>
<li>同步后如果文件大小超过阈值（大了64M），会对appendonly.aof 文件进行重写。</li>
</ol>
<p><strong>特点：</strong>可以追加指令到文件，但是不可以改写文件</p>
<p><strong>同步规则：</strong>1、不设置规则让操作系统决定   2、每次修改同步    3、每秒同步（建议）   </p>
<p><strong>重写 rewrite</strong>：fork处一条新进程，通过读取缓存的数据，实现指令的压缩。</p>
<p><strong>缺点：</strong>同样容量文件AOF远大于RDB，恢复速度因此更慢</p>
<p><strong>优点：</strong>每次修改就保存策略可以<code>不丢失数据</code>，每秒的形式兼顾性能和效果。</p>
<p><strong>注意点：</strong>不同步效率和rdb相同。</p>
<blockquote>
<p>配置</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appendonly</span> <span class="literal">no</span> <span class="comment"># 持久化方式，</span></span><br><span class="line"><span class="comment"># 默认使用的是rdb方式持久化，这种方式在许多应用中已经足够用了 </span></span><br><span class="line"><span class="comment"># 设置成yes，开启AOF方式</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># appendfilename AOF 生成文件名称</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span> <span class="comment"># appendfsync aof持久化策略的配置 </span></span><br><span class="line"><span class="comment"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。 </span></span><br><span class="line"><span class="comment"># always表示每次写入都执行fsync，以保证数据同步到磁盘。 </span></span><br><span class="line"><span class="comment"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br><span class="line"></span><br><span class="line"><span class="literal">no</span><span class="string">-appendfsync-on-rewrite</span> <span class="literal">no</span> </span><br><span class="line"><span class="comment"># 重写时是否可以运用Appendfsync，用默认no即可保证数据安全性</span></span><br><span class="line"><span class="comment"># yes：不写入aof文件只写入缓存，用户请求不会阻塞</span></span><br><span class="line"><span class="comment"># no，会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="string">Auto-aof-rewrite-min-size</span>        <span class="comment"># 设置重写的基准值 </span></span><br><span class="line"><span class="string">Auto-aof-rewrite-percentage</span>      <span class="comment"># 设置重写的基准值</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据恢复</p>
</blockquote>
<p><strong>正常恢复：</strong></p>
<ul>
<li>启动：修改默认的appendonly no，改为yes</li>
<li>将有数据的aof文件复制一份保存到对应目录</li>
<li>恢复：重启redis然后重新加载</li>
</ul>
<p><strong>异常恢复：</strong></p>
<ul>
<li>启动：修改默认的appendonly no，改为yes</li>
<li>故意破坏 appendonly.aof 文件！</li>
<li>修复： redis-check-aof –fix appendonly.aof 进行修复</li>
<li>恢复：重启 redis 然后重新加载</li>
</ul>
<h2 id="7-3、总结"><a href="#7-3、总结" class="headerlink" title="7.3、总结"></a>7.3、总结</h2><p><strong>RDB：</strong>性能高，但是容易丢失修改的操作。</p>
<p><strong>AOF：</strong>性能低，但是对文件的修改保存的更好。</p>
<p><strong>使用建议：</strong>同时开启 RDB 和 AOF</p>
<ol>
<li>Redis 重启 优先加载 AOF，因为AOF往往记录更加完整。</li>
<li>RDB 作为后备用途，更适合用于备份数据库（AOF在不断变化不好备份）。</li>
</ol>
<p><strong>性能建议</strong></p>
<ul>
<li>RDB文件只用作后备用途，建议只在Slave（从机）上持久化RDB文件，而且只要15分钟备份一次就够了，保留 save 900 1 这条规则。</li>
<li>如果开启AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li>
<li>如果不开启 AOF ，仅靠 Master-Slave Repllcation （主从复制）实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li>
</ul>
<h1 id="8、Redis事务"><a href="#8、Redis事务" class="headerlink" title="8、Redis事务"></a>8、Redis事务</h1><p><strong>本质</strong>：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令</p>
<p><strong>特点：</strong>不存在隔离级别，ACID原则，回滚</p>
<ol>
<li>事务开启并不会执行命令，而是放入缓存；命令会被序列化，等提交后依次执行。</li>
<li>在执行事务之前，事务支持被打断（类似<code>乐观锁机制</code>）</li>
</ol>
<p><strong>原子性：</strong>可以使用Lua语言来实现原子性。</p>
<p><strong>Redis事务的三个阶段</strong>：1、开始事务  2、命令入队  3、执行事务</p>
<p><strong>Redis事务相关命令</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">watch</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">...</span> <span class="comment">#监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则 事务被打断(类似乐观锁)</span></span><br><span class="line"><span class="string">multi</span>    <span class="comment"># 标记一个事务块的开始(queued) 标记之后，结束之前指令会加入队列但不执行。</span></span><br><span class="line"><span class="string">exec</span>     <span class="comment"># 执行所有事务块的命令(一旦执行exec后，之前加的监控锁都会被取消掉) </span></span><br><span class="line"></span><br><span class="line"><span class="string">discard</span>  <span class="comment"># 取消事务，放弃事务块中的所有命令 </span></span><br><span class="line"><span class="string">unwatch</span>  <span class="comment"># 取消watch对所有key的监控</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>正常执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">multi       # 开始事务</span><br><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">get k2</span><br><span class="line">set k3 v3</span><br><span class="line">exec        # 执行事务</span><br></pre></td></tr></table></figure>

<blockquote>
<p>放弃事务</p>
</blockquote>
<ul>
<li>全部都不执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multi       # 开始事务</span><br><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">discard     # 放弃事务</span><br><span class="line">exec        # 执行事务</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事务出现命令错误，语法对</p>
</blockquote>
<ul>
<li>执行阶段发生错误，错误的不执行，其他都执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multi       # 开始事务</span><br><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">get k3 v3   # 错误命令</span><br><span class="line">exec        # 执行事务</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事务出现语法错误</p>
</blockquote>
<ul>
<li>执行阶段前发生错误，全部都不执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multi       # 开始事务</span><br><span class="line">set k1      # 语法错误</span><br><span class="line">set k2 v2</span><br><span class="line">exec        # 执行事务</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Watch监控：实现乐观锁</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现乐观锁机制</span></span><br><span class="line"><span class="string">set</span> <span class="string">balance</span> <span class="number">100</span>  <span class="comment"># 余额100</span></span><br><span class="line"><span class="string">set</span> <span class="string">debt</span> <span class="number">0</span>       <span class="comment"># 欠款0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用watch检测balance，事务期间balance数据未变动，事务执行成功</span></span><br><span class="line"><span class="string">watch</span> <span class="string">balance</span>          <span class="comment"># 开启监控</span></span><br><span class="line"><span class="string">MULTI</span>                  <span class="comment"># 开始事务</span></span><br><span class="line"><span class="string">decrby</span> <span class="string">balance</span> <span class="number">20</span>      <span class="comment"># 减少余额20</span></span><br><span class="line"><span class="string">incrby</span> <span class="string">debt</span> <span class="number">20</span>         <span class="comment"># 增加欠款20</span></span><br><span class="line"><span class="string">exec</span>                   <span class="comment"># 执行事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若中途balance有变化，就会执行失败</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一但执行 EXEC 开启事务的执行后， WARCH 对变量的监控就会被取消。</li>
<li>所以事务失败后，需要重新使用watch变量监视</li>
</ul>
<h1 id="9、发布订阅"><a href="#9、发布订阅" class="headerlink" title="9、发布订阅"></a>9、发布订阅</h1><p><strong>概念：</strong></p>
<ul>
<li>Redis 发布订阅(pub/sub)是一种消息通信模式：</li>
<li>发送者(pub)发送消息，订阅者(sub)接收消息。</li>
<li>Redis 客户端可以订阅任意数量的频道。</li>
<li>每当有新消息通过publish命令发送给频道时，消息就会发送给所有客户端</li>
</ul>
<blockquote>
<p>命令</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅一个或多个符合给定模式的频道。</span></span><br><span class="line"><span class="string">PSUBSCRIBE</span> <span class="string">pattern</span> [<span class="string">pattern</span> <span class="string">...</span>] </span><br><span class="line"><span class="comment"># 查看订阅与发布系统状态。</span></span><br><span class="line"><span class="string">PUBSUB</span> <span class="string">subcommand</span> [<span class="string">argument</span> [<span class="string">argument</span> <span class="string">...</span>]] </span><br><span class="line"><span class="string">PUBSUB</span> <span class="string">Channels</span> <span class="string">myChat</span></span><br><span class="line"><span class="comment"># 将信息发送到指定的频道。</span></span><br><span class="line"><span class="string">PUBLISH</span> <span class="string">channel</span> <span class="string">message</span> </span><br><span class="line"><span class="comment"># 退订所有给定模式的频道。</span></span><br><span class="line"><span class="string">PUNSUBSCRIBE</span> [<span class="string">pattern</span> [<span class="string">pattern</span> <span class="string">...</span>]] </span><br><span class="line"><span class="comment"># 订阅给定的一个或多个频道的信息。</span></span><br><span class="line"><span class="string">SUBSCRIBE</span> <span class="string">channel</span> [<span class="string">channel</span> <span class="string">...</span>] </span><br><span class="line"><span class="comment"># 指退订给定的频道。</span></span><br><span class="line"><span class="string">UNSUBSCRIBE</span> [<span class="string">channel</span> [<span class="string">channel</span> <span class="string">...</span>]] </span><br></pre></td></tr></table></figure>

<blockquote>
<p>实战</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建订阅频道名字为myChat</span></span><br><span class="line"><span class="string">SUBSCRIBE</span> <span class="string">myChat</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 新开一个客户端连接redis，同一个频道myChat发布消息</span></span><br><span class="line"><span class="string">publish</span> <span class="string">myChat</span> <span class="string">&quot;hello,redis&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个客户端就能收到信息</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理</p>
</blockquote>
<p><strong>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能</strong></p>
<ul>
<li> SUBSCRIBE 命令订阅某频道后，redis-server 里会维护了一个字典，字典的键就是一个个 channel（频道），而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中</li>
<li>PUBLISH 命令向订阅者发送消息，根据链表发送给所有客户端</li>
</ul>
<blockquote>
<p>使用场景</p>
</blockquote>
<ul>
<li>Pub/Sub构建实时消息系统</li>
</ul>
<h1 id="10、主从复制"><a href="#10、主从复制" class="headerlink" title="10、主从复制"></a>10、主从复制</h1><h2 id="10-1、概念"><a href="#10-1、概念" class="headerlink" title="10.1、概念"></a>10.1、概念</h2><ul>
<li>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。</li>
<li>前者称为主节点(master/leader)，后者称为从节点(slave/follower)；</li>
<li>数据的复制是<strong>单向的，只能由主到从</strong>。Master以写为主，Slave 以读为主。</li>
<li>默认情况下，每台Redis服务器都是主节点，一个从节点只能有一个主节点。</li>
</ul>
<h2 id="10-2、-优点"><a href="#10-2、-优点" class="headerlink" title="10.2、 优点"></a>10.2、 优点</h2><ul>
<li>数据冗余：主从复制实现了数据的<strong>热备份</strong>，是持久化外的一种数据冗余方式</li>
<li>故障恢复：当主节点出现问题时，可以由从节点故障恢复；服务的冗余。</li>
<li>负载均衡：配合读写分离，可以由主节点提供写服务，由从节点提供读服务分担服务器负载；大大提高Redis服务器的并发量。</li>
<li>高可用基石：主从复制是<strong>哨兵</strong>和<strong>集群</strong>能够实施的基础。</li>
</ul>
<h2 id="10-3、环境配置"><a href="#10-3、环境配置" class="headerlink" title="10.3、环境配置"></a>10.3、环境配置</h2><ul>
<li>准备</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前库的信息</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">info</span> <span class="string">replication</span></span><br><span class="line"><span class="string">role:master</span>            <span class="comment"># 角色，主机</span></span><br><span class="line"><span class="string">connected_slaves:0</span>     <span class="comment"># 从机  0 个</span></span><br></pre></td></tr></table></figure>

<h3 id="1、启动三个redis"><a href="#1、启动三个redis" class="headerlink" title="1、启动三个redis"></a>1、启动三个redis</h3><ul>
<li>复制启动文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cp</span> <span class="string">redis.conf</span> <span class="string">redis79.conf</span>  <span class="comment"># 依次复制三份</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">vim</span> <span class="string">redis79.conf</span>   <span class="comment"># 先进入配置文件</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/www/server/redis/redis6379.pid</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">&quot;/www/server/redis/redis6379.log&quot;</span>  <span class="comment">#日志文件修改</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump6379.rdb</span>   <span class="comment"># 默认持久化文件名修改</span></span><br><span class="line"></span><br><span class="line"><span class="string">vim</span> <span class="string">redis80.conf</span>   <span class="comment"># 先进入配置文件</span></span><br><span class="line"><span class="string">port</span> <span class="number">6380</span>          <span class="comment"># 修改端口号</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/www/server/redis/redis6380.pid</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">&quot;/www/server/redis/redis6380.log&quot;</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump6380.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次配置81</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动redis</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/www/server/redis/src/redis-server /www/server/redis/redis.conf</span><br><span class="line"></span><br><span class="line">/www/server/redis/src/redis-server /www/server/redis/redis79.conf</span><br><span class="line">redis-cli -p 6379</span><br><span class="line"></span><br><span class="line">/www/server/redis/src/redis-server /www/server/redis/redis80.conf</span><br><span class="line">/www/server/redis/src/redis-server /www/server/redis/redis81.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>查看进程信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure>

<h3 id="2、暂时配置主从"><a href="#2、暂时配置主从" class="headerlink" title="2、暂时配置主从"></a>2、暂时配置主从</h3><ul>
<li>开始配置</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">info</span> <span class="string">replication</span>  <span class="comment"># 默认都是主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置79 为主机 80 81为从机</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6380&gt;</span> <span class="string">slaveof</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span>  <span class="comment"># 设置认 6379 当做主机</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6380&gt;</span> <span class="string">info</span> <span class="string">replication</span>        <span class="comment"># 此时信息显示该为从机</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6381&gt;</span> <span class="string">slaveof</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span>  <span class="comment"># 设置认 6379 当做主机</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6381&gt;</span> <span class="string">info</span> <span class="string">replication</span>        <span class="comment"># 此时信息显示该为从机</span></span><br></pre></td></tr></table></figure>

<h3 id="3、永久配置主从"><a href="#3、永久配置主从" class="headerlink" title="3、永久配置主从"></a>3、永久配置主从</h3><ul>
<li>再配置文件中找到replication修改</li>
</ul>
<p><img src="/img/Redis/4.jpg"></p>
<ul>
<li>去掉注释 &lt;&gt; 里面写入内容即可</li>
<li>地址 主机IP      replicaof 127.0.0.1 6379</li>
<li>主机密码</li>
</ul>
<h3 id="4、关闭服务"><a href="#4、关闭服务" class="headerlink" title="4、关闭服务"></a>4、关闭服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown save</span><br></pre></td></tr></table></figure>

<h3 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h3><ul>
<li>在主机设置值，在从机都可以取到！从机不能写值</li>
</ul>
<h2 id="10-4、测试"><a href="#10-4、测试" class="headerlink" title="10.4、测试"></a>10.4、测试</h2><h3 id="1、正常读写"><a href="#1、正常读写" class="headerlink" title="1、正常读写"></a>1、正常读写</h3><ul>
<li>在主机设置值，在从机都可以取到（增量复制）！从机不能写值</li>
</ul>
<h3 id="2、宕机"><a href="#2、宕机" class="headerlink" title="2、宕机"></a>2、宕机</h3><ul>
<li><p>主机宕机后，从机还是从机，不会变为主机</p>
</li>
<li><p>主机宕机恢复后，从机会自动重新连接，获取主机新操作</p>
</li>
<li><p>从机宕机恢复后，会自动同步主机的信息（全量复制）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Slave 启动成功连接到 master 后会发送一个sync命令</span><br><span class="line">Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行</span><br><span class="line">完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</span><br><span class="line">全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内中。</span><br><span class="line">增量复制：Master继续将新的所有收集到的修改命令依次传给slave完成同步、</span><br><span class="line"></span><br><span class="line">但是只要是重新连接master，一次完全同步（全量复制）将被自动执行</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3、谋权篡位"><a href="#3、谋权篡位" class="headerlink" title="3、谋权篡位"></a>3、谋权篡位</h3><ul>
<li>一主二从的情况下，主机长时间宕机了怎么办？</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用命令将自己改为主机,原来同步所得的数据集不会被丢弃</span></span><br><span class="line"><span class="string">SLAVEOF</span> <span class="literal">NO</span> <span class="string">ONE</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>若此时原主机再恢复，会成为一个独立的机</li>
</ul>
<h3 id="4、薪火相传"><a href="#4、薪火相传" class="headerlink" title="4、薪火相传"></a>4、薪火相传</h3><ul>
<li>B从机在当A的从机时还充当C的主机，可以减少主机压力</li>
<li>不过B主机作为从机仍然是不能写入的</li>
</ul>
<h2 id="10-5、哨兵模式"><a href="#10-5、哨兵模式" class="headerlink" title="10.5、哨兵模式"></a>10.5、哨兵模式</h2><ul>
<li><strong>谋权篡位</strong>的自动版</li>
<li>后台监控主机，主机故障了就<strong>根据投票数</strong>自动将从库转换为主库。</li>
<li>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，</li>
<li>哨兵是一个独立的进程，作为进程，它会独立运行。</li>
</ul>
<h3 id="1、原理："><a href="#1、原理：" class="headerlink" title="1、原理："></a>1、原理：</h3><ul>
<li>哨兵通过发送命令，等待Redis服务器响应，监控运行的多个Redis实例。</li>
<li>哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改<strong>配置文件</strong>（永久更改），让它们切换主机</li>
<li>原主机回来之后<code>自动变为从机</code></li>
</ul>
<h3 id="2、多哨兵模式："><a href="#2、多哨兵模式：" class="headerlink" title="2、多哨兵模式："></a>2、多哨兵模式：</h3><ul>
<li>一个哨兵可能会出现问题，所以可以使用多个哨兵互相监控。</li>
<li>哨兵1检测到主机宕机，不会立即选取新主机，这个现象成为<strong>主观下线</strong></li>
<li>后面的哨兵也检测到主服务器不可用，且达到一定数量时，会进行投票</li>
<li>投票的结果由一个哨兵发起，进行failover[故障转移]操作，选择新主机，并且通过发布订阅模式，让哨兵通知监视的从机修改配置切换成新主机，该过程成为<strong>客观下线</strong></li>
</ul>
<h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><ul>
<li><p>设置一主二从，79主机，80、81从机</p>
</li>
<li><p>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cd</span> <span class="string">/www/server/redis/</span>  <span class="comment"># 进入目录</span></span><br><span class="line"><span class="string">vim</span> <span class="string">sentinel.conf</span>      <span class="comment"># 进入文件</span></span><br><span class="line"></span><br><span class="line"><span class="string">port</span> <span class="number">26379</span>   <span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line"><span class="string">dir</span> <span class="string">/tmp</span>     <span class="comment"># 哨兵sentinel的工作目录 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line"><span class="comment"># 哨兵sentinel      主机名(自己取) 地址  主机端口号</span></span><br><span class="line"><span class="comment"># 1个哨兵认为宕机就宕机</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379 </span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line"><span class="comment"># 哨兵sentinel   监控 mymaster     连接主机的密码</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">auth-pass</span> <span class="string">mymaster</span> <span class="string">MySUPER--secret-0123passw0rd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; </span></span><br><span class="line"><span class="comment"># 30毫秒之后 主节点没有应答哨兵sentinel ，哨兵就主观上认为主节点下线 </span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">30000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发生failover主备切换时同时只能有1个从机可以对新的主机同步</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; sentinel </span></span><br><span class="line"><span class="string">parallel-syncs</span> <span class="string">mymaster</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间设置为 3分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">180000</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动哨兵</p>
<p>/www/server/redis/src/redis-sentinel /www/server/redis/sentinel.conf</p>
</li>
<li><p>关闭主机</p>
</li>
<li><p>新主机被自动选举出来</p>
</li>
<li><p>原主机重新回来后，只能当从机（永久性的改变）</p>
</li>
</ul>
<h3 id="4、优缺点"><a href="#4、优缺点" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点</strong></p>
<ol>
<li><p>哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。</p>
</li>
<li><p>主从可以切换，故障可以转移，系统可用性更好。</p>
</li>
<li><p>哨兵模式是主从模式的升级，系统更健壮，可用性更高。</p>
</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><p>Redis<strong>较难支持在线扩容</strong>，在集群容量达到上限时在线扩容会变得很复杂。</p>
</li>
<li><p>实现哨兵模式的配置也不简单，甚至可以说有些繁琐</p>
</li>
</ol>
<h1 id="11、Redis集群"><a href="#11、Redis集群" class="headerlink" title="11、Redis集群"></a>11、Redis集群</h1><h2 id="11-1、概念"><a href="#11-1、概念" class="headerlink" title="11.1、概念"></a>11.1、概念</h2><ul>
<li>对Redis的水平扩容，即启动N个redis主节点，将整个数据库<code>均匀分布</code>存储在这N个主节点中，每个主节点存储总数据的1/N。</li>
<li>无中心节点，各个主节点之间保持联系</li>
<li>每个主节点可以有多个从节点</li>
</ul>
<h2 id="11-2、配置"><a href="#11-2、配置" class="headerlink" title="11.2、配置"></a>11.2、配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先复制六份配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后配置文件配置 redis.conf</span></span><br><span class="line"><span class="string">cluster-enabled</span> <span class="literal">yes</span>                  <span class="comment"># 打开集群模式</span></span><br><span class="line"><span class="string">cluster-config-file</span> <span class="string">nodes-6379.conf</span>  <span class="comment"># 设定节点配置文件名</span></span><br><span class="line"><span class="string">cluster-node-timeout</span> <span class="number">15000</span>   </span><br><span class="line"><span class="comment"># 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着配置完之后启动六个redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将六个节点合成一个集群</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">--cluster</span> <span class="string">create</span> <span class="string">--cluster-replicas</span> <span class="number">1</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6379</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6380</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6381</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6389</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6390</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.101</span><span class="string">:6391</span></span><br><span class="line"></span><br><span class="line"><span class="string">不要用127.0.0.1，</span> <span class="string">请用真实IP地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11-3、登录"><a href="#11-3、登录" class="headerlink" title="11.3、登录"></a>11.3、登录</h2><p><strong>普通方式登陆</strong></p>
<ul>
<li>可能直接进入<strong>读主机</strong>，存储数据时，会出现MOVED重定向操作</li>
<li>所以，应该以集群方式登录。</li>
</ul>
<p><strong>集群方式登录：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 6379</span><br></pre></td></tr></table></figure>

<ul>
<li>-c 采用集群策略连接，设置数据会自动切换到相应的写主机</li>
</ul>
<p><strong>查看集群信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>

<h2 id="11-4、节点分配问题"><a href="#11-4、节点分配问题" class="headerlink" title="11.4、节点分配问题"></a>11.4、节点分配问题</h2><ul>
<li>一个集群至少要有三个主节点</li>
<li>选项 –cluster-replicas 1 表示我们希望为集群中的<code>每个主节点创建一个从节点</code></li>
<li>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</li>
</ul>
<h2 id="11-5、Slot插槽"><a href="#11-5、Slot插槽" class="headerlink" title="11.5、Slot插槽"></a>11.5、Slot插槽</h2><ul>
<li>一个 Redis 集群包含 16384 个插槽（hash slot），</li>
<li> 数据库中的每个键都属于这 16384 个插槽的其中一个</li>
<li>集群每个主节点负责一部分插槽，存取值时根据 key(插槽)去对应节点</li>
<li>上面使用   - c  连接后会自动根据插槽，<strong>重定向到合适的主机</strong></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>不是一个插槽下的值，不能使用<strong>mget,mset</strong>等多键操作</p>
</li>
<li><p>不过可以通过  {  } 来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset k1&#123;cust&#125; v1 k2&#123;cust&#125; v2</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>查询值</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">CLUSTER</span> <span class="string">GETKEYSINSLOT</span> <span class="string">&lt;slot&gt;&lt;count&gt;</span></span><br><span class="line"><span class="string">cluster</span> <span class="string">keyslot</span> <span class="string">cust</span> 		<span class="comment"># 返回插槽cust的一个值</span></span><br><span class="line"><span class="string">cluster</span> <span class="string">keyslot</span> <span class="string">cust</span>  <span class="number">10</span> 	<span class="comment"># 返回插槽cust的十个值</span></span><br></pre></td></tr></table></figure>

<h2 id="11-6、故障"><a href="#11-6、故障" class="headerlink" title="11.6、故障"></a>11.6、故障</h2><ul>
<li>如果主节点下线：从节点自动升为主节点</li>
<li>如果主节点恢复：主节点变成了从节点</li>
</ul>
<p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉</p>
<p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，只是<strong>该插槽部分不能使用</strong>，也无法存储。</p>
<h2 id="11-7、缺点"><a href="#11-7、缺点" class="headerlink" title="11.7、缺点"></a>11.7、缺点</h2><ul>
<li>多键操作是不被支持的 </li>
<li>多键的Redis事务是不被支持的。lua脚本不被支持</li>
</ul>
<h1 id="12、Jedis"><a href="#12、Jedis" class="headerlink" title="12、Jedis"></a>12、Jedis</h1><h3 id="1、依赖"><a href="#1、依赖" class="headerlink" title="1、依赖"></a>1、依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;121.41.4.48&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="comment">//查看服务是否运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要先修改</span></span><br><span class="line"><span class="comment">bind 182.100.29.183 </span></span><br><span class="line"><span class="comment">bind 127.0.0.1</span></span><br><span class="line"><span class="comment">protected-mode no</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3、其他代码"><a href="#3、其他代码" class="headerlink" title="3、其他代码"></a>3、其他代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>); </span><br><span class="line"><span class="comment">//验证密码，如果没有设置密码这段代码省略 </span></span><br><span class="line"><span class="comment">// jedis.auth(&quot;password&quot;);</span></span><br><span class="line"></span><br><span class="line">jedis.connect(); <span class="comment">//连接 </span></span><br><span class="line">jedis.disconnect(); <span class="comment">//断开连接 </span></span><br><span class="line">jedis.flushAll(); <span class="comment">//清空所有的key</span></span><br></pre></td></tr></table></figure>

<h3 id="4、操作事务"><a href="#4、操作事务" class="headerlink" title="4、操作事务"></a>4、操作事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建客户端连接服务端，redis服务端需要被开启 </span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>); </span><br><span class="line">jedis.flushDB();</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启事务 </span></span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//向redis存入一条数据 </span></span><br><span class="line">    multi.set(<span class="string">&quot;json&quot;</span>, result); </span><br><span class="line">    <span class="comment">//再存入一条数据 </span></span><br><span class="line">    multi.set(<span class="string">&quot;json2&quot;</span>, result); </span><br><span class="line">    <span class="comment">//这里引发了异常，用0作为被除数 </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>/<span class="number">0</span>; </span><br><span class="line">    <span class="comment">//如果没有引发异常，执行进入队列的命令</span></span><br><span class="line">    multi.exec(); </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">    <span class="comment">//如果出现异常，放弃 </span></span><br><span class="line">    multi.discard(); </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123; </span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json2&quot;</span>)); </span><br><span class="line">    <span class="comment">//最终关闭客户端 </span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、集群情况下"><a href="#5、集群情况下" class="headerlink" title="5、集群情况下"></a>5、集群情况下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JedisCluster jedisCluster=new JedisCluster(set);</span><br><span class="line">jedisCluster.set(&quot;k1&quot;, &quot;v1&quot;);</span><br></pre></td></tr></table></figure>



<h1 id="13、SpringBoot整合"><a href="#13、SpringBoot整合" class="headerlink" title="13、SpringBoot整合"></a>13、SpringBoot整合</h1><h2 id="13-1、分析"><a href="#13-1、分析" class="headerlink" title="13.1、分析"></a>13.1、分析</h2><ul>
<li><p>SpringBoot2之后，jedis变成了lettuce</p>
<ul>
<li>jedis采用的直连，多线程不安全，需要使用连接池</li>
<li>lettuce采用的netty，实例可以再多个线程中共享</li>
</ul>
</li>
<li><p>在SpringBoot中一般使用<strong>RedisTemplate提供的方法</strong>来操作Redis。</p>
</li>
<li><p>RedisAutoConfiguration类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>   <span class="comment">//不存在bean才生效，所以可以自定义</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认的RedisTemplate 没有过多的设置，redis对象需要序列化</span></span><br><span class="line">    <span class="comment">// 两个泛型都是object，我们后使用需要强转</span></span><br><span class="line">   RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">   template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">   <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span> <span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">	StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">	template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">	<span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>默认的序列化配置（通过JDK序列化，使字符串转义）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer keySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer valueSerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashKeySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashValueSerializer = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-2、简单测试"><a href="#13-2、简单测试" class="headerlink" title="13.2、简单测试"></a>13.2、简单测试</h2><ul>
<li>确保有如下依赖</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>yaml（可以查看 RedisProperties 分析）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">121.41</span><span class="number">.4</span><span class="number">.48</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	opsForValue() 操作字符串 </span></span><br><span class="line"><span class="comment">    	opsForList()  操作list</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;myKey&quot;</span>,<span class="string">&quot;myValue&quot;</span>);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;myKey&quot;</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取redis连接对象</span></span><br><span class="line">     RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        connection.flushAll();</span><br></pre></td></tr></table></figure>



<h2 id="13-3、深入测试"><a href="#13-3、深入测试" class="headerlink" title="13.3、深入测试"></a>13.3、深入测试</h2><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">    connection.flushAll();</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;wzh&quot;</span>);</span><br><span class="line">    <span class="comment">//直接传对象会报错，转换成json字符串</span></span><br><span class="line">    <span class="comment">// 或者user对象继承serializable类序列化</span></span><br><span class="line">    String jsonUser = <span class="keyword">new</span> ObjectMapper().writeValueAsString(user);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>, jsonUser);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xac\xed\x00\x05t\x00\x04user&quot;</span>  JDK序列化会显示成这样</span><br></pre></td></tr></table></figure>

<ul>
<li>编写自定义Redistemplate，自定义序列化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemp</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">//序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer); </span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer); </span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer); </span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">     template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14、常见面试题"><a href="#14、常见面试题" class="headerlink" title="14、常见面试题"></a>14、常见面试题</h1><h2 id="14-1、-Redis-和-Memcached"><a href="#14-1、-Redis-和-Memcached" class="headerlink" title="14.1、 Redis 和 Memcached"></a>14.1、 Redis 和 Memcached</h2><p><strong>共同点</strong> ：</p>
<ul>
<li>都是基于内存的数据库，⼀般都用来来当做缓存使⽤。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常⾼。</li>
</ul>
<p><strong>区别</strong> ：</p>
<ol>
<li>Redis的类型丰富，Memcached只支持最简单的 K / V</li>
<li>Redis 支持持久化，可以有灾难恢复机制，Memcached不支持</li>
<li>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。Memcached则报异常。</li>
<li>Redis 支持原生的集群模式，Memcached没有，需要依靠客户端实现集群中分片写入数据。</li>
<li>Redis 单线程，多路IO复用模型；Memcached多线程，非阻塞 的IO 复用的网络类型。</li>
<li>Redis 支持发布订阅模型、Lua脚本、事务；Memcached不支持</li>
<li>Redis 同时使用了惰性删除与定期删除；Memcached过期数据的删除策略只用了惰性删除。</li>
</ol>
<p>所以现在一般选用 Redis 作为缓存数据库。</p>
<h2 id="14-2、-缓存数据处理流程"><a href="#14-2、-缓存数据处理流程" class="headerlink" title="14.2、 缓存数据处理流程"></a>14.2、 缓存数据处理流程</h2><p><img src="/img/Redis/5.jpg"></p>
<h2 id="14-3、为什么要用Redis-缓存数据库"><a href="#14-3、为什么要用Redis-缓存数据库" class="headerlink" title="14.3、为什么要用Redis/缓存数据库"></a>14.3、为什么要用Redis/缓存数据库</h2><blockquote>
<p>高性能</p>
</blockquote>
<p><strong>作用：</strong>使用缓存主要是为了提升用户体验以及应对更多的用户</p>
<p><strong>第一次读取：</strong>从数据库取出数据较慢，然后同时更新缓存</p>
<p><strong>第二次读取：</strong>直接从缓存读取，很快。</p>
<p><strong>注意：</strong>当数据库的数据改变后，要同步改变缓存中的数据才可以。</p>
<blockquote>
<p>高并发</p>
</blockquote>
<p><strong>QPS（Query Per Second）：</strong>服务器每秒可以执行的查询次数；</p>
<p>⼀般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使⽤ Redis 缓存之后很容易达到 10w+，甚⾄最⾼能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p>
<ul>
<li></li>
</ul>
<h2 id="14-4、Redis单线程模型"><a href="#14-4、Redis单线程模型" class="headerlink" title="14.4、Redis单线程模型"></a>14.4、Redis单线程模型</h2><p><strong>事件处理模型：</strong>Redis基于 Reactor 模式设计开发的 <code>文件事件处理器</code>，文件事件处理器基于单线程运行，使用 IO 多路复用技术来同时监听多个套接字。</p>
<p><strong>IO多路复用模型</strong>：Redis 通过 IO 多路复用程序监听来自客户端的大量连接，它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生，这样 Redis 就不需要 额外创建多余的线程来监听客户端了，降低了资源的消耗。（类似 NIO 的 Selector组件）</p>
<p><strong>多路IO复用技术</strong>：异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</p>
<ul>
<li>文件事件处理器会同时监听多个套接字（Socket），根据套接字执行的任务来<code>匹配不同事件处理器</code></li>
<li>被监听的套接字<code>准备进行 IO 操作</code>时，文件事件处理器就会返回，然后调用匹配的事件处理器。如果一直，没有响应，文件事件处理器就会阻塞</li>
</ul>
<blockquote>
<p>Redis单线程为什么这么快？</p>
</blockquote>
<ul>
<li>Redis基于内存操作的，所以速度快</li>
<li>数据结构简单，操作节省时间</li>
<li>多路复用io阻塞机制</li>
</ul>
<h2 id="14-5、Redis单线程？4-0加入多线程？"><a href="#14-5、Redis单线程？4-0加入多线程？" class="headerlink" title="14.5、Redis单线程？4.0加入多线程？"></a>14.5、Redis单线程？4.0加入多线程？</h2><p><strong>单线程：</strong>指处理我们的网络请求的时候只有一个线程来处理。</p>
<blockquote>
<p>Redis6.0 之前 为什么不使⽤多线程？</p>
</blockquote>
<ol>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 基于内存处理，所以性能瓶颈不再 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
<p><strong>总结：</strong>不需要靠多线程提高CPU速度，反而多线程会带来问题。</p>
<blockquote>
<p>Redis6.0 之后 为什么 加入多线程</p>
</blockquote>
<p><strong>原因：</strong>提高网络IO 读写性能，因为这个算是 Redis 中的⼀个性能瓶颈</p>
<p><strong>因此：</strong>Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此不需要担心线程安全问题。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要修改 redis 配置⽂件开启多线程</span></span><br><span class="line"><span class="string">io-threads-do-reads</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">io-threads</span> <span class="number">4</span> <span class="comment">#官⽹建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure>

<h2 id="14-6、Redis缓存数据过期问题"><a href="#14-6、Redis缓存数据过期问题" class="headerlink" title="14.6、Redis缓存数据过期问题"></a>14.6、Redis缓存数据过期问题</h2><blockquote>
<p>为什么要设计过期时间？</p>
</blockquote>
<p>如果不设置过期时间，很容易内存溢出。</p>
<p><strong>注意：</strong>只有字符串有 setex 命令， 其他都得通过 expire设置，persist移除过期时间。</p>
<blockquote>
<p>Redis如何判断过期的</p>
</blockquote>
<p>Redis 通过⼀个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是⼀个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line"> ...</span><br><span class="line"> dict *dict; //数据库键空间,保存着数据库中所有键值对</span><br><span class="line"> dict *expires // 过期字典,保存着键的过期时间</span><br><span class="line"> ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除策略</p>
</blockquote>
<p><strong>惰性删除</strong>：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。</p>
<p><strong>定期删除</strong>： 每隔⼀段时间抽取⼀批 key执行删除过期key操作。并且，Redis 底层会通过限制删除操作执行和时长和频率来减少删除操作对CPU时间的影响。</p>
<p><strong>Redis：</strong>两者结合使用</p>
<blockquote>
<p>内存淘汰机制</p>
</blockquote>
<p><strong>问题：</strong>如果有大量的键值对没有设置过期时间，仍然容易 out of memory，需要自动删除。</p>
<p>MySQL 有 2000w 数据，Redis 中只存 20w ，如何保证 Redis 中的数据都是热点数据?</p>
<p><strong>八种内存淘汰机制</strong></p>
<ol>
<li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li>
<li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li>
<li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。  </li>
<li>volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。  </li>
<li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰  </li>
<li>allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。  </li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰  </li>
<li> no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。  </li>
</ol>
<p><strong>总结：</strong>这八种大体上可以分为4种，lru、lfu、random、ttl。</p>
<p><strong>即最近最少使用、将要过期、频率最低、任意选择 四种</strong></p>
<h2 id="14-7、缓存穿透"><a href="#14-7、缓存穿透" class="headerlink" title="14.7、缓存穿透"></a>14.7、缓存穿透</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><ul>
<li>用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，</li>
<li>于是向持久层数据库查询。发现也没有，于是本次查询失败。</li>
<li>当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了<strong>缓存穿透</strong></li>
</ul>
<h3 id="2、解决"><a href="#2、解决" class="headerlink" title="2、解决"></a>2、解决</h3><blockquote>
<p>布隆过滤器：</p>
</blockquote>
<p><strong>原理：</strong>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，通过它我们可以非常方便地判断⼀个给定数据是否存在于海量数据中。</p>
<p><strong>流程：</strong>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程</p>
<blockquote>
<p>缓存空对象：</p>
</blockquote>
<p><strong>流程：</strong>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p>
<p><strong>缺点：</strong>需要更大的缓存空间，可能导致缓存大量无用的key；缓存层和存储层的数据还是会有一段时间窗口的不一致，影响一致性</p>
<h2 id="14-8、缓存雪崩-穿透"><a href="#14-8、缓存雪崩-穿透" class="headerlink" title="14.8、缓存雪崩/ 穿透"></a>14.8、缓存雪崩/ 穿透</h2><h3 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h3><p><strong>雪崩：</strong>在某一个时间段，缓存集中过期失效，访问都落到了数据库上。</p>
<p><strong>穿透：</strong>单个缓存</p>
<h3 id="2、解决-1"><a href="#2、解决-1" class="headerlink" title="2、解决"></a>2、解决</h3><blockquote>
<p>针对Redis服务不可用的情况</p>
</blockquote>
<ol>
<li>使用Redis集群，避免某个Redis主机挂掉</li>
<li>限流降级：通过加锁或者队列来控制读数据库写缓存的线程数量。</li>
</ol>
<blockquote>
<p>针对热点缓存失效的情况</p>
</blockquote>
<ol>
<li>热点永不失效</li>
<li>不同的缓存数据设置不同的过期时间</li>
<li>数据预热：针对高峰访问期间，先访问一遍数据，避免失效。</li>
</ol>
<h2 id="14-9、保证缓存和数据库数据的⼀致性"><a href="#14-9、保证缓存和数据库数据的⼀致性" class="headerlink" title="14.9、保证缓存和数据库数据的⼀致性"></a>14.9、保证缓存和数据库数据的⼀致性</h2><blockquote>
<p>Cache Aside Pattern（旁路缓存模式）</p>
</blockquote>
<p>更新 DB，然后直接删除 cache 。如果缓存删除失败</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本） ：</strong>我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加cache更新重试机制（常⽤）：</strong> 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔⼀段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li>
</ol>
<h2 id="14-10、Redis实现分布式锁"><a href="#14-10、Redis实现分布式锁" class="headerlink" title="14.10、Redis实现分布式锁"></a>14.10、Redis实现分布式锁</h2><h3 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h3><ul>
<li>分布式系统中，不同的系统不能识别同一把锁</li>
</ul>
<h3 id="2、实现方式（基于Redis）"><a href="#2、实现方式（基于Redis）" class="headerlink" title="2、实现方式（基于Redis）"></a>2、实现方式（基于Redis）</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">setnx</span> <span class="string">users</span> <span class="number">10</span>  <span class="comment"># 成功</span></span><br><span class="line"><span class="string">setnx</span> <span class="string">users</span> <span class="number">20</span>  <span class="comment"># 失败,注意如果用set仍然可以设置</span></span><br><span class="line"><span class="string">del</span> <span class="string">users</span>	    <span class="comment"># 只在键不存在时，才对键进行设置操作</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">sku:1:info</span> <span class="string">“OK”</span> <span class="string">NX</span> <span class="string">PX</span> <span class="number">10000</span></span><br><span class="line"><span class="comment"># EX second:设置键的过期时间为 second 秒(EX可以省略)</span></span><br><span class="line"><span class="comment"># PX millisecond ：设置键的过期时间为 毫秒(PX可以省略)</span></span><br><span class="line"><span class="comment"># 注意 px 写在key和value之间，ex写在value之后 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过expire设置过期时间，</span></span><br><span class="line"><span class="comment"># 但是如果在setnx和expire之间出现异常，锁也无法释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NX:只在键不存在时，才对键进行设置操作。（setnx也可以） </span></span><br><span class="line"><span class="comment"># XX:只在键已经存在时，才对键进行设置操作。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过修改成功，可以判断是否被<strong>逻辑上上锁了</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1获取锁，setne</span></span><br><span class="line">    <span class="comment">// (&quot;lock&quot;, &quot;111&quot;,3，TimeUnit.SENCONDS); 设置过期时间</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(lock)&#123;</span><br><span class="line">      	<span class="comment">// 2业务代码</span></span><br><span class="line">        <span class="comment">// 3释放锁，del</span></span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 4获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、优化之UUID防误删"><a href="#3、优化之UUID防误删" class="headerlink" title="3、优化之UUID防误删"></a>3、优化之UUID防误删</h3><ul>
<li>业务代码执行时间<strong>小于</strong>锁释放的时间，</li>
<li>导致业务代码执行后，删除的是其他业务的锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">String uuid = UUID.randonUUID().toString();</span><br><span class="line">Boolean lock = <span class="keyword">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">if</span>(uuid.equals((String)redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>)))&#123;</span><br><span class="line">    <span class="keyword">this</span>.redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="4、LUA脚本保证原子性"><a href="#4、LUA脚本保证原子性" class="headerlink" title="4、LUA脚本保证原子性"></a>4、LUA脚本保证原子性</h3><ul>
<li>查询uuid相等到删除操作之间可能被其他进程插入，导致释放错锁</li>
<li>因为没有原子性</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Bug</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">http://example.com/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Notes</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/">Redis数据库</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><img class="prev-cover" src="/img/cover/17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/21/JavaSE/JavaSE%20(%20%E4%B8%80%20)%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"><img class="next-cover" src="/img/cover/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaSE(一):基本语法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-text">1、发展历史</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81NoSQL"><span class="toc-text">2、NoSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-text">2.1、概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-text">2.2、特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81%E6%8B%93%E5%B1%95"><span class="toc-text">2.3、拓展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-text">2.4、经典应用分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E3%80%81NoSQL%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="toc-text">2.5、NoSQL数据模型简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81KV%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text">1、KV键值对</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%96%87%E6%A1%A3%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Bson%E6%AF%94%E8%BE%83%E5%A4%9A%EF%BC%89"><span class="toc-text">2、文档型数据库（Bson比较多）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%88%97%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A"><span class="toc-text">3、列存储数据库：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6%E3%80%81CAP-BASE"><span class="toc-text">2.6、CAP + BASE</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81Redis%E7%AE%80%E4%BB%8B"><span class="toc-text">3、Redis简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81linux%E5%AE%89%E8%A3%85"><span class="toc-text">3.2、linux安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">3.3、选择数据库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">4、五大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">4.1、简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81Redis%E7%9A%84%E9%94%AE"><span class="toc-text">4.2、Redis的键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2String"><span class="toc-text">4.3、字符串String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E3%80%81%E5%88%97%E8%A1%A8List"><span class="toc-text">4.4、列表List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5%E3%80%81%E5%93%88%E5%B8%8CHash"><span class="toc-text">4.5、哈希Hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6%E3%80%81%E9%9B%86%E5%90%88Set"><span class="toc-text">4.6、集合Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7%E3%80%81%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88Zset"><span class="toc-text">4.7、有序集合Zset</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">5、三种特殊数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81GEO%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-text">5.1、GEO地理位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81HyperLogLog"><span class="toc-text">5.2、HyperLogLog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81BitMap"><span class="toc-text">5.3、BitMap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81Redis-conf"><span class="toc-text">6、Redis.conf</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">7、Redis的持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81RDB%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="toc-text">7.1、RDB（默认）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81AOF"><span class="toc-text">7.2、AOF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">7.3、总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81Redis%E4%BA%8B%E5%8A%A1"><span class="toc-text">8、Redis事务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-text">9、发布订阅</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">10、主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-text">10.1、概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2%E3%80%81-%E4%BC%98%E7%82%B9"><span class="toc-text">10.2、 优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3%E3%80%81%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">10.3、环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%90%AF%E5%8A%A8%E4%B8%89%E4%B8%AAredis"><span class="toc-text">1、启动三个redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9A%82%E6%97%B6%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E"><span class="toc-text">2、暂时配置主从</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B0%B8%E4%B9%85%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E"><span class="toc-text">3、永久配置主从</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1"><span class="toc-text">4、关闭服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%B5%8B%E8%AF%95"><span class="toc-text">5、测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4%E3%80%81%E6%B5%8B%E8%AF%95"><span class="toc-text">10.4、测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%AD%A3%E5%B8%B8%E8%AF%BB%E5%86%99"><span class="toc-text">1、正常读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AE%95%E6%9C%BA"><span class="toc-text">2、宕机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%B0%8B%E6%9D%83%E7%AF%A1%E4%BD%8D"><span class="toc-text">3、谋权篡位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-text">4、薪火相传</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5%E3%80%81%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">10.5、哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">1、原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A4%9A%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-text">2、多哨兵模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B5%8B%E8%AF%95"><span class="toc-text">3、测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">4、优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E3%80%81Redis%E9%9B%86%E7%BE%A4"><span class="toc-text">11、Redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-text">11.1、概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2%E3%80%81%E9%85%8D%E7%BD%AE"><span class="toc-text">11.2、配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3%E3%80%81%E7%99%BB%E5%BD%95"><span class="toc-text">11.3、登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4%E3%80%81%E8%8A%82%E7%82%B9%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-text">11.4、节点分配问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5%E3%80%81Slot%E6%8F%92%E6%A7%BD"><span class="toc-text">11.5、Slot插槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6%E3%80%81%E6%95%85%E9%9A%9C"><span class="toc-text">11.6、故障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-7%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-text">11.7、缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E3%80%81Jedis"><span class="toc-text">12、Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BE%9D%E8%B5%96"><span class="toc-text">1、依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81"><span class="toc-text">2、代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%85%B6%E4%BB%96%E4%BB%A3%E7%A0%81"><span class="toc-text">3、其他代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%93%8D%E4%BD%9C%E4%BA%8B%E5%8A%A1"><span class="toc-text">4、操作事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E9%9B%86%E7%BE%A4%E6%83%85%E5%86%B5%E4%B8%8B"><span class="toc-text">5、集群情况下</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E3%80%81SpringBoot%E6%95%B4%E5%90%88"><span class="toc-text">13、SpringBoot整合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1%E3%80%81%E5%88%86%E6%9E%90"><span class="toc-text">13.1、分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2%E3%80%81%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-text">13.2、简单测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3%E3%80%81%E6%B7%B1%E5%85%A5%E6%B5%8B%E8%AF%95"><span class="toc-text">13.3、深入测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">14、常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1%E3%80%81-Redis-%E5%92%8C-Memcached"><span class="toc-text">14.1、 Redis 和 Memcached</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2%E3%80%81-%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">14.2、 缓存数据处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Redis-%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">14.3、为什么要用Redis&#x2F;缓存数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4%E3%80%81Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">14.4、Redis单线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-5%E3%80%81Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F4-0%E5%8A%A0%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">14.5、Redis单线程？4.0加入多线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-6%E3%80%81Redis%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98"><span class="toc-text">14.6、Redis缓存数据过期问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-7%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">14.7、缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-text">1、概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E5%86%B3"><span class="toc-text">2、解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-8%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E7%A9%BF%E9%80%8F"><span class="toc-text">14.8、缓存雪崩&#x2F; 穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5-1"><span class="toc-text">1、概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E5%86%B3-1"><span class="toc-text">2、解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-9%E3%80%81%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E2%BC%80%E8%87%B4%E6%80%A7"><span class="toc-text">14.9、保证缓存和数据库数据的⼀致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-10%E3%80%81Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">14.10、Redis实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%97%AE%E9%A2%98"><span class="toc-text">1、问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E5%9F%BA%E4%BA%8ERedis%EF%BC%89"><span class="toc-text">2、实现方式（基于Redis）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BC%98%E5%8C%96%E4%B9%8BUUID%E9%98%B2%E8%AF%AF%E5%88%A0"><span class="toc-text">3、优化之UUID防误删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81LUA%E8%84%9A%E6%9C%AC%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">4、LUA脚本保证原子性</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Bug</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>