<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java并发(七):Java并发容器 | Notes</title><meta name="keywords" content="JUC"><meta name="author" content="Bug"><meta name="copyright" content="Bug"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于Java并发容器的简介">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发(七):Java并发容器">
<meta property="og:url" content="http://example.com/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%B8%83%20)%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="Notes">
<meta property="og:description" content="关于Java并发容器的简介">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/14.jpg">
<meta property="article:published_time" content="2021-07-04T06:01:05.000Z">
<meta property="article:modified_time" content="2021-07-04T06:01:05.000Z">
<meta property="article:author" content="Bug">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/14.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%B8%83%20)%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Bug","link":"链接: ","source":"来源: Notes","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java并发(七):Java并发容器',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-04 14:01:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/14.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Notes</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java并发(七):Java并发容器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-04T06:01:05.000Z" title="发表于 2021-07-04 14:01:05">2021-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-04T06:01:05.000Z" title="更新于 2021-07-04 14:01:05">2021-07-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java并发(七):Java并发容器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1、JDK1-7、HashMap"><a href="#1、JDK1-7、HashMap" class="headerlink" title="1、JDK1.7、HashMap"></a>1、JDK1.7、HashMap</h2><ul>
<li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li>
<li>key 不可重复，所以所在的类要重写：equals()和hashCode()  ，value要重写：equals() </li>
<li>HashMap 判断<strong>两个key相等</strong>的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。</li>
<li>HashMap 判断<strong>两个value相等</strong>的标准是：两个 value 通过 equals() 方法返回 true。</li>
</ul>
<p><img src="/img/Thread/6.jpg"></p>
<p><strong>结构：</strong> 数组 + 链表 ，每个节点都是一个 Entry 实例对象。</p>
<ol>
<li>实例化一个HashMap时，系统会创建一个长度为Capacity（称为容量）的Entry数组，数组存放元素的位置称为 “ 桶 “，每个” 桶 “ 都有自己的索引。</li>
<li>若添加的数据在一个” 桶 “ 中，则 会形成链表</li>
</ol>
<p><strong>添加过程</strong></p>
<ol>
<li>添加一个数据时，先封装成 Entry 对象，根据其中 key 的哈希值来判断应该放入哪个桶中</li>
<li>哈希值可能存在相同的情况，则依次遍历该桶中的链表，依次通过 equals 方法判断是否相等，若相等则把旧的 Entry 对象的 value 替换成新的，若不等则添加到头部。</li>
</ol>
<p><strong>扩容：</strong>和JDK1.8相同</p>
<h2 id="2、JDK1-8：HashMap"><a href="#2、JDK1-8：HashMap" class="headerlink" title="2、JDK1.8：HashMap"></a>2、JDK1.8：HashMap</h2><p><img src="/img/Thread/7.jpg"></p>
<p><strong>结构：</strong> 数组 + 链表 + 红黑树，每个节点都是一个 Node 实例对象（树形化后为 TreeNode）。</p>
<ol>
<li>实例化一个HashMap时，会初始化initialCapacity（默认容量）和<code>loadFactor（填充因子）</code></li>
<li><strong>put数据时，才会</strong>根据默认容量（16）创建Node数组，数组存放数据的地方称为” 桶 “ (bucket),每个bucket都有自己的<code>索引</code>。</li>
<li>每个bucket存一个Node对象，里面含有指向下一个元素的next引用变量，所以一个bucket可能形成<code>Node链</code>，或者是<code>TreeNode树</code>，而新添加的元素作为链表的last，或树的叶子结点</li>
</ol>
<p><strong>哈希函数：</strong></p>
<ul>
<li>JDK7：通过<strong>扰动函数处理</strong>过后得到 hash值，然后通过 (n - 1) &amp; hash判断当前元素存放的位置</li>
<li>JDK8：优化了代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK7</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK8</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line"> 	<span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line"> 	<span class="comment">// ^ ：按位异或</span></span><br><span class="line">	<span class="comment">// &gt;&gt;&gt;:⽆符号右移，忽略符号位，空位都以0补⻬</span></span><br><span class="line"> 	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩容情况</strong>：</p>
<ol>
<li><p>HashMap的元素个数大于 initialCapacity（默认容量）*  loadFactor（填充因子）时，就会扩大一倍。</p>
</li>
<li><p>扩容时会重新计算每个元素的位置，消耗资源，所以可以预设大小，减少资源消耗</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap(<span class="number">15</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>树形化</strong>：</p>
<p>​        若是一个 Node 链 里面的元素超过了8个（容量小于64则会优先先尝试扩大容量减少哈希冲突），就会尝试树形化，然后数节点<code>由Node类型变为TreeNode类型</code>，当然，映射关系移除后，若小于6个，重新变回Node链</p>
<p>​        <strong>也就是说，桶里的Node链  &gt;  8 ，hashMap 容量 &gt; 64时，实际上才会发生树形化</strong></p>
<p><strong>填充因子</strong></p>
<ol>
<li>负载因子越大，数据密度越大，发生碰撞的几率越高，数组中的链表越容易长，查询或插入时的比较次数多，性能下降</li>
<li>负载因子越小越容易扩容，容易浪费空间</li>
<li>最好设置为0.7~0.75</li>
</ol>
<blockquote>
<p>JDK1.8相较于之前的变化：</p>
</blockquote>
<ol>
<li>HashMap map = new HashMap();      //默认情况下，先不创建长度为16的数组，当首次调用map.put()时，再创建长度为16的数组</li>
<li>JDK 8 数组为Node类型，在jdk7中称为Entry类型</li>
<li>形成链表结构时，新添加的key-value对在链表的尾部（七上八下）</li>
<li>当数组指定索引位置的链表长度&gt;8时，且map中的数组的长度&gt; 64时，此索引位置上的所有key-value对使用红黑树进行存储。</li>
</ol>
<h2 id="3、JDK1-7：ConcurrentHashMap"><a href="#3、JDK1-7：ConcurrentHashMap" class="headerlink" title="3、JDK1.7：ConcurrentHashMap"></a>3、JDK1.7：ConcurrentHashMap</h2><p><img src="/img/Thread/8.jpg"></p>
<h3 id="3-1、内部结构和属性"><a href="#3-1、内部结构和属性" class="headerlink" title="3.1、内部结构和属性"></a>3.1、内部结构和属性</h3><p><strong>主要结构：</strong> Segment + HashEntry + Unsafe ，Segment继承了 ReentrantLock。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体为一个Segment数组，每个Segment对象里面还有一个HashEntry数组，HashEntry数组的每个节点存储键值对，即我门存的数据</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>属性：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 默认加载因子 0.75f （作用域segment内部）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 默认并发级别（和默认初始容量一致） 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 允许的最大容量 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 每段segment最小容量（必须是2的幂，至少是2）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 允许的最大segment数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>; <span class="comment">// slightly conservative</span></span><br><span class="line"><span class="comment">// 锁之前，重试次数（默认自旋次数）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 分段索引的掩码值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</span><br><span class="line"><span class="comment">// 段内索引的移位值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</span><br><span class="line"></span><br><span class="line"><span class="comment">// segment 数组</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br><span class="line">从上面大概可以看出ConcurrentHashMap的结构</span><br></pre></td></tr></table></figure>

<h3 id="3-2、方法分析"><a href="#3-2、方法分析" class="headerlink" title="3.2、方法分析"></a>3.2、方法分析</h3><blockquote>
<p>构造方法</p>
</blockquote>
<ul>
<li>构造方法确定了初始容量，加载因子，并发级别等参数。会创建Segment数组并且放入一个数据。</li>
<li><strong>Segment数组的大小：</strong>sszie，为2的次方，并且不能小于并发级别</li>
<li><strong>HashEntry初始大小：</strong>cap，且也必须是2的幂，最小为2。cap 乘 sszie 不能小于默认大小。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    <span class="comment">// 默认大16,0.75，并发级别16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 2. 控制最大并发级别不能超过初始容量</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 3. sszie为Segment数组的大小，2^sshift = sszie &gt; 并发级别</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 4. 控制最大初始容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 5. CAP为HashEntry初始大小</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;       <span class="comment">// 默认最小值2，</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 创建第一个Segment元素</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    <span class="comment">// 7. 创建CHM的segments数组，ssize的大小和并发级别有关</span></span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// 把数据放入</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Segment初始化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化其他Segment(构造方法只初始化了Segments[0]，其他位置第一次插入的时候还是null,需要初始化)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="comment">// 计算原始偏移量</span></span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">// 1. 再次确保是没有初始化过的</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 以第一个segment作为模版原型</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">// 取第一个segment的HashEntry数组长度，加载因子等</span></span><br><span class="line">        <span class="comment">// 因为构造方法时已经算过了，后面的都取第一个的初始化参数</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf); <span class="comment">// 计算阈值</span></span><br><span class="line">        <span class="comment">// 3.初始化segment的HashEntry数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="comment">// 4. 再次检查确保是没有这个过程中没有被其他线程初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            <span class="comment">// 初始化Segment</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// while自旋检测，并将初始化好的segment设置到segments数组对应的索引位置中</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回初始化好的segment by:https://jinglingwang.cn</span></span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>put方法</p>
</blockquote>
<ol>
<li>根据Hash计算出在 segment 数组的位置，若该位置没初始化就先初始化，然后调用HashEntry的put方法。</li>
<li>尝试获得锁（segment对象），获得锁之后会通过Hash计算在 HashEntry数组的位置（桶），获取后遍历链表并且添加或覆盖节点，记录修改次数，以及扩容检测。完成后会释放锁。</li>
<li>没有获得锁会调用scanAndLockForPut自旋（最多64次），直到返回一个节点并持有锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="comment">// 1.参数校验，不允许value为null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 2.计算key的hash(32位)</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 3. 默认值时，hash无符号右移28位，保留高4位，然后做位运算 &amp; 15；j的值就是下标</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          </span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) </span><br><span class="line">    <span class="comment">// 4. 构造方法只初始化了Segments[0]，其他位置第一次插入的时候还是null,需要初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 5.往segments中放入值</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  内部类Segment中的实现，真正放segment中添加数据的方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  尝试获得锁，没有获得锁会调用scanAndLockForPut自旋，直到返回一个节点并持有锁</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    <span class="comment">// 旧的值</span></span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前槽Segment中的HashEntry数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 1.计算hash所在的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 定位数组中的HashEntry元素，HashEntry是链表结构，第一个也就是表头</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123; <span class="comment">// 遍历hashEntry链表</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 存在旧值</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">// 1.1 校验key是否一致</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||  (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;  <span class="comment">// 取出覆盖前的旧值</span></span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value; <span class="comment">// 覆盖旧值</span></span><br><span class="line">                        ++modCount; <span class="comment">// 记录修改次数</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next; <span class="comment">// 继续遍历下一个元素</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在旧值</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first); <span class="comment">// 直接设置表头first</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 初始化节点并设置表头first</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>; <span class="comment">// 元素的数量+1</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    <span class="comment">// 触发扩容</span></span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node); <span class="comment">// 将node放到数组tab的index位置，</span></span><br><span class="line">                ++modCount; <span class="comment">// 记录修改次数+1</span></span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>; <span class="comment">// 第一次添加返回null</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue; <span class="comment">// 返回旧值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>自旋获取锁：scanAndLockForPut</p>
</blockquote>
<ul>
<li>会预先创建节点，</li>
<li>最多自旋64次，超过就是调用 lock方法替代 trylock ，让线程阻塞</li>
<li>每次自旋会判断调整遍历的 first 节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;      <span class="comment">// 自旋尝试获得锁，直到获得锁退出循环</span></span><br><span class="line">        HashEntry&lt;K,V&gt; f; </span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 预先创建节点</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                e = e.next; <span class="comment">//链表，下一个</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;<span class="comment">// 最大重试次数：单核1，多核64</span></span><br><span class="line">            lock(); <span class="comment">// 阻塞线程，直到获得锁</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            <span class="comment">// first节点所在的位置发生了变化，重新赋值first</span></span><br><span class="line">            e = first = f; </span><br><span class="line">            retries = -<span class="number">1</span>; <span class="comment">// 相当于重新进入scanAndLockForPut方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩容：rehash方法</p>
</blockquote>
<ul>
<li>对Segment中的HashEntry数组进行两倍的扩容，并将入参的节点加入到数组列表中。</li>
<li>只有在put方法时才会触发扩容，调用该方法时已经持有锁。</li>
<li>对于单节点的直接放到新HashEntry数组中；若形成了链表，其中有些节点的索引会发生改变，需要单独处理。</li>
<li><strong>注意：</strong>Segment数组是不能进行扩容的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;   <span class="comment">// 旧的容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;  <span class="comment">// 扩容，新的值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">// 计算新的扩容阈值</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历旧的数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i]; <span class="comment">// 旧数组中的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">// 非链表直接将旧值放入到新的数组中</span></span><br><span class="line">                newTable[idx] = e; </span><br><span class="line">            <span class="keyword">else</span> &#123;              <span class="comment">// 说明HashEntry数组中的节点是链表</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;  <span class="comment">// 头结点</span></span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 遍历链表，确定下来一个节点lastRun（重新计算索引后有变化的最后一个节点） </span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="keyword">null</span>;  last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将lastRun节点及它身上所处链表赋值到新的数组中</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// lastRun节点之前的节点，因为重新计算索引有变化，需要赋值到不同的位置</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask; <span class="comment">// 重新计算索引，与lastIdx不一样</span></span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">    <span class="comment">// 重新构造一个新的hashentry节点并赋值到新的数组中，如果不new需要切断链表更麻烦</span></span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新加入的节点，计算索引</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    <span class="comment">// newTable[nodeIndex] 可能已经存在有值，node节点作为头结点设置</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node; <span class="comment">// 重新设置nodeIndex位置</span></span><br><span class="line">    table = newTable; <span class="comment">// 赋值新的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取：get方法</p>
</blockquote>
<ol>
<li>先要确认槽的位置，也就是segment的位置</li>
<li>然后确定在segment里面的HashEntry数组中的索引位置。</li>
<li>在链表上找目标key并返回其值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所在的槽</span></span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 计算hash</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="comment">// 1.计算槽的索引位置</span></span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp; (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 计算在HashEntry中的索引位置,遍历链表  </span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile(tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) <span class="comment">// 找到元素，并返回值</span></span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 没有找到，返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除：remove</p>
</blockquote>
<p>删除和put类似。</p>
<h3 id="3-3、总结"><a href="#3-3、总结" class="headerlink" title="3.3、总结"></a>3.3、总结</h3><p><strong>结构：</strong> Segment + HashEntry + Unsafe ，Segment继承了 ReentrantLock。</p>
<ul>
<li>初始化会根据并发程度来创建 Segment数组（默认大小16），不可以扩容；初始化只会 添加一个Segment节点。</li>
<li>数组的每个 Segment对象 都封装了 HashEntry 数组，类似 HasMap 的 Entry，默认大小与 并发大小和 ConcurrentHashMap 的默认大小有关</li>
</ul>
<p><strong>添加数据</strong></p>
<ul>
<li><code>第一次根据 Hashcode 判断</code>去哪个 Segment 节点，若为空则CAS初始化；不为空则 trylcok 获取锁（Segment），获取不到的则自旋。</li>
<li><code>第二次根据 Hashcode 判断</code>去HashEntry 节点。</li>
</ul>
<p><strong>扩容：</strong></p>
<ul>
<li>扩容只发生在 put ，所以已获得锁了。</li>
<li>HashEntry 中链表和单节点的处理方式不同。</li>
<li>扩容为2倍。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>根据分段式锁实现的，不过锁的粒度仍然有些大，引入Segment数组保持并发度也必将耗费资源</li>
<li>Segment不支持扩容，并发性一定会有所降低。</li>
</ul>
<h2 id="4、JDK1-8：ConcurrentHashMap"><a href="#4、JDK1-8：ConcurrentHashMap" class="headerlink" title="4、JDK1.8：ConcurrentHashMap"></a>4、JDK1.8：ConcurrentHashMap</h2><h3 id="4-1、基本结构"><a href="#4-1、基本结构" class="headerlink" title="4.1、基本结构"></a>4.1、基本结构</h3><p><img src="/img/Thread/9.jpg"></p>
<p><strong>结构：</strong>Node + CAS + Synchronized + 红黑树(链表)</p>
<ul>
<li>Node节点和TreeNode节点防置我们存的数据 key 和 value</li>
<li>Node数组放的是Node或者TreeBin，TreeBin 封装了TreeNode的头结点</li>
<li>ForwardingNode</li>
</ul>
<blockquote>
<p>Node</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node类实现了Map.Entry接口，主要存放key/value键值对，链表结构具有next域。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// volatile 修饰，保证可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TreeNode</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树化后红黑树存储节点，继承于承载数据的Node类。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ForwardingNode</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表特殊节点，hash值为-1（MOVED），在扩容迁移数据时插入到原数组中，表示正在迁移数据。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">        ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="comment">// MOVED: hash值，-1。</span></span><br><span class="line">            <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TreeBin</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeBin通过root属性维护红黑树的根结点，first属性指向TreeNode链表的头结点。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter; <span class="comment">// 当前使用这棵红黑树的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重要属性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;     <span class="comment">// 默认容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能的最大（非 2 的幂）数组大小。 toArray 和相关方法需要。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;    <span class="comment">// 默认并发级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;            <span class="comment">// 默认加载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;     <span class="comment">// 链表转换成树的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;   <span class="comment">// 树退化成链表时的计数值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 链表树化时，最小的链表表容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;<span class="comment">// 最小转移容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;<span class="comment">// sizeCtl 中用于生成标记的位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeCtl 中用于生成标记的位数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeCtl 中记录大小标记的位移位。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">//表示正在转移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">//表示已经转换成树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 装载Node的数组,第一次插入数据时延迟初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 扩容时使用，平时为null，只有在扩容的时候才为非null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本计数器值，主要在没有争用时使用（通过CAS的方式修改）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表初始化和调整大小控制；</span></span><br><span class="line"><span class="comment">// 当 table 为 null 时，保存创建时使用的初始表大小，或默认为 0。</span></span><br><span class="line"><span class="comment">// 负数，则表正在初始化或调整大小，</span></span><br><span class="line"><span class="comment">// 正数，表示容量的大小，或者将要扩容的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整大小时要拆分的下一个表索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br></pre></td></tr></table></figure>

<h3 id="4-2、初始化方法"><a href="#4-2、初始化方法" class="headerlink" title="4.2、初始化方法"></a>4.2、初始化方法</h3><blockquote>
<p>构造方法</p>
</blockquote>
<ol>
<li><code>tableSizeFor</code>方法最后会返回一个2的幂的数作为最后的cap。</li>
<li>构造方法没有初始化数组，具体是在put第一个元素的时候初始化。</li>
<li>sizeCtl 的计算结果要保证是2的幂（计算方式是1.5*initialCapacity+1的结果向上取第一个2的幂，如果入参initialCapacity为10，sizeCtl就是16，如果入参initialCapacity为17，最后sizeCtl就是32），初始化数组之前表示的是容量的意思。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检验参数的正确性</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 保证并发级别不能大于容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   </span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// 使用默认的并发级别</span></span><br><span class="line">    <span class="comment">// 计算size</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// cap表示容量，为2的倍数</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>数组初始化：initTable</p>
</blockquote>
<ol>
<li>初始化数组一般是在第一次put数据的时候完成的。</li>
<li>使用<code>volatile</code>+CAS+自旋+双重检查的方式来控制<code>sizeCtl</code>，<code>sizeCtl</code>小于0表示有线程正在初始化数组。</li>
<li>未初始化前sizeCtl表示容量，初始化后<code>sizeCtl</code>被表示为下次要扩容的阈值（0.75*n）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123; <span class="comment">// 自旋，判断表是否有初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>) <span class="comment">// 表示正在被其他线程初始化或调整大小。</span></span><br><span class="line">            Thread.yield();     <span class="comment">// 暂停当前正在执行的线程</span></span><br><span class="line">        <span class="comment">// cas 修改为-1，表示当前线程正在初始化table</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123; </span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                 <span class="comment">// 双重检查</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123; </span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;    <span class="comment">// 赋值初始化好的table</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);  <span class="comment">// 计算实际上等同于 0.75 * n</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;   <span class="comment">// sizeCtl 设置为扩容的阈值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab; <span class="comment">// 返回初始化好的table</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3、添加获取数据"><a href="#4-3、添加获取数据" class="headerlink" title="4.3、添加获取数据"></a>4.3、添加获取数据</h3><blockquote>
<p>put方法</p>
</blockquote>
<ol>
<li>ConcurrentHashMap 不允许key/value 为null。在第一次插入数据时才初始化数组<code>table</code>。</li>
<li>put时如果正在扩容（要插入位置的节点hash值为-1），当前线程会加入到帮组扩容迁移数据（<code>helpTransfer</code>），并返回扩容后的新数组，然后继续执行put逻辑。</li>
<li>如果put时，目标位置为空时，直接插入，不要锁。</li>
<li>如果put时，目标位置不为空时，使用<code>synchronized</code>锁住一个桶，然后决定是替换旧值或是加入到链表或树中。替换旧值不会触发扩容，直接返回旧值。</li>
<li>如果冲突的位置链表长度大于等于8时，会尝试链表树化（<code>treeifyBin</code>：实际还需要数组长度至少为64才会树化 ）。</li>
<li>添加计数（<code>addCount</code>），检查是否需要扩容，退出。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验，不允许key/value为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 1. 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;       <span class="comment">// 用于记录冲突链表的大小</span></span><br><span class="line">    <span class="comment">// 自旋：第一次put数据时要先初始化数组，</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">// tab 为数组引用</span></span><br><span class="line">        Node&lt;K,V&gt; f;  <span class="comment">// 索引位的节点</span></span><br><span class="line">        <span class="keyword">int</span> n, i, fh; <span class="comment">// n：数组的长度；i:索引（计算方法 (n - 1) &amp; hash）；fh: f节点的hash</span></span><br><span class="line">        <span class="comment">// 数组还没初始化，就初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)  </span><br><span class="line">            tab = initTable(); </span><br><span class="line">         <span class="comment">// 当put进来，计算的目标索引位置没有元素时，直接插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 通过cas的方式修改，直接将put的值放入到指定数组的位置</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>))) </span><br><span class="line">                <span class="comment">// 完成put,退出整个for循环，退出方法</span></span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="comment">// 如果正在扩容，帮助数据迁移，并返回扩容后的新数组</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f); </span><br><span class="line">        <span class="comment">// 已初始化，表明发生了hash冲突</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 同步锁f</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; </span><br><span class="line">                <span class="comment">// 再次检查是否是同一个节点，有没有被修改 </span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// e f 是冲突链表的头结点，这里遍历</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 目标hash，key都一致，满足条件就替换旧值</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 遍历到了尾节点了</span></span><br><span class="line">                                <span class="comment">// new 一个node节点，插入到链表的尾巴上</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,  value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 冲突的位置已经不是链表了，是树</span></span><br><span class="line">                        Node&lt;K,V&gt; p; <span class="comment">// 接收插入树中成功的目标节点</span></span><br><span class="line">                        binCount = <span class="number">2</span>;  <span class="comment">//树，直接设置成2</span></span><br><span class="line">                        <span class="comment">// putTreeVal：查找或添加一个节点兵返回</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value; <span class="comment">// 替换旧值</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 上面put的时候如果已经是树了，binCount会被直接设置成2</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) <span class="comment">// 至少是8，才去尝试转换成为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);  <span class="comment">// 里面还有条件检查，不一定马上转成树</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 退出整个for自旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 元素数量加1，并判断是否达到扩容门槛</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>get方法</p>
</blockquote>
<ol>
<li>先计算hash值，再根据hash值计算索引<ul>
<li>如果索引位置为null，直接返回null</li>
<li>如果该位置上的节点hash值、key值都一致，返回找到的节点</li>
<li>如果该位置节点是链表，则遍历链表查找</li>
</ul>
</li>
<li>如果该位置节点hash值为-1，说明正在扩容，<code>调用find方法</code>查找</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// (n - 1) &amp; h ： 计算hash所在的索引</span></span><br><span class="line">    <span class="comment">// 数组初始化了，并且所在索引有值</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123; <span class="comment">// 目标hash值一致</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))) <span class="comment">// 目标key值一致</span></span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) <span class="comment">// 扩容迁移中by:https://jinglingwang.cn</span></span><br><span class="line">            <span class="comment">// 1.ForwardingNode.find</span></span><br><span class="line">            <span class="comment">// 2.TreeBin.find</span></span><br><span class="line">            <span class="comment">// 3.TreeNode.find</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123; <span class="comment">// 链表，遍历</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加计数：addCount</p>
</blockquote>
<ol>
<li>当没有冲突时，直接cas修改<code>basecount</code>完成计数更新。</li>
<li>自旋，判断是否达到扩容门槛<code>sizeCtl</code>。</li>
<li>如果达到扩容门槛，调用<code>transfer</code>方法进行扩容和转移数据操作。</li>
<li>如果发现已经有其他线程在扩容了，则当前线程加入迁移数据中（<code>transfer(tab, nt)</code>）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;<span class="comment">// b:基础计数</span></span><br><span class="line">    <span class="comment">// 两个条件：1.counterCells 不为空   2.cas修改baseCount失败（或的关系）</span></span><br><span class="line">    <span class="comment">// cas修改失败说明存在竞争关系，需要用到counterCells记录</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> || !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<span class="comment">//s:基础加上x后的计数</span></span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>; <span class="comment">//无竞争</span></span><br><span class="line">        <span class="comment">// 1. as == null：说明counterCells数组还没有初始化</span></span><br><span class="line">        <span class="comment">// 2. (m = as.length - 1) &lt; 0：counterCells数组长度为0</span></span><br><span class="line">        <span class="comment">// 3. 当前线程所在的位置段为null</span></span><br><span class="line">        <span class="comment">// 4. cas 修改当前线程段的值失败</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">// 完成了CounterCell数组初始化等工作，计数加入到CounterCell 数组</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>) <span class="comment">// 链表长度小于等与1，不看扩容，直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount(); <span class="comment">// 重新计算元素个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;  <span class="comment">// 主要看这里（counterCells为null,cas修改baseCount成功 ）</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 自旋，判断达到扩容门槛</span></span><br><span class="line">        <span class="comment">// 第一次自旋的时候sizeCtl表示的还是扩容门槛的意思，s表示的再次put一个元素后的值</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;  (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123; <span class="comment">// sc&lt;0 说明正在扩容中</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 扩容完成，退出自旋</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt); <span class="comment">// 其他线程正在扩容，去帮助扩容，nt是已经扩容后的数组了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 正常第一个线程触发扩容时会进入到这里</span></span><br><span class="line">                <span class="comment">// 进入迁移元素</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount(); <span class="comment">// 重新计算元素个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4、扩容"><a href="#4-4、扩容" class="headerlink" title="4.4、扩容"></a>4.4、扩容</h3><blockquote>
<p>扩容转移：transfer</p>
</blockquote>
<ol>
<li>每次调用transfer方法会按照<code>stride</code> 大小的纬度迁移数组数据（<code>stride:</code>默认16，和数组长度以及CPU数有），按数组索引倒序迁移。</li>
<li>transfer 方法完成了数组扩容*2的过程，通过<code>volatile</code>修饰的<code>nextTable</code>数组是否能null来验证是否已经有线程扩容了数组。</li>
<li>将原数组中的节点迁移到新数组后会将原数组中的位置设置成一个特殊的节点<code>ForwardingNode</code>，其hash值为-1，迁移时通过<code>synchronized</code>的方式来锁住迁移的桶。</li>
<li>当迁移时桶中冲突的链表或树会被拆分成两个新的链表（会被倒序）或树，然后分别放入到低位（原数组的索引位i）和高位（新数组的索引位i+n）。</li>
<li>第一次迁移完后会做一次对原数组的检查，再次遍历原数组检查数组是否完成迁移（hash为-1）</li>
<li>最后会将<code>sizeCtl</code>设置为下一次扩容检测阈值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride; <span class="comment">// n:原数组的长度</span></span><br><span class="line">        <span class="comment">// 保证stride 最小16，步长，将n按照stride大小切分成N段  </span></span><br><span class="line">        <span class="comment">// 当原数组n为512，CPU核数为2，stride 会变为32      </span></span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; </span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            </span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="comment">// nextTab 为 null，先进行一次初始化</span></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="comment">// 新的数组大小是原来的2倍   n&lt;&lt;1</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;  <span class="comment">// 防止扩容时内存溢出</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n; <span class="comment">// n是原数组的长度大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length; <span class="comment">// 扩容后数组的大小</span></span><br><span class="line">        <span class="comment">// ForwardingNode 翻译过来就是正在被迁移的 Node   构造方法会把hash设置成-1（MOVED）</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环 ，bound是边界值，i会倒序遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;  <span class="comment">// 自旋</span></span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing) <span class="comment">// 第一次这个if肯定不成立,i每次自减1</span></span><br><span class="line">                    advance = <span class="keyword">false</span>;  <span class="comment">// 退出自旋（这里不是马上退出，下面advance 还有可能被设置成true）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123; <span class="comment">// 第一次while自旋是不会进入到分支里面的,进入到这里说明倒序遍历到0了，已经结束了</span></span><br><span class="line">                    <span class="comment">// transferIndex 在上面被赋值成n,也就是原数组的长度大小</span></span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;  <span class="comment">// 退出自旋</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - **stride** : <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="comment">// 这里cas 修改transferIndex的值成功</span></span><br><span class="line">                    <span class="comment">//  nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0) 是神马意思呢？</span></span><br><span class="line">                    <span class="comment">//  如果原数组长度为512，这里nextBound就是481</span></span><br><span class="line">                    bound = nextBound; <span class="comment">// 遍历完一个stride 单位后，继续下一个边界计算</span></span><br><span class="line">                    i = nextIndex - <span class="number">1</span>; <span class="comment">// i变为原数组长度-1，也就是原数组最后一个元素</span></span><br><span class="line">                    advance = <span class="keyword">false</span>;   <span class="comment">// 退出自旋</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一次自旋进入到下面时，i表示的是原数组的倒序索引（也就是最后一个元素的索引）  </span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;  <span class="comment">// 第一次不会进第一个if分支，先看if后面的分支逻辑，最后走这个分支</span></span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="keyword">null</span>; <span class="comment">// 协助扩容的table置为null</span></span><br><span class="line">                    table = nextTab;  <span class="comment">// 更新扩容后的table</span></span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">// 相当于 n*0.75，作为下次扩容判断的阈值</span></span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 退出</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;  <span class="comment">// 最后面的synchronized 部分全部走完了，会进入到这儿</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>; <span class="comment">// 标记finishing 为true ,下面把i重新设置为原数组大小</span></span><br><span class="line">                    <span class="comment">// i被重新设置成n后，会再次检查原数组是否已经迁移完成；也就是下面的(fh = f.hash) == MOVED；检查完后，再进入到上面finishint = true的逻辑，最后退出</span></span><br><span class="line">                    i = n; <span class="comment">// recheck before commit by:https://jinglingwang.cn</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)  <span class="comment">// tab是原数组，原数组第i个元素是空的？</span></span><br><span class="line">                <span class="comment">// 如果桶中无数据，直接放入ForwardingNode节点标记该位置已经迁移</span></span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// 桶中有数据，但是hash值表示已经迁移过了（节点已经被设置过ForwardingNode）</span></span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 锁原数组的那个桶 table[i]</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">// 再次校验节点是否有变化，防止在锁之前已经被其他线程迁移</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// fh是hash值，只要不是负数（MOVED），就表示还没被迁移</span></span><br><span class="line">                            <span class="comment">// 运行位，和计算索引类似，但是有区别(索引计算是: (n-1) &amp; hash)</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                            <span class="comment">// lastRun 和jdk1.7的类似</span></span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">// 遍历链表</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123; <span class="comment">// 直到找到最后一个不一样的</span></span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 遍历链表，拆分成两个链表（倒序）</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>) <span class="comment">// 放入到低位链表（倒序）</span></span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span> <span class="comment">// 放入到高位链表（倒序）</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 放入到新数组的原位置</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            <span class="comment">// 放入到新数组的新位置</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">// 标记原数组的i位置已迁移</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>; <span class="comment">// 继续自旋处理下一个i--</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;  <span class="comment">//原数组i位置的元素是树节点</span></span><br><span class="line">                            <span class="comment">// 大致过程也是拆分成两棵树</span></span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">// lc  hc 是count数</span></span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="comment">// 遍历整棵树</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123; <span class="comment">// 根据计算，拆分成两棵不同的树</span></span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 分化后的树，节点数小于等于6时，则将树链表化</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln); <span class="comment">// 设置到低位</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn); <span class="comment">// 设置到高位</span></span><br><span class="line">                            setTabAt(tab, i, fwd); <span class="comment">// 标记原数组该位置已迁移</span></span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>helpTransfer</p>
</blockquote>
<ol>
<li>当put时，如果原节点的hash值为-1，说明正在扩容，线程会进入到该方法，确定是否要加入到扩容。</li>
<li>扩容完成后会返回扩容后的新数组，这样put方法继续执行之后的插入值逻辑。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入该方法，说明是有扩容在发生的</span></span><br><span class="line"><span class="comment">// table是原数组，f是索引位hash为-1的节点</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc; <span class="comment">// nextTab：预扩容的数组（要扩容后的新数组）</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// if 就是检查是否在扩容 </span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;  (sc = sizeCtl) &lt; <span class="number">0</span>) &#123; <span class="comment">// 检查是否正在扩容 </span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// transferIndex &lt;= 0 说明就扩容完成了 </span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);<span class="comment">// 加入到扩容</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// 扩容完成，退出自旋by:https://jinglingwang.cn</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table; <span class="comment">//进入方法发现已经完成扩容了，直接返回新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5、树形化"><a href="#4-5、树形化" class="headerlink" title="4.5、树形化"></a>4.5、树形化</h3><blockquote>
<p>链表树化：treeifyBin</p>
</blockquote>
<ol>
<li>在put元素的时候，如果冲突链表超过一定长度（至少为<code>8</code>），会触发尝试树化的操作。</li>
<li>实际还需要数组的长度至少达到了<code>64</code>才会执行树化，如果达不到会尝试扩容。</li>
<li>需要同时满足 8 + 64的条件才会树化。</li>
<li>树化的时候会锁住数组中整个冲突的节点（链表）。</li>
<li>树化会先将原Node链表转换成TreeNode链表，然后再转换成TreeBin节点并构造一颗红黑树设置到原数组的索引位置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">    Node&lt;K,V&gt; b;  // 数组索引位置的元素</span><br><span class="line">    int n, sc; // n:数组的长度，</span><br><span class="line">    if (tab != null) &#123;</span><br><span class="line">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) // 数组的长度小于64</span><br><span class="line">            tryPresize(n &lt;&lt; 1); // 尝试扩容( &lt;&lt; 1 等效于 *2)，不执行树化</span><br><span class="line">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123; // 需要同时满足 8 + 64的条件</span><br><span class="line">            synchronized (b) &#123; // 锁指定的node节点</span><br><span class="line">                if (tabAt(tab, index) == b) &#123; // 获得锁后再次检查索引位置的节点是否有变</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">                    // 开始遍历链表，转换成树节点链表（还是一个链表关系）</span><br><span class="line">                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;</span><br><span class="line">                        // 构造树节点，这里还不是树形的</span><br><span class="line">                        TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,  null, null);</span><br><span class="line">                        if ((p.prev = tl) == null)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        else</span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 将树链表树化设置到数组中的相应位置，hash值是-2</span><br><span class="line">                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>树化前尝试扩容: tryPresize</p>
</blockquote>
<p>有两种情况会进入到该方法：</p>
<ol>
<li>直接调用<code>putAll</code>方法。<br>putAll时该方法会先初始化表，和initTable逻辑一致。</li>
<li>当put元素后，冲突节点的链表长度≥8，&lt;64会进入到该方法。</li>
</ol>
<ul>
<li>最后调用<code>transfer</code>方法开始扩容或者加入到扩容。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private final void tryPresize(int size) &#123;</span><br><span class="line">    // put时这里的size入参已经是原table的长度*2了</span><br><span class="line">    // c: 扩容的值，防止为了超过最大值，保证是2的幂</span><br><span class="line">    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span><br><span class="line">    int sc;</span><br><span class="line">    // sizeCtl：在表初始化好后，存储的值就是扩容的阈值</span><br><span class="line">    while ((sc = sizeCtl) &gt;= 0) &#123; //sizeCtl要么是扩容阈值，要么是初始化容量</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; int n;</span><br><span class="line">        if (tab == null || (n = tab.length) == 0) &#123; // 这里是防止table还没有初始化，putAll方法会直接调这里，和initTable逻辑一致</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (table == tab) &#123; // 初始化表</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) // 没有达到扩容的阈值或者已经达到最大不能再扩容了</span><br><span class="line">            break; // 退出； by:https://jinglingwang.cn</span><br><span class="line">        else if (tab == table) &#123; // 这里再次检查，是否已经被其他线程扩容，表已经发生变化？</span><br><span class="line">            // resizeStamp(n)： return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));</span><br><span class="line">            // Integer.numberOfLeadingZeros(n): 会返回从高位（总32位）数一共有多少个0，直到遇到1，比如numberOfLeadingZeros(n) 返回26</span><br><span class="line">            // 1 &lt;&lt; (RESIZE_STAMP_BITS - 1) ： 1 左位移 15 位，相当于2的15次方</span><br><span class="line">            // |  相当于把两个结果加起来</span><br><span class="line">            int rs = resizeStamp(n); // rs源码没注释，具体什么作用暂时不懂</span><br><span class="line">            if (sc &lt; 0) &#123;// 说明有其他线程已经正在扩容</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                    transferIndex &lt;= 0) // 满足条件退出，这条件啥意思？</span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt); //加入到扩容by:https://jinglingwang.cn</span><br><span class="line">            &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab, null); // 扩容，迁移数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>链表树化：treeBin</p>
</blockquote>
<p>通过TreeBin的构造方法，将TreeNode链表转换成红黑树；</p>
<ol>
<li>初始化TreeBin节点，hash值为-1。by:<a target="_blank" rel="noopener" href="https://jinglingwang.cn/">https://jinglingwang.cn</a></li>
<li>TreeBin节点的first属性指向TreeNode链表的头结点。</li>
<li>TreeBin节点的root属性记录整颗红黑树根节点。</li>
<li>加入到右子树后会平衡整棵树。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.first = b; <span class="comment">// treeBin的first节点指向TreeNode链表的头结点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;<span class="comment">// 树化后的根节点root </span></span><br><span class="line">    <span class="comment">// 开始遍历TreeNode链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123; </span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next; <span class="comment">// 遍历当前节点的下一个节点</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>; <span class="comment">// 保证左右节点为null</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123; <span class="comment">// 确定根节点</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 进入到下面，x是从TreeNode链表的第二个节点开始的</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;  <span class="comment">// 当前节点的key和hash值</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 遍历以r为根节点的红黑树</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">								<span class="comment">// 比较确定方向by:https://jinglingwang.cn</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) </span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// comparableClassFor 返回key的class类型（没有实现Comparable接口返回null）</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">// 根据上面确认下来的dir,判断是要加入到树的左子树还是右子树? 并且为null的子树</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp; <span class="comment">// 关联父节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x; <span class="comment">// 加入到左子树</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;  加入到右子树</span><br><span class="line">                    r = balanceInsertion(r, x);  <span class="comment">// 平衡，返回根节点</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 子树非null,继续遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = r;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>; <span class="comment">// 递归检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-6、总结"><a href="#4-6、总结" class="headerlink" title="4.6、总结"></a>4.6、总结</h3><p><strong>结构：</strong>Node数组 + CAS + Synchronized。 Node数组存放 Node节点，或者TreeBin节点（封装TreeNode头结点）</p>
<p><strong>定义一个属性 sizeCtl：</strong>记录表的状态，如正在初始化，正在扩容</p>
<ol>
<li>构造对象时：2的次方且刚好大于参数传进来的容量大小，表示容量大小</li>
<li>初始化时：CAS设置为 -1 ，表示正在初始化</li>
<li>初始化完成：设置为容量 * 扩充因子，即扩容的阈值</li>
<li>扩容完成：新的阈值</li>
</ol>
<p><strong>初始化：</strong>volatile+CAS+自旋+双重检查的方式创建Node数组</p>
<p>1、自旋尝试 CAS 把 sizeCtl 设置为 -1，判断是否有其他线程正在初始化</p>
<p>2、大于则继续双重检查，选择使用 sizeCtl 或 默认容量来创建 Node 数组</p>
<p>3、成功，把sizeCtl 设置为扩容阈值</p>
<p><strong>put操作：</strong>不允许key/value 为null，第一次put时候初始化 Node 数组</p>
<p>1、自旋：先判断是否初始化，然后根据Hashcode找到索引出判断，</p>
<p>2、索引处没有元素，则CAS的添加元素；成功则退出，失败进行下一步</p>
<p>3、若在扩容，则先帮助扩容，直到结束；</p>
<p>4、使用synchronized锁住Node对象，进行操作（添加、替换旧值、树等）。</p>
<p>5、自旋结束后，使用 addCount计数，当数量大于阈值时，扩容。</p>
<p><strong>addCount方法：</strong>CAS的方式</p>
<p><strong>get方法：</strong></p>
<ol>
<li>先计算hash值，再根据hash值计算索引<ul>
<li>如果索引位置为null，直接返回null</li>
<li>如果该位置上的节点hash值、key值都一致，返回找到的节点</li>
<li>如果该位置节点是链表，则遍历链表查找</li>
</ul>
</li>
<li>如果该位置节点hash值为-1，说明正在扩容，<code>调用find方法</code>查找</li>
</ol>
<p><strong>扩容转移：</strong>CAS的方式转移节点。</p>
<p><strong>树形化：</strong></p>
<h2 id="5、CopyOnWriteArrayList"><a href="#5、CopyOnWriteArrayList" class="headerlink" title="5、CopyOnWriteArrayList"></a>5、CopyOnWriteArrayList</h2><p><strong>原理：</strong>每次操作（add ，set，remove等）都是通过复制一个底层的数组副本来实现的，在写操作的时候都会加上锁，有读写分离的意思。</p>
<p><strong>思想：</strong></p>
<ul>
<li>读操作不上锁，多个线程获取的都是同一个资源</li>
<li>写操作上锁，保证同时只有一个写操作线程。同时 copy 数组，写操作在复制的数组上进行，读操作在原数组上，互不干扰。</li>
</ul>
<h3 id="5-1、内部属性"><a href="#5-1、内部属性" class="headerlink" title="5.1、内部属性"></a>5.1、内部属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;   <span class="comment">// 数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类：迭代器，不支持add、set、remove操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot; <span class="comment">// array 快照记录了当时数组状态的引用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;              <span class="comment">// 游标，后续调用 next 将返回的元素索引</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2、方法分析"><a href="#5-2、方法分析" class="headerlink" title="5.2、方法分析"></a>5.2、方法分析</h3><blockquote>
<p>构造方法</p>
</blockquote>
<ol>
<li>初始化时没有指定数组的初始长度。</li>
<li>Arrays.copyOf的逻辑就是底层的System.arraycopy数组赋值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化默认无参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化指定集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="comment">// 判断类型</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含给定数组副本的列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将toCopyIn转化为Object[]类型数组，然后设置当前数组</span></span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>add方法</p>
</blockquote>
<ol>
<li>加锁</li>
<li>拿到原数组引用，并且copy一个长度+1的新数组</li>
<li>将新增元素加入到新数组的最后，新数组覆盖旧数组</li>
<li>释放锁，返回结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 0.加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.拿到数组引用</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 2.copy一个长度+1的数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.将新增元素加入到数组的最后</span></span><br><span class="line">        newElements[len] = e; </span><br><span class="line">        <span class="comment">// 4.覆盖旧数组</span></span><br><span class="line">        setArray(newElements); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 5.解锁</span></span><br><span class="line">        lock.unlock();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 覆盖数组</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引的add方法大致相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// addIfAbsent(e)方法：添加的元素不存在，才可以添加成功，避免多线程情况下重复添加元素</span></span><br><span class="line"><span class="comment">// 每次添加前判断数组是否发生了变化，若发生了改变，就判断要加的元素是否已经在数组中</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>remove方法</p>
</blockquote>
<ol>
<li>加锁，找索引，copy删除，覆盖旧数组，解锁返回</li>
<li>每次删除前判断依次数组是否发生改变，若改变就需要重写检验元素。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除指定索引位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获得锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 数组引用</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 指定元素的旧值 </span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="comment">// 索引位置后面的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 是最后一个元素，全部复制到一个长度减一的新数组中</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新的长度减一的数组</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 复制两次，相当于删掉了elements[index]</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements); <span class="comment">// 设置新数组的引用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue; <span class="comment">// 返回旧值by:https://jinglingwang.cn</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="comment">// 元素所在位置索引</span></span><br><span class="line">    <span class="keyword">int</span> index = indexOf(o, snapshot, <span class="number">0</span>, snapshot.length);</span><br><span class="line">    <span class="keyword">return</span> (index &lt; <span class="number">0</span>) ? <span class="keyword">false</span> : remove(o, snapshot, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o, Object[] snapshot, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) findIndex: &#123; <span class="comment">// 数组有变化会进入到if分支里面</span></span><br><span class="line">            <span class="keyword">int</span> prefix = Math.min(index, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix; i++) &#123;</span><br><span class="line">                <span class="comment">// 在新的数组中找到了和旧的元素不一致，并且就是要移除的值</span></span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123;</span><br><span class="line">                    index = i; <span class="comment">// 从新数组中重新确认的索引</span></span><br><span class="line">                    <span class="keyword">break</span> findIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上面for循环没找到，有可能元素在新的数组中还是在那个index位置没变化（current[i] != snapshot[i] 条件不满足）</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= len) <span class="comment">// 如果新数组是移除了一个元素，index最多也就等于len,既然新数组移除了元素，上面又没检查出来？直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (current[index] == o) <span class="comment">// 元素在新数组的同一个位置，没变化</span></span><br><span class="line">                <span class="keyword">break</span> findIndex;</span><br><span class="line">            index = indexOf(o, current, index, len); <span class="comment">// 位置有变化，就重新找到新位置</span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)  <span class="comment">// 没找到，已经删掉了，本次删除失败 by:https://jinglingwang.cn</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 后面的逻辑和上面的一直</span></span><br><span class="line">        Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(current, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">        System.arraycopy(current, index + <span class="number">1</span>,</span><br><span class="line">                         newElements, index,</span><br><span class="line">                         len - index - <span class="number">1</span>);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>set方法</p>
</blockquote>
<ol>
<li>加锁</li>
<li>找到指定索引的值，复制一个长度一样的新数组</li>
<li>在新数组中指定位置设置新元素，设置为新数组，</li>
<li>解锁返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 旧值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123; <span class="comment">// 两个值不一样</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">// 复制一个长度一样的新数组</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            <span class="comment">// 在新数组中指定位置设置元素</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">// 设置数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">		        <span class="comment">// 值一样，设置数组</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue; <span class="comment">// 返回旧值</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3、弱一致性"><a href="#5-3、弱一致性" class="headerlink" title="5.3、弱一致性"></a>5.3、弱一致性</h3><p>只有释放锁的时候，才会把信息强制刷新到主存，所以读操作可能获取到过时的信息，</p>
<h3 id="5-4、总结"><a href="#5-4、总结" class="headerlink" title="5.4、总结"></a>5.4、总结</h3><ol>
<li><code>CopyOnWriteArrayList</code> 是一个线程安全的ArrayList，jdk1.8版本是通过<code>ReentrantLock</code>锁实现的，jdk11就已经改成了<code>synchronized</code>锁。</li>
<li>每次对数据的修改都会copy一份新的数组（哪怕数组的长度没变化），对内存要求比较高。</li>
<li><code>CopyOnWriteArrayList</code> 是弱一致性，不能保证修改数据后，其他线程马上就能感知。</li>
<li><code>CopyOnWriteArrayList</code> 不能限制数组的最长长度，使用需要谨慎。</li>
<li>适合集合大小保持较小，读操作大大超过可变操作的场景</li>
</ol>
<h2 id="6、CopyOnWriteArraySet"><a href="#6、CopyOnWriteArraySet" class="headerlink" title="6、CopyOnWriteArraySet"></a>6、CopyOnWriteArraySet</h2><p><strong>概念：</strong>CopyOnWriteArraySet是一个基于CopyOnWriteArrayList实现的线程安全的Set集合，所以该Set和CopyOnWriteArrayList拥有完全相似的特性。</p>
<h3 id="6-1、结构分析"><a href="#6-1、结构分析" class="headerlink" title="6.1、结构分析"></a>6.1、结构分析</h3><p>CopyOnWriteArraySet继承了AbstractSet，内部持有一个CopyOnWriteArrayList实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5457747651344034263L</span>;</span><br><span class="line">    <span class="comment">// 内部持有CopyOnWriteArrayList实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2、方法"><a href="#6-2、方法" class="headerlink" title="6.2、方法"></a>6.2、方法</h3><blockquote>
<p>构造方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个CopyOnWriteArrayList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其他方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部调用CopyOnWriteArrayList方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过addIfAbsent保证添加的数据不重复</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.addAllAbsent(c) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.contains(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    al.forEach(action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.iterator();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.remove(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>equals方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>) <span class="comment">// 引用相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Set)) <span class="comment">// 比较的对象都不属于Set，没必要比下去了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    Set&lt;?&gt; set = (Set&lt;?&gt;)(o);</span><br><span class="line">    <span class="comment">// 拿到迭代器</span></span><br><span class="line">    Iterator&lt;?&gt; it = set.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Uses O(n^2) algorithm that is only appropriate</span></span><br><span class="line">    <span class="comment">// for small sets, which CopyOnWriteArraySets should be.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Use a single snapshot of underlying array</span></span><br><span class="line">    <span class="comment">// 当前对象的数组，以及数组长度</span></span><br><span class="line">    Object[] elements = al.getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="comment">// Mark matched elements to avoid re-checking</span></span><br><span class="line">    <span class="comment">// 初始化一个长度一样的标识数组，用来记录标识另一个数组是否已经被校验过</span></span><br><span class="line">    <span class="keyword">boolean</span>[] matched = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 一次遍历</span></span><br><span class="line">    outer: <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++k &gt; len) <span class="comment">// 遍历发现两个集合长度都不一致</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Object x = it.next();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="comment">// 遍历，比较，并记录下来标志位</span></span><br><span class="line">            <span class="keyword">if</span> (!matched[i] &amp;&amp; eq(x, elements[i])) &#123;</span><br><span class="line">                matched[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//没匹配到未校验过的目标一致的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k == len; <span class="comment">// 遍历完后只需要校验长度是否一致即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3、总结"><a href="#6-3、总结" class="headerlink" title="6.3、总结"></a>6.3、总结</h3><ol>
<li><code>CopyOnWriteArraySet</code>主要是基于<code>CopyOnWriteArrayList</code>的<code>addIfAbsent</code>方法实现的。</li>
<li><code>CopyOnWriteArraySet</code>是线程安全的有序集合。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Bug</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%B8%83%20)%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">http://example.com/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E4%B8%83%20)%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Notes</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC/">JUC</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E5%85%AD%20)%20%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/"><img class="prev-cover" src="/img/cover/13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java并发(六):Java并发队列</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/04/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%20(%20%E5%85%AB%20)%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><img class="next-cover" src="/img/cover/16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java并发(八):Java线程池</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/04/Java并发/Java并发 ( 一 ) 简介/" title="Java并发(一):简介"><img class="cover" src="/img/cover/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-04</div><div class="title">Java并发(一):简介</div></div></a></div><div><a href="/2021/07/04/Java并发/Java并发 ( 九 ) 框架和其他工具类/" title="Java并发(九):Java并发的其他知识"><img class="cover" src="/img/cover/17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-04</div><div class="title">Java并发(九):Java并发的其他知识</div></div></a></div><div><a href="/2021/07/04/Java并发/Java并发 ( 八 ) 线程池/" title="Java并发(八):Java线程池"><img class="cover" src="/img/cover/16.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-04</div><div class="title">Java并发(八):Java线程池</div></div></a></div><div><a href="/2021/07/04/Java并发/Java并发 ( 四 ) 原子操作类/" title="Java并发(四):原子类"><img class="cover" src="/img/cover/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-04</div><div class="title">Java并发(四):原子类</div></div></a></div><div><a href="/2021/07/04/Java并发/Java并发 ( 三 ) 内存模型/" title="Java并发(三):JMM内存模型"><img class="cover" src="/img/cover/10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-04</div><div class="title">Java并发(三):JMM内存模型</div></div></a></div><div><a href="/2021/07/04/Java并发/Java并发 ( 二 ) 编程基础/" title="Java并发(二):多线程基础"><img class="cover" src="/img/cover/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-04</div><div class="title">Java并发(二):多线程基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81JDK1-7%E3%80%81HashMap"><span class="toc-text">1、JDK1.7、HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81JDK1-8%EF%BC%9AHashMap"><span class="toc-text">2、JDK1.8：HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81JDK1-7%EF%BC%9AConcurrentHashMap"><span class="toc-text">3、JDK1.7：ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-text">3.1、内部结构和属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">3.2、方法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">3.3、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81JDK1-8%EF%BC%9AConcurrentHashMap"><span class="toc-text">4、JDK1.8：ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">4.1、基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">4.2、初始化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E3%80%81%E6%B7%BB%E5%8A%A0%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">4.3、添加获取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E3%80%81%E6%89%A9%E5%AE%B9"><span class="toc-text">4.4、扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E3%80%81%E6%A0%91%E5%BD%A2%E5%8C%96"><span class="toc-text">4.5、树形化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">4.6、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81CopyOnWriteArrayList"><span class="toc-text">5、CopyOnWriteArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">5.1、内部属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">5.2、方法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">5.3、弱一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">5.4、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81CopyOnWriteArraySet"><span class="toc-text">6、CopyOnWriteArraySet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-text">6.1、结构分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">6.2、方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">6.3、总结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Bug</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>