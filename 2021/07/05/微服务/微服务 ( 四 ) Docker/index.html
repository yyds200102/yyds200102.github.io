<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>微服务(四):Docker的基本概念 | Notes</title><meta name="keywords" content="MicroService"><meta name="author" content="Bug"><meta name="copyright" content="Bug"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker的基本概念">
<meta property="og:type" content="article">
<meta property="og:title" content="微服务(四):Docker的基本概念">
<meta property="og:url" content="http://example.com/2021/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%20(%20%E5%9B%9B%20)%20Docker/index.html">
<meta property="og:site_name" content="Notes">
<meta property="og:description" content="Docker的基本概念">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/4.jpg">
<meta property="article:published_time" content="2021-07-05T04:53:03.000Z">
<meta property="article:modified_time" content="2021-07-05T04:56:05.000Z">
<meta property="article:author" content="Bug">
<meta property="article:tag" content="MicroService">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/4.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%20(%20%E5%9B%9B%20)%20Docker/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Bug","link":"链接: ","source":"来源: Notes","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '微服务(四):Docker的基本概念',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-05 12:56:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/4.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Notes</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">微服务(四):Docker的基本概念</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-05T04:53:03.000Z" title="发表于 2021-07-05 12:53:03">2021-07-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-05T04:56:05.000Z" title="更新于 2021-07-05 12:56:05">2021-07-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="微服务(四):Docker的基本概念"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1、Docker的基本概念"><a href="#1、Docker的基本概念" class="headerlink" title="1、Docker的基本概念"></a>1、Docker的基本概念</h2><p><strong>简介：</strong>虚拟化容器技术。Docker基于镜像，可以秒级启动各种容器，每个容器都是一个完整的环境，容器直接互相隔离。</p>
<ul>
<li><p>镜像：就是各种环境的模板</p>
</li>
<li><p>容器：Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。 它可以被启动、开始、停止、删除。每个容器都是相互隔离的，保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等） 和运行在其中的应用程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写 的。</p>
</li>
<li><p>仓库：存放镜像的地方</p>
</li>
</ul>
<h2 id="2、Docker的安装"><a href="#2、Docker的安装" class="headerlink" title="2、Docker的安装"></a>2、Docker的安装</h2><h3 id="2-1、系统要求"><a href="#2-1、系统要求" class="headerlink" title="2.1、系统要求"></a>2.1、系统要求</h3><p>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r    查看自己的内核：</span><br><span class="line">cat /etc/os-release        查看版本信息：</span><br></pre></td></tr></table></figure>

<h3 id="2-2、安装步骤"><a href="#2-2、安装步骤" class="headerlink" title="2.2、安装步骤"></a>2.2、安装步骤</h3><ol>
<li><p>yum安装gcc相关环境（两个步骤）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc </span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure></li>
<li><p>卸载旧版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">	docker-client \ </span><br><span class="line">	docker-client-latest \ </span><br><span class="line">	docker-common \ </span><br><span class="line">	docker-latest \ </span><br><span class="line">	docker-latest-logrotate \ </span><br><span class="line">	docker-logrotate \ </span><br><span class="line">	docker-engine </span><br></pre></td></tr></table></figure></li>
<li><p>安装需要的软件包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure></li>
<li><p>设置镜像仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li><p>更新yum软件包索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure></li>
<li><p>安装 Docker CE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li>
<li><p>启动Docker</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li><p>测试命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version </span><br><span class="line">docker run hello-world </span><br><span class="line">docker images</span><br></pre></td></tr></table></figure></li>
<li><p>卸载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker </span><br><span class="line">yum -y remove docker-ce docker-ce-cli containerd.io </span><br><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-3、阿里云镜像加速"><a href="#2-3、阿里云镜像加速" class="headerlink" title="2.3、阿里云镜像加速"></a>2.3、阿里云镜像加速</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://el4654bx.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="3、探究Docker-run-hello-world-原理"><a href="#3、探究Docker-run-hello-world-原理" class="headerlink" title="3、探究Docker run hello-world 原理"></a>3、探究Docker run hello-world 原理</h2><p><img src="/img/microservice/21.jpg"></p>
<p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱</p>
<p><img src="/img/microservice/22.jpg"></p>
<p><strong>为什么Docker比 VM 快</strong> </p>
<p>1、docker有着比虚拟机<strong>更少的抽象层</strong>。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p>
<p>2、docker<strong>利用的是宿主机的内核,而不需要Guest OS</strong>。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。</p>
<p><img src="/img/microservice/23.jpg"></p>
<h2 id="4、Docker常用命令"><a href="#4、Docker常用命令" class="headerlink" title="4、Docker常用命令"></a>4、Docker常用命令</h2><h3 id="4-1、帮助命令"><a href="#4-1、帮助命令" class="headerlink" title="4.1、帮助命令"></a>4.1、帮助命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version   # 显示 Docker 版本信息。 </span><br><span class="line">docker info      # 显示 Docker 系统信息，包括镜像和容器数。。 </span><br><span class="line">docker --help    # 帮助</span><br></pre></td></tr></table></figure>



<h3 id="4-2、镜像命令"><a href="#4-2、镜像命令" class="headerlink" title="4.2、镜像命令"></a>4.2、镜像命令</h3><p><strong>docker images</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 列出本地主机上的镜像 </span><br><span class="line">[root@kuangshen ~]# docker images </span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    d1165f221234   5 months ago   13.3kB</span><br><span class="line"></span><br><span class="line"># 解释 </span><br><span class="line">REPOSITORY   镜像的仓库源 </span><br><span class="line">TAG          镜像的标签 </span><br><span class="line">IMAGE ID     镜像的ID </span><br><span class="line">CREATED      镜像创建时间 </span><br><span class="line">SIZE         镜像大小 </span><br><span class="line"></span><br><span class="line"># 同一个仓库源可以有多个 TAG，代表这个仓库源的不同版本，我们使用REPOSITORY：TAG 定义不同 的镜像，如果你不定义镜像的标签版本，docker将默认使用 lastest 镜像！ </span><br><span class="line"></span><br><span class="line"># 可选项 </span><br><span class="line">-a： 列出本地所有镜像    docker -a   docker images -a</span><br><span class="line">-q： 只显示镜像id        -aq 显示所有的包括隐藏的</span><br><span class="line">--digests： 显示镜像的摘要信息</span><br></pre></td></tr></table></figure>

<p><strong>docker search</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 搜索镜像</span></span><br><span class="line">[root@kuangshen ~]# docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   11231</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker search 某个镜像的名称 对应DockerHub仓库中的镜像</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项</span> </span><br><span class="line">--filter=stars=50 ： 列出收藏数不小于指定值的镜像。</span><br><span class="line"></span><br><span class="line">docker search mysql --filter=stars=50</span><br></pre></td></tr></table></figure>

<p><strong>docker pull</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像  docker pull 镜像名[:tag]</span> </span><br><span class="line">docker pull mysql  不写默认下载最新版</span><br><span class="line"></span><br><span class="line">Using default tag: latest   # 不写tag，默认是latest</span><br><span class="line">latest: Pulling from library/mysql </span><br><span class="line">54fec2fa59d0: Already exists # 分层下载 </span><br><span class="line">bcc6c6145912: Already exists </span><br><span class="line">951c3d959c9d: Already exists </span><br><span class="line">05de4d0e206e: Already exists </span><br><span class="line">319f0394ef42: Already exists </span><br><span class="line">d9185034607b: Already exists </span><br><span class="line">013a9c64dadc: Already exists </span><br><span class="line">42f3f7d10903: Pull complete </span><br><span class="line">c4a3851d9207: Pull complete</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定版本下载</span> </span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果已经下载了最新版，在下载5.7，部分资源可以共用，无需继续下载</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像</span></span><br><span class="line">docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">mysql         5.7       8cf625070931   2 weeks ago    448MB</span><br><span class="line">hello-world   latest    d1165f221234   5 months ago   13.3kB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>docker rmi</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 删除镜像 </span><br><span class="line">docker rmi -f 镜像id                   # 删除单个 </span><br><span class="line">docker rmi -f 镜像名:tag 镜像名:tag     # 删除多个 </span><br><span class="line">docker rmi -f $(docker images -qa)    # 删除全部 1234</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-3、容器命令"><a href="#4-3、容器命令" class="headerlink" title="4.3、容器命令"></a>4.3、容器命令</h3><p>说明：有镜像才能创建容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos    # 虚拟一个centos</span><br></pre></td></tr></table></figure>

<p><strong>新建容器并启动</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span> </span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND][ARG...] </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常用参数说明 [OPTIONS]</span></span><br><span class="line">--name=&quot;Name&quot; # 给容器指定一个名字 </span><br><span class="line">-d # 后台方式运行容器，并返回容器的id！ </span><br><span class="line">-i # 以交互模式运行容器，通过和 -t 一起使用 </span><br><span class="line">-t # 给容器重新分配一个终端，通常和 -i 一起使用 </span><br><span class="line">-P # 随机端口映射（大写） </span><br><span class="line">-p # 指定端口映射（小结），一般可以有四种写法 </span><br><span class="line">	ip:hostPort:containerPort </span><br><span class="line">	ip::containerPort </span><br><span class="line">	hostPort:containerPort (常用)</span><br><span class="line">	containerPort </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span> </span><br><span class="line">docker images </span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">mysql         5.7       8cf625070931   2 weeks ago    448MB</span><br><span class="line">hello-world   latest    d1165f221234   5 months ago   13.3kB</span><br><span class="line">centos        latest    300e315adb2f   8 months ago   209MB</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用centos进行用交互模式启动容器，在容器内执行/bin/bash命令！</span> </span><br><span class="line">docker run -it centos /bin/bash </span><br><span class="line"></span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@62b77404dabc /]# ls      #内部centos 和外面无关系</span><br><span class="line">bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var</span><br><span class="line">dev  home  lib64  media       opt  root  sbin  sys  usr</span><br><span class="line">[root@62b77404dabc /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# ls</span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# </span><br></pre></td></tr></table></figure>

<p><strong>退出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exit         # 容器停止退出 </span><br><span class="line">ctrl+P+Q     # 容器不停止退出 read escape sequence</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>列出所有运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span> </span><br><span class="line">docker ps [OPTIONS] </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常用参数说明</span> </span><br><span class="line">-a      # 列出当前所有正在运行的容器 和 历史运行过的容器 </span><br><span class="line">-l      # 显示最近创建的容器 </span><br><span class="line">-n=?    # 显示最近n个创建的容器 </span><br><span class="line">-q      # 静默模式，只显示容器编号。</span><br><span class="line"></span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# docker ps -n=1</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                     PORTS     NAMES</span><br><span class="line">62b77404dabc   centos    &quot;/bin/bash&quot;   5 minutes ago   Exited (0) 3 minutes ago             blissful_williams</span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>启动停止容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start (容器id or 容器名)   # 启动容器 </span><br><span class="line">docker restart (容器id or 容器名) # 重启容器 </span><br><span class="line">docker stop (容器id or 容器名)    # 停止容器 </span><br><span class="line">docker kill (容器id or 容器名)    # 强制停止容器</span><br></pre></td></tr></table></figure>

<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id   # 删除指定容器，不能删除运行的容器。 -f 强制删除</span><br><span class="line"></span><br><span class="line">docker rm -f $(docker ps -a -q)   # 删除所有容器 </span><br><span class="line">docker ps -a -q|xargs docker rm   # 删除所有容器</span><br></pre></td></tr></table></figure>



<h3 id="4-4、其他命令"><a href="#4-4、其他命令" class="headerlink" title="4.4、其他命令"></a>4.4、其他命令</h3><p><strong>后台启动容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span> </span><br><span class="line">docker run -d 容器名 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子</span> </span><br><span class="line">docker run -d centos   # 启动centos，使用后台方式启动 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 问题： 使用docker ps 查看，发现容器已经退出了！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解释：Docker容器后台运行，就必须有一个前台进程，容器运行的命令如果不是那些一直挂起的命 令，就会自动退出。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如，你运行了nginx服务，但是docker前台没有运行应用，这种情况下，容器启动后，会立即自 杀，因为他觉得没有程序了，所以最好的情况是，将你的应用使用前台进程的方式运行启动。</span></span><br></pre></td></tr></table></figure>

<p><strong>查看日志</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span> </span><br><span class="line">docker logs -f -t --tail 容器id </span><br><span class="line">-t          # 显示时间戳  </span><br><span class="line">-f          # 打印最新的日志 </span><br><span class="line">--tail  数字 # 显示多少条！</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子：我们启动 centos，并编写一段脚本来测试玩玩！最后查看日志</span></span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# docker run -d centos /bin/sh -c &quot;while true;do echo wuzhihai;sleep 1;done&quot;</span><br><span class="line">debf6a52aa51c85bc16a8caa4165eb4b0477d1f7351fcff52ac429f456011db3</span><br><span class="line"></span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line">debf6a52aa51   centos    &quot;/bin/sh -c &#x27;while t…&quot;   5 seconds ago   Up 4 seconds             busy_albattani</span><br><span class="line"></span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# docker logs -tf --tail 10 debf6a52aa51</span><br><span class="line">2021-08-08T02:40:16.192348478Z wuzhihai</span><br><span class="line">2021-08-08T02:40:17.194521492Z wuzhihai</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>查看容器中运行的进程信息，支持ps命令参数。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span> </span><br><span class="line">docker top 容器id </span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     </span><br><span class="line">debf6a52aa51   centos    </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker top debf6a52aa51</span></span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                9649                9631                0                   10:38               ?                   00:00:00            /bin/sh -c while true;do echo wuzhihai;sleep 1;done</span><br><span class="line">root                12623               9649                0                   10:41               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>查看容器镜像的元数据</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span> </span><br><span class="line">docker inspect 容器id</span><br><span class="line"></span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# docker inspect debf6a52aa51</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">    # 完整的id，这里上面的容器id，就是截取的这个id前几位！</span><br><span class="line">        &quot;Id&quot;: &quot;debf6a52aa51c85bc16a8caa4165eb4b0477d1f7351fcff52ac429f456011db3&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-08-08T02:38:59.696047201Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/sh&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;while true;do echo wuzhihai;sleep 1;done&quot;</span><br><span class="line">        ],</span><br><span class="line">..............</span><br></pre></td></tr></table></figure>

<p><strong>进入正在运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令1</span> </span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line"></span><br><span class="line">docker exec -it debf6a52aa51 /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span> -it debf6a52aa51 /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ps -ef</span></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 02:38 ?        00:00:00 /bin/sh -c while true;do echo wuzhihai;sleep 1;done</span><br><span class="line">root       742     0  0 02:51 pts/0    00:00:00 /bin/bash</span><br><span class="line">root       763     1  0 02:51 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br><span class="line">root       764   742  0 02:51 pts/0    00:00:00 ps -ef</span><br><span class="line">[root@debf6a52aa51 /]# </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令2</span> </span><br><span class="line">docker attach 容器id</span><br></pre></td></tr></table></figure>

<ul>
<li> exec 是在容器中打开新的终端，并且可以启动新的进程 </li>
<li>attach 直接进入容器启动命令的终端，不会启动新的进程</li>
</ul>
<p><strong>从容器内拷贝文件到主机上</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span> </span><br><span class="line">docker cp 容器id:容器内路径 目的主机路径</span><br><span class="line"></span><br><span class="line">docker cp c8530dbbe3b4:/home/test.java /home</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-5、命令汇总"><a href="#4-5、命令汇总" class="headerlink" title="4.5、命令汇总"></a>4.5、命令汇总</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">attach   # 当前 shell 下 attach 连接指定运行镜像 </span><br><span class="line">build    # 通过 Dockerfile 定 制镜像 </span><br><span class="line">commit   # 提交当前容器为新的镜像 </span><br><span class="line">cp       #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line">create   # 创建一个新的容器，同 run，但不启动容器 </span><br><span class="line">diff     # 查看 docker 容器变化 </span><br><span class="line">events   # 从 docker 服务获取容 器实时事件 </span><br><span class="line">exec     # 在已存在的容器上运行命 令</span><br><span class="line">export   # 导出容器的内 容流作为一个 tar 归档文件[对应 import ] </span><br><span class="line">history  # 展示一个镜像形成历史 </span><br><span class="line">images   # 列出系统当前镜像</span><br><span class="line">import   # 从 tar包中的内容创建一个新的文件系统映像[对应export] </span><br><span class="line">info     # 显示系统相关信息 </span><br><span class="line">inspect  # 查看容器详细信息</span><br><span class="line">kill     # kill 指定 docker 容 器</span><br><span class="line">load     # 从一个 tar 包中加载一 个镜像[对应 save] </span><br><span class="line">login    # 注册或者登陆一个 docker 源服务器 </span><br><span class="line">logout   # 从当前 Docker registry 退出 </span><br><span class="line">logs     # 输出当前容器日志信息 </span><br><span class="line">port     # 查看映射端口对应的容器内部源端口 </span><br><span class="line">pause    # 暂停容器 </span><br><span class="line">ps       # 列出容器列表</span><br><span class="line">pull     # 从docker镜像源服务器拉取指定镜像或者库镜像 </span><br><span class="line">push     # 推送指定镜像或者库镜像至docker源服务器 </span><br><span class="line">restart  # 重启运行的容器 </span><br><span class="line">rm       # 移除一个或者多个容器 </span><br><span class="line">rmi      # 移除一个或多个镜像[无容器使用该 镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] </span><br><span class="line">run      # 创建一个新的容器并运行 一个命令 </span><br><span class="line">save     # 保存一个镜像为一个 tar 包[对应 load] </span><br><span class="line">search   # 在 docker hub 中搜 索镜像 </span><br><span class="line">start    # 启动容器 </span><br><span class="line">stop     # 停止容器 </span><br><span class="line">tag      # 给源中镜像打标签 </span><br><span class="line">top      # 查看容器中运行的进程信 息</span><br><span class="line">unpause  # 取消暂停容器 </span><br><span class="line">version  # 查看 docker 版本号 </span><br><span class="line">wait     # 截取容 器停止时的退出状态值</span><br></pre></td></tr></table></figure>

<h2 id="5、实战"><a href="#5、实战" class="headerlink" title="5、实战"></a>5、实战</h2><h3 id="5-1、安装Nginx"><a href="#5-1、安装Nginx" class="headerlink" title="5.1、安装Nginx"></a>5.1、安装Nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、搜索镜像</span></span><br><span class="line">docker search nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、拉取镜像</span> </span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、启动容器</span></span><br><span class="line">docker images</span><br><span class="line">docker run -d --name mynginx -p 3500:80 nginx </span><br><span class="line">                         # 把docker的80端口映射到主机的3500端口</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、测试访问</span></span><br><span class="line">curl localhost:3500</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、进入容器</span></span><br><span class="line">docker exec -it mynginx /bin/bash</span><br><span class="line">whereis nginx   # 寻找nginx</span><br><span class="line">cd /usr/share/nginx # nginx 的路径</span><br></pre></td></tr></table></figure>

<h3 id="5-2、安装Tomcat"><a href="#5-2、安装Tomcat" class="headerlink" title="5.2、安装Tomcat"></a>5.2、安装Tomcat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 官方文档解释</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> -it ：交互模式</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> --rm：容器启动成功并退出以后容器就自动移除，一般在测试情况下使用！</span> </span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、下载tomcat镜像</span> </span><br><span class="line">docker pull tomcat:9.0 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、启动</span> </span><br><span class="line">docker run -d -p 8080:8080 --name mytomcat tomcat:9.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、进入tomcat</span> </span><br><span class="line">docker exec -it mytomcat /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">问题 linux 命令少了  没有weapps</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">原因 最小可运行环境</span></span><br></pre></td></tr></table></figure>



<h3 id="5-3、安装Es-Kinbana"><a href="#5-3、安装Es-Kinbana" class="headerlink" title="5.3、安装Es+Kinbana"></a>5.3、安装Es+Kinbana</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们启动es这种容器需要考虑几个问题</span> </span><br><span class="line">1、端口暴露问题 9200、9300 </span><br><span class="line">2、数据卷的挂载问题 data、plugins、conf </span><br><span class="line">3、吃内存 - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 扩展命令</span> </span><br><span class="line">docker stats 容器id # 查看容器的cpu内存和网络状态</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、启动es测试</span> </span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、启动之后很卡，使用 docker stats 容器id 查看下cpu状态 ，发现占用的很大</span></span><br><span class="line">docker stats 容器id</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、测试</span></span><br><span class="line">curl localhost:9200</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、增加上内存限制启动</span> </span><br><span class="line">docker run -d --name myelasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx256m&quot; elasticsearch:7.6.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6、可视化"><a href="#6、可视化" class="headerlink" title="6、可视化"></a>6、可视化</h2><h3 id="6-1、Portainer"><a href="#6-1、Portainer" class="headerlink" title="6.1、Portainer"></a>6.1、Portainer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 -v /root/portainer:/data -v /var/run/docker.sock:/var/run/docker.sock --name dev-portainer portainer/portainer</span><br></pre></td></tr></table></figure>

<p>访问：外网:8088</p>
<p><strong>介绍：</strong></p>
<p>Portainer是Docker的图形化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。如果仅有一个docker宿主机，则可使用单机版运行，Portainer单机版运行十分简单，只需要一条语句即可启动容器，来管理该机器上的docker镜像、容器等数据。</p>
<h3 id="6-2、Rancher"><a href="#6-2、Rancher" class="headerlink" title="6.2、Rancher"></a>6.2、Rancher</h3><h2 id="7、Docker镜像讲解"><a href="#7、Docker镜像讲解" class="headerlink" title="7、Docker镜像讲解"></a>7、Docker镜像讲解</h2><h3 id="7-1、镜像是什么"><a href="#7-1、镜像是什么" class="headerlink" title="7.1、镜像是什么"></a>7.1、镜像是什么</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包<strong>软件运行环境</strong>和<strong>基于运行环境开发的软件</strong>，它包含运行某个软件所需的所有内容，<code>包括代码、运行时、库、环境变量和配置文件</code>。</p>
<h3 id="7-2、Docker镜像加载原理"><a href="#7-2、Docker镜像加载原理" class="headerlink" title="7.2、Docker镜像加载原理"></a>7.2、Docker镜像加载原理</h3><blockquote>
<p>UnionFS （联合文件系统）</p>
</blockquote>
<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual fifilesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p><strong>特性：</strong>一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<blockquote>
<p>Docker镜像加载原理</p>
</blockquote>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<ul>
<li><p>bootfs(boot fifile system)主要包含<strong>bootloader和kernel</strong>, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
</li>
<li><p> rootfs (root fifile system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
</li>
</ul>
<blockquote>
<p>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</p>
</blockquote>
<p>对于一个精简的OS，<strong>rootfs 可以很小，</strong>只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host（主机）的kernel（内核），自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
<h3 id="7-3、分层理解"><a href="#7-3、分层理解" class="headerlink" title="7.3、分层理解"></a>7.3、分层理解</h3><blockquote>
<p>分层的镜像</p>
</blockquote>
<p><strong>描述：</strong>从Docker 仓库 pull 一个镜像，会发现下载很多层而不是下载一个单一文件</p>
<p><strong>原因：</strong>节约空间，资源共享。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# docker pull redis</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/redis    </span><br><span class="line">33847f680f63: Already exists     # 该环境已经存在</span><br></pre></td></tr></table></figure>

<p>查看镜像分层的方式可以通过 docker image inspect 命令！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect redis:latest</span><br></pre></td></tr></table></figure>

<p><strong>理解：</strong></p>
<ol>
<li>所有的 Docker 镜像都起始于一个<strong>基础镜像层</strong>，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</li>
<li>假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</li>
</ol>
<p><strong>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合</strong></p>
<ul>
<li>每个镜像层包含 3 个文件，而镜像包含了来自两个镜像层的 6 个文件。</li>
</ul>
<p><img src="/img/microservice%5C24.jpg"></p>
<ul>
<li>在外部看来整个镜像只有 6 个文件，因为最上层中的文件7 是文件 5 的一个更新版本</li>
</ul>
<p><img src="/img/microservice%5C25.jpg"></p>
<h3 id="7-4、分层的实现"><a href="#7-4、分层的实现" class="headerlink" title="7.4、分层的实现"></a>7.4、分层的实现</h3><p>Docker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p>
<p>Linux 上可用的存储引擎有 AUFS、Overlay2、Device Mapper、Btrfs 以及 ZFS。顾名思义，每种存储引擎都基于 Linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p>
<p>Docker 在 Windows 上仅支持 windowsfifilter 一种存储引擎，该引擎基于 NTFS 文件系统之上实现了分层和 CoW[1]</p>
<p><img src="/img/microservice%5C26.jpg"></p>
<blockquote>
<p>特点</p>
</blockquote>
<p>Docker镜像都是只读的，当容器启动时，会<strong>增加一个新的可写层</strong>到镜像的顶部！</p>
<p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p>
<h2 id="8、commit镜像"><a href="#8、commit镜像" class="headerlink" title="8、commit镜像"></a>8、commit镜像</h2><p><strong>docker commit</strong> <strong>从容器创建一个新的镜像。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器副本使之成为一个新的镜像！ </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 语法</span> </span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、启动tomcat</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、进入容器内的Tomact</span></span><br><span class="line">docker exec -it 5a0f0008b77e /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、拷贝文件到webapps下面</span></span><br><span class="line">root@5a0f0008b77e:/usr/local/tomcat# cp -r webapps.dist/* webapps</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、进入webapps下面查看</span></span><br><span class="line">root@5a0f0008b77e:/usr/local/tomcat# cd webapps</span><br><span class="line">root@5a0f0008b77e:/usr/local/tomcat/webapps# ls</span><br><span class="line">ROOT  docs  examples  host-manager  manager</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、访问 http://121.41.4.48:8080/  发现出现了页面</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6、提交镜像到本地</span></span><br><span class="line">docker commit -a=&quot;wzh&quot; -m=&quot;add webapps&quot; 5a0f0008b77e tomcatbywzh:1.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7、查看</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>



<h2 id="9、容器数据卷"><a href="#9、容器数据卷" class="headerlink" title="9、容器数据卷"></a>9、容器数据卷</h2><h3 id="9-1、什么是容器数据卷"><a href="#9-1、什么是容器数据卷" class="headerlink" title="9.1、什么是容器数据卷"></a>9.1、什么是容器数据卷</h3><p>卷就是目录或者文件，存在一个或者多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System ， 提供一些用于持续存储或共享数据的特性：</p>
<p>卷的设计目的就是<strong>数据的持久化</strong>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p>
<blockquote>
<p>特点</p>
</blockquote>
<p>1、数据卷可在容器之间共享或重用数据</p>
<p>2、卷中的更改可以直接生效</p>
<p>3、数据卷中的更改不会包含在镜像的更新中</p>
<p>4、数据卷的生命周期一直持续到没有容器使用它为止</p>
<p><strong>所以：总结一句话： 就是容器的持久化，以及容器间的继承和数据共享！</strong></p>
<h3 id="9-2、使用数据卷"><a href="#9-2、使用数据卷" class="headerlink" title="9.2、使用数据卷"></a>9.2、使用数据卷</h3><blockquote>
<p>方法一：容器中直接使用命令来添加</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span> </span><br><span class="line">docker run -it -v 宿主机绝对路径目录:容器内目录 镜像名 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span> </span><br><span class="line">docker run -it -v /home/ceshi:/home centos /bin/bash</span><br></pre></td></tr></table></figure>

<p>查看数据卷是否挂载成功 docker inspect 容器id</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">           &#123;</span><br><span class="line">               &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">               &quot;Source&quot;: &quot;/home/ceshi&quot;,</span><br><span class="line">               &quot;Destination&quot;: &quot;/home&quot;,</span><br><span class="line">               &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">               &quot;RW&quot;: true,</span><br><span class="line">               &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">           &#125;</span><br><span class="line">       ],</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>docker 安装 mysql</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、拉取镜像</span> </span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、启动容器 -e 环境变量！</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意： mysql的数据应该不丢失！先体验下 -v 挂载卷！</span> </span><br><span class="line">docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、使用本地的sqlyog连接测试一下 3310</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、查看本地的 /home/mysql 目录</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、删除容器</span></span><br><span class="line">docker rm -f mysql01</span><br></pre></td></tr></table></figure>

<h3 id="9-3、匿名和具名挂载"><a href="#9-3、匿名和具名挂载" class="headerlink" title="9.3、匿名和具名挂载"></a>9.3、匿名和具名挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载</span> </span><br><span class="line">-v 容器内路径 </span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载的缺点，就是不好维护，通常使用命令 docker volume维护</span> </span><br><span class="line">docker volume ls  # 查看所有卷的情况</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 具名挂载 -</span></span><br><span class="line">v 卷名:/容器内路径 </span><br><span class="line">docker run -d -P --name nginx02 -v nginxconfig:/etc/nginx nginx </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看挂载的路径</span> </span><br><span class="line">docker volume inspect nginxconfig </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 怎么判断挂载的是卷名而不是本机目录名？</span> </span><br><span class="line">不是/开始就是卷名，是/开始就是目录名 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改变文件的读写权限</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> ro: <span class="built_in">readonly</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> rw: readwrite</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定容器对我们挂载出来的内容的读写权限</span> </span><br><span class="line">docker run -d -P --name nginx02 -v nginxconfig:/etc/nginx:ro nginx </span><br><span class="line">docker run -d -P --name nginx02 -v nginxconfig:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">FORM centos</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;volume01&quot;:&quot;valume02&quot;]</span><br><span class="line"></span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Docker创建镜像时创建匿名数据卷</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、创建镜像</span></span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ home]# mkdir docker-test-volume</span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ docker-test-volume]# vim dockerfile1</span><br><span class="line"></span><br><span class="line">	FROM centos</span><br><span class="line"></span><br><span class="line">	VOLUME [&quot;volume01&quot;:&quot;valume02&quot;]</span><br><span class="line"></span><br><span class="line">	CMD echo &quot;----end----&quot;</span><br><span class="line">	CMD /bin/bash</span><br><span class="line"></span><br><span class="line">docker build -f /home/docker-test-volume/dockerfile1 -t wzh/centos:1.0 .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、启动容器</span></span><br><span class="line"></span><br><span class="line">docker run -it 88c7581e5504 /bin/bash        # 启动容器</span><br><span class="line"></span><br><span class="line">ls -l  # 查看刚刚自动挂载的数据卷目录，这个卷和外面有同步的目录</span><br><span class="line"> </span><br><span class="line">drwxr-xr-x   2 root root 4096 Aug  8 08:45 volume01</span><br><span class="line">drwxr-xr-x   2 root root 4096 Aug  8 08:45 volume02</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、查找匿名数据卷的路径</span></span><br><span class="line"></span><br><span class="line">docker ps   查找容器</span><br><span class="line">找到mounts里面的路径，然后查看</span><br></pre></td></tr></table></figure>

<h3 id="9-4、数据卷容器"><a href="#9-4、数据卷容器" class="headerlink" title="9.4、数据卷容器"></a>9.4、数据卷容器</h3><p>命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动docker01</span></span><br><span class="line">docker run -it --name docker01 wzh/centos:1.0 /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动其他两个容器继承docker01</span></span><br><span class="line">docker run -it --name docker02 --volumes-from docker01 wzh/centos:1.0 /bin/bash</span><br><span class="line">docker run -it --name docker03 --volumes-from docker01 wzh/centos:1.0 /bin/bash</span><br></pre></td></tr></table></figure>



<p><strong>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。</strong></p>
<p><strong>存储在本机的文件则会一直保留！</strong></p>
<h2 id="10、DockerFile"><a href="#10、DockerFile" class="headerlink" title="10、DockerFile"></a>10、DockerFile</h2><h3 id="10-1、简介"><a href="#10-1、简介" class="headerlink" title="10.1、简介"></a>10.1、简介</h3><p>dockerfifile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p>
<blockquote>
<p>构建步骤：</p>
</blockquote>
<p>1、编写DockerFile文件</p>
<p>2、docker build 构建镜像</p>
<p>3、docker run 运行镜像</p>
<p>4、docker push 发布镜像</p>
<h3 id="10-2、DockerFile构建过程"><a href="#10-2、DockerFile构建过程" class="headerlink" title="10.2、DockerFile构建过程"></a>10.2、DockerFile构建过程</h3><p><strong>基础知识：</strong></p>
<p>1、每条保留字指令都必须为大写字母且后面要跟随至少一个参数</p>
<p>2、指令按照从上到下，顺序执行</p>
<p>3、# 表示注释</p>
<p>4、每条指令都会创建一个新的镜像层，并对镜像进行提交</p>
<p><strong>流程：</strong></p>
<p>1、docker从基础镜像运行一个容器</p>
<p>2、执行一条指令并对容器做出修改</p>
<p>3、执行类似 docker commit 的操作提交一个新的镜像层</p>
<p>4、Docker再基于刚提交的镜像运行一个新容器</p>
<p>5、执行dockerfifile中的下一条指令直到所有指令都执行完成！</p>
<p><strong>说明：</strong></p>
<p>从应用软件的角度来看DockerFile，docker镜像与docker容器分别代表软件的三个不同阶段。</p>
<ul>
<li>DockerFile 是软件的原材料 （代码）</li>
<li>Docker 镜像则是软件的交付品 （.apk）</li>
<li>Docker 容器则是软件的运行状态 （客户下载安装执行）</li>
</ul>
<p>DockerFile 面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可！</p>
<p>从实现和功能的角度</p>
<p><strong>DockerFile：</strong>需要定义一个DockerFile，DockerFile定义了进程需要的一切东西。DockerFile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程（当引用进行需要和系统服务和内核进程打交道，这时需要考虑如何设计 namespace的权限控制）等等。</p>
<p><strong>Docker镜像：</strong>在DockerFile 定义了一个文件之后，Docker build 时会产生一个Docker镜像，当运行Docker 镜像时，会真正开始提供服务；</p>
<p><strong>Docker容器：</strong>容器是直接提供服务的。</p>
<h3 id="10-3、指令"><a href="#10-3、指令" class="headerlink" title="10.3、指令"></a>10.3、指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM         # 基础镜像，当前新镜像是基于哪个镜像的 </span><br><span class="line">MAINTAINER   # 镜像维护者的姓名混合邮箱地址 </span><br><span class="line">RUN          # 容器构建时需要运行的命令 </span><br><span class="line">EXPOSE       # 当前容器对外保留出的端口 </span><br><span class="line">WORKDIR      # 指定在创建容器后，终端默认登录的进来工作目录，一个落脚点 </span><br><span class="line">ENV          # 用来在构建镜像过程中设置环境变量 </span><br><span class="line">ADD          # 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包 </span><br><span class="line">COPY         # 类似ADD，拷贝文件和目录到镜像中！ </span><br><span class="line">VOLUME       # 容器数据卷，用于数据保存和持久化工作 </span><br><span class="line">CMD          # 指定一个容器启动时要运行的命令，dockerFile中可以有多个CMD指令，但只有最 后一个生效！ </span><br><span class="line">ENTRYPOINT   # 指定一个容器启动时要运行的命令！和CMD一样 </span><br><span class="line">ONBUILD      # 当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，父镜像的 ONBUILD被触发</span><br></pre></td></tr></table></figure>

<h3 id="10-4、实战测试Centos"><a href="#10-4、实战测试Centos" class="headerlink" title="10.4、实战测试Centos"></a>10.4、实战测试Centos</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、编写DockerFile文件</span></span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# cd /home</span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ home]# mkdir dockerfile</span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ home]# cd dockerfile/</span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ dockerfile]# vim mydockerfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FROM centos </span><br><span class="line">MAINTAINER wuzhihai&lt;2459425424@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local </span><br><span class="line">WORKDIR $MYPATH </span><br><span class="line"></span><br><span class="line">RUN yum -y install vim </span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80 </span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;----------end--------&quot; </span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、build构建</span></span><br><span class="line"></span><br><span class="line">docker build -f dockerfile地址 -t 新镜像名字:TAG .</span><br><span class="line"></span><br><span class="line">docker build -f mydockerfile -t mycentos:0.1 。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、运行</span></span><br><span class="line">docker run -it 新镜像名字:TAG</span><br><span class="line">docker run -it mycentos:0.1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、列出镜像地的变更地址</span></span><br><span class="line"></span><br><span class="line">docker history dcd6399af076 # image名</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CMD 和 ENTRYPOINT 的区别</p>
</blockquote>
<ul>
<li><p><strong>CMD</strong>：Dockerfifile 中可以有多个CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换！</p>
</li>
<li><p><strong>ENTRYPOINT</strong>：docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合！</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">CMD [ &quot;ls&quot;, &quot;-a&quot; ] </span><br><span class="line"></span><br><span class="line">docker run xxx      # 成功</span><br><span class="line">docker run xxx -l   # 失败</span><br><span class="line"></span><br><span class="line">FROM centos ENTRYPOINT </span><br><span class="line">[ &quot;ls&quot;, &quot;-a&quot; ]        </span><br><span class="line"></span><br><span class="line">docker run xxx      # 成功</span><br><span class="line">docker run xxx -l   # 成功</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>10.5、实战测试Tomcat</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1 准备tomcat和jdk</span></span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ wzh]# ls</span><br><span class="line">apache-tomcat-9.0.52.tar.gz  jdk-linux-x64.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、编写 Dockerfile 文件，build会自动寻找这个文件</span></span><br><span class="line">vim Dockerfile</span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER wzh&lt;2459425424@qq.com&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">把宿主机当前上下文的read.txt拷贝到容器/usr/<span class="built_in">local</span>/路径下</span></span><br><span class="line">COPY readme.txt /usr/local/readme.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">把java与tomcat添加到容器中</span></span><br><span class="line">ADD jdk-linux-x64.tar.gz /usr/local/</span><br><span class="line">ADD apache-tomcat-9.0.52.tar.gz /usr/local/</span><br><span class="line"><span class="meta">#</span><span class="bash">安装vim编辑器</span></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"><span class="meta">#</span><span class="bash">设置工作访问时候的WORKDIR路径，登录落脚点</span></span><br><span class="line">ENV MYPATH /usr/local </span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"><span class="meta">#</span><span class="bash">配置java与tomcat环境变量</span></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_131</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar </span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.52 </span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.52 </span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash">容器运行时监听的端口</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line"><span class="meta">#</span><span class="bash">启动时运行tomcat</span></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.52/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.52/bin/logs/catalina.out</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、构建镜像</span></span><br><span class="line">docker build -t diytomcat .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、构建完成</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、启动运行，挂载项目</span></span><br><span class="line">docker run -d -p 9090:8080 --name mydiytomcat -v /home/wzh/build/tomcat/test:/usr/local/apache-tomcat-9.0.52/webapps/test -v /home/wzh/build/tomcat/tomcat9logs/:/usr/local/apache-tomcat-9.0.52/logs --privileged=true diytomcat</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6、验证测试</span></span><br><span class="line">curl localhost:9090</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7、进入容器</span></span><br><span class="line">docker exec -it fdca5204d5d6 /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8、更改文件</span></span><br><span class="line">在路径的test文件夹下面添加项目</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-5、发布镜像"><a href="#10-5、发布镜像" class="headerlink" title="10.5、发布镜像"></a>10.5、发布镜像</h3><blockquote>
<p>到Dockhub</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 登录</span><br><span class="line">docker login -u wzh2459425424</span><br><span class="line">mfdpx2012%wzh</span><br><span class="line"></span><br><span class="line"># 发布镜像  必须和账号对应</span><br><span class="line">docker tag 6769d0deb977 wzh2459425424/diytomcat:1.0</span><br><span class="line">docker push wzh2459425424/diytomcat:1.0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>阿里云</p>
</blockquote>
<ol>
<li>登录阿里云Docker Registry</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 1、登录</span><br><span class="line">docker login --username=今天吃炸鸡啊 registry.cn-hangzhou.aliyuncs.com</span><br><span class="line"></span><br><span class="line"># 2、设置tag</span><br><span class="line">docker tag 6769d0deb977 registry.cn-hangzhou.aliyuncs.com/wuzhihai/wuzhihai-test:1.0</span><br><span class="line"></span><br><span class="line"># 3、推送</span><br><span class="line"></span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/wuzhihai/wuzhihai-test:1.0</span><br></pre></td></tr></table></figure>



<h2 id="11、Docker网络"><a href="#11、Docker网络" class="headerlink" title="11、Docker网络"></a>11、Docker网络</h2><h3 id="11-1、理解Docker0"><a href="#11-1、理解Docker0" class="headerlink" title="11.1、理解Docker0"></a>11.1、理解Docker0</h3><p>准备工作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -a -q) # 删除所有容器 </span><br><span class="line">docker rmi -f $(docker images -qa) # 删除全部镜像</span><br></pre></td></tr></table></figure>

<p>查看本地IP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">lo 127.0.0.1          # 本机回环地址 </span><br><span class="line">eth0 172.27.241.216   # 阿里云的私有IP </span><br><span class="line">docker0 172.18.0.1    # docker网桥</span><br></pre></td></tr></table></figure>

<p>我们用Docker管理的话，假设数据库出问题了，我们重新启动运行一个，这个时候数据库的地址就会发生变化，docker会给每个容器都分配一个ip，且容器和容器之间是可以互相访问的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动tomcat01</span> </span><br><span class="line">docker run -d -P --name tomcat01 tomcat </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tomcat01的ip地址，docker会给每个容器都分配一个ip！</span> </span><br><span class="line">docker exec -it tomcat01 ip addr</span><br><span class="line"></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">70: eth0@if71: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 思考，我们的linux服务器是否可以ping通容器内的tomcat ？</span> </span><br><span class="line">ping 172.17.0.2</span><br><span class="line"></span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]# ping 172.17.0.2   # 成功</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.050 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.074 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理</p>
</blockquote>
<p>1、每一个安装了Docker的linux主机都有一个docker0的虚拟网卡。这是个桥接网卡，使用了veth-pair技术！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看主机ip</span> </span><br><span class="line">ip addr</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现：本来我们有三个网络，我们在启动了个tomcat容器之后，多了一个71的网络！</span></span><br><span class="line"></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:16:3e:0c:db:61 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.27.241.216/20 brd 172.27.255.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 315224657sec preferred_lft 315224657sec</span><br><span class="line">    inet6 fe80::216:3eff:fe0c:db61/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:18:dc:34:7c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:18ff:fedc:347c/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">71: veth1e0eb8b@if70: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default </span><br><span class="line">    link/ether fe:15:00:b3:31:2b brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::fc15:ff:feb3:312b/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>2、每启动一个容器，linux主机就会多了一个虚拟网卡</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们启动了一个tomcat01，主机的ip地址多了一个  71: veth1e0eb8b@if70</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后我们在tomcat01容器中查看容器的ip是       70: eth0@if71:</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们再启动一个tomcat02观察</span> </span><br><span class="line">docker run -d -P --name tomcat02 tomcat </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后发现linux主机上又多了一个网卡 73: veth06db057@if72</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们看下tomcat02的容器内ip地址是 72: eth0@if73:</span> </span><br><span class="line">docker exec -it tomcat02 ip addr </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 观察现象：</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> tomcat --- linux主机 veth1e0eb8b@if70 ---- 容器内 eth0@if71</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tomcat --- linux主机 veth06db057@if72  ---- 容器内 eth0@if73</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 相信到了这里，大家应该能看出点小猫腻了吧！只要启动一个容器，就有一对网卡</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> veth-pair 就是一对的虚拟设备接口，它都是成对出现的。一端连着协议栈，一端彼此相连着。 <span class="comment"># 正因为有这个特性，它常常充当着一个桥梁，连接着各种虚拟网络设备!</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> “Bridge、OVS 之间的连接”，“Docker 容器之间的连接” 等等，以此构建出非常复杂的虚拟网络 结构，比如 OpenStack Neutron。</span></span><br></pre></td></tr></table></figure>

<p>3、我们来测试下tomcat01和tomcat02容器间是否可以互相ping通 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it tomcat01 ping 172.17.0.3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结</p>
</blockquote>
<p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p>
<p>总结：利用了Linux虚拟网络技术，把docker内部和linux的端口互相连通。</p>
<h3 id="11-2、–Link"><a href="#11-2、–Link" class="headerlink" title="11.2、–Link"></a>11.2、–Link</h3><p>我们编写一个微服务，数据库连接地址原来是使用ip的，如果ip变化就不行了，那我们能不能使用服务名访问呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们使用tomcat02，直接通过容器名ping tomcat01，不使用ip</span> </span><br><span class="line">docker exec -it tomcat02 ping tomcat01 </span><br><span class="line">ping: tomcat01: Name or service not known # 发现ping不通 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们再启动一个tomcat03，但是启动的时候连接tomcat02</span></span><br><span class="line">docker run -d -P --name tomcat03 --link tomcat02 tomcat</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个时候，我们就可以使用tomcat03 ping通tomcat02 了</span> </span><br><span class="line">docker exec -it tomcat03 ping tomcat02</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再来测试，tomcat03 是否可以ping tomcat01 失败</span> </span><br><span class="line">docker exec -it tomcat03 ping tomcat01 </span><br><span class="line">ping: tomcat01: Name or service not known </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再来测试，tomcat02 是否可以ping tomcat03 反向也ping不通</span> </span><br><span class="line">docker exec -it tomcat02 ping tomcat03 </span><br><span class="line">ping: tomcat03: Name or service not known</span><br></pre></td></tr></table></figure>

<p>原理</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看配置文件</span></span><br><span class="line">docker exec -it tomcat03 cat /etc/hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters </span><br><span class="line">172.17.0.3      tomcat02 b1a45408a15b        # 发现tomcat2直接被写在这里</span><br><span class="line">172.17.0.4      ed4ca03c2c7e</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所以这里其实就是配置了一个 hosts 地址而已！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 原因：--link的时候，直接把需要link的主机的域名和ip直接配置到了hosts文件中了。</span></span><br></pre></td></tr></table></figure>

<p>–link早都过时了，我们不推荐使用！我们可以使用自定义网络的方式</p>
<h3 id="11-3、自定义网络"><a href="#11-3、自定义网络" class="headerlink" title="11.3、自定义网络"></a>11.3、自定义网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看命令</span></span><br><span class="line">docker network --help</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  connect     Connect a container to a network</span><br><span class="line">  create      Create a network</span><br><span class="line">  disconnect  Disconnect a container from a network</span><br><span class="line">  inspect     Display detailed information on one or more networks</span><br><span class="line">  ls          List networks</span><br><span class="line">  prune       Remove all unused networks</span><br><span class="line">  rm          Remove one or more networks</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有网络</span></span><br><span class="line">[root@iZbp1iwfe0y8g9dqfz8xjoZ ~]#  docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">4c9c306ea5ef   bridge    bridge    local</span><br><span class="line">8c611b25b136   host      host      local</span><br><span class="line">44bc59533008   none      null      local</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一个具体的网络的详细信息</span></span><br><span class="line">docker network inspect 4c9c306ea5ef</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;4c9c306ea5ef8a55139b3faea56f78d097811af936b4320f55f715054ce48579&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-08-07T23:02:25.311953229+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                // 默认docker0是管理这个子网范围内的。0~16，也就是 255*255，去 掉0个255，我们有65534可以分配的ip</span><br><span class="line">                // docker0网络默认可以支持创建6万多个容器ip不重复</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;b1a45408a15b24334162a7317edd90ca48768a322a6f0bb0f8247b79b3e4c7c5&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat02&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;b1d91e47e04b981b51d76591b4eaab1942be9e2cef651a893d457a2eccbb7f73&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;ea0f4a17e8c9610be277c16adb726d82ba7897e91bba455c5279aa5cda439050&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat01&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;3a2caec3387bc140a6d99f583f956b8ab87838fd20996a682dda2e57ee3e373b&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;ed4ca03c2c7e347b2c870cfa7a36488aac22793d4ae20a54a3186268820b9a2c&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat03&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;5fc66d4b341ef3aad4fed4603d8ba57ffd1b58fecc955ee153b90d0dd47ce168&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:04&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.4/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>网络模式</strong></th>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bridge</td>
<td>–net=bridge</td>
<td>默认值，在Docker网桥docker0上为容器创建新的网络栈</td>
</tr>
<tr>
<td>none</td>
<td>–net=none</td>
<td>不配置网络，用户可以稍后进入容器，自行配置</td>
</tr>
<tr>
<td>container</td>
<td>--net=container:name/id</td>
<td>容器和另外一个容器共享Network namespace。</td>
</tr>
<tr>
<td>host</td>
<td>–net=host</td>
<td>容器和宿主机共享Network namespace</td>
</tr>
<tr>
<td>自定义</td>
<td>–net=自定义网络</td>
<td>用户自己使用network相关命令定义网络，创建容器的</td>
</tr>
</tbody></table>
<h3 id="11-4、自定义网卡"><a href="#11-4、自定义网卡" class="headerlink" title="11.4、自定义网卡"></a>11.4、自定义网卡</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、删除原来的容器</span></span><br><span class="line"></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认我们不配置网络，也就相当于默认值 --net bridge 使用的docker0</span> </span><br><span class="line">docker run -d -P --name tomcat01 --net bridge tomcat</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker0网络的特点 1.它是默认的 2.域名访问不通 3.--link 域名通了，但是删了又不行</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、创建容器使用自定义网络</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自定义创建一个网络网络</span> </span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"></span><br><span class="line">docker network ls</span><br><span class="line">docker network inspect mynet</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们来启动两个容器测试，使用自己的 mynet！</span></span><br><span class="line">docker run -d -P --name tomcat-net-01 --net mynet tomcat</span><br><span class="line">docker run -d -P --name tomcat-net-02 --net mynet tomcat</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、查看</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、测试</span></span><br><span class="line"></span><br><span class="line">docker exec -it tomcat-net-01 ping 192.168.0.3</span><br><span class="line">docker exec -it tomcat-net-01 ping tomcat-net-02</span><br><span class="line">docker exec -it tomcat-net-02 ping tomcat-net-01</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现，我们自定义的网络docker都已经帮我们维护好了对应的关系</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 所以我们平时都可以这样使用网络，不使用--link效果一样，所有东西实时维护好，直接域名 ping 通</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-5、网络连通"><a href="#11-5、网络连通" class="headerlink" title="11.5、网络连通"></a>11.5、网络连通</h3><p>docker0和自定义网络肯定不通，我们使用自定义网络的好处就是网络隔离：</p>
<p>大家公司项目部署的业务都非常多，假设我们有一个商城，我们会有订单业务（操作不同数据），会有订单业务购物车业务（操作不同缓存）。如果在一个网络下，有的程序猿的恶意代码就不能防止了，所以我们就在部署的时候网络隔离，创建两个桥接网卡，比如订单业务（里面的数据库，redis，mq，全部业务 都在order-net网络下）其他业务在其他网络。</p>
<p><img src="C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210809114309269.png" alt="image-20210809114309269"></p>
<p>如何让 tomcat-net-01 访问 tomcat1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动默认的容器，在docker0网络下</span></span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat02 tomcat</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连通</span></span><br><span class="line">docker network connect [OPTIONS] NETWORK CONTAINER</span><br><span class="line">docker network connect mynet tomcat01</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试，此时tomcat02 依旧连不通</span></span><br><span class="line">docker exec -it tomcat01 ping tomcat-net-01</span><br></pre></td></tr></table></figure>

<h2 id="12、实战：部署一个Redis集群"><a href="#12、实战：部署一个Redis集群" class="headerlink" title="12、实战：部署一个Redis集群"></a>12、实战：部署一个Redis集群</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">for port in $(seq 1 6); \</span><br><span class="line">do \</span><br><span class="line">mkdir -p /mydata/redis/node-$&#123;port&#125;/conf</span><br><span class="line">touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">port 6379 bind 0.0.0.0</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1$&#123;port&#125;</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">docker run -p 637$&#123;port&#125;:6379 -p 1637$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \</span><br><span class="line">-v /mydata/redis/node-$&#123;port&#125;/data:/data \</span><br><span class="line">-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server</span><br><span class="line">/etc/redis/redis.conf; \</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Bug</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%20(%20%E5%9B%9B%20)%20Docker/">http://example.com/2021/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%20(%20%E5%9B%9B%20)%20Docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Notes</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MicroService/">MicroService</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%20(%20%E4%BA%8C%20)%20MyBatisplus/"><img class="prev-cover" src="/img/cover/23.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">微服务(二):Mybatis-Plus框架</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%20(%20%E4%B8%89%20)%20Swagger/"><img class="next-cover" src="/img/cover/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">微服务(三):Swagger</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/05/微服务/微服务 ( 三 ) Swagger/" title="微服务(三):Swagger"><img class="cover" src="/img/cover/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-05</div><div class="title">微服务(三):Swagger</div></div></a></div><div><a href="/2021/07/05/微服务/微服务 ( 二 ) MyBatisplus/" title="微服务(二):Mybatis-Plus框架"><img class="cover" src="/img/cover/23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-05</div><div class="title">微服务(二):Mybatis-Plus框架</div></div></a></div><div><a href="/2021/07/05/微服务/微服务 ( 一 ) SpringBoot/" title="微服务(一):SpringBoot框架"><img class="cover" src="/img/cover/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-05</div><div class="title">微服务(一):SpringBoot框架</div></div></a></div><div><a href="/2021/07/05/微服务/微服务 ( 五 ) RabbitMQ/" title="微服务(五):RabbitMQ的基本概念"><img class="cover" src="/img/cover/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-05</div><div class="title">微服务(五):RabbitMQ的基本概念</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1、Docker的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Docker%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">2、Docker的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E7%B3%BB%E7%BB%9F%E8%A6%81%E6%B1%82"><span class="toc-text">2.1、系统要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-text">2.2、安装步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F"><span class="toc-text">2.3、阿里云镜像加速</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%8E%A2%E7%A9%B6Docker-run-hello-world-%E5%8E%9F%E7%90%86"><span class="toc-text">3、探究Docker run hello-world 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">4、Docker常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4"><span class="toc-text">4.1、帮助命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-text">4.2、镜像命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E3%80%81%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">4.3、容器命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E3%80%81%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="toc-text">4.4、其他命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E3%80%81%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB"><span class="toc-text">4.5、命令汇总</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%AE%9E%E6%88%98"><span class="toc-text">5、实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E5%AE%89%E8%A3%85Nginx"><span class="toc-text">5.1、安装Nginx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E5%AE%89%E8%A3%85Tomcat"><span class="toc-text">5.2、安装Tomcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81%E5%AE%89%E8%A3%85Es-Kinbana"><span class="toc-text">5.3、安装Es+Kinbana</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-text">6、可视化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81Portainer"><span class="toc-text">6.1、Portainer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81Rancher"><span class="toc-text">6.2、Rancher</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Docker%E9%95%9C%E5%83%8F%E8%AE%B2%E8%A7%A3"><span class="toc-text">7、Docker镜像讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E9%95%9C%E5%83%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">7.1、镜像是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-text">7.2、Docker镜像加载原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E3%80%81%E5%88%86%E5%B1%82%E7%90%86%E8%A7%A3"><span class="toc-text">7.3、分层理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4%E3%80%81%E5%88%86%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">7.4、分层的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81commit%E9%95%9C%E5%83%8F"><span class="toc-text">8、commit镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">9、容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">9.1、什么是容器数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E3%80%81%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">9.2、使用数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3%E3%80%81%E5%8C%BF%E5%90%8D%E5%92%8C%E5%85%B7%E5%90%8D%E6%8C%82%E8%BD%BD"><span class="toc-text">9.3、匿名和具名挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-text">9.4、数据卷容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81DockerFile"><span class="toc-text">10、DockerFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">10.1、简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E3%80%81DockerFile%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">10.2、DockerFile构建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3%E3%80%81%E6%8C%87%E4%BB%A4"><span class="toc-text">10.3、指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4%E3%80%81%E5%AE%9E%E6%88%98%E6%B5%8B%E8%AF%95Centos"><span class="toc-text">10.4、实战测试Centos</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5%E3%80%81%E5%8F%91%E5%B8%83%E9%95%9C%E5%83%8F"><span class="toc-text">10.5、发布镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81Docker%E7%BD%91%E7%BB%9C"><span class="toc-text">11、Docker网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1%E3%80%81%E7%90%86%E8%A7%A3Docker0"><span class="toc-text">11.1、理解Docker0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2%E3%80%81%E2%80%93Link"><span class="toc-text">11.2、–Link</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-text">11.3、自定义网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E5%8D%A1"><span class="toc-text">11.4、自定义网卡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5%E3%80%81%E7%BD%91%E7%BB%9C%E8%BF%9E%E9%80%9A"><span class="toc-text">11.5、网络连通</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E5%AE%9E%E6%88%98%EF%BC%9A%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AARedis%E9%9B%86%E7%BE%A4"><span class="toc-text">12、实战：部署一个Redis集群</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Bug</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>